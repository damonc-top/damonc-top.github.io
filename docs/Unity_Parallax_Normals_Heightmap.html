<!DOCTYPE html><html lang="zh-Hans"> <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>视差和法线、高度图回顾(翻译二十) - 编程散记</title><meta name="author" content="编程散记"><meta name="description" content="视差和法线、高度图回顾(翻译二十)"><meta name="keywords" content="Shader"><meta property="og:previous_url" content="/unity3d/Unity_Addressable_Editor.html"><meta property="og:next_url" content="/Unity_GPU_Instance.html"><meta property="post-date-format" content="0"><meta property="post-date" content="2018-01-25 20:00:00 +0800" /><meta property="calendar-scale" content="year" /><meta property="calendar-scheme" content="null" /><meta property="calendar-color" content="null" /><meta property="og:title" content="视差和法线、高度图回顾(翻译二十) - 编程散记"><meta property="og:type" content="website"><meta property="og:url" content="https://www.damonc.top/Unity_Parallax_Normals_Heightmap.html"><meta property="og:baseurl" content=""><meta property="og:description" content="个人的一个技术博客站点，记录生活、工作、学习中的一些小事，以及一些比较有趣的事情，留点什么东西也挺不错的，偶尔会在这里停留。"><meta property="og:site_name" content="编程散记"><meta property="og:gray" content="false"><meta property="og:lang" content="zh-Hans"><meta name="alivestart" content="12/23/2020"><meta name="theme-color" content="#81BBFF" /><meta name="algolia-site-verification" content="5E91324370E1262B" /><title>Algolia Verification</title><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="manifest" href="/manifest.json" async><link rel="apple-touch-icon" href="/assets/img/touch/apple-touch-icon.png" /><link rel="Shortcut Icon" href="/favicon.ico"><link rel="icon" href="/favicon.ico" type="image/x-icon" /><link rel="bookmark" href="/favicon.ico" type="image/x-icon" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.min.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.2.0/github-markdown-light.min.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-light.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://unpkg.com/@waline/client@3.3.2/dist/waline.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3" async><link rel="stylesheet" href="/assets/css/app.min.css" async><body class="line-numbers" ontouchstart=""><div id="all" class="post" data-theme="default"><div class="alert-tip" id="no-previous">已经是最新一篇文章了！</div><div class="alert-tip" id="no-next">已经是最后一篇文章了！</div><input id="nm-switch" type="hidden" value="false"><header class="g-header" data-theme="default"><div class="g-logo"> <a href="/" aria-label="logo"></a></div><div id="search-toggle"></div><div id="travelling-toggle"> <a href="https://www.travellings.cn/go.html" aria-label="Travelings" target="_blank"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-train-subway"></use> </svg> </a></div><div id="mode-toggle"> <svg class="icon icon-day" aria-hidden="true"> <use xlink:href="#icon-day"></use> </svg> <svg class="icon icon-night" aria-hidden="true"> <use xlink:href="#icon-night"></use> </svg></div><svg id="menu-toggle" class="icon-menu" aria-hidden="true"> <use xlink:href="#icon-menu"></use> </svg><nav class="g-nav"><ul><li> <a href="/" aria-label="home"> home </a><li> <a href="/blog/index.html" aria-label="blog"> blog </a><li> <a href="/archives.html" aria-label="archives"> archives </a><li> <a href="/tags.html" aria-label="tags"> tags </a><li class="dropdown"> <a class="dropdown-toggle" href="#"> about </a><ul class="dropdown-menu"><li> <a href="/feed.xml" aria-label="RSS"> RSS </a></ul><li class="travelling"> <a href="https://www.travellings.cn/go.html" aria-label="Travelings" target="_blank"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-train-subway"></use> </svg> </a><li class="mode"> <svg class="icon day" aria-hidden="true"> <use xlink:href="#icon-day"></use> </svg> <svg class="icon night" aria-hidden="true"> <use xlink:href="#icon-night"></use> </svg><li id="search"></ul></nav></header><div class="g-banner post-header post-pattern-circuitBoard bgcolor-default post-no-cover" data-theme="default"><div class="post-wrapper"><div class="post-tags"> <a href="/%20/tags.html#Shader" class="post-tag">Shader</a></div><h1>视差和法线、高度图回顾(翻译二十)</h1><div class="post-meta"> <span class="post-meta-item"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-user"></use> </svg> catlikecoding </span> <time class="post-meta-item" datetime=" 18-01-25"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-calendar"></use> </svg> <span class="create-at"></span> </time> <time class="post-meta-item" datetime=" 18-01-25"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-update"></use> </svg> <span class="update-at"></span> </time> <span class="post-meta-item"> <svg class="icon words" aria-hidden="true"> <use xlink:href="#icon-words"></use> </svg> 本文总共 16.3k 字 </span> <span class="post-meta-item"> <svg class="icon time" aria-hidden="true"> <use xlink:href="#icon-time"></use> </svg> 阅读全文大约需要 47 分钟 </span> <span class="post-meta-item"> <svg class="icon pv" aria-hidden="true"> <use xlink:href="#icon-pv"></use> </svg> 本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次 </span></div></div></div><main class="post-content visible"><div class="container"><div class="submenu hidden"></div><div class="contents"><article class="markdown-body post"><p>由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外的景物，附近的物体看起来很大并且移动很快，而远处的背景看起来很小并且移动较慢。渲染时，相机使用透视模式时，也会出现视差。</p><h2 id="视差纹理">视差纹理</h2><p>之前翻译使用过法线贴图将表面不规则感添加到平滑表面。 它会影响照明，但不会影响表面的实际形状。 因此，该效果视差不明显，通过实现法线贴图基于视野深度的幻觉有许多限制。这一篇的目的就是解决该限制。</p><h3 id="法线贴图效果回顾">法线贴图效果回顾</h3><p>下面给出许多albedo map 和 normal map差异对比：</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200615181223145-1229624244.png" width="250"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200615181223966-473200226.png" width="250"><font size="2.5"> <i>albedo map 和 normal map.</i> </font> </center><p>如果没有法线贴图，表面看起来很平坦。 添加法线贴图会使它看起来好像具有不规则的表面。 但是，高度海拔差异看起来不明显。 当从入射视角与表面的夹角越趋于0，高度差越不明显。如果高程差异较大，则表面特征的相对视觉位置应由于视差而发生很大变化，但不会发生变化。 我们看到的视差是平坦的表面。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200616191420845-1957506928.png" width="250"><font size="2.5"> <i>平坦的视角.</i> </font> </center><p>虽然可以增加法线贴图的强度，但这不会改变视差。同样，当法线贴图变得太强时，它会看起来很奇怪。它影响了平坦表面的光线的明暗变换，而视差效果它们确实是平的。所以法线贴图只适用于小的变化，但不会表现出明显的视差。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200616191421654-712293996.png" width="250"><font size="2.5"> <i>法线贴图的光线变化.</i> </font> </center><p>要获得真正的深度视差感，<strong>首先</strong>需要确定深度应该是多少。法线贴图不包含这些信息。所以我们需要一个高度图。这样，我们就可以创建一个基于高度信息的假视差效果，就像法线贴图创建一个假斜率一样。下面的贴图也称它是灰度图，黑色代表最低点，白色代表最高点。因为我们将使用这个贴图来创建一个视差效果，也称为视差图。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200616191422519-1710373191.png" width="250"><font size="2.5"> <i>高度图.</i> </font> </center><p>确保在导入时禁用sRGB(颜色纹理)，这样在使用线性空间渲染时数据就不会被弄乱</p><h3 id="shader参数">Shader参数</h3><p>为了能够使用视差贴图，我们必须为它添加一个属性到着色器。也会给它一个强度参数来缩放效果。因为视差效果相当强，我们将其范围设置为(0 , 0.1)。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_ParallaxMap</span> <span class="p">(</span><span class="s">"Parallax"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"black"</span> <span class="p">{}</span>
<span class="n">_ParallaxStrength</span> <span class="p">(</span><span class="s">"Parallax Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>

<span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_OcclusionMap</span> <span class="p">(</span><span class="s">"Occlusion"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
<span class="n">_OcclusionStrength</span> <span class="p">(</span><span class="s">"Occlusion Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div><p>视差贴图是一个着色器特性，我们将启用__PARALLAX_MAP_关键字。将必需的编译器指令添加到base pass、additive pass和deferred pass。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma shader_feature _NORMAL_MAP
#pragma shader_feature _PARALLAX_MAP
</span></code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>为什么不在ShadowCaster增加视差贴图？
当使用albedo贴图的alpha通道的透明度时，视差贴图只会影响阴影。即使是这样，在阴影贴图中的视差效果也很难被注意到。所以它通常不值得额外的计算时间。但是如果愿意，也可以将它添加到阴影施法者通道中。
</code></pre></div></div><p>为了访问新的属性，给我的照明添加相应的变量</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_ParallaxMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>

<span class="n">sampler2D</span> <span class="n">_OcclusionMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_OcclusionStrength</span><span class="p">;</span>
</code></pre></div></div><p>为了能够自定义配置材质，在Extend ShaderGUI扩展中增加相应Enable与Disanble key的方法。</p><div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">DoParallax</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialProperty</span> <span class="n">map</span> <span class="p">=</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_ParallaxMap"</span><span class="p">);</span>
    <span class="n">Texture</span> <span class="n">tex</span> <span class="p">=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">;</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="nf">BeginChangeCheck</span><span class="p">();</span>
    <span class="n">editor</span><span class="p">.</span><span class="nf">TexturePropertySingleLine</span>
    <span class="p">(</span>
        <span class="nf">MakeLabel</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">"Parallax (G)"</span><span class="p">),</span> <span class="n">map</span><span class="p">,</span>
        <span class="n">tex</span> <span class="p">?</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_ParallaxStrength"</span><span class="p">)</span> <span class="p">:</span> <span class="k">null</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="nf">EndChangeCheck</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">tex</span> <span class="p">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">SetKeyword</span><span class="p">(</span><span class="s">"_PARALLAX_MAP"</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200616191423089-347056836.png" width="250"></center><h3 id="坐标匹配">坐标匹配</h3><p>通过在fragment程序中调整纹理坐标，让平坦表面的某些部分看起来高低交错。创建一个应用视差函数，给它一个inout插值器参数。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div><p>在fragment程序使用插入的数据之前调用视差函数。_会有点异常是LOD衰落，_因为这取决于屏幕位置。先不调整这些坐标。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="n">ApplyParallax</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">GetAlpha</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#if defined(_RENDERING_CUTOUT)
</span>        <span class="nb">clip</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">_Cutoff</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><p>通过简单地向U坐标添加视差强度来调整纹理坐标。做一次偏移计算</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><p>改变视差强度会导致纹理偏移。增加U坐标会使纹理向负的U方向移动，V坐标同理。这看起来不是视差效果，因为这是一个与视角无关的均匀位移。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012938981-982216259.gif" width="250"><font size="2.5"> <i>u坐标移动.</i> </font> </center><h3 id="随视角方向移动">随视角方向移动</h3><p>视差是由相对于观察者的透视投影，所以必须改变纹理坐标。这意味着必须基于视图的方向来移动坐标，而视图的方向对于表面上每个片段都是不同的。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192759952-594530144.png" width="250"><font size="2.5"> <i>varies across a surface.</i> </font> </center><p>纹理坐标存在于切线空间中。为了调整这些坐标，需要知道视图在切线空间中的方向。这需要矩阵乘法对空间进行转换。在fragment-程序已经有了一个切线空间矩阵，但是它是用于从切线空间到世界空间的转换。在本例中，需要从对象空间转到切线空间。</p><p>视图方向向量定义为从表面到摄像机，需要归一化。我们可以在vertex程序中确定这个向量，转换它并将它传递给fragment程序。但是为了最终得到正确的方向，需要推迟归一化，直到插值完成后。添加切线空间视图方向作为一个新的插值成员变量。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="kt">float3</span> <span class="n">tangentViewDir</span> <span class="o">:</span> <span class="n">TEXCOORD8</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="kt">float3</span> <span class="n">tangentViewDir</span> <span class="o">:</span> <span class="n">TEXCOORD8</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>寄存器数量限制是多少?
model 1与model 2都只支持8个Texture Coordinate Register -&gt;Texcoord[0-7]。当使用model 3时，可以使用TEXCOORD8。若硬件不支持model 3其机能也就不是很强大，所以不要使用视差映射。
</code></pre></div></div><p><strong>首先</strong>, 使用mesh网格数据中的原始顶点切向量和法向量，在顶点程序中创建一个从对象空间到切线空间的转换矩阵。因为我们只用它来变换一个向量而不是一个位置我们用一个3×3矩阵就足够了。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ComputeVertexLightColor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="cp">#if defined (_PARALLAX_MAP)
</span>        <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span><span class="p">(</span>
            <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
            <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
            <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
        <span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>然后</strong>，可以使用<code class="language-plaintext highlighter-rouge">ObjSpaceViewDir</code>函数得到对象空间中顶点位置的视图方向，再用矩阵变换它我们就得到了我们需要的切线空间下视图方向。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined (_PARALLAX_MAP)
</span>    <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span>
    <span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
        <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
    <span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">objectToTangent</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ObjSpaceViewDir内部实现?</span>
<span class="c1">//ObjSpaceViewDir函数是在UnityCG中定义的。它先将摄像机位置转换到对象空间，然后减去对象空间下顶点位置得到一个从顶点指向摄像机的向量，注意它还没有标准化.</span>

<span class="k">inline</span> <span class="kt">float3</span> <span class="nf">ObjSpaceViewDir</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float3</span> <span class="n">objSpaceCameraPos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToObject</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">objSpaceCameraPos</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>最后</strong>，我们可以在ApplyParallax函数使用切线空间视图方向了。首先，对它进行规格化normalize，把它变成一个合适的方向向量。然后，添加它的XY组件到纹理坐标，再由视差强度缩放。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><p>这能有效地将视图方向投影到纹理表面上。当以90度角直视表面时，在切空间中的视图方向等于表面法线(0,0,1)，这不会导致位移。视角越浅，投影越大，位移效果也越大。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192800432-1757806048.png" width="250"><font size="2.5"> <i>影视图方向用作UV偏移.</i> </font> </center><p>所有这一切的影响是表面似乎被拉向上的切线空间，看起来比它实际上更高，基于视差强度。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012940748-384205609.gif" width="250"><font size="2.5"> <i>随投影视角方向移动UV.</i> </font> </center><h3 id="基于高度滑动">基于高度滑动</h3><p>在基于高度这一点上，我们可以让表面看起来更高，但它仍然是一个均匀位移。下一步是使用视差贴图来缩放位移。采样贴图，使用它的G通道作为高度，应用视差强度，并使用它来调节位移。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
<span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012942351-290008046.gif" width="250"><font size="2.5"> <i>由高度调整的移动.</i> </font> </center><p>低的区域现在保持不变，而高的区域被向上拉。standard shader抵消了这种效果，所以低的区域也向下移动，而在中间的区域保持他们原来的位置。这是通过从原始高度数据中减去差值来实现的。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012944095-1997194416.gif" width="250"><font size="2.5"> <i>视差贴图效果 由合理到过量.</i> </font> </center><p>这就产生了我们想要的视差效果，但它只在低强度下有效。不足的是位移位移变换的很快，会撕裂表面。</p><h3 id="偏移视差映射算法">偏移视差映射算法</h3><p>我们目前使用的视差映射技术被称为带偏移限制的视差映射。我们只是使用了视图方向的XY部分，它的最大长度是1。因此，纹理偏移量是有限的。这种效果不错，但不能代表正确的透视投影。</p><p>一个更精确的计算偏移量的物理方法是将高度场视为几何图形表面下的体积，并通过它拍摄一个视图射线。光线从相机发射到表面，从上面进入高度场体积，并持续发射直到它到达由场定义的表面。</p><p>如果高度场均匀为零，那么射线就会一直持续到体积的底部。它与物体的距离取决于光线进入物体时的角度。它没有限制。角度越浅，越远。最极端的情况是当视角趋于0时，光线射向无穷大。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192800958-1980748310.png" width="250"><font size="2.5"> <i>光线投射到底部，有限且正确.</i> </font> </center><p>为了找到合适的偏移量，我们必须缩放视图方向向量，通过除以它自己的Z分量来使它的Z分量变成1。因为我们以后不需要用Z，我们只需要用X和Y除以Z。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
<span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</code></pre></div></div><p>虽然这样可以得到一个更正确的投影，但它确实会使浅视角的视差效果恶化。standard着色器通过增加0.42偏差到Z减轻浅视角的视差效果恶化，所以它永远不会接近零。这扭曲了透视图，但使工件更易于管理。我们再加上这个偏差.</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">42</span><span class="p">);</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192802151-218582125.png" width="250"><font size="2.5"> <i>视差贴图像标准着色器.</i> </font> </center><p>通过上述多个步骤修正后, 现在我们的着色器与标准着色器支持同样的视差效果。视差映射可以应用于任何表面，投影假设切线空间是均匀的。曲面具有弯曲的切线空间，因此会产生物理上不正确的结果。只要视差强度和曲率很小，你就可以摆脱它。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192802555-2049613835.png" width="250"><font size="2.5"> <i>球面视差贴图.</i> </font> </center><p>同样，阴影坐标不会受到这个效果的影响。因此，阴影在强烈的视差的组合下看起来很奇怪，好像漂浮在表面上。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192803371-1931947503.png" width="250"><font size="2.5"> <i>阴影不受视差影响.</i> </font> </center><h3 id="parallax-configuration">Parallax Configuration</h3><p>你不同意Unity使用0.42的偏移值吗?或者你想使用一个不同的值，还是让它保持在0?或者你想用偏移限制代替吗?它是可以配置!</p><p>当你想使用偏移限制，定义<code class="language-plaintext highlighter-rouge">PARALLAX_OFFSET_LIMITING</code>在着色器。或者，通过定义PARALLAX_BIAS来设置要使用的偏差。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>            <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><p>当没有定义时，假设偏差是0.42。在<code class="language-plaintext highlighter-rouge">ApplyParallax</code> 中定义它。注意，宏定义不关心函数作用域，它们总是全局的。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>    <span class="cp">#if !defined(PARALLAX_BIAS)
</span>        <span class="cp">#define PARALLAX_BIAS 0.42
</span>    <span class="cp">#endif
</span>    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div><p>现在我们可以通过着色器的CGINCLUDE块来微调我们的视差效果。添加无偏差和限制偏移的选项，但将它们转换为注释，以坚持默认选项。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGINCLUDE</span>
    <span class="cp">#define BINORMAL_PER_FRAGMENT
</span>    <span class="cp">#define FOG_DISTANCE
</span>
<span class="c1">//	#define PARALLAX_BIAS 0</span>
<span class="c1">//	#define PARALLAX_OFFSET_LIMITING</span>

<span class="n">ENDCG</span>
</code></pre></div></div><h3 id="detail-uv">Detail UV</h3><p>视差贴图可以在主贴图上工作，但是我们还没有注意到副贴图。我们必须应用纹理坐标偏移到细节UV上。</p><p>首先，下面是一个包含网格模式的详细地图。它可以很容易地验证效果是否正确地应用于细节。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192803893-1797850325.png" width="250"><font size="2.5"> <i>细节网格纹理.</i> </font> </center><p>使用这个纹理作为材质的细节albedo贴图。设置二级贴图的平铺为10×10。这表明，细节紫外线确实仍然不受影响。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192804491-290326603.png" width="250"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192805295-1360127209.png" width="250"><font size="2.5"> <i>细节UV不受影响.</i> </font> </center><p>Standard也简单地添加了UV偏移到细节UV，这是存储在UV插值器的ZW组件。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
<span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
</code></pre></div></div><p>细节可能有所变化，但是它们肯定还不匹配视差效果。 那是因为我们平铺了二级纹理。 这样会将细节UV缩放10倍，使视差偏移量变弱十倍。 我们还必须将细节拼贴应用到偏移量。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
</code></pre></div></div><p>实际上，缩放应该相对于主UV平铺，以防它被设置为1×1以外的一些东西。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192806533-2106069113.png" width="250"><font size="2.5"> <i>正确的UV.</i> </font> </center><h2 id="ray-marching-光线步进">Ray Marching-光线步进</h2><p>然而，除了上述的偏移视差映射还有另外的视差算法：发射射线与高度场体积相交，确定其交点在表面上的位置，然后对该位置采样。 它通过在射线进入体积时的交点，对高度图进行一次采样。 但是，当看向任意一个角度时，这并不能准确告诉射线实际上与高度场相交的高度。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192807160-2024700857.png" width="250"><font size="2.5"> <i>实际与预测的高度对比.</i> </font> </center><p>先假设入口点的高度与交点的高度相同，但这实际上只有在入口点和交点具有相同的高度时才是正确的。当偏移量不大且高度场变化不大时，它的效果仍然很好。但是，当偏移量太大或高度变化太快时，该算法就会出现问题，而这很可能是错误的。这就会造成表面撕裂。</p><p>如果我们能算出射线实际到达的高度场的位置，那么总能找到真正的可见表面点。这不能通过单个纹理样本来实现，我们必须沿着视图射线逐步移动，并每次都采样高度场，直到射线到达表面。该技术是RayMarching。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192807679-1545265192.png" width="250"><font size="2.5"> <i>随视图射线前进.</i> </font> </center><p>有各种不同的视差贴图使用raymarching。常见的是陡视差映射_Steep Parallax Mapping_、地形映射_Relief Mapping_和视差遮挡映射_Parallax Occlusion Mapping_。与使用单一纹理样本相比，它们能通过高度场来创建更好的视差效果。除此之外，它们还可以应用额外的阴影和技术来改进该算法。当我们做的匹配这些方法时，我会调用它。</p><h3 id="自定义视差函数">自定义视差函数</h3><p>标准着色器仅支持简单的偏移视差映射。 现在，我们要在自己的着色器中添加对视差光线Ray marching的支持。 但是，我们还要继续支持这种简单方法。 两者都需要采样height字段，因此将采样代码行放在单独的GetParallaxHeight函数中。 而且，两种方法的投影视图方向和偏移量的最终应用都相同。 因此，将偏移量计算也单独为一个函数。 它仅需要原始UV坐标和已处理的视图方向作为参数，结果返回要应用的UV偏移。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">GetParallaxHeight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="nf">ParallaxOffset</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>            <span class="cp">#if !defined(PARALLAX_BIAS)
</span>                <span class="cp">#define PARALLAX_BIAS 0.42
</span>            <span class="cp">#endif
</span>            <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
        <span class="cp">#endif
</span>
        <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">ParallaxOffset</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><p>现在，我们将应用视差函数宏替换对视差偏移的硬编码调用，从而使视差方法更加灵活。如果没有定义它，我们将它设置为使用偏移量方法。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="c1">//...</span>
        <span class="cp">#if !defined(PARALLAX_FUNCTION)
</span>            <span class="cp">#define PARALLAX_FUNCTION ParallaxOffset
</span>        <span class="cp">#endif
</span>        <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">PARALLAX_FUNCTION</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><p>为RayMarching方法创建一个新函数。与ParallaxOffset函数类似的参数和返回类型。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxOffset</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>现在可以通过定义_PARALLAX_FUNCTION_来改变着色器中的视差方法。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div><h3 id="相交计算">相交计算</h3><p>为了找到视图射线到达高度场的点，我们需要对射线上的多个点进行采样并计算出在表面下方的位置。第一个采样点在顶部，我们在这里输入高度量，就像使用偏移方法一样。最后一个采样点就是射线到达体积底部的地方。我们会在这些端点之间均匀地添加额外的采样点。</p><p>假设每条射线进行10次采样。这意味着我们将对高度图采样10次而不是一次，所以这不是一个便宜计算方法。因为我们用了10个样本，所以步长是0.1。这是我们沿着视图射线移动的因子，也就是UV偏移增量。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>为了应用视差强度，我们可以调整每一步采样的高度。但是缩放UV delta也有同样的效果，只需要计算一次。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>
</code></pre></div></div><p>通过这种方式，无论视差强度如何，我们都可以继续使用0–1作为高度场的范围。 因此，射线的第一步高度始终为1。低于或高于该高度的表面点的高度由高度场定义。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span><span class="c1">//步长</span>
<span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>
<span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//步高</span>
<span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
</code></pre></div></div><p>现在我们要沿着射线迭代。<strong>首先</strong>，每一步我们都会增加UV偏移量。视图向量指向摄像机，但我们是在向表面移动，所以我们需要减去UV delta。<strong>然后</strong>我们用步高来减小步长。<strong>然后</strong>我们再次对高度图采样。使用while循环重复上述步骤，直到采样完毕。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>当编译时，会得到一个编译器警告和错误。这个警告告诉我们在循环中使用了梯度指令。这指的是循环中的纹理采样。GPU必须弄清楚使用哪个mipmap级别，它需要比较相邻片段使用的UV坐标。只有当所有片段执行相同的代码时，它才能对比。对于循环来说，这是不可能的，因为它可以提前终止，每个片段都可能不同。因此编译器将展开循环，这意味着它将一直执行所有9个步骤，而不管逻辑是否可以提前停止。相反，它随后使用确定性逻辑选择最终结果。</p><p>编译失败是因为编译器无法确定循环的最大迭代次数。它不知道这个最多是9。通过将while循环转换为执行限制的for循环来明确这一点。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012945572-448280189.png" width="250"><font size="2.5"> <i>Raymarching 步进10次 无偏差, 无限制.</i> </font> </center><p>与简单的视差偏移方法相比，视差效果更加明显。较高的区域现在也正确地阻挡了我们后面较低区域的视野。我们还得到了明显的图层，总共10层。</p><h3 id="更多步进">更多步进</h3><p>这个基本的光线行进方法最适合陡峭的视差贴图。效果的质量是由我们的样本分辨率决定的。一些方法根据视角使用可变的步骤。较浅的角度需要更多的步长，因为光线较长。但我们的样本量是固定的，所以我们不会这样做。</p><p>提高质量的明显方法是增加采样的次数，因此让其可配置。使用_PARALLAX_RAYMARCHING_STEPS_，默认值为10，而不是固定的步长和迭代次数。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if !defined(PARALLAX_RAYMARCHING_STEPS)
</span>        <span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
</span>    <span class="cp">#endif
</span>    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="n">PARALLAX_RAYMARCHING_STEPS</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>

    <span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span>
        <span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_STEPS</span> <span class="o">&amp;&amp;</span> <span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
        <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
        <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>现在我们可以在着色器中控制步数。对于真正的高质量，将PARALLAX_RAYMARCHING_STEPS定义为100。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 100
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012948054-536464296.png" width="250"><font size="2.5"> <i>Raymarching 100次采样.</i> </font> </center><p>这让我们知道了它的效果能有多好，但它计算量太大了，一般不适合手机。所以把样本数设为10后，我们仍然可以看到视差效果看起来连续和平滑。然而，由视差遮挡引起的轮廓总是锯齿状的，MSAA并不能消除这一点，因为它只适用于几何图形的边缘，而不是纹理效果。只要不依赖深度缓冲区，后处理抗锯齿技术能解决。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>不能按片段写入深度缓冲区吗?
这在足够先进的硬件上确实是可能的，使它能够正确地与高度场相交并应用阴影。不过，它计算量太大。
</code></pre></div></div><p>我们当前的方法是沿着射线步进，直到到达表面以下的点，或者到达射线末端可能的最低点。然后我们用UV偏移处理那个点。但隐藏在表面之下的这个点，很可能会出现错误。这就是导致表面撕裂的原因。</p><p>增加步长数只会减少最大误差。使用足够的步骤，错误会变得更小，以至于我们无法再看到它。所以当一个表面总是从远处看，你可以用更少的步骤。距离越近，视角越小，需要的样本就越多。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012948690-1598196626.png" width="250"><font size="2.5"> <i>Raymarching 100次采样.</i> </font> </center><h3 id="步长之间插值">步长之间插值</h3><p>提高质量的一种方法是根据经验预测光线真正到达表面的位置。比如第一步在表面之上，下一步在表面之下。在这两步之间的某个点射线一定到达了表面。</p><p>两个射线点、和两个射线点到表面最近的点，能定义两条线段。因为光线和表面碰撞，这两条线段会相交。所以如果我们跟踪前面的步骤，我们可以在循环之后执行直线交叉。我们可以用这个信息来近似出真正的交点。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012949277-977122761.png" width="250"><font size="2.5"> <i>执行直线交叉.</i> </font> </center><p>在for循环内，我们必须跟踪之前的UV偏移量、步长高度和表面高度。一般来说，这些等于循环之前的第一个样本。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="n">prevUVOffset</span> <span class="o">=</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="n">float</span> <span class="n">prevStepHeight</span> <span class="o">=</span> <span class="n">stepHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">prevSurfaceHeight</span> <span class="o">=</span> <span class="n">surfaceHeight</span><span class="p">;</span>
</code></pre></div></div><p>在循环之后，我们计算这些线的交点。我们可以使用这个插值之间的前点和后点的UV偏移。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
<span class="n">uvOffset</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">prevUVOffset</span><span class="p">,</span> <span class="n">uvOffset</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

<span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
</code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>数学原理：
这两个线段定义在两个样本步骤之间的空间内。我们将这个空间的宽度设置为1。从前一步到最后一步的直线由点(0，a)和点(1，b)定义，其中a是前一步的高度，b是后一步的高度。因此，可以用线性函数'v(t) = a + (b - a)t'来定义视图线。同样地，面线由点(0，c)和(1，d)定义，函数's(t) = hlsl + (d - hlsl)t'。

交点存在于s(t) = v(t)'处。那么t的值是多少?
c + (d - c)t = a + (b - a)t
(d - c)t - (b - a)t = a - c
(a - c + d - b)t = a - c
t = (a - c) / (a - c + d - b)
注意:a - c是在t = 0处直线高度的绝对差。d - b是t = 1处的绝对高度差。
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012950193-51635460.png" width="250"><font size="2.5"> <i>线段交点.</i> </font> </center><p>实际上，在这种情况下，我们可以使用插值器来缩放我们要添加到上一点上的UV偏移量。它可以归结为相同的东西，只是用了更少的数学。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">-</span> <span class="n">difference</span><span class="p">);</span>
<span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
</code></pre></div></div><center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012951620-360864955.png" width="250"></center><p>效果看起来好多了。我们现在假设表面在样本点之间是线性的，这可以防止最明显的分层假象。然而，它不能帮助我们检测我们是否错过了步骤之间的交集。我们仍然需要很多的样本来处理小的特征，轮廓和浅角度。</p><p>有了这个技巧，我们的方法类似于视差遮挡映射。虽然这是一个相对便宜的改进，但通过定义_PARALLAX_RAYMARCHING_INTERPOLATE_，我们让它成为可选的。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(PARALLAX_RAYMARCHING_INTERPOLATE)
</span>    <span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
    <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div><p>在shader内定义PARALLAX_RAYMARCHING_INTERPOLATE。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div><h3 id="步长搜索">步长搜索</h3><p>通过在两个步长之间进行线性插值，我们假定表面在两个步长之间是笔直的。 但是，通常情况并非如此。 为了更好地处理不规则的高度场，我们必须在两个步长之间搜索实际的交点。 或至少接近它。</p><p>完成循环后，不要使用最后的偏移量，而是将偏移量调整到最后两个步长的中间位置。对该点的高度进行采样。如果我们结束在表面以下，向表面之上方向移动四分之一，并再次采样。如果我们在表面上结束，向表面之下方向移动四分之，并再次采样。不断重复这个过程。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012952340-10743193.png" width="250"><font size="2.5"> <i>越来越接近交点.</i> </font> </center><p>上述方法是二分查找的一个应用。它与地形测绘方法最匹配。每走一步，路程减半，直到到达目的地。在我们的例子中，我们将简单地做固定次数，以达到预期的解决方案。一步，得到0.5。两步，得到0.25、0.75。三步，是0.125、0.375、0.625、0.875。注意，从第二步开始，每次采样提升分的辨率将翻倍。</p><p>为了控制是否使用此方法，我们定义_PARALLAX_RAYMARCHING_SEARCH_STEPS_。默认情况下将其设置为零，这意味着我们根本不进行搜索。如果它被定义为大于0，我们将不得不使用另一个循环。注意，这种方法与_PARALLAX_RAYMARCHING_INTERPOLATE_是<strong>不兼容</strong>的，因为我们不能再保证表面是交叉的最后两个步骤。当我们搜索的时候，禁用插值。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(PARALLAX_RAYMARCHING_SEARCH_STEPS)
</span>    <span class="cp">#define PARALLAX_RAYMARCHING_SEARCH_STEPS 0
#endif
#if PARALLAX_RAYMARCHING_SEARCH_STEPS &gt; 0
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="cp">#elif defined(PARALLAX_RAYMARCHING_INTERPOLATE)
</span>    <span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
    <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div><p>此循环也执行与原始循环相同的基本工作。调整偏移量和步高，然后采样高度字段。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>但每次迭代，UV增量和步长减半。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvDelta</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">stepSize</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>同样，如果点在表面之下，我们必须朝相反的方向移动。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uvDelta</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">stepSize</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">stepHeight</span> <span class="o">&lt;</span> <span class="n">surfaceHeight</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">+=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">+=</span> <span class="n">stepSize</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
</code></pre></div></div><p>调整着色器，所以它使用三个搜索步骤</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012953271-1061541462.png" width="250"><font size="2.5"> <i>10步长加上3个二分查找的最终效果.</i> </font> </center><p>结果看起来相当不错，但仍不完美。二分法搜索可以比简单的插值处理较浅的角度，但仍然需要相当多的搜索步骤，以摆脱分层。所以这是一个试验的问题，找出哪种方法在特定情况下最有效，需要多少步骤。</p><h3 id="缩放对象和动态批处理">缩放对象和动态批处理</h3><p>尽管我们的视差映射方法似乎可行，但存在一个隐藏的错误。 而且还把错误显示出来了。它显示了何时使用动态批处理来组合已缩放的对象。 例如，给我们的四边形一个像\((10,10,10)\)的比例，然后复制它，将副本移到它下面一点。 假设在播放器设置中启用了此选项，这将触发Unity动态批处理四边形。</p><p>批处理开始时，视差效果将扭曲。 旋转相机时，这一点非常明显。 但是，这仅发生在游戏视图和构建中，而不发生在场景视图中。 请注意，standard着色器也存在此问题，但是当使用弱偏移视差效果时，您可能不会立即注意到它。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012954391-1540920343.png" width="250"><font size="2.5"> <i>动态批处理会产生奇怪的结果.</i> </font> </center><p>在批处理将它们合并到一个单一的网格中之后，Unity不能标准化处理后的几何法向量和切向量。因此顶点数据正确的假设不再成立。</p><p>顶点法向量和切向量没有规范化不是什么大的问题，因为我们在顶点程序中将视图向量转换到切线空间。对于其他所有内容，数据在使用之前都要标准化。</p><p>解决方法是在构造对象转换到切线矩阵之前对向量进行归一化。 因为只有动态批处理的缩放几何才需要此选项，所以根据是否定义了PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING，将其设为可选。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined (_PARALLAX_MAP)
</span>    <span class="cp">#if defined(PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING)
</span>        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span><span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
        <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
    <span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">objectToTangent</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3
#define PARALLAX_FUNCTION ParallaxRaymarching
#define PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING
</span></code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/batched-correct.png" width="250"><font size="2.5"> <i>动态批量与正确的结果.</i> </font> </center><div class="post-copyright"><p> <span>版权声明：</span> 如无特别声明，本文版权归 <a href="https://www.damonc.top" class="cplink">编程散记</a> 所有，转载请注明本文链接。</p><p> （采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" class="extlinks">CC BY-NC-SA 4.0</a> 许可协议进行授权）</p><p><span>本文标题：</span>《 视差和法线、高度图回顾(翻译二十) 》</p><p><span>本文链接：</span><a href="https://www.damonc.top/Unity_Parallax_Normals_Heightmap.html" class="cplink">https://www.damonc.top/Unity_Parallax_Normals_Heightmap.html</a></p><p class="tips">本文最后一次更新为 <span></span> 天前，文章中的某些内容可能已过时！</p></div></article></div><div class="table-of-contents"><div class="toc-header"><h2>目录</h2></div><div class="toc-body"><ul><li><a onclick="scrollToAdjust('视差纹理')">1. 视差纹理</a><ul><li><a onclick="scrollToAdjust('法线贴图效果回顾')">1.1 法线贴图效果回顾</a><li><a onclick="scrollToAdjust('shader参数')">1.2 Shader参数</a><li><a onclick="scrollToAdjust('坐标匹配')">1.3 坐标匹配</a><li><a onclick="scrollToAdjust('随视角方向移动')">1.4 随视角方向移动</a><li><a onclick="scrollToAdjust('基于高度滑动')">1.5 基于高度滑动</a><li><a onclick="scrollToAdjust('偏移视差映射算法')">1.6 偏移视差映射算法</a><li><a onclick="scrollToAdjust('parallax-configuration')">1.7 Parallax Configuration</a><li><a onclick="scrollToAdjust('detail-uv')">1.8 Detail UV</a></ul><li><a onclick="scrollToAdjust('ray-marching-光线步进')">2. Ray Marching-光线步进</a><ul><li><a onclick="scrollToAdjust('自定义视差函数')">2.1 自定义视差函数</a><li><a onclick="scrollToAdjust('相交计算')">2.2 相交计算</a><li><a onclick="scrollToAdjust('更多步进')">2.3 更多步进</a><li><a onclick="scrollToAdjust('步长之间插值')">2.4 步长之间插值</a><li><a onclick="scrollToAdjust('步长搜索')">2.5 步长搜索</a><li><a onclick="scrollToAdjust('缩放对象和动态批处理')">2.6 缩放对象和动态批处理</a></ul></ul></div></div></div></div><div class="social-share-wrapper"><div class="social-share"></div></div></main><section class="author-detail"><section class="post-footer-item author-card"><div class="avatar"> <img src="https://img.damonc.top/commons/avatar.png" alt=""></div><div class="author-name" rel="author">编程散记</div><div class="bio"><p>Developer & Maintainer</p></div><ul class="sns-links"><li> <a href="https://github.com/damonc-top" target="_blank" aria-label="github"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-github"></use> </svg> </a><li> <a href="https://segmentfault.com/u/junyidebocai" target="_blank" aria-label="segmentfault"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-segmentfault"></use> </svg> </a></ul></section><section class="post-footer-item read-next"><div class="read-next-item"> <a href="/unity3d/Unity_Addressable_Editor.html" class="read-next-link" aria-label="Unity Addressable System使用分析(一)"></a><section> <span>Unity Addressable System使用分析(一)</span><p>Addressable安装  总结在使用Unity Addressable System过程中遇到的一部分问题，该...</p></section></div><div class="read-next-item"> <a href="/Unity_GPU_Instance.html" class="read-next-link" aria-label="Unity GPU Instance(翻译十九)"></a><section> <span>Unity GPU Instance(翻译十九)</span><p>本篇摘要： 渲染大量球体-优化DrawCall 支持GPU-Instance 使用材质属性块 LOD-Gr...</p></section></div></section><script src="https://unpkg.com/@waline/client@3.3.2/dist/waline.umd.js" async onload="initWaline()"></script> <script> function initWaline() { $(document).ready(function () { Waline.init({ el: '#waline', serverURL: "https://comments.damonc.top", reaction: "true", comment: true, locale: "{reaction0: '赞一个', reaction1: '踩一下', reaction2: '有点酷', reaction3: '看不懂', reaction4: '啥玩意', reaction5: '想睡觉'}", }); }); } </script> <script> $(document).ready(function () { if ($("#comments-switch").length > 0) { var comment_status = $("#cmn-toggle-4")[0].checked; if (comment_status) { $("#waline").addClass("active"); } else { $("#disqus_thread").addClass("active"); } $("#cmn-toggle-4").click(function () { $("#disqus_thread").toggleClass("active"); $("#waline").toggleClass("active"); }) } else { if ($("#disqus_thread").length > 0) { $("#disqus_thread").addClass("active"); } else if ($("#waline").length > 0) { $("#waline").addClass("active"); } } }) </script><section class="post-footer-item comment"><div class="comments-headline"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-comment"></use> </svg> <span>评论</span></div></section><section class="post-footer-item comment"><div id="waline"></div></section></section><footer class="g-footer"><div class="g-container"><div class="g-left"><section class="links"> 本站由 <a href="//jekyllrb.com" target="_blank" class="extlinks">Jekyll</a> 和 基于 <a href="https://github.com/kaeyleo/jekyll-theme-H2O" target="_blank" class="extlinks">H2O主题模版</a> 强力驱动</section><section class="links">编程散记 © 2016 - 2025 <a href="https://icp.gov.moe/?keyword=20240160" target="_blank" class="extlinks">萌ICP备20240160号</a> <a href="/rss.xml" target="_blank" aria-label="Terms of Service" class="others"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-rss"></use> </svg> RSS </a> <a href="/tos" target="_blank" aria-label="Terms of Service" class="others"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-tos"></use> </svg> 使用条款 </a></section><section class="links"> <span id="busuanzi_container_site_pv"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-pv"></use> </svg> 总浏览量 <span id="busuanzi_value_site_pv"></span> <b>·</b> </span> <span id="busuanzi_container_site_uv"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-user"></use> </svg> 总访问量 <span id="busuanzi_value_site_uv"></span> </span></section><section> 本站已运行 <span class="alivetime_days"></span> 天 <span class="alivetime_hours"></span> 小时 <span class="alivetime_minutes"></span> 分 <span class="alivetime_seconds"></span> 秒</section></div><div class="g-right"><section class="badges"> <a href="https://www.foreverblog.cn/" target="_blank" class="foreverblog" aria-label="foreverblog"> <img loading="lazy" src="https://img.foreverblog.cn/logo_en_default.png" alt=""> </a> <a href="https://www.foreverblog.cn/go.html" target="_blank" class="wormhole" aria-label="wormhole"> <img loading="lazy" src="https://img.foreverblog.cn/wormhole_3.gif" alt="" title="穿梭虫洞-随机访问十年之约友链博客"> </a> <a href="https://www.travellings.cn/go.html" target="_blank" class="travelling-badge" aria-label="Travelling" rel="noopener" title="开往-友链接力"> <img loading="lazy" src="https://cdn.jsdelivr.net/gh/travellings-link/travellings/assets/logo.gif" alt="开往-友链接力"> </a> <a href="https://notbyai.fyi/" target="_blank" class="notbyAI" aria-label="notbyAI"> <img loading="lazy" src="/assets/icons/notbyAI-white.png" alt="Written by Human, Not by AI"> </a></section></div></div></footer><div class="cookie-tip"> 为了提升本站的使用体验和必要功能的正常使用，本站会使用本地 Cookie。详细请查看「 <a href="/tos.html">本站使用条款</a> 」了解更多。 <button id="accept-tos">同意</button></div><section id="tools"><div class="tool toc"> <svg class="icon b1 active" aria-hidden="true"> <use xlink:href="#icon-toc"></use> </svg> <svg class="icon b2" aria-hidden="true"> <use xlink:href="#icon-exit"></use> </svg></div></section><section id="bttb" aria-label="Scroll back to top" class="bttb"><div class="tool"> <svg class="icon top" aria-hidden="true"> <use xlink:href="#icon-top"></use> </svg></div></section></div><div class="modal"><div class="modal-content"><header> <span class="close">&times;</span></header><div class="container"></div></div></div><script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" async></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/dayjs.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/plugin/customParseFormat.js"></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/plugin/relativeTime.js"></script> <script> $(document).ready(function () { var time_formats = ['YYYY-MM-DD HH:mm:ss ZZ', 'YYYY DD MMM HH:mm:ss ZZ', 'YYYY年MM月DD日 HH:mm:ss ZZ']; function dateFormat(date, format) { var date_org = dayjs(date, time_formats[format]); var date = date_org.format(time_formats[format]); return { "date_org": date_org, "date": date } } dayjs.extend(window.dayjs_plugin_customParseFormat); dayjs.extend(window.dayjs_plugin_relativeTime); var post_date = $("meta[property='post-date']").attr('content'); var post_date_format = $("meta[property='post-date-format']").attr('content'); var local_post_date = dateFormat(post_date, post_date_format); $(".post time span.create-at").html(local_post_date["date"]); var path = "post_project/_posts/2018/ShaderTranslate/2018-01-25-Unity_Parallax_Normals_Heightmap.md"; var workerUrl = "https://winter-meadow-170b.damoncbl.workers.dev?" + new URLSearchParams({ path: path }); fetch(workerUrl).then(function (res) { if (!res.ok) throw new Error("worker non-200: " + res.status); return res.json(); }).then(function (commits) { if (commits && commits.length) { var update_at = dayjs(commits[0]['commit']['committer']['date']); } else { var update_at = post_date; } var local_update_at = dateFormat(update_at, post_date_format); $('.post time span.update-at').html(local_update_at["date"]); var relative_time = dayjs().diff(local_update_at["date_org"], 'day'); $(".post-copyright .tips span").append(relative_time); if (relative_time > 365) { $(".post-copyright .tips").addClass("active"); } }).catch(function () { var local_update_at = dateFormat(post_date, post_date_format); $('.post time span.update-at').html(local_update_at["date"]); }); }); </script> <script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script> <script> socialShare('.social-share', { sites: [ 'wechat', 'weibo', 'douban', 'twitter' ], wechatQrcodeTitle: "分享到微信朋友圈", wechatQrcodeHelper: '<p>扫码后点击右上角</p><p>将本文分享至朋友圈</p>' }); $("a.social-share-icon").each(function () { $(this).attr("aria-label", $(this).attr("class").split(' ')[1]) }); </script> <script src="https://cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script> <script> function scrollToAdjust(id){ var element = document.getElementById(id); var headerOffset = 90; var elementPosition = element.getBoundingClientRect().top; var offsetPosition = elementPosition + window.scrollY - headerOffset; window.scrollTo({ top: offsetPosition, behavior: "smooth" }); } </script> <script src="/assets/js/app.min.js"></script> <script src="https://at.alicdn.com/t/c/font_3046306_ujr2yq34hw.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-WN45VXRK"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'GTM-WN45VXRK'); </script> <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> <script async src="https://cdn.jsdelivr.net/npm/promise-polyfill@8.3.0/dist/polyfill.min.js"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax-full@3.2.2/es5/tex-mml-svg.min.js"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ jax: ["input/TeX", "output/HTML-CSS"], tex2jax: { inlineMath: [['$', '$'], ["\\(", "\\)"]], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }, "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] } }); </script> <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.min.js"></script> <script> $(document).ready(function () { var baseurl = $("meta[property='og:baseurl']").attr('content'); $("center img").each(function () { $(this).attr('data-src', $(this).attr('src')).removeAttr('src').addClass("lazyload").attr('src', baseurl + '/assets/img/loading.gif'); var strA = "<a data-fancybox='gallery' ref='gallery' href='" + $(this).attr('data-src') + "' data-caption='" + $(this).attr('alt') + "'></a>"; $(this).wrapAll(strA); var caption = $(this)[0].alt; $(this).parent().after('<span class="caption">' + caption + '</span>'); }); Fancybox.bind('[data-fancybox]', { on: { load: function(fancybox, slide) { var gray = $("meta[property='og:gray']").attr('content'); if (gray == "true") { $(".fancybox__content img").addClass("gray"); $(".carousel__track .fancybox__thumb").addClass("gray"); } } } }); }); </script> <script src="https://cdn.jsdelivr.net/npm/hotkeys-js/dist/hotkeys.min.js"></script> <script> $(document).ready(function () { var previous_url = $("meta[property='og:previous_url']").attr('content'); var next_url = $("meta[property='og:next_url']").attr('content'); hotkeys('left', function (event, handler) { event.preventDefault(); if (previous_url) { console.log('you pressed left!'); window.location.href = previous_url; } else { $("#no-previous").addClass("active"); setTimeout(function () { $("#no-previous").removeClass("active"); }, 1500); } }); hotkeys('right', function (event, handler) { event.preventDefault(); if (next_url) { console.log('you pressed right!'); window.location.href = next_url; } else { $("#no-next").addClass("active"); setTimeout(function () { $("#no-next").removeClass("active"); }, 1500); } }); }); </script> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.6/dist/mermaid.min.js"></script> <script> $(document).ready(function () { mermaid.initialize({ startOnLoad: true, theme: "default", }); mermaid.init(undefined, $('.mermaid2')); }); </script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script> <script> if (window.Prism) { Prism.languages.mermaid2 = Prism.languages.none || {}; } </script> <script> if ("serviceWorker" in navigator) { var env = 'development'; var isDev = env === 'development'; navigator.serviceWorker .register('/sw.js', { scope: '/' }) .then(function (reg) { if (isDev) console.log("Service worker registered for scope:", reg.scope); }) .catch(function (err) { if (isDev) console.warn("Service worker registration failed:", err); }); } </script> <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script> <script type="text/javascript"> docsearch({ appId: "NCUJ5WJECO", apiKey: "b625a4b91a45af033cbdb526694e9e65", indexName: "damonc", lang: "zh", insights: true, debug: false, container: 'li#search', }); </script>
