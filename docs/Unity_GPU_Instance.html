<!DOCTYPE html><html lang="zh-Hans"> <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Unity GPU Instance(翻译十九) - 编程散记</title><meta name="author" content="编程散记"><meta name="description" content="Unity GPU Instance(翻译十九)"><meta name="keywords" content="Shader"><meta property="og:previous_url" content="/Unity_Parallax_Normals_Heightmap.html"><meta property="og:next_url" content="/Unity_RealTime_GI_LOD.html"><meta property="post-date-format" content="0"><meta property="post-date" content="2018-01-24 20:00:00 +0800" /><meta property="calendar-scale" content="year" /><meta property="calendar-scheme" content="null" /><meta property="calendar-color" content="null" /><meta property="og:title" content="Unity GPU Instance(翻译十九) - 编程散记"><meta property="og:type" content="website"><meta property="og:url" content="https://www.damonc.top/Unity_GPU_Instance.html"><meta property="og:baseurl" content=""><meta property="og:description" content="个人的一个技术博客站点，记录生活、工作、学习中的一些小事，以及一些比较有趣的事情，留点什么东西也挺不错的，偶尔会在这里停留。"><meta property="og:site_name" content="编程散记"><meta property="og:gray" content="false"><meta property="og:lang" content="zh-Hans"><meta name="alivestart" content="12/23/2020"><meta name="theme-color" content="#81BBFF" /><meta name="algolia-site-verification" content="5E91324370E1262B" /><title>Algolia Verification</title><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="manifest" href="/manifest.json" async><link rel="apple-touch-icon" href="/assets/img/touch/apple-touch-icon.png" /><link rel="Shortcut Icon" href="/favicon.ico"><link rel="icon" href="/favicon.ico" type="image/x-icon" /><link rel="bookmark" href="/favicon.ico" type="image/x-icon" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.min.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.2.0/github-markdown-light.min.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-light.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://unpkg.com/@waline/client@3.3.2/dist/waline.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3" async><link rel="stylesheet" href="/assets/css/app.min.css" async><body class="line-numbers" ontouchstart=""><div id="all" class="post" data-theme="default"><div class="alert-tip" id="no-previous">已经是最新一篇文章了！</div><div class="alert-tip" id="no-next">已经是最后一篇文章了！</div><input id="nm-switch" type="hidden" value="false"><header class="g-header" data-theme="default"><div class="g-logo"> <a href="/" aria-label="logo"></a></div><div id="search-toggle"></div><div id="travelling-toggle"> <a href="https://www.travellings.cn/go.html" aria-label="Travelings" target="_blank"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-train-subway"></use> </svg> </a></div><div id="mode-toggle"> <svg class="icon icon-day" aria-hidden="true"> <use xlink:href="#icon-day"></use> </svg> <svg class="icon icon-night" aria-hidden="true"> <use xlink:href="#icon-night"></use> </svg></div><svg id="menu-toggle" class="icon-menu" aria-hidden="true"> <use xlink:href="#icon-menu"></use> </svg><nav class="g-nav"><ul><li> <a href="/" aria-label="home"> home </a><li> <a href="/blog/index.html" aria-label="blog"> blog </a><li> <a href="/archives.html" aria-label="archives"> archives </a><li> <a href="/tags.html" aria-label="tags"> tags </a><li class="dropdown"> <a class="dropdown-toggle" href="#"> about </a><ul class="dropdown-menu"><li> <a href="/feed.xml" aria-label="RSS"> RSS </a></ul><li class="travelling"> <a href="https://www.travellings.cn/go.html" aria-label="Travelings" target="_blank"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-train-subway"></use> </svg> </a><li class="mode"> <svg class="icon day" aria-hidden="true"> <use xlink:href="#icon-day"></use> </svg> <svg class="icon night" aria-hidden="true"> <use xlink:href="#icon-night"></use> </svg><li id="search"></ul></nav></header><div class="g-banner post-header post-pattern-circuitBoard bgcolor-default post-no-cover" data-theme="default"><div class="post-wrapper"><div class="post-tags"> <a href="/%20/tags.html#Shader" class="post-tag">Shader</a></div><h1>Unity GPU Instance(翻译十九)</h1><div class="post-meta"> <span class="post-meta-item"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-user"></use> </svg> catlikecoding </span> <time class="post-meta-item" datetime=" 18-01-24"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-calendar"></use> </svg> <span class="create-at"></span> </time> <time class="post-meta-item" datetime=" 18-01-24"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-update"></use> </svg> <span class="update-at"></span> </time> <span class="post-meta-item"> <svg class="icon words" aria-hidden="true"> <use xlink:href="#icon-words"></use> </svg> 本文总共 9.1k 字 </span> <span class="post-meta-item"> <svg class="icon time" aria-hidden="true"> <use xlink:href="#icon-time"></use> </svg> 阅读全文大约需要 26 分钟 </span> <span class="post-meta-item"> <svg class="icon pv" aria-hidden="true"> <use xlink:href="#icon-pv"></use> </svg> 本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次 </span></div></div></div><main class="post-content visible"><div class="container"><div class="submenu hidden"></div><div class="contents"><article class="markdown-body post"><p>本篇摘要：</p><ul><li>渲染大量球体-优化DrawCall<li>支持GPU-Instance<li>使用材质属性块<li>LOD-Groups支持GPU-Instance</ul><h2 id="batching-instance-批处理">Batching Instance-批处理</h2><p>指示GPU绘制需要花时间；向其传递mesh和material属性也要花时间。现在已知两种节省Draw Call的方式：static和<a href="https://docs.unity3d.com/Manual/DrawCallBatching.html" rel="nofollow" target="_blank" class="extlinks"><strong>dynamic batching</strong></a></p><p>Unity可以将多个静态物体的网格合并为一个更大的静态网格，从而减少draw call。 <strong>注意：</strong> 只有使用相同材质的对象才能以这种方式组合。 这是以必须存储更多网格数据为代价的。 启用动态批处理后，Unity在运行时会对视图中的动态对象执行相同的操作。 这仅适用于小型网格物体，否则开销将变得太大。</p><p>还有另一种组合draw call的方法：GPU instance或Geometry instance。与动态批处理一样，此操作在运行时针对可见对象。 它的目标是让GPU一次性渲染同一网格的多个副本。 因此，它不能组合不同的网格或材质。</p><h3 id="创建大量球体">创建大量球体</h3><div class="language-plaintext tip-info highlighter-rouge"><div class="highlight"><pre class="highlight"><code>im title?
test test test.
test test test.
test test test!!dfS:FDFH&amp;*YER#.
</code></pre></div></div><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">using</span> <span class="n">UnityEngine</span><span class="p">;</span>

<span class="kr">public</span> <span class="k">class</span> <span class="n">GPUInstancingTest</span> <span class="o">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="n">Transform</span> <span class="n">prefab</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">int</span> <span class="n">instances</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">50</span><span class="n">f</span><span class="p">;</span>
    <span class="c1">//单位圆内随机一点并放大坐标50倍，生成5000个球体</span>
    <span class="c1">//然后查看statistics统计的draw Call信息</span>
    <span class="kt">void</span> <span class="n">Start</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
            <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>使用forward render path统计到的draw call，去掉背景和camera Effect两个draw call：</p><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010902826-821880737.png" width="250"><font size="2.5"> <i>5000 draw call.</i> </font> </center><p>但是当使用cube代替球体</p><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010904552-338192039.png" width="250"><font size="2.5"> <i>6 draw call.</i> </font> </center><h3 id="支持instance">支持Instance</h3><p>默认情况下，GPU Instance不会开启，必须设计shader以支持它。 即使这样，也必须为每种材料显式启用实例化。 Unity的standard着色器有一个开关。像标准着色器的GUI一样，我们将为shader扩展面板创建“高级选项”部分。 可以通过调用MaterialEditor.EnableInstancingField方法来添加切换。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoAdvanced</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">GUILayout</span><span class="p">.</span><span class="n">Label</span><span class="p">(</span><span class="s">"Advanced Options"</span><span class="p">,</span> <span class="n">EditorStyles</span><span class="p">.</span><span class="n">boldLabel</span><span class="p">);</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">EnableInstancingField</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div><p>仅当shader实际支持instance时，才会显示该切换。 我们可以通过将#pragma multi_compile_instancing指令添加到着色器base-pass启用此支持。 这将为一些关键字启用着色器变体，自定义关键字_INSTANCING_ON_，其他关键字也可以。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_fwdbase
#pragma multi_compile_fog
#pragma multi_compile_instancing
</span></code></pre></div></div><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010905493-1524350499.png" width="250"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010906722-1492830859.png" width="250"><font size="2.5"> <i>合并了，但是显示有错误.</i> </font> </center><p>批处理数量已减少到42，这意味着现在仅用40个批处理即可渲染所有5000个球体。帧速率也高达80 fps，但是只有几个球体可见。<strong>错误原因</strong>：虽然5000个球体仍在渲染，但是在合批中同一批次的所有球体的顶点转换时都使用了同一个位置：它们都使用同一批次中第一个球的转换矩阵。 发生这种情况是因为现在同一批中所有球体的矩阵都作为数组发送到GPU。 在不告知着色器要使用哪个数组索引的情况下，它始终使用第一个索引。</p><h3 id="instance-ids">Instance IDs</h3><p>上述错误解决办法：每个Instance相对应的数组索引称为其Instance ID，GPU通过顶点数据将其传递到着色器的vertex程序。在大多数平台上，它是一个无符号整数，名为instanceID，具有SV_InstanceID语义。 我们可以简单地使用_UNITY_VERTEX_INPUT_INSTANCE_ID_宏将其包含在我们的VertexData结构中。 它在UnityCG中包含的_UnityInstancing.cginc_文件中定义。 它为我们提供了实例ID的正确定义，或者在未启用实例化时不提供任何内容。将其添加到VertexData结构。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div><p>启用instance后，我们现在可以在顶点程序中访问instanceID。 有了它，我们可以在变换顶点位置时使用正确的矩阵。 但是，UnityObjectToClipPos函数没有矩阵参数，它函数内部始终使用unity_ObjectToWorld矩阵。要解决此问题，UnityInstancing包含文件会使用矩阵数组的宏覆盖unity_ObjectToWorld。 <em>这可以被认为是肮脏的宏技巧，但无需更改现有着色器代码即可工作，从而确保了向后兼容性</em>。</p><p>要使它工作，instance的数组索引必须对所有着色器代码全局可用。必须通过_UNITY_SETUP_INSTANCE_ID_宏进行手动设置，该宏必须在vertex程序最先计算，然后再执行其他的代码。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010908398-221325174.png" width="250"><font size="2.5"> <i>矩阵替换内部实现？.</i> </font> </center><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//UnityInstancing中的实际代码要复杂得多。 它要处理平台差异，其他使用实例化的方法以及用于立</span>
<span class="c1">//体声渲染的特殊代码，从而导致间接定义的多个步骤。 它还必须重新定义UnityObjectToClipPos，因</span>
<span class="c1">//为UnityCG首先包含UnityShaderUtilities。</span>
<span class="c1">//缓冲区宏将在后面说明。</span>
<span class="k">static</span> <span class="n">uint</span> <span class="n">unity_InstanceID</span><span class="p">;</span>

<span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityDrawCallInfo</span><span class="p">)</span>
    <span class="c1">// Where the current batch starts within the instanced arrays.</span>
    <span class="n">int</span> <span class="n">unity_BaseInstanceID</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>

<span class="cp">#define UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;
</span>
<span class="cp">#define UNITY_SETUP_INSTANCE_ID(input) \
    unity_InstanceID = input.instanceID + unity_BaseInstanceID;
</span>
<span class="c1">// Redefine some of the built-in variables</span>
<span class="c1">// macros to make them work with instancing.</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">PerDraw0</span><span class="p">)</span>
    <span class="kt">float4x4</span> <span class="n">unity_ObjectToWorldArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
    <span class="kt">float4x4</span> <span class="n">unity_WorldToObjectArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
<span class="cp">#define unity_ObjectToWorld     unity_ObjectToWorldArray[unity_InstanceID]
#define unity_WorldToObject     unity_WorldToObjectArray[unity_InstanceID]
</span></code></pre></div></div><h3 id="批处理大小">批处理大小</h3><p>每台设备不一样，最终得到的批次数量可能与当前实验得到的数量不同。现在这情况下，以40批渲染5000个球体实例，这意味着每批125个球体。</p><p>每个批次都需要自己的矩阵数组。 此数据发送到GPU并存储在内存缓冲区中，在Direct3D中称为常量缓冲区，在OpenGL中称为统一缓冲区。 这些<strong>缓冲区具有最大大小</strong>，这限制了一批中可以容纳多少个实例。 假设台式机GPU每个缓冲区的限制为64KB。</p><p>一个矩阵由16个浮点数组成，每个浮点数均为4个字节。 因此，每个矩阵64个字节。 每个实例都需要一个对象到世界的转换矩阵。 但是，我们还需要一个世界到对象的矩阵来转换法线向量。 因此，最终每个实例有128个字节。 这导致最大批处理大小为“ 64000/128 = 500”，这只能在10个批处理中渲染5000个球体。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>内存单位是2进制，所以1KB表示1024字节，而不是1000。因此，'(64 * 1024)/ 128 = 512 '。UNITY_INSTANCED_ARRAY_SIZE默认定义为500，但您可以使用编译器指令覆盖它。例如，#pragma instancing_options maxcount:512将最大值设置为512。但是，这将导致断言失败错误，因此实际限制为511。到目前为止，500和512之间没有太大的差别。
</code></pre></div></div><p>即使假设台式机的最大容量为64KB成立，但是大多数移动设备的最大容量远远达不到64，可能仅为16KB。 Unity通过在针对OpenGL ES 3，OpenGL Core或Metal时将最大值除以四来解决此问题。 因为我在编辑器中使用的是OpenGL Core，所以最终的最大批处理大小为“ 500/4 = 125”。</p><p>可以通过添加编译器指令#pragma instancing_options force_same_maxcount_for_gl来禁用此自动减少功能。 多个instance选项组合在同一指令中。 但是，这可能会导致在部署到移动设备上时发生故障，因此请小心使用。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>那假设均等缩放选项呢？

可以使用#pragma instancing_options指示所有instance对象具有统一的缩放比例。 这消除了将世界到对象矩阵用于法线转换的需要(少存储一个矩阵)。 设置此选项后，虽然UnityObjectToWorldNormal函数确实会更改其行为，但它不会消除第二个矩阵数组。 因此，至少在Unity 2017.1.0中，此选项实际上没有任何作用。
</code></pre></div></div><h3 id="instance-shadows">Instance Shadows</h3><p>到目前为止，一直没有阴影。 重新打开主阴影的Soft shadow，并确保阴影距离足以包含所有球体</p><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010909964-776430193.png" width="250"><font size="2.5"> <i>批处理爆炸.</i> </font> </center><p>为大量物体渲染阴影会增加GPU耗能。但是我们也可以在渲染球体阴影时使用GPU instance。在shadow caster-pass中添加instance指令；同时也增加<code class="language-plaintext highlighter-rouge">UNITY_VERTEX_INPUT_INSTANCE_ID</code> and <code class="language-plaintext highlighter-rouge">UNITY_SETUP_INSTANCE_ID</code></p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_shadowcaster
#pragma multi_compile_instancing
</span><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
	<span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010911627-1161944067.png" width="250"><font size="2.5"> <i>instanced 阴影.</i> </font> </center><h3 id="多光源">多光源</h3><p>我们仅在base-pass和shadow caster-pass中添加了instance支持。 因此，批处理不适用于其他光源。 要验证这一点，停用主光源并添加一些会影响多个球体的聚光灯或点光源。 不要为它们打开阴影，因为那样会降低帧速率。</p><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010913312-1389275661.png" width="250"><font size="2.5"> <i>批处理爆炸.</i> </font> </center><p>上图，完全不支持多光源批处理。 要将instance与多个光源结合使用，只能切换到延迟渲染路径。 为此，请将所需的编译器指令添加到着色器的延迟传递中。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_prepassfinal
#pragma multi_compile_instancing
</span></code></pre></div></div><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010914967-1310775534.png" width="250"><font size="2.5"> <i>多光源instance.</i> </font> </center><h2 id="mixing-material-properties">Mixing Material Properties</h2><p>所有批处理都有一个限制：它们仅限于具有相同材料的对象。 当我们希望渲染的对象具有多样性时，此限制就会成为问题。</p><h3 id="随机着色">随机着色</h3><p>随机改变球体的颜色</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">MeshRenderer</span><span class="o">&gt;</span><span class="p">().</span><span class="n">material</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span>    <span class="kr">new</span> <span class="n">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010916576-490651101.png" width="250"><font size="2.5"> <i>球体与随机的颜色，没有批量和阴影.</i> </font> </center><p>即使我们为物料启用了批处理，它也不再起作用。由于每个球体现在都有自己的材质，因此每个球体的着色器状态也必被更改。 这显示在统计面板中为SetPass call的数量。在这修改之前只有少量几个批次渲染，但是现在是5000加批次。</p><h3 id="材质属性块-material-property-blocks">材质属性块-Material Property Blocks</h3><p>除了为每个球体创建新的材质实例外，我们还可以使用材质属性块。 这些是小的修改，设置属性块的颜色并将其传递给球体的渲染器，而不是直接分配材质的颜色。<a href="http://docs.unity3d.com/Documentation/ScriptReference/MaterialPropertyBlock.html" rel="nofollow" target="_blank" class="extlinks">MaterialPropertyBlock</a>官网介绍;</p><h3 id="property-buffers-属性缓冲区">Property Buffers-属性缓冲区</h3><p>渲染instance对象时，Unity通过数组形式将颜色数据传递到GPU内存并转换矩阵，Unity对存储在材料属性块中的属性执行相同的操作，但要使其起作用的话，我们必须在shader中定义一个instance的缓冲区。</p><p>声明instance缓冲区的工作类似于创建诸如插值器之类的结构，但是确切的语法因平台而异。 我们可以使用UNITY_INSTANCING_CBUFFER_START和UNITY_INSTANCING_CBUFFER_END宏来解决差异。 启用实例化后，它们将不执行任何操作。</p><p>将_Color变量的定义放在instance缓冲区中。 UNITY_INSTANCING_CBUFFER_START宏需要一个名称参数，实际名称无关紧要但要注意避免重名冲突。 宏以UNITY_INSTANCING_为其前缀。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="kt">float4</span> <span class="n">_Color</span><span class="p">;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div><p>像变换矩阵一样，启用instance后，颜色数据作为数组上传到GPU。UNITY_DEFINE_INSTANCED_PROP宏会为我们处理正确的声明语法。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="c1">//float4 _Color;</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div><p>最后要访问fragment程序中的数组，我们还需要在其中知道instanceID。 因此，将其添加到插值器结构中。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</code></pre></div></div><p>在vertex顶点程序中，将ID从顶点数据复制到插值器。 启用实例化时，UNITY_TRANSFER_INSTANCE_ID宏定义此简单操作，否则不执行任何操作。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>在片段程序的开头，使ID全局可用，就像在顶点程序中一样。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>现在，我们必须在不使用instance时以_Color的形式访问颜色，而在启用实例化时以_Color [unity_InstanceID]的形式访问颜色。 使用UNITY_ACCESS_INSTANCED_PROP宏可同时支持上述两种访问。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="nf">GetAlbedo</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">albedo</span> <span class="o">=</span>
        <span class="nb">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>新版本如果编译有错误：
从2017.3及以上版本, UNITY_ACCESS_INSTANCED_PROP macro改了它需要的两个参数：buffer名，颜色名使用UNITY_ACCESS_INSTANCED_PROP(InstanceProperties, _Color).
</code></pre></div></div><center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010918398-38688989.png" width="250"></center><p>现在，我们的颜色随机的球再次被批处理。 我们<strong>可以用相同的方式使其他属性可变。 对于颜色，浮点数，矩阵和四分量浮点向量，这是可能的</strong>。 <strong>如果要改变纹理，可以使用单独的纹理数组</strong>，并将索引添加到实例化缓冲区。其他属性修改类似。</p><p>可以在同一个缓冲区中组合多个属性，但要牢记大小限制。 还应注意，缓冲区被划分为32位块，因此单个浮点数需要与向量相同的空间。 您也可以使用多个缓冲区，但是也有一个限制，它们不是免费提供的。 启用instance后，每个要缓冲的属性都将成为一个数组，因此仅对需要根据instance变化的属性执行此操作。</p><h3 id="阴影">阴影</h3><p>我们的阴影也取决于颜色。 调整shader阴影以便每个实例也可以支持唯一的颜色。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//float4 _Color;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>

<span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">float4</span> <span class="nf">MyShadowFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="lod-instance">LOD Instance</h3><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialPropertyBlock</span> <span class="n">properties</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="p">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="nf">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="c1">//MaterialPropertyBlock properties = new MaterialPropertyBlock();</span>
        <span class="n">properties</span><span class="p">.</span><span class="nf">SetColor</span>
        <span class="p">(</span>
            <span class="s">"_Color"</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="c1">//t.GetComponent&lt;MeshRenderer&gt;().SetPropertyBlock(properties);</span>
        <span class="n">MeshRenderer</span> <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> 
        <span class="p">{</span>
            <span class="c1">//对LOD子对象设置颜色</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ci</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">ci</span> <span class="p">&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">childCount</span><span class="p">;</span> <span class="n">ci</span><span class="p">++)</span> <span class="p">{</span>
                <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">GetChild</span><span class="p">(</span><span class="n">ci</span><span class="p">).</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010919954-2006515171.png" width="250"></center><p>不幸的是没有有效的批处理。Unity能够对以相同的LOD颜色球体进行批处理，但是如果可以像往常一样进行批处理会更好。 我们可以通过用缓冲数组替换unity_LODFade来实现。可以通过为支持实例化的每个过程添加lodfade实例化选项来指示Unity的着色器代码执行此操作。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_instancing
#pragma instancing_options lodfade
</span></code></pre></div></div><center class="half"> <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010921540-656727216.png" width="250"><font size="2.5"> <i>instance LOD fading.</i> </font> </center><div class="post-copyright"><p> <span>版权声明：</span> 如无特别声明，本文版权归 <a href="https://www.damonc.top" class="cplink">编程散记</a> 所有，转载请注明本文链接。</p><p> （采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" class="extlinks">CC BY-NC-SA 4.0</a> 许可协议进行授权）</p><p><span>本文标题：</span>《 Unity GPU Instance(翻译十九) 》</p><p><span>本文链接：</span><a href="https://www.damonc.top/Unity_GPU_Instance.html" class="cplink">https://www.damonc.top/Unity_GPU_Instance.html</a></p><p class="tips">本文最后一次更新为 <span></span> 天前，文章中的某些内容可能已过时！</p></div></article></div><div class="table-of-contents"><div class="toc-header"><h2>目录</h2></div><div class="toc-body"><ul><li><a onclick="scrollToAdjust('batching-instance-批处理')">1. Batching Instance-批处理</a><ul><li><a onclick="scrollToAdjust('创建大量球体')">1.1 创建大量球体</a><li><a onclick="scrollToAdjust('支持instance')">1.2 支持Instance</a><li><a onclick="scrollToAdjust('instance-ids')">1.3 Instance IDs</a><li><a onclick="scrollToAdjust('批处理大小')">1.4 批处理大小</a><li><a onclick="scrollToAdjust('instance-shadows')">1.5 Instance Shadows</a><li><a onclick="scrollToAdjust('多光源')">1.6 多光源</a></ul><li><a onclick="scrollToAdjust('mixing-material-properties')">2. Mixing Material Properties</a><ul><li><a onclick="scrollToAdjust('随机着色')">2.1 随机着色</a><li><a onclick="scrollToAdjust('材质属性块-material-property-blocks')">2.2 材质属性块-Material Property Blocks</a><li><a onclick="scrollToAdjust('property-buffers-属性缓冲区')">2.3 Property Buffers-属性缓冲区</a><li><a onclick="scrollToAdjust('阴影')">2.4 阴影</a><li><a onclick="scrollToAdjust('lod-instance')">2.5 LOD Instance</a></ul></ul></div></div></div></div><div class="social-share-wrapper"><div class="social-share"></div></div></main><section class="author-detail"><section class="post-footer-item author-card"><div class="avatar"> <img src="https://damonc-top2.github.io/web-assets/commons/avatar.png" alt=""></div><div class="author-name" rel="author">编程散记</div><div class="bio"><p>Developer & Maintainer</p></div><ul class="sns-links"><li> <a href="https://github.com/damonc-top" target="_blank" aria-label="github"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-github"></use> </svg> </a><li> <a href="https://segmentfault.com/u/junyidebocai" target="_blank" aria-label="segmentfault"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-segmentfault"></use> </svg> </a></ul></section><section class="post-footer-item read-next"><div class="read-next-item"> <a href="/Unity_Parallax_Normals_Heightmap.html" class="read-next-link" aria-label="视差和法线、高度图回顾(翻译二十)"></a><section> <span>视差和法线、高度图回顾(翻译二十)</span><p>由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外...</p></section></div><div class="read-next-item"> <a href="/Unity_RealTime_GI_LOD.html" class="read-next-link" aria-label="Unity 实时 GI & LPPV & LOD(翻译十八)"></a><section> <span>Unity 实时 GI & LPPV & LOD(翻译十八)</span><p>本篇摘要： 支持实时全局光照 用动画控制发光对GI的贡献 使用光照探针代理体LPPV LOD组与GI结合 ...</p></section></div></section><script src="https://unpkg.com/@waline/client@3.3.2/dist/waline.umd.js" async></script> <script> $(document).ready(function () { Waline.init({ el: '#waline', serverURL: "https://comments.damonc.top", reaction: "true", comment: true, locale: "{reaction0: '赞一个', reaction1: '踩一下', reaction2: '有点酷', reaction3: '看不懂', reaction4: '啥玩意', reaction5: '想睡觉'}", }); }); </script> <script> $(document).ready(function () { if ($("#comments-switch").length > 0) { var comment_status = $("#cmn-toggle-4")[0].checked; if (comment_status) { $("#waline").addClass("active"); } else { $("#disqus_thread").addClass("active"); } $("#cmn-toggle-4").click(function () { $("#disqus_thread").toggleClass("active"); $("#waline").toggleClass("active"); }) } else { if ($("#disqus_thread").length > 0) { $("#disqus_thread").addClass("active"); } else if ($("#waline").length > 0) { $("#waline").addClass("active"); } } }) </script><section class="post-footer-item comment"><div class="comments-headline"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-comment"></use> </svg> <span>评论</span></div></section><section class="post-footer-item comment"><div id="waline"></div></section></section><footer class="g-footer"><div class="g-container"><div class="g-left"><section class="links"> 本站由 <a href="//jekyllrb.com" target="_blank" class="extlinks">Jekyll</a> 和 基于 <a href="https://github.com/kaeyleo/jekyll-theme-H2O" target="_blank" class="extlinks">H2O主题模版</a> 强力驱动</section><section class="links">编程散记 © 2016 - 2025 <a href="https://icp.gov.moe/?keyword=20240160" target="_blank" class="extlinks">萌ICP备20240160号</a> <a href="/rss.xml" target="_blank" aria-label="Terms of Service" class="others"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-rss"></use> </svg> RSS </a> <a href="/tos" target="_blank" aria-label="Terms of Service" class="others"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-tos"></use> </svg> 使用条款 </a></section><section class="links"> <span id="busuanzi_container_site_pv"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-pv"></use> </svg> 总浏览量 <span id="busuanzi_value_site_pv"></span> <b>·</b> </span> <span id="busuanzi_container_site_uv"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-user"></use> </svg> 总访问量 <span id="busuanzi_value_site_uv"></span> </span></section><section> 本站已运行 <span class="alivetime_days"></span> 天 <span class="alivetime_hours"></span> 小时 <span class="alivetime_minutes"></span> 分 <span class="alivetime_seconds"></span> 秒</section></div><div class="g-right"><section class="badges"> <a href="https://www.foreverblog.cn/" target="_blank" class="foreverblog" aria-label="foreverblog"> <img loading="lazy" src="https://img.foreverblog.cn/logo_en_default.png" alt=""> </a> <a href="https://www.foreverblog.cn/go.html" target="_blank" class="wormhole" aria-label="wormhole"> <img loading="lazy" src="https://img.foreverblog.cn/wormhole_3.gif" alt="" title="穿梭虫洞-随机访问十年之约友链博客"> </a> <a href="https://www.travellings.cn/go.html" target="_blank" class="travelling-badge" aria-label="Travelling" rel="noopener" title="开往-友链接力"> <img loading="lazy" src="https://cdn.jsdelivr.net/gh/travellings-link/travellings/assets/logo.gif" alt="开往-友链接力"> </a> <a href="https://notbyai.fyi/" target="_blank" class="notbyAI" aria-label="notbyAI"> <img loading="lazy" src="/assets/icons/notbyAI-white.png" alt="Written by Human, Not by AI"> </a></section></div></div></footer><div class="cookie-tip"> 为了提升本站的使用体验和必要功能的正常使用，本站会使用本地 Cookie。详细请查看「 <a href="/tos.html">本站使用条款</a> 」了解更多。 <button id="accept-tos">同意</button></div><section id="tools"><div class="tool toc"> <svg class="icon b1 active" aria-hidden="true"> <use xlink:href="#icon-toc"></use> </svg> <svg class="icon b2" aria-hidden="true"> <use xlink:href="#icon-exit"></use> </svg></div></section><section id="bttb" aria-label="Scroll back to top" class="bttb"><div class="tool"> <svg class="icon top" aria-hidden="true"> <use xlink:href="#icon-top"></use> </svg></div></section></div><div class="modal"><div class="modal-content"><header> <span class="close">&times;</span></header><div class="container"></div></div></div><script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" async></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/dayjs.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/plugin/customParseFormat.js"></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/plugin/relativeTime.js"></script> <script> $(document).ready(function () { var time_formats = ['YYYY-MM-DD HH:mm:ss ZZ', 'YYYY DD MMM HH:mm:ss ZZ', 'YYYY年MM月DD日 HH:mm:ss ZZ']; function dateFormat(date, format) { var date_org = dayjs(date, time_formats[format]); var date = date_org.format(time_formats[format]); return { "date_org": date_org, "date": date } } dayjs.extend(window.dayjs_plugin_customParseFormat); dayjs.extend(window.dayjs_plugin_relativeTime); var post_date = $("meta[property='post-date']").attr('content'); var post_date_format = $("meta[property='post-date-format']").attr('content'); var local_post_date = dateFormat(post_date, post_date_format); $(".post time span.create-at").html(local_post_date["date"]); var path = "post_project/_posts/2018/ShaderTranslate/2018-01-24-Unity_GPU_Instance.md"; var workerUrl = "https://winter-meadow-170b.damoncbl.workers.dev?" + new URLSearchParams({ path: path }); fetch(workerUrl).then(function (res) { if (!res.ok) throw new Error("worker non-200: " + res.status); return res.json(); }).then(function (commits) { if (commits && commits.length) { var update_at = dayjs(commits[0]['commit']['committer']['date']); } else { var update_at = post_date; } var local_update_at = dateFormat(update_at, post_date_format); $('.post time span.update-at').html(local_update_at["date"]); var relative_time = dayjs().diff(local_update_at["date_org"], 'day'); $(".post-copyright .tips span").append(relative_time); if (relative_time > 365) { $(".post-copyright .tips").addClass("active"); } }).catch(function () { var local_update_at = dateFormat(post_date, post_date_format); $('.post time span.update-at').html(local_update_at["date"]); }); }); </script> <script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script> <script> socialShare('.social-share', { sites: [ 'wechat', 'weibo', 'douban', 'twitter' ], wechatQrcodeTitle: "分享到微信朋友圈", wechatQrcodeHelper: '<p>扫码后点击右上角</p><p>将本文分享至朋友圈</p>' }); $("a.social-share-icon").each(function () { $(this).attr("aria-label", $(this).attr("class").split(' ')[1]) }); </script> <script src="https://cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script> <script> function scrollToAdjust(id){ var element = document.getElementById(id); var headerOffset = 90; var elementPosition = element.getBoundingClientRect().top; var offsetPosition = elementPosition + window.scrollY - headerOffset; window.scrollTo({ top: offsetPosition, behavior: "smooth" }); } </script> <script src="/assets/js/app.min.js"></script> <script src="https://at.alicdn.com/t/c/font_3046306_ujr2yq34hw.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-WN45VXRK"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'GTM-WN45VXRK'); </script> <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> <script async src="https://cdn.jsdelivr.net/npm/promise-polyfill@8.3.0/dist/polyfill.min.js"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax-full@3.2.2/es5/tex-mml-svg.min.js"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ jax: ["input/TeX", "output/HTML-CSS"], tex2jax: { inlineMath: [['$', '$'], ["\\(", "\\)"]], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }, "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] } }); </script> <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.min.js"></script> <script> $(document).ready(function () { var baseurl = $("meta[property='og:baseurl']").attr('content'); $("center img").each(function () { $(this).attr('data-src', $(this).attr('src')).removeAttr('src').addClass("lazyload").attr('src', baseurl + '/assets/img/loading.gif'); var strA = "<a data-fancybox='gallery' ref='gallery' href='" + $(this).attr('data-src') + "' data-caption='" + $(this).attr('alt') + "'></a>"; $(this).wrapAll(strA); var caption = $(this)[0].alt; $(this).parent().after('<span class="caption">' + caption + '</span>'); }); Fancybox.bind('[data-fancybox]', { on: { load: function(fancybox, slide) { var gray = $("meta[property='og:gray']").attr('content'); if (gray == "true") { $(".fancybox__content img").addClass("gray"); $(".carousel__track .fancybox__thumb").addClass("gray"); } } } }); }); </script> <script src="https://cdn.jsdelivr.net/npm/hotkeys-js/dist/hotkeys.min.js"></script> <script> $(document).ready(function () { var previous_url = $("meta[property='og:previous_url']").attr('content'); var next_url = $("meta[property='og:next_url']").attr('content'); hotkeys('left', function (event, handler) { event.preventDefault(); if (previous_url) { console.log('you pressed left!'); window.location.href = previous_url; } else { $("#no-previous").addClass("active"); setTimeout(function () { $("#no-previous").removeClass("active"); }, 1500); } }); hotkeys('right', function (event, handler) { event.preventDefault(); if (next_url) { console.log('you pressed right!'); window.location.href = next_url; } else { $("#no-next").addClass("active"); setTimeout(function () { $("#no-next").removeClass("active"); }, 1500); } }); }); </script> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.6/dist/mermaid.min.js"></script> <script> $(document).ready(function () { mermaid.initialize({ startOnLoad: true, theme: "default", }); mermaid.init(undefined, $('.mermaid2')); }); </script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script> <script> if (window.Prism) { Prism.languages.mermaid2 = Prism.languages.none || {}; } </script> <script> if ("serviceWorker" in navigator) { var env = 'development'; var isDev = env === 'development'; navigator.serviceWorker .register('/sw.js', { scope: '/' }) .then(function (reg) { if (isDev) console.log("Service worker registered for scope:", reg.scope); }) .catch(function (err) { if (isDev) console.warn("Service worker registration failed:", err); }); } </script> <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script> <script type="text/javascript"> docsearch({ appId: "NCUJ5WJECO", apiKey: "b625a4b91a45af033cbdb526694e9e65", indexName: "damonc", lang: "zh", insights: true, debug: false, container: 'li#search', }); </script>
