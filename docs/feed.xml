<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://www.damonc.top/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.damonc.top/" rel="alternate" type="text/html" /><updated>2025-09-02T07:30:19+00:00</updated><id>https://www.damonc.top/feed.xml</id><title type="html">编程散记</title><subtitle>个人的一个技术博客站点，记录生活、工作、学习中的一些小事，以及一些比较有趣的事情，留点什么东西也挺不错的，偶尔会在这里停留。</subtitle><author><name>编程散记</name></author><entry><title type="html">在Unity中模块化封装实践</title><link href="https://www.damonc.top/unity3d/Unity_Assembly_Definition.html" rel="alternate" type="text/html" title="在Unity中模块化封装实践" /><published>2025-06-07T10:00:00+00:00</published><updated>2025-06-07T10:00:00+00:00</updated><id>https://www.damonc.top/unity3d/Unity_Assembly_Definition</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Assembly_Definition.html"><![CDATA[<p>如何进行模块化封装？
模块化封装有什么优缺点？</p>

<p>待更新。</p>]]></content><author><name>编程散记</name></author><category term="Unity3D" /><summary type="html"><![CDATA[。]]></summary></entry><entry><title type="html">多线程编程模型篇(三)</title><link href="https://www.damonc.top/csharp/CSharp_Thread_Pattern.html" rel="alternate" type="text/html" title="多线程编程模型篇(三)" /><published>2025-06-07T10:00:00+00:00</published><updated>2025-06-07T10:00:00+00:00</updated><id>https://www.damonc.top/csharp/CSharp_Thread_Pattern</id><content type="html" xml:base="https://www.damonc.top/csharp/CSharp_Thread_Pattern.html"><![CDATA[<p>  Unity有着严格的主线程限制，同时Unity的C#库一直没有得到及时的更新，导致很多C#的异步编程模式在Unity中无法使用。持续到Unity2020版本发布加入了.net 4.x正式版本的支持才有了完整的C#异步编程模型。APM、EAP、async/await异步模式都有了。</p>

<h2 id="apm模式">APM模式</h2>

<p>  APM模式是基于委托的异步编程模式，全称<code class="language-plaintext highlighter-rouge">Asynchronous Programming Model</code>，该模式的典型特征是BeginOperationName和EndOperationName，用于开始和结束异步操作OperationName。例如，FileStream类提供 BeginRead和EndRead方法。Begin方法返回一个IAsyncResult对象，调用End方法时需要传入IAsyncResult对象，End方法会返回异步操作的结果。</p>

<h3 id="iasyncresult对象">IAsyncResult对象</h3>

<p>  该方法BeginOperationName开始异步操作OperationName并返回实现IAsyncResult接口的对象。IAsyncResult对象存储有关异步作的信息。</p>

<table>
  <thead>
    <tr>
      <th>成员</th>
      <th>DESCRIPTION</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>AsyncState</td>
      <td>一个可选的特定于应用程序的对象，其中包含有关异步作的信息。</td>
    </tr>
    <tr>
      <td>AsyncWaitHandle</td>
      <td>WaitHandle可用于阻止应用程序执行，直到异步操作完成。</td>
    </tr>
    <tr>
      <td>CompletedSynchronously</td>
      <td>一个值，该值指示异步操作是否在用于调用 BeginOperationName 的线程上完成，而不是在单独的 ThreadPool 线程上完成。</td>
    </tr>
    <tr>
      <td>IsCompleted</td>
      <td>一个表示异步操作是否已完成的值。</td>
    </tr>
  </tbody>
</table>

<h3 id="委托异步操作">委托异步操作</h3>

<p>  无参无返回值的委托异步操作示例：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">delegate</span> <span class="k">void</span> <span class="nf">WorkerHandler</span><span class="p">();</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Worker</span><span class="p">();</span>

<span class="n">WorkerHandler</span> <span class="n">workerHandler</span> <span class="p">=</span> <span class="n">Worker</span><span class="p">;</span>

<span class="c1">//可以不用回调函数和自定义参数</span>
<span class="n">IAsyncResult</span> <span class="n">asyncResult</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="n">workerHandler</span><span class="p">.</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">asyncResult</span><span class="p">);</span>
</code></pre></div></div>

<p>  BeginInvoke前几个参数必须与委托签名一致，最后两个参数是固定的回调函数和自定义参数，有参有返回值的委托异步操作示例：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">delegate</span> <span class="kt">string</span> <span class="nf">WorkerHandler</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">);</span>
<span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">Worker</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">);</span>

<span class="n">WorkerHandler</span> <span class="n">workerHandler</span> <span class="p">=</span> <span class="n">Worker</span><span class="p">;</span>

<span class="c1">//BeginInvoke前几个参数必须与委托签名一致</span>
<span class="c1">//BeginInvoke最后两个参数是固定的回调函数和自定义参数</span>
<span class="n">IAsyncResult</span> <span class="n">asyncResult</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="s">"message"</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">asyncResult</span><span class="p">);</span>
</code></pre></div></div>

<p>  完成回调函数与AsyncCallback委托的签名一致，自定义参数通过IAsyncResult.AsyncState属性获取，异步操作的完成回调与自定义参数示例：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">delegate</span> <span class="kt">string</span> <span class="nf">WorkerHandler</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">);</span>
<span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">Worker</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">);</span>

<span class="n">WorkerHandler</span> <span class="n">workerHandler</span> <span class="p">=</span> <span class="n">Worker</span><span class="p">;</span>

<span class="c1">//完成回调函数与AsyncCallback委托的签名一致</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">FinishCallback</span><span class="p">(</span><span class="n">IAsyncResult</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">message</span> <span class="p">=</span> <span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="n">result</span><span class="p">.</span><span class="n">AsyncState</span><span class="p">;</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">IAsyncResult</span> <span class="n">asyncResult</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="s">"message"</span><span class="p">,</span> <span class="n">FinishCallback</span><span class="p">,</span> <span class="s">"custom parameter"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="异步操作等待">异步操作等待</h3>

<p>  IAsyncResult.AsyncWaitHandle属性返回一个WaitHandle对象，可以用于阻塞当前线程，直到异步操作完成。异步操作等待示例：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 直接阻塞等待异步操作完成</span>
<span class="n">IAsyncResult</span> <span class="n">asyncResult</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="s">"message"</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">asyncResult</span><span class="p">);</span>

<span class="c1">// 2. 轮询检查</span>
<span class="n">IAsyncResult</span> <span class="n">asyncResult</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="s">"message"</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(!</span><span class="n">asyncResult</span><span class="p">.</span><span class="n">IsCompleted</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">100</span><span class="p">);</span> <span class="c1">// 做其他工作</span>
<span class="p">}</span>
<span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">asyncResult</span><span class="p">);</span>

<span class="c1">// 3. 使用WaitHandle</span>
<span class="n">IAsyncResult</span> <span class="n">asyncResult</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="s">"message"</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="n">asyncResult</span><span class="p">.</span><span class="n">AsyncWaitHandle</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span> <span class="c1">// 等待完成</span>
<span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">workerHandler</span><span class="p">.</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">asyncResult</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="eap模式">EAP模式</h2>
<p>  EAP模式是基于事件的异步编程模式，全称<code class="language-plaintext highlighter-rouge">Event-based Asynchronous Pattern</code>，该模式的典型特征是事件操作。它通过事件回调来处理异步操作的完成。相比APM模式，EAP模式更加用户友好，支持取消操作和进度报告。EAP模式的最小设计包含一个BeginMethodName方法和一个MethodNameCompleted事件。BeginMethodName方法启动异步操作并返回IAsyncResult对象，MethodNameCompleted事件在异步操作完成时触发。MethodNameCompletedEventArgs类派生自AsyncCompletedEventArgs，提供异步操作的结果和任何错误信息。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">delegate</span> <span class="k">void</span> <span class="nf">MethodNameCompletedEventHandler</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span>
    <span class="n">MethodNameCompletedEventArgs</span> <span class="n">e</span><span class="p">);</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MethodNameCompletedEventArgs</span> <span class="p">:</span>
    <span class="n">System</span><span class="p">.</span><span class="n">ComponentModel</span><span class="p">.</span><span class="n">AsyncCompletedEventArgs</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">MyReturnType</span> <span class="n">Result</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="eap模式的核心特征">EAP模式的核心特征</h3>

<table>
  <thead>
    <tr>
      <th>方法/事件</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MethodNameAsync</td>
      <td>方法 - 启动异步操作</td>
    </tr>
    <tr>
      <td>MethodNameCompleted</td>
      <td>事件 - 异步操作完成时触发</td>
    </tr>
    <tr>
      <td>MethodNameCompletedEventArgs</td>
      <td>事件参数，包含结果和错误信息</td>
    </tr>
    <tr>
      <td>CancelAsync</td>
      <td>方法 - 支持取消操作</td>
    </tr>
    <tr>
      <td>ProgressChanged</td>
      <td>事件 - 支持进度报告</td>
    </tr>
  </tbody>
</table>

<h3 id="实现支持eap的类">实现支持EAP的类</h3>

<p>  定义事件参数类MethodNameCompletedEventArgs，派生自AsyncCompletedEventArgs，提供异步操作的结果和任何错误信息。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">DownloadCompletedEventArgs</span> <span class="p">:</span> <span class="n">AsyncCompletedEventArgs</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FilePath</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">long</span> <span class="n">BytesDownloaded</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="k">public</span> <span class="nf">DownloadCompletedEventArgs</span><span class="p">(</span><span class="n">Exception</span> <span class="n">error</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cancelled</span><span class="p">,</span> 
        <span class="kt">object</span> <span class="n">userState</span><span class="p">,</span> <span class="kt">string</span> <span class="n">filePath</span><span class="p">,</span> <span class="kt">long</span> <span class="n">bytesDownloaded</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">cancelled</span><span class="p">,</span> <span class="n">userState</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FilePath</span> <span class="p">=</span> <span class="n">filePath</span><span class="p">;</span>
        <span class="n">BytesDownloaded</span> <span class="p">=</span> <span class="n">bytesDownloaded</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">DownloadProgressChangedEventArgs</span> <span class="p">:</span> <span class="n">ProgressChangedEventArgs</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">long</span> <span class="n">BytesReceived</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">long</span> <span class="n">TotalBytesToReceive</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="k">public</span> <span class="nf">DownloadProgressChangedEventArgs</span><span class="p">(</span><span class="kt">int</span> <span class="n">progressPercentage</span><span class="p">,</span> <span class="kt">object</span> <span class="n">userState</span><span class="p">,</span>
        <span class="kt">long</span> <span class="n">bytesReceived</span><span class="p">,</span> <span class="kt">long</span> <span class="n">totalBytes</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">progressPercentage</span><span class="p">,</span> <span class="n">userState</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">BytesReceived</span> <span class="p">=</span> <span class="n">bytesReceived</span><span class="p">;</span>
        <span class="n">TotalBytesToReceive</span> <span class="p">=</span> <span class="n">totalBytes</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  定义支持EAP的类DownloadManager，包含MethodNameAsync方法和MethodNameCompleted事件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 实现EAP模式的下载器类</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">DownloadManager</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">WebClient</span> <span class="n">_webClient</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">object</span> <span class="n">_lockObject</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>
    
    <span class="c1">// 2. 定义事件</span>
    <span class="k">public</span> <span class="k">event</span> <span class="n">EventHandler</span><span class="p">&lt;</span><span class="n">DownloadCompletedEventArgs</span><span class="p">&gt;</span> <span class="n">DownloadCompleted</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">event</span> <span class="n">EventHandler</span><span class="p">&lt;</span><span class="n">DownloadProgressChangedEventArgs</span><span class="p">&gt;</span> <span class="n">ProgressChanged</span><span class="p">;</span>
    
    <span class="c1">// 3. 异步方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">,</span> <span class="kt">string</span> <span class="n">filePath</span><span class="p">,</span> <span class="kt">object</span> <span class="n">userState</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 检查是否已有操作在进行</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lockObject</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_webClient</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"下载操作已在进行中"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">_webClient</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WebClient</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="c1">// 订阅WebClient事件</span>
        <span class="n">_webClient</span><span class="p">.</span><span class="n">DownloadProgressChanged</span> <span class="p">+=</span> <span class="n">OnDownloadProgressChanged</span><span class="p">;</span>
        <span class="n">_webClient</span><span class="p">.</span><span class="n">DownloadFileCompleted</span> <span class="p">+=</span> <span class="n">OnDownloadFileCompleted</span><span class="p">;</span>
        
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="c1">// 开始异步下载</span>
            <span class="n">_webClient</span><span class="p">.</span><span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="n">url</span><span class="p">),</span> <span class="n">filePath</span><span class="p">,</span> 
                <span class="k">new</span> <span class="n">DownloadState</span> <span class="p">{</span> <span class="n">Url</span> <span class="p">=</span> <span class="n">url</span><span class="p">,</span> <span class="n">FilePath</span> <span class="p">=</span> <span class="n">filePath</span><span class="p">,</span> <span class="n">UserState</span> <span class="p">=</span> <span class="n">userState</span> <span class="p">});</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 如果启动失败，立即触发完成事件</span>
            <span class="nf">OnDownloadCompleted</span><span class="p">(</span><span class="k">new</span> <span class="nf">DownloadCompletedEventArgs</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="n">userState</span><span class="p">,</span> <span class="n">filePath</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 4. 取消方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">CancelAsync</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lockObject</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_webClient</span><span class="p">?.</span><span class="nf">CancelAsync</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 5. 内部状态类</span>
    <span class="k">private</span> <span class="k">class</span> <span class="nc">DownloadState</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">FilePath</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">object</span> <span class="n">UserState</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 6. 进度变化事件处理</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDownloadProgressChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">DownloadProgressChangedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">state</span> <span class="p">=</span> <span class="p">(</span><span class="n">DownloadState</span><span class="p">)</span><span class="n">e</span><span class="p">.</span><span class="n">UserState</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">args</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DownloadProgressChangedEventArgs</span><span class="p">(</span>
            <span class="n">e</span><span class="p">.</span><span class="n">ProgressPercentage</span><span class="p">,</span>
            <span class="n">state</span><span class="p">.</span><span class="n">UserState</span><span class="p">,</span>
            <span class="n">e</span><span class="p">.</span><span class="n">BytesReceived</span><span class="p">,</span>
            <span class="n">e</span><span class="p">.</span><span class="n">TotalBytesToReceive</span><span class="p">);</span>
            
        <span class="n">ProgressChanged</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 7. 完成事件处理</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDownloadFileCompleted</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">AsyncCompletedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">state</span> <span class="p">=</span> <span class="p">(</span><span class="n">DownloadState</span><span class="p">)</span><span class="n">e</span><span class="p">.</span><span class="n">UserState</span><span class="p">;</span>
        <span class="kt">long</span> <span class="n">bytesDownloaded</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(!</span><span class="n">e</span><span class="p">.</span><span class="n">Cancelled</span> <span class="p">&amp;&amp;</span> <span class="n">e</span><span class="p">.</span><span class="n">Error</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="n">bytesDownloaded</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FileInfo</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">FilePath</span><span class="p">).</span><span class="n">Length</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">{</span> <span class="cm">/* 忽略获取文件大小的错误 */</span> <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 清理资源</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lockObject</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_webClient</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_webClient</span><span class="p">.</span><span class="n">DownloadProgressChanged</span> <span class="p">-=</span> <span class="n">OnDownloadProgressChanged</span><span class="p">;</span>
                <span class="n">_webClient</span><span class="p">.</span><span class="n">DownloadFileCompleted</span> <span class="p">-=</span> <span class="n">OnDownloadFileCompleted</span><span class="p">;</span>
                <span class="n">_webClient</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
                <span class="n">_webClient</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 触发完成事件</span>
        <span class="nf">OnDownloadCompleted</span><span class="p">(</span><span class="k">new</span> <span class="nf">DownloadCompletedEventArgs</span><span class="p">(</span>
            <span class="n">e</span><span class="p">.</span><span class="n">Error</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">,</span> <span class="n">state</span><span class="p">.</span><span class="n">UserState</span><span class="p">,</span> <span class="n">state</span><span class="p">.</span><span class="n">FilePath</span><span class="p">,</span> <span class="n">bytesDownloaded</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="c1">// 8. 安全触发完成事件的方法</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDownloadCompleted</span><span class="p">(</span><span class="n">DownloadCompletedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DownloadCompleted</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 9. 释放资源</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lockObject</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_webClient</span><span class="p">?.</span><span class="nf">Dispose</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  使用支持EAP的类DownloadManager，可以实现异步下载文件。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">downloader</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FileDownloader</span><span class="p">();</span>
        
        <span class="c1">// 订阅事件</span>
        <span class="n">downloader</span><span class="p">.</span><span class="n">ProgressChanged</span> <span class="p">+=</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"下载进度: </span><span class="p">{</span><span class="n">e</span><span class="p">.</span><span class="n">ProgressPercentage</span><span class="p">}</span><span class="s">% "</span> <span class="p">+</span>
                            <span class="s">$"(</span><span class="p">{</span><span class="n">e</span><span class="p">.</span><span class="n">BytesReceived</span><span class="p">}</span><span class="s">/</span><span class="p">{</span><span class="n">e</span><span class="p">.</span><span class="n">TotalBytesToReceive</span><span class="p">}</span><span class="s"> bytes)"</span><span class="p">);</span>
        <span class="p">};</span>
        
        <span class="n">downloader</span><span class="p">.</span><span class="n">DownloadCompleted</span> <span class="p">+=</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"下载已取消"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Error</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"下载失败: </span><span class="p">{</span><span class="n">e</span><span class="p">.</span><span class="n">Error</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"下载完成: </span><span class="p">{</span><span class="n">e</span><span class="p">.</span><span class="n">FilePath</span><span class="p">}</span><span class="s">, 大小: </span><span class="p">{</span><span class="n">e</span><span class="p">.</span><span class="n">BytesDownloaded</span><span class="p">}</span><span class="s"> bytes"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>
        
        <span class="c1">// 开始异步下载</span>
        <span class="kt">string</span> <span class="n">url</span> <span class="p">=</span> <span class="s">"https://example.com/largefile.zip"</span><span class="p">;</span>
        <span class="kt">string</span> <span class="n">filePath</span> <span class="p">=</span> <span class="s">@"C:\temp\downloaded.zip"</span><span class="p">;</span>
        
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"开始下载..."</span><span class="p">);</span>
        <span class="n">downloader</span><span class="p">.</span><span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">filePath</span><span class="p">,</span> <span class="s">"自定义状态对象"</span><span class="p">);</span>
        
        <span class="c1">// 模拟其他工作</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">5000</span><span class="p">);</span>
        
        <span class="c1">// 可以取消下载</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"5秒后取消下载"</span><span class="p">);</span>
        <span class="n">downloader</span><span class="p">.</span><span class="nf">CancelAsync</span><span class="p">();</span>
        
        <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 不推荐EAP模式 </div> </div> <div class="content"> <p>相比于APM模式，EAP模式更加复杂，而且容易出现资源泄漏。
同时官方也不推荐使用EAP模式，改用async/await异步模式。
Unity之前大部分都是类EAP模式，现在推荐使用async/await异步模式。</p>



 </div> </div>
<h2 id="asyncawait异步模式">async/await异步模式</h2>

<p>  async/await异步模式全称<code class="language-plaintext highlighter-rouge">Async/Await</code>，该模式的典型特征是async/await关键字。async/await关键字用于声明异步方法，await关键字用于等待异步操作完成。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="状态机">状态机</h3>

<p>  async/await的本质是编译器生成的状态机。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">DownloadAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"开始下载"</span><span class="p">);</span> <span class="c1">// 同步执行</span>
    
    <span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>
    <span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span> <span class="c1">// 异步等待点</span>
    
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"下载完成"</span><span class="p">);</span> <span class="c1">// 异步继续执行</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">();</span> <span class="c1">// 同步执行</span>
<span class="p">}</span>

<span class="c1">// 编译器实际生成的状态机伪代码：</span>
<span class="c1">// - 状态0：开始执行</span>
<span class="c1">// - 状态1：await之后的继续执行</span>
</code></pre></div></div>

<h3 id="async关键字">async关键字</h3>

<p>  async关键字用于声明异步方法，async关键字用于修饰方法，表示该方法是一个异步方法。如果不是异步方法就不要乱加async关键字，因为调用async方法会有显著的性能损失。同样的方法用通常的同步定义，要比加上async关键字修饰的快40-50倍。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  避免使用async void方法，这是非常危险的，异常处理容易忽略，处理不当容易造成进程崩溃。如果async方法返回Task，Task对象很容易监控，异常也被包装在内。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">public</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"异常"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"异常"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromException</span><span class="p">(</span><span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"异常"</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="await关键字">await关键字</h3>

<p>  await关键字用于等待异步操作完成。await关键字用于修饰表达式，表示该表达式是一个异步操作。异步操作完成后，控制权会返回到await语句所在的上下文。</p>

<h3 id="configureawait">ConfigureAwait</h3>

<p>  ConfigureAwait(bool continueOnCapturedContext)用于配置在等待异步操作完成时，是否继续在捕获的上下文中执行。使用ConfigureAwait(false)可以避免死锁，同时也不需要回到原始上下文减少线程切换开销。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">LibraryMethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ✅ 不需要回到原始上下文</span>
    <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">GetDataFromApiAsync</span><span class="p">().</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">processed</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">ProcessDataAsync</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="异常处理模式">异常处理模式</h3>

<p>  异步方法中使用try/catch块捕获异常，逐一展开异常，避免吞掉异常。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 正确的异常处理模式</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">SafeExecuteAsync</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">operation</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">operation</span><span class="p">().</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="nf">Success</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="nf">Cancelled</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">TimeoutException</span> <span class="n">ex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="nf">Failure</span><span class="p">(</span><span class="s">$"操作超时: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">HttpRequestException</span> <span class="n">ex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="nf">Failure</span><span class="p">(</span><span class="s">$"网络错误: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 记录未预期的异常</span>
        <span class="n">Logger</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s">"未处理的异常"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="nf">Failure</span><span class="p">(</span><span class="s">$"未知错误: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ❌ 错误：吞掉异常</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">BadExceptionHandling</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="nf">RiskyOperation</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span>
    <span class="p">{</span>
        <span class="c1">// 静默忽略异常是危险的</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="valuetask">ValueTask</h2>

<p>  ValueTask是Task的轻量级版本，用于避免不必要的内存分配。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 问题场景：缓存场景下的Task分配</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetDataAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_cache</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="kt">string</span> <span class="n">cachedValue</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// ❌ 即使数据已缓存（同步可用），仍然分配Task对象</span>
        <span class="k">return</span> <span class="n">cachedValue</span><span class="p">;</span> <span class="c1">// 编译器会包装成 Task.FromResult(cachedValue)</span>
    <span class="p">}</span>
    
    <span class="c1">// 只有这里才真正需要异步</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">_database</span><span class="p">.</span><span class="nf">GetAsync</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="使用场景分析">使用场景分析</h3>

<p>  缓存场景下的ValueTask使用示例：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">readonly</span> <span class="n">ConcurrentDictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">User</span><span class="p">&gt;</span> <span class="n">_userCache</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;</span> <span class="nf">GetUserAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">userId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_userCache</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">userId</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">cachedUser</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">cachedUser</span><span class="p">;</span> <span class="c1">// 同步路径，零分配</span>
    <span class="p">}</span>
    
    <span class="kt">var</span> <span class="n">user</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_userService</span><span class="p">.</span><span class="nf">LoadUserAsync</span><span class="p">(</span><span class="n">userId</span><span class="p">);</span>
    <span class="n">_userCache</span><span class="p">.</span><span class="nf">TryAdd</span><span class="p">(</span><span class="n">userId</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">user</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  条件异步操作的ValueTask使用示例：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ProcessAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">input</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useAsync</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">useAsync</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 同步处理</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="nf">ProcessSync</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="c1">// 异步处理</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="nf">ProcessAsyncInternal</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  可能立即完成的I/O操作的ValueTask使用示例：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">async</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">ReadAsync</span><span class="p">(</span><span class="kt">byte</span><span class="p">[]</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 检查缓冲区是否有数据</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_internalBuffer</span><span class="p">.</span><span class="n">Available</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nf">ReadFromBuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> <span class="c1">// 同步完成</span>
        <span class="p">}</span>
        
        <span class="c1">// 需要从网络读取</span>
        <span class="k">return</span> <span class="k">await</span> <span class="nf">ReadFromNetworkAsync</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>  状态机优化的ValueTask使用示例：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">enum</span> <span class="n">AsyncState</span> <span class="p">{</span> <span class="n">NotStarted</span><span class="p">,</span> <span class="n">InProgress</span><span class="p">,</span> <span class="n">Completed</span> <span class="p">}</span>
<span class="k">private</span> <span class="n">AsyncState</span> <span class="n">_state</span> <span class="p">=</span> <span class="n">AsyncState</span><span class="p">.</span><span class="n">NotStarted</span><span class="p">;</span>
<span class="k">private</span> <span class="kt">string</span> <span class="n">_result</span><span class="p">;</span>

<span class="k">public</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetOrCreateAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">_state</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">AsyncState</span><span class="p">.</span><span class="n">Completed</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">_result</span><span class="p">);</span> <span class="c1">// 立即返回</span>
            
        <span class="k">case</span> <span class="n">AsyncState</span><span class="p">.</span><span class="n">NotStarted</span><span class="p">:</span>
            <span class="n">_state</span> <span class="p">=</span> <span class="n">AsyncState</span><span class="p">.</span><span class="n">InProgress</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="nf">CreateAsync</span><span class="p">());</span> <span class="c1">// 开始异步操作</span>
            
        <span class="k">case</span> <span class="n">AsyncState</span><span class="p">.</span><span class="n">InProgress</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="nf">WaitForCompletionAsync</span><span class="p">());</span> <span class="c1">// 等待完成</span>
            
        <span class="k">default</span><span class="p">:</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>编程散记</name></author><category term="CSharp" /><category term="Thread" /><summary type="html"><![CDATA[Unity有着严格的主线程限制，同时Unity的C#库一直没有得到及时的更新，导致很多C#的异步编程模式在Unity中无法使用。持续到Unity2020版本发布加入了.net 4.x正式版本的支持才有了完整的C#异步编程模型。APM、EAP、async/await异步模式都有了。]]></summary></entry><entry><title type="html">多线程编程模型篇-Task(二)</title><link href="https://www.damonc.top/csharp/Csharp_Task_Base.html" rel="alternate" type="text/html" title="多线程编程模型篇-Task(二)" /><published>2025-06-06T10:00:00+00:00</published><updated>2025-06-06T10:00:00+00:00</updated><id>https://www.damonc.top/csharp/Csharp_Task_Base</id><content type="html" xml:base="https://www.damonc.top/csharp/Csharp_Task_Base.html"><![CDATA[<h2 id="什么是task">什么是Task</h2>

<p>  任务是对象，其中封装了以异步方式执行的工作。这听起来有点儿耳熟，委托不也是封装了代码的对象吗？区别在于委托是同步的而任务是异步的。如果执行一个委托(例如一个Action)，当前线程的控制点会立即转移到委托的代码；除非委托结束，否则控制不会返回调用者。简单地说，<strong>任务是将委托从同步执行模式转变成异步执行</strong>。</p>

<p>  任务是.NET4.0引入的，是.NET4.0中新增的异步编程模型。用以取代复杂、老旧的、代价高昂的Thread编程模型。</p>

<h3 id="task-vs-线程">Task vs 线程</h3>

<p>  <code class="language-plaintext highlighter-rouge">Thread</code>是.NET中最基础的线程模型，它提供了最底层的线程管理。但是Thread的创建和销毁成本很高，而且编码过程不能很好地管理线程。</p>

<p>  <code class="language-plaintext highlighter-rouge">ThreadPool</code>是.NET中基础组件，为所有异步编程模型提供底层支持并在不断改进中。它提供了线程的复用，可以很好地管理线程的创建和销毁。但是ThreadPool的线程只适合短时轻量化任务，像操作I/O这样的活动或者长时间占用线程池中的线程的方法极可能拖慢线程队列中的其他任务，反而性能降低。</p>

<p>  <code class="language-plaintext highlighter-rouge">Task</code>是.NET4.0中提供的异步编程模型，是基于ThreadPool实现的，可以更方便地编写异步代码。Task的引入使得异步编程变得更加简单、直观。</p>

<h3 id="task的生命周期">Task的生命周期</h3>

<p>  Task的生命周期包含创建（Created）、等待运行（WaitingToRun）、运行（Running）、完成（RanToCompletion/Completed）、失败（Faulted）或已取消（Canceled）等阶段。</p>

<pre><code class="language-mermaid2">graph LR
    A[Task Created&lt;br/&gt;Created] --&gt; B{Task Started?}
    
    B --&gt;|No| C[WaitingToRun]
    B --&gt;|Yes| D[Running]
    
    C --&gt; E[Task Started]
    E --&gt; D
    
    D --&gt; F{Task Completed?}
    D --&gt; G{Task Cancelled?}
    D --&gt; H{Task Faulted?}
    
    F --&gt;|Yes| I[RanToCompletion]
    G --&gt;|Yes| J[Cancelled]
    H --&gt;|Yes| K[Faulted]
    
    I --&gt; L[Task Completed&lt;br/&gt;Final State]
    J --&gt; L
    K --&gt; L
    
    style A fill:#e1f5fe
    style L fill:#c8e6c9
    style D fill:#fff3e0
    style I fill:#e8f5e8
    style J fill:#ffebee
    style K fill:#fff3e0
</code></pre>

<h2 id="task的api">Task的API</h2>

<p>  从Task构造函数创建Task实例开始。System.Threading.Tasks命名空间下提供了Task类。</p>

<h3 id="task构造函数">Task构造函数</h3>

<p>  Task的构造函数有多个重载，主要用于创建Task对象。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 内部构造函数签名</span>
<span class="k">internal</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Delegate</span><span class="p">,</span><span class="kt">object</span><span class="p">,</span><span class="n">Task</span><span class="p">,</span><span class="n">CancellationToken</span><span class="p">,</span>
    <span class="n">TaskCreationOptions</span><span class="p">,</span><span class="n">InternalTaskOptions</span><span class="p">,</span><span class="n">TaskScheduler</span><span class="p">)</span>

<span class="c1">// 创建一个Task对象，参数为要执行的委托</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数为取消令牌</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数为TaskCreationOptions枚举的值</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数为取消令牌，参数为TaskCreationOptions枚举的值</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数是传递给委托的</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;,</span> <span class="n">Object</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数是传递给委托的，参数为取消令牌</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数是传递给委托的，参数为TaskCreationOptions枚举的值</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数是传递给委托的，参数为取消令牌，参数为TaskCreationOptions枚举的值</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">)</span>
</code></pre></div></div>

<p>  虽然Task的构造函数有多个重载，但是<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.-ctor?view=net-9.0#system-threading-tasks-task-ctor(system-action)">官方示例</a>推荐常见做法还是使用Task.Run或TaskFactory.StartNew方法来创建Task对象。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 推荐使用方式 </div> </div> <div class="content"> <p>每一个Task构造函数，都提供了对应版本的Task.Run或者TaskFactory.StartNew方法。官方示例中的所有构造函数都多次推荐使用上述方法来创建Task对象。除了要实现一套更高级别的分离任务创建和启动的高级方案。</p>



 </div> </div>

<h3 id="使用taskrun">使用Task.Run</h3>

<p>  对在 ThreadPool 上运行的指定工作进行排队，并为该工作返回任务或Task<TResult>句柄。它是StartNew重载的轻型替代方法。</TResult></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Run(Func<Task>, CancellationToken)</Task></td>
      <td>在线程池上排队运行任务，返回任务代理。可取消。</td>
    </tr>
    <tr>
      <td>Run(Action, CancellationToken)</td>
      <td>在线程池上排队运行工作，返回Task对象。可取消。</td>
    </tr>
    <tr>
      <td>Run(Func<Task>)</Task></td>
      <td>在线程池上排队运行任务，返回任务代理。</td>
    </tr>
    <tr>
      <td>Run(Action)</td>
      <td>在线程池上排队运行工作，返回Task对象。</td>
    </tr>
    <tr>
      <td>Run<TResult>(Func&lt;Task<TResult>&gt;)</TResult></TResult></td>
      <td>在线程池上排队运行任务，返回Task(TResult)代理。</td>
    </tr>
    <tr>
      <td>Run<TResult>(Func<TResult>)</TResult></TResult></td>
      <td>在线程池上排队运行工作，返回Task<TResult>对象。</TResult></td>
    </tr>
    <tr>
      <td>Run<TResult>(Func&lt;Task<TResult>&gt;, CancellationToken)</TResult></TResult></td>
      <td>在线程池上排队运行任务，返回Task(TResult)代理。</td>
    </tr>
    <tr>
      <td>Run<TResult>(Func<TResult>, CancellationToken)</TResult></TResult></td>
      <td>在线程池上排队运行工作，返回Task<TResult>对象。</TResult></td>
    </tr>
  </tbody>
</table>

<p>  新线程要运行的代码由传给Task.Run()方法的委托(本例是Action类型)来定义。这个委托(以Lambda表达式的形式)在控制台不断打印。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"-"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Task</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="n">task</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
</code></pre></div></div>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 任务的冷与热 </div> </div> <div class="content"> <p>调用Task.Run()之后，作为参数传递的 Action几乎立即开始执行。这称为“热”任务，即已触发并开始执行(或已开始排队等待执行)。</p>

<p>new Task()则是“冷”任务，它需要在显式触发start之后才开始进入线程池排队去执行任务。在start之前不能调用wait、getRuselt等。</p>



 </div> </div>
<h3 id="使用taskfactory">使用Task.Factory</h3>

<p>  启动Task对象并将任务调度到TaskScheduler，它与Run方法基本相同，但返回Task对象而不是Task<TResult>代理。可以调用TaskFactory类的构造函数来配置 TaskFactory类创建所需要的模版任务。</TResult></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>

<span class="k">static</span> <span class="n">TaskFactory</span> <span class="n">factory</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TaskFactory</span><span class="p">(</span>
    <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">,</span>
    <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">PreferFairness</span><span class="p">,</span>
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">ExecuteSynchronously</span><span class="p">,</span>
    <span class="k">new</span> <span class="nf">CustomScheduler</span><span class="p">());</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">t2</span> <span class="p">=</span> <span class="n">factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoWork</span><span class="p">());</span>
    <span class="n">cts</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">DoWork</span><span class="p">()</span> <span class="p">{</span><span class="cm">/*...*/</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="task的核心属性">Task的核心属性</h2>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Status</td>
      <td>获取任务的当前状态。</td>
    </tr>
    <tr>
      <td>IsCompleted</td>
      <td>该值指示Task是否已通过运行其方法完成执行。</td>
    </tr>
    <tr>
      <td>IsFaulted</td>
      <td>该值指示Task是否由于未处理异常而完成执行。</td>
    </tr>
    <tr>
      <td>IsCanceled</td>
      <td>该值指示Task是否由于被取消而完成执行。</td>
    </tr>
    <tr>
      <td>Exception</td>
      <td>获取一个异常，该异常是Task因未处理异常而完成时引发的。</td>
    </tr>
    <tr>
      <td>Result</td>
      <td>获取Task的结果值。</td>
    </tr>
    <tr>
      <td>Id</td>
      <td>获取任务的唯一标识符。</td>
    </tr>
  </tbody>
</table>

<h2 id="task的等待和同步">Task的等待和同步</h2>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>返回类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>WaitAny</td>
      <td>int</td>
      <td>返回已完成Task在数组中的索引</td>
    </tr>
    <tr>
      <td>WaitAll</td>
      <td>void</td>
      <td>无返回值，阻塞直到所有完成</td>
    </tr>
    <tr>
      <td>WhenAny</td>
      <td>Task<Task></Task></td>
      <td>返回一个Task，其Result是第一个完成的Task</td>
    </tr>
    <tr>
      <td>WhenAll</td>
      <td>Task 或 Task&lt;TResult[]&gt;</td>
      <td>返回一个Task，当所有输入Task完成后完成</td>
    </tr>
  </tbody>
</table>

<p>  <code class="language-plaintext highlighter-rouge">Wait接口是阻塞方法</code>。是不管是哪一种Wait、WaitAny、WaitAll他们都阻塞当前线程，直到条件满足。异常会直接抛出，需要立即处理。</p>

<p>  <code class="language-plaintext highlighter-rouge">When接口是非阻塞方法</code>。都是非阻塞方法，它们不会阻塞当前线程，而是返回一个Task，当条件满足时，该Task会完成。异常被包装在返回的Task中。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 传统方式 - 阻塞</span>
<span class="n">Task</span><span class="p">[]</span> <span class="n">tasks</span> <span class="p">=</span> <span class="p">{</span> <span class="nf">Task1</span><span class="p">(),</span> <span class="nf">Task2</span><span class="p">(),</span> <span class="nf">Task3</span><span class="p">()</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">index</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WaitAny</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>  <span class="c1">// 阻塞等待</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Task </span><span class="p">{</span><span class="n">index</span><span class="p">}</span><span class="s"> completed first"</span><span class="p">);</span>

<span class="c1">// 异步方式 - 非阻塞</span>
<span class="n">Task</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">whenAnyResult</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAny</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
<span class="n">Task</span> <span class="n">completedTask</span> <span class="p">=</span> <span class="k">await</span> <span class="n">whenAnyResult</span><span class="p">;</span>  <span class="c1">// 不阻塞线程</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"First task completed"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="task接口一致性">Task接口一致性</h3>

<p>  FromResult、FromException、FromCanceled是Task的静态方法，用于创建已完成的Task对象。这些方法的主要价值在于保持异步接口的一致性，尤其是在无法使用async/await关键字的情况下，符合Task<T>的契约。</T></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>FromResult</td>
      <td>创建一个已完成的Task对象，参数为结果</td>
    </tr>
    <tr>
      <td>FromException</td>
      <td>创建一个已完成的Task对象，参数为异常</td>
    </tr>
    <tr>
      <td>FromCanceled</td>
      <td>创建一个已完成的Task对象，参数为取消令牌</td>
    </tr>
  </tbody>
</table>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IMathService</span>
<span class="p">{</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="nf">DivideAsync</span><span class="p">(</span><span class="kt">double</span> <span class="n">numerator</span><span class="p">,</span> <span class="kt">double</span> <span class="n">denominator</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MathService</span> <span class="p">:</span> <span class="n">IMathService</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="nf">DivideAsync</span><span class="p">(</span><span class="kt">double</span> <span class="n">numerator</span><span class="p">,</span> <span class="kt">double</span> <span class="n">denominator</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 同步的参数验证</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">denominator</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 发现错误，立即返回一个失败的任务，而不是抛出阻塞性异常</span>
            <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromException</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;(</span><span class="k">new</span> <span class="nf">DivideByZeroException</span><span class="p">(</span><span class="s">"Denominator cannot be zero."</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// 如果验证通过，进行同步计算并返回成功结果</span>
        <span class="kt">double</span> <span class="n">result</span> <span class="p">=</span> <span class="n">numerator</span> <span class="p">/</span> <span class="n">denominator</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  避免线程切换的开销。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 不好 - 不必要的线程切换v</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">BadExample</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="s">"Hello"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 好 - 直接返回</span>
<span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GoodExample</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="task的延续操作">Task的延续操作</h2>

<p>  延续任务（Continuation Tasks）是Task并行库中最重要的特性之一，它允许您在某个任务完成后自动执行后续操作，形成任务链。延续任务的核心方法是ContinueWith。</p>

<h3 id="taskcontinuewith">Task.ContinueWith</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Task</span> <span class="nf">ContinueWith</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">continuationAction</span><span class="p">);</span>
<span class="k">public</span> <span class="n">Task</span> <span class="nf">ContinueWith</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">continuationAction</span><span class="p">,</span> <span class="n">TaskContinuationOptions</span> <span class="n">continuationOptions</span><span class="p">);</span>
<span class="k">public</span> <span class="n">Task</span> <span class="nf">ContinueWith</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">continuationAction</span><span class="p">,</span> <span class="n">TaskScheduler</span> <span class="n">scheduler</span><span class="p">);</span>
<span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;</span> <span class="n">ContinueWith</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">continuationFunction</span><span class="p">);</span>
</code></pre></div></div>

<p>关键特性：</p>
<ol>
  <li>非阻塞性：延续任务不会阻塞前置任务的完成</li>
  <li>自动调度：当任务完成时，延续任务会自动被调度执行</li>
  <li>状态感知：延续任务可以通过Task参数访问前置任务的状态、结果和异常</li>
</ol>

<p>  延续任务的执行依赖于前置任务的状态：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">antecedent</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">ComputeData</span><span class="p">());</span>

<span class="n">Task</span> <span class="n">continuation</span> <span class="p">=</span> <span class="n">antecedent</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">IsCompleted</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 任务成功完成</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">IsFaulted</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 任务出现异常</span>
        <span class="kt">var</span> <span class="n">exception</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Exception</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">IsCanceled</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 任务被取消</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"任务被取消"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="延续任务的选项">延续任务的选项</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 无条件执行 - 无论前置任务什么状态都执行</span>
<span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">None</span>

<span class="c1">// 2. 条件执行选项</span>
<span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span>    <span class="c1">// 仅在前置任务成功完成时执行</span>
<span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnFaulted</span>           <span class="c1">// 仅在前置任务失败时执行  </span>
<span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnCanceled</span>          <span class="c1">// 仅在前置任务取消时执行</span>

<span class="c1">// 3. 支持组合条件</span>
<span class="n">OnlyOnRanToCompletion</span> <span class="p">|</span> <span class="n">OnlyOnFaulted</span>
</code></pre></div></div>

<h3 id="链式延续任务">链式延续任务</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DownloadData</span><span class="p">())</span>
<span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">ProcessData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">)</span>
<span class="p">.</span><span class="nf">Uwarp</span><span class="p">()</span>
<span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">processedData</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">SaveResults</span><span class="p">(</span><span class="n">processedData</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">);</span>

<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
</code></pre></div></div>

<p>  Unwrap是Task的扩展方法，用于将Task&lt;Task<T>&gt;解包为Task<T>。可以将链式任务解包，避免嵌套的Task。</T></T></p>

<h2 id="task的异常处理">Task的异常处理</h2>

<p>  不能用try块包装start()调用来捕捉异常，因为控制会立即从调用返回，然后控制会离开try块，而这时距离工作者线程发生异常可能还有好久呢 一个解决方案是将任务的委托主体包装到try/catch块中。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"Something went wrong"</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 异常此时还没有抛出</span>
<span class="c1">// 只有在以下操作时才会抛出：</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="n">task</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>  <span class="c1">// 直接抛出异常</span>
    <span class="c1">// 或</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>  <span class="c1">// 通过Result抛出</span>
    <span class="c1">// 或在async方法中</span>
    <span class="k">await</span> <span class="n">task</span><span class="p">;</span>  <span class="c1">// await时抛出</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">InvalidOperationException</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="异常传播机制">异常传播机制</h3>

<p>  当一个Task抛出异常时，异常会被捕获并存储在Task对象中，只有在访问Result属性、调用Wait()或await时才会抛出异常，异常可以在任何线程上被观察到。</p>

<h3 id="aggregateexception详解">AggregateException详解</h3>

<p>  多个Task的异常会被包装成AggregateException，可以嵌套其他AggregateException。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">task1</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{});</span>
<span class="n">Task</span> <span class="n">task2</span> <span class="p">=</span> <span class="n">task1</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"exception"</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">try</span> <span class="p">{</span>
    <span class="n">Task</span><span class="p">.</span><span class="nf">WaitAll</span><span class="p">(</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ae</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 处理聚合异常</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">innerEx</span> <span class="k">in</span> <span class="n">ae</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Inner exception: </span><span class="p">{</span><span class="n">innerEx</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 或者展开所有异常</span>
    <span class="n">ae</span><span class="p">.</span><span class="nf">Flatten</span><span class="p">().</span><span class="nf">Handle</span><span class="p">(</span><span class="n">ex</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Flattened exception: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span> <span class="c1">// 表示已处理</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="异常处理最佳实践">异常处理最佳实践</h3>

<p>  ①使用await进行自然异常处理。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 推荐：异常自然传播</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ProcessDataAsync</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">DownloadDataAsync</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">ProcessDataAsync</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 调用方自然处理异常</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">ProcessDataAsync</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">InvalidOperationException</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 直接处理具体异常类型</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  ②聚合异常的处理模式</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 模式1：展开并逐个处理</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ae</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ae</span><span class="p">.</span><span class="nf">Flatten</span><span class="p">().</span><span class="nf">Handle</span><span class="p">(</span><span class="n">ex</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="k">is</span> <span class="n">IOException</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 处理IO异常</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="k">is</span> <span class="n">ValidationException</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 处理验证异常</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span> <span class="c1">// 未处理的异常会重新抛出</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// 模式2：重新抛出第一个异常</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ae</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">ae</span><span class="p">.</span><span class="n">InnerException</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  ③避免混用同步和异步等待</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 避免：混用.Wait()和await</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ProcessAsync</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="nf">DoWorkAsync</span><span class="p">();</span>
    
    <span class="c1">// 不要这样做 - 可能导致死锁</span>
    <span class="n">task</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>  <span class="c1">// 阻塞当前线程</span>
    
    <span class="c1">// 而应该：</span>
    <span class="k">await</span> <span class="n">task</span><span class="p">;</span>  <span class="c1">// 正确的方式</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  ④延续任务的异常处理</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoWork</span><span class="p">());</span>
<span class="n">Task</span> <span class="n">continuation</span> <span class="p">=</span> <span class="n">task</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">IsFaulted</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 处理前置任务的异常</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Previous task failed: </span><span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">Exception</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 处理成功结果</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="未观察异常的处理">未观察异常的处理</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 危险：创建Task但不观察其结果</span>
<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"This will be unobserved!"</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// 危险：创建Task但不观察其结果</span>
<span class="n">New</span> <span class="nf">Task</span><span class="p">(()=&gt;{}).</span><span class="nf">Start</span><span class="p">();</span>
<span class="c1">// Task被垃圾回收时才会触发UnobservedTaskException</span>
</code></pre></div></div>

<p>  Unity中未观察异常的处理。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Unity中处理未观察异常</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">TaskExceptionHandler</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">UnobservedTaskException</span> <span class="p">+=</span> <span class="n">HandleUnobservedException</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">void</span> <span class="nf">OnDestroy</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">UnobservedTaskException</span> <span class="p">-=</span> <span class="n">HandleUnobservedException</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">void</span> <span class="nf">HandleUnobservedException</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">UnobservedTaskExceptionEventArgs</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 在主线程处理异常，避免Unity崩溃</span>
        <span class="n">UnityEngine</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"Unobserved Task Exception: </span><span class="p">{</span><span class="n">e</span><span class="p">.</span><span class="n">Exception</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="n">e</span><span class="p">.</span><span class="nf">SetObserved</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="task的取消机制">Task的取消机制</h2>

<h3 id="cancellationtokensource">CancellationTokenSource</h3>

<p>  CancellationTokenSource是Task取消机制的核心类，负责创建和管理CancellationToken实例。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建CancellationTokenSource</span>
<span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
<span class="c1">// 获取令牌</span>
<span class="n">CancellationToken</span> <span class="n">token</span> <span class="p">=</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">;</span>
<span class="c1">// 启动任务</span>
<span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 执行工作</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="n">token</span><span class="p">);</span>
<span class="c1">// 请求取消</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">Cancel</span><span class="p">();</span>
<span class="c1">// 清理资源</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
</code></pre></div></div>

<h4 id="超时cancellationtokensource">超时CancellationTokenSource</h4>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建带超时的令牌源</span>
<span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">5</span><span class="p">));</span>
<span class="c1">// 或者手动设置超时</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">CancelAfter</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">10</span><span class="p">));</span>
<span class="c1">// 使用</span>
<span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">LongRunningOperation</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">),</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="链接cancellationtokensource">链接CancellationTokenSource</h4>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CancellationTokenSource</span> <span class="n">cts1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
<span class="n">CancellationTokenSource</span> <span class="n">cts2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
<span class="c1">// 创建链接的令牌源</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">linkedCts</span> <span class="p">=</span> <span class="n">CancellationTokenSource</span><span class="p">.</span><span class="nf">CreateLinkedTokenSource</span><span class="p">(</span><span class="n">cts1</span><span class="p">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">cts2</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
<span class="c1">// 任何一个令牌取消都会导致链接令牌取消</span>
<span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoWork</span><span class="p">(</span><span class="n">linkedCts</span><span class="p">.</span><span class="n">Token</span><span class="p">),</span> <span class="n">linkedCts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="cancellationtoken">CancellationToken</h3>

<p>  CancellationToken是不可变的值类型，用于传递取消请求。</p>

<h4 id="核心属性和方法">核心属性和方法</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">struct</span> <span class="nc">CancellationToken</span> <span class="p">{</span>
    <span class="c1">// 属性</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsCancellationRequested</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 是否请求了取消</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">CanBeCanceled</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>            <span class="c1">// 是否可以被取消</span>
    <span class="k">public</span> <span class="n">WaitHandle</span> <span class="n">WaitHandle</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>         <span class="c1">// 用于同步等待</span>
    
    <span class="c1">// 方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">ThrowIfCancellationRequested</span><span class="p">()</span>    <span class="c1">// 抛出取消异常</span>
    <span class="k">public</span> <span class="n">CancellationTokenRegistration</span> <span class="nf">Register</span><span class="p">(</span><span class="n">Action</span> <span class="n">callback</span><span class="p">)</span>  <span class="c1">// 注册取消回调</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="基本取消检查模式">基本取消检查模式</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoWorkAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 方式1：轮询检查</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>  <span class="c1">// 自动处理取消</span>
    <span class="p">}</span>
    
    <span class="c1">// 方式2：定期检查</span>
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">DoStep1Async</span><span class="p">();</span>
    
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">DoStep2Async</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="注册取消回调">注册取消回调</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CancellationToken</span> <span class="n">token</span> <span class="p">=</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">;</span>

<span class="c1">// 注册取消时的回调</span>
<span class="n">CancellationTokenRegistration</span> <span class="n">registration</span> <span class="p">=</span> <span class="n">token</span><span class="p">.</span><span class="nf">Register</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"任务被取消，执行清理工作"</span><span class="p">);</span>
    <span class="c1">// 清理资源</span>
<span class="p">});</span>

<span class="c1">// 取消注册（可选）</span>
<span class="n">registration</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="取消操作的模式">取消操作的模式</h3>

<h4 id="协作式取消模式">协作式取消模式</h4>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ProcessDataAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 阶段1：数据验证</span>
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">ValidateDataAsync</span><span class="p">();</span>
    
    <span class="c1">// 阶段2：数据处理</span>
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">ProcessDataAsync</span><span class="p">();</span>
    
    <span class="c1">// 阶段3：结果保存</span>
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">SaveResultAsync</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="基于回调的取消模式">基于回调的取消模式</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">using</span> <span class="nn">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>
        
        <span class="c1">// 注册取消回调</span>
        <span class="k">using</span> <span class="nn">var</span> <span class="n">registration</span> <span class="p">=</span> <span class="n">token</span><span class="p">.</span><span class="nf">Register</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="n">client</span><span class="p">.</span><span class="nf">CancelPendingRequests</span><span class="p">();</span>
        <span class="p">});</span>
        
        <span class="c1">// 执行下载</span>
        <span class="k">return</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span>
    <span class="p">},</span> <span class="n">token</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="超时取消模式">超时取消模式</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ExecuteWithTimeoutAsync</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span>
    <span class="n">Func</span><span class="p">&lt;</span><span class="n">CancellationToken</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">operation</span><span class="p">,</span> 
    <span class="n">TimeSpan</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="k">using</span> <span class="nn">var</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
    
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">await</span> <span class="nf">operation</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="nf">when</span> <span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">TimeoutException</span><span class="p">(</span><span class="s">$"操作在</span><span class="p">{</span><span class="n">timeout</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">}</span><span class="s">秒内未完成"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="复合取消模式用户取消--超时">复合取消模式（用户取消 + 超时）</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ExecuteWithUserCancellationAsync</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span>
    <span class="n">Func</span><span class="p">&lt;</span><span class="n">CancellationToken</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">operation</span><span class="p">,</span>
    <span class="n">CancellationToken</span> <span class="n">userToken</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="k">using</span> <span class="nn">var</span> <span class="n">timeoutCts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMinutes</span><span class="p">(</span><span class="m">5</span><span class="p">));</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">linkedCts</span> <span class="p">=</span> <span class="n">CancellationTokenSource</span><span class="p">.</span><span class="nf">CreateLinkedTokenSource</span><span class="p">(</span>
        <span class="n">userToken</span><span class="p">,</span> <span class="n">timeoutCts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="k">await</span> <span class="nf">operation</span><span class="p">(</span><span class="n">linkedCts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="取消操作的传播">取消操作的传播</h3>

<h4 id="父子任务的取消传播">父子任务的取消传播</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ProcessMultipleFilesAsync</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">files</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">files</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">file</span> <span class="p">=&gt;</span> 
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">ProcessFileAsync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">token</span><span class="p">),</span> <span class="n">token</span><span class="p">)</span>
    <span class="p">);</span>
    
    <span class="c1">// 当任何一个任务失败或取消时，取消所有任务</span>
    <span class="kt">var</span> <span class="n">allTasks</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
    
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">await</span> <span class="n">allTasks</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 取消传播到所有子任务</span>
        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="延续任务的取消处理">延续任务的取消处理</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">initialTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoInitialWork</span><span class="p">(),</span> <span class="n">token</span><span class="p">);</span>

<span class="c1">// 只有当初始任务成功完成时才执行延续</span>
<span class="n">Task</span> <span class="n">continuation1</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 处理成功结果</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">);</span>

<span class="c1">// 无论初始任务什么状态都执行延续（用于清理）</span>
<span class="n">Task</span> <span class="n">continuation2</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 执行清理工作</span>
    <span class="nf">CleanupResources</span><span class="p">();</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="取消状态的传播">取消状态的传播</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">OperationResult</span><span class="p">&gt;</span> <span class="nf">ExecuteOperationAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">DoWorkAsync</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">OperationResult</span> <span class="p">{</span> <span class="n">Success</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span> <span class="n">Data</span> <span class="p">=</span> <span class="n">result</span> <span class="p">};</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 取消状态传播</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">OperationResult</span> <span class="p">{</span> <span class="n">Success</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span> <span class="n">WasCancelled</span> <span class="p">=</span> <span class="k">true</span> <span class="p">};</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 其他异常</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">OperationResult</span> <span class="p">{</span> <span class="n">Success</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span> <span class="n">Error</span> <span class="p">=</span> <span class="n">ex</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="资源清理的取消传播">资源清理的取消传播</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ProcessWithCleanupAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IDisposable</span> <span class="n">resource</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
    
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">resource</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">AcquireResourceAsync</span><span class="p">();</span>
        
        <span class="c1">// 检查取消状态</span>
        <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
        
        <span class="k">await</span> <span class="nf">ProcessResourceAsync</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 即使取消也要清理资源</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">resource</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">resource</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
        <span class="c1">// 确保资源被清理</span>
        <span class="n">resource</span><span class="p">?.</span><span class="nf">Dispose</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="取消请求的级联传播">取消请求的级联传播</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">CancellationTokenSource</span> <span class="n">_cts</span><span class="p">;</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">StartOperation</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
    <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">ExecuteOperationAsync</span><span class="p">(</span><span class="n">_cts</span><span class="p">.</span><span class="n">Token</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ExecuteOperationAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 子操作也会收到取消请求</span>
        <span class="k">await</span> <span class="nf">Step1Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">Step2Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">Step3Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 取消被正确处理</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"操作被取消"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="task的调度和配置">Task的调度和配置</h2>

<p>  TaskScheduler是Task调度系统的核心抽象类，负责控制Task的执行方式和位置。</p>

<h3 id="taskscheduler详解">TaskScheduler详解</h3>

<p>  TaskScheduler调度器维护了一个等待执行的任务队列，并决定任务执行的优先级和处理任务的依赖关系。TaskScheduler可以决定任务在哪个线程执行，控制并发执行的任务数量，处理任务的异常。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 线程池调度器（默认）</span>
<span class="n">TaskScheduler</span> <span class="n">threadPoolScheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Default</span><span class="p">;</span>

<span class="c1">// 2. 当前同步上下文调度器</span>
<span class="n">TaskScheduler</span> <span class="n">currentScheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>

<span class="c1">// 3. 从同步上下文中捕获的调度器</span>
<span class="n">TaskScheduler</span> <span class="n">capturedScheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="nf">FromCurrentSynchronizationContext</span><span class="p">();</span>

<span class="c1">// 默认调度器 - 使用线程池</span>
<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"执行线程: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="m">42</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 显式指定调度器</span>
<span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">DoWork</span><span class="p">();</span>
<span class="p">},</span> <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>



<span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 在后台线程执行</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoWork</span><span class="p">());</span>
    
    <span class="c1">// 自动切换回UI线程更新界面</span>
    <span class="n">textBox</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 显式使用调度器</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">UpdateUI</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TaskScheduler</span> <span class="n">uiScheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="nf">FromCurrentSynchronizationContext</span><span class="p">();</span>
    
    <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="nf">LoadData</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}).</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">// 在UI线程执行</span>
        <span class="nf">UpdateUI</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
    <span class="p">},</span> <span class="n">uiScheduler</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="taskcreationoptions">TaskCreationOptions</h3>

<p>  TaskCreationOptions枚举用于配置Task的创建行为。</p>

<table>
  <thead>
    <tr>
      <th>选项</th>
      <th>说明</th>
      <th>使用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>None</td>
      <td>默认行为</td>
      <td>标准任务创建</td>
    </tr>
    <tr>
      <td>PreferFairness</td>
      <td>公平调度</td>
      <td>确保任务按顺序执行</td>
    </tr>
    <tr>
      <td>LongRunning</td>
      <td>长运行任务</td>
      <td>CPU密集型或长时间运行任务</td>
    </tr>
    <tr>
      <td>AttachedToParent</td>
      <td>附加到父任务</td>
      <td>创建子任务层次结构</td>
    </tr>
    <tr>
      <td>DenyChildAttach</td>
      <td>拒绝子任务附加</td>
      <td>独立任务执行</td>
    </tr>
    <tr>
      <td>HideScheduler</td>
      <td>隐藏调度器</td>
      <td>内部使用</td>
    </tr>
    <tr>
      <td>RunContinuationsAsynchronously</td>
      <td>异步延续</td>
      <td>避免死锁</td>
    </tr>
  </tbody>
</table>

<p>  LongRunning选项用于将任务分配给专用线程，适用于CPU密集型或长时间运行的任务。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 长运行任务 - 为其分配专用线程</span>
<span class="n">Task</span> <span class="n">longRunningTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// CPU密集型计算</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="c1">// 复杂计算</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">LongRunning</span><span class="p">);</span>
</code></pre></div></div>

<p>  AttachedToParent选项用于将子任务自动附加到父任务，适用于创建子任务层次结构。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">parentTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"父任务开始"</span><span class="p">);</span>
    
    <span class="c1">// 子任务自动附加到父任务</span>
    <span class="n">Task</span> <span class="n">childTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"子任务执行"</span><span class="p">);</span>
        <span class="k">return</span> <span class="m">42</span><span class="p">;</span>
    <span class="p">},</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">AttachedToParent</span><span class="p">);</span>
    
    <span class="c1">// 父任务等待所有子任务完成</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"父任务结束"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>  PreferFairness选项用于确保任务按提交顺序执行。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 确保任务按提交顺序执行</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"任务 </span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="s"> 执行"</span><span class="p">);</span>
    <span class="p">},</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">PreferFairness</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="taskcontinuationoptions">TaskContinuationOptions</h3>

<p>  TaskContinuationOptions控制延续任务的执行条件和行为。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">initialTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 可能成功、失败或取消</span>
    <span class="k">return</span> <span class="nf">ComputeResult</span><span class="p">();</span>
<span class="p">});</span>

<span class="c1">// 1. 只有成功时执行</span>
<span class="n">Task</span> <span class="n">successContinuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"结果: </span><span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">);</span>

<span class="c1">// 2. 只有失败时执行</span>
<span class="n">Task</span> <span class="n">failureContinuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"错误: </span><span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">Exception</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnFaulted</span><span class="p">);</span>

<span class="c1">// 3. 只有取消时执行</span>
<span class="n">Task</span> <span class="n">cancellationContinuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"任务被取消"</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnCanceled</span><span class="p">);</span>

<span class="c1">// 4. 无论什么情况都执行（用于清理）</span>
<span class="n">Task</span> <span class="n">cleanupContinuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nf">CleanupResources</span><span class="p">();</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>

<span class="c1">// 组合多个选项</span>
<span class="n">TaskContinuationOptions</span> <span class="n">options</span> <span class="p">=</span> 
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span> <span class="p">|</span> 
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">RunContinuationsAsynchronously</span> <span class="p">|</span> 
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">AttachedToParent</span><span class="p">;</span>

<span class="n">Task</span> <span class="n">continuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">ProcessResult</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
<span class="p">},</span> <span class="n">options</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="自定义taskscheduler">自定义TaskScheduler</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">UnityTaskScheduler</span> <span class="p">:</span> <span class="n">TaskScheduler</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">_tasks</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">object</span> <span class="n">_lock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">QueueTask</span><span class="p">(</span><span class="n">Task</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lock</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_tasks</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">TryExecuteTaskInline</span><span class="p">(</span><span class="n">Task</span> <span class="n">task</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">taskWasPreviouslyQueued</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">TryExecuteTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="nf">GetScheduledTasks</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_tasks</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 在Unity主线程调用此方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">ExecutePendingTasks</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">_tasks</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="n">task</span><span class="p">))</span> <span class="p">{</span>
            <span class="nf">TryExecuteTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 在MonoBehaviour中使用</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">TaskManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">private</span> <span class="n">UnityTaskScheduler</span> <span class="n">_scheduler</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">_scheduler</span><span class="p">.</span><span class="nf">ExecutePendingTasks</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">RunOnMainThread</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">action</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">tcs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskCompletionSource</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
        
        <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">action</span><span class="p">();</span>
            <span class="n">tcs</span><span class="p">.</span><span class="nf">SetResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="p">},</span> <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">_scheduler</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">tcs</span><span class="p">.</span><span class="n">Task</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="task的高级用法">Task的高级用法</h2>

<h3 id="taskcompletionsource">TaskCompletionSource</h3>

<p>  TaskCompletionSource是Task并行库中最强大的工具之一，允许创建”冷”任务，用于手动控制Task的生命周期和完成状态。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">TaskCompletionSource</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Task</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 获取关联的Task对象</span>
    
    <span class="c1">// 完成控制方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetResult</span><span class="p">(</span><span class="n">T</span> <span class="n">result</span><span class="p">);</span>           <span class="c1">// 设置成功结果</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetException</span><span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">);</span>    <span class="c1">// 设置异常</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetException</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Exception</span><span class="p">&gt;</span> <span class="n">exs</span><span class="p">);</span>  <span class="c1">// 设置多个异常</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetCanceled</span><span class="p">();</span>                <span class="c1">// 设置为已取消</span>
    
    <span class="c1">// 尝试版本（如果任务已完成则返回false）</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">TrySetResult</span><span class="p">(</span><span class="n">T</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">TrySetException</span><span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">);</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">TrySetCanceled</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  包装异步回调操作</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">tcs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskCompletionSource</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
    
    <span class="k">using</span> <span class="nn">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WebClient</span><span class="p">();</span>
    <span class="n">client</span><span class="p">.</span><span class="n">DownloadStringCompleted</span> <span class="p">+=</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Error</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tcs</span><span class="p">.</span><span class="nf">SetException</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Error</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tcs</span><span class="p">.</span><span class="nf">SetCanceled</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tcs</span><span class="p">.</span><span class="nf">SetResult</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
    
    <span class="n">client</span><span class="p">.</span><span class="nf">DownloadAssestAsync</span><span class="p">(</span><span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="n">url</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">tcs</span><span class="p">.</span><span class="n">Task</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="task在unity3d中的应用">Task在Unity3D中的应用</h2>

<h3 id="unity主线程限制">Unity主线程限制</h3>

<p>  Unity3D有严格的主线程限制，这是使用Task时必须了解的核心概念：</p>

<p>  <strong>Unity API的线程安全性限制</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ 错误：在后台线程调用Unity API会抛出异常</span>
<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 这会导致异常："UnityEngine.Transform can only be called from the main thread"</span>
    <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
    <span class="n">GameObject</span><span class="p">.</span><span class="nf">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// ✅ 正确：在主线程执行Unity API调用</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">UnityTaskManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Action</span><span class="p">&gt;</span> <span class="n">_mainThreadActions</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
    
    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 在主线程执行队列中的操作</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">_mainThreadActions</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="n">action</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">action</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">RunOnMainThread</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">action</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">tcs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskCompletionSource</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
        
        <span class="n">_mainThreadActions</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">action</span><span class="p">();</span>
                <span class="n">tcs</span><span class="p">.</span><span class="nf">SetResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tcs</span><span class="p">.</span><span class="nf">SetException</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
        
        <span class="k">return</span> <span class="n">tcs</span><span class="p">.</span><span class="n">Task</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="异步操作的最佳实践">异步操作的最佳实践</h3>

<p>  <strong>网络请求的异步处理</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">NetworkManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">HttpClient</span> <span class="n">_httpClient</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>
    
    <span class="c1">// 异步下载并更新UI</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">Sprite</span><span class="p">&gt;</span> <span class="nf">LoadSpriteAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">,</span> <span class="n">Image</span> <span class="n">targetImage</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="c1">// 后台线程下载</span>
            <span class="kt">var</span> <span class="n">imageData</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_httpClient</span><span class="p">.</span><span class="nf">GetByteArrayAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
            
            <span class="c1">// 主线程创建Sprite并更新UI</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">UnityTaskScheduler</span><span class="p">.</span><span class="nf">RunOnMainThread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="kt">var</span> <span class="n">texture</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Texture2D</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>
                <span class="n">texture</span><span class="p">.</span><span class="nf">LoadImage</span><span class="p">(</span><span class="n">imageData</span><span class="p">);</span>
                
                <span class="kt">var</span> <span class="n">sprite</span> <span class="p">=</span> <span class="n">Sprite</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span> 
                    <span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">texture</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">texture</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> 
                    <span class="n">Vector2</span><span class="p">.</span><span class="n">one</span> <span class="p">*</span> <span class="m">0.5f</span><span class="p">);</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">targetImage</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">targetImage</span><span class="p">.</span><span class="n">sprite</span> <span class="p">=</span> <span class="n">sprite</span><span class="p">;</span>
                <span class="p">}</span>
                
                <span class="k">return</span> <span class="n">sprite</span><span class="p">;</span>
            <span class="p">});</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"加载图片失败: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  <strong>文件I/O的异步处理</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">SaveSystem</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="nf">SaveGameDataAsync</span><span class="p">(</span><span class="n">GameData</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="c1">// 后台线程序列化和写入文件</span>
            <span class="kt">var</span> <span class="n">json</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">JsonUtility</span><span class="p">.</span><span class="nf">ToJson</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">true</span><span class="p">));</span>
            <span class="kt">var</span> <span class="n">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">Combine</span><span class="p">(</span><span class="n">Application</span><span class="p">.</span><span class="n">persistentDataPath</span><span class="p">,</span> <span class="s">"save.json"</span><span class="p">);</span>
            
            <span class="k">await</span> <span class="n">File</span><span class="p">.</span><span class="nf">WriteAllTextAsync</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">json</span><span class="p">);</span>
            
            <span class="c1">// 主线程显示保存成功提示</span>
            <span class="k">await</span> <span class="n">UnityTaskScheduler</span><span class="p">.</span><span class="nf">RunOnMainThread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="nf">ShowSaveSuccessMessage</span><span class="p">();</span>
            <span class="p">});</span>
            
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"保存失败: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">GameData</span><span class="p">&gt;</span> <span class="nf">LoadGameDataAsync</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="kt">var</span> <span class="n">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">Combine</span><span class="p">(</span><span class="n">Application</span><span class="p">.</span><span class="n">persistentDataPath</span><span class="p">,</span> <span class="s">"save.json"</span><span class="p">);</span>
            
            <span class="k">if</span> <span class="p">(!</span><span class="n">File</span><span class="p">.</span><span class="nf">Exists</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">GameData</span><span class="p">();</span> <span class="c1">// 返回默认数据</span>
            <span class="p">}</span>
            
            <span class="c1">// 后台线程读取和反序列化</span>
            <span class="kt">var</span> <span class="n">json</span> <span class="p">=</span> <span class="k">await</span> <span class="n">File</span><span class="p">.</span><span class="nf">ReadAllTextAsync</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">JsonUtility</span><span class="p">.</span><span class="n">FromJson</span><span class="p">&lt;</span><span class="n">GameData</span><span class="p">&gt;(</span><span class="n">json</span><span class="p">));</span>
            
            <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"加载失败: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">GameData</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  <strong>批量操作的进度报告</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AssetLoader</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">LoadAssetsWithProgressAsync</span><span class="p">(</span>
        <span class="kt">string</span><span class="p">[]</span> <span class="n">assetPaths</span><span class="p">,</span> 
        <span class="n">IProgress</span><span class="p">&lt;</span><span class="kt">float</span><span class="p">&gt;</span> <span class="n">progress</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span>
        <span class="n">CancellationToken</span> <span class="n">cancellationToken</span> <span class="p">=</span> <span class="k">default</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="kt">var</span> <span class="n">loadedCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">totalCount</span> <span class="p">=</span> <span class="n">assetPaths</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
        
        <span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">assetPaths</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="k">async</span> <span class="n">path</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="c1">// 后台加载资源数据</span>
                <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">LoadAssetDataAsync</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">cancellationToken</span><span class="p">);</span>
                
                <span class="c1">// 主线程创建Unity对象</span>
                <span class="k">await</span> <span class="n">UnityTaskScheduler</span><span class="p">.</span><span class="nf">RunOnMainThread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                    <span class="nf">CreateUnityAsset</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
                <span class="p">});</span>
                
                <span class="c1">// 更新进度</span>
                <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="n">loadedCount</span><span class="p">);</span>
                <span class="kt">var</span> <span class="n">currentProgress</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">loadedCount</span> <span class="p">/</span> <span class="n">totalCount</span><span class="p">;</span>
                
                <span class="c1">// 主线程更新UI进度</span>
                <span class="k">await</span> <span class="n">UnityTaskScheduler</span><span class="p">.</span><span class="nf">RunOnMainThread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                    <span class="n">progress</span><span class="p">?.</span><span class="nf">Report</span><span class="p">(</span><span class="n">currentProgress</span><span class="p">);</span>
                <span class="p">});</span>
                
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"加载 </span><span class="p">{</span><span class="n">path</span><span class="p">}</span><span class="s"> 被取消"</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"加载 </span><span class="p">{</span><span class="n">path</span><span class="p">}</span><span class="s"> 失败: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
        
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="协程-vs-task">协程 vs Task</h3>

<p>  <strong>功能对比分析</strong></p>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>协程(Coroutine)</th>
      <th>Task</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>执行线程</strong></td>
      <td>仅主线程</td>
      <td>可多线程</td>
    </tr>
    <tr>
      <td><strong>Unity集成</strong></td>
      <td>原生支持</td>
      <td>需要适配器</td>
    </tr>
    <tr>
      <td><strong>取消机制</strong></td>
      <td>手动实现</td>
      <td>内置CancellationToken</td>
    </tr>
    <tr>
      <td><strong>异常处理</strong></td>
      <td>复杂</td>
      <td>标准try-catch</td>
    </tr>
    <tr>
      <td><strong>组合性</strong></td>
      <td>有限</td>
      <td>强大(WhenAll/WhenAny)</td>
    </tr>
    <tr>
      <td><strong>性能开销</strong></td>
      <td>低</td>
      <td>中等</td>
    </tr>
    <tr>
      <td><strong>调试支持</strong></td>
      <td>一般</td>
      <td>优秀</td>
    </tr>
  </tbody>
</table>

<p>  <strong>协程的优势场景</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">CoroutineExamples</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="c1">// 简单的时间延迟和帧等待</span>
    <span class="n">IEnumerator</span> <span class="nf">SimpleAnimation</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="m">0.1f</span><span class="p">;</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// 等待一帧</span>
        <span class="p">}</span>
        
        <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitForSeconds</span><span class="p">(</span><span class="m">1f</span><span class="p">);</span> <span class="c1">// 等待1秒</span>
        
        <span class="c1">// 等待特定条件</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitUntil</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">Space</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="c1">// Unity特定的等待条件</span>
    <span class="n">IEnumerator</span> <span class="nf">WaitForAnimation</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">animator</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Animator</span><span class="p">&gt;();</span>
        <span class="n">animator</span><span class="p">.</span><span class="nf">SetTrigger</span><span class="p">(</span><span class="s">"Play"</span><span class="p">);</span>
        
        <span class="c1">// 等待动画完成</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitForAnimatorState</span><span class="p">(</span><span class="n">animator</span><span class="p">,</span> <span class="s">"IdleState"</span><span class="p">);</span>
        
        <span class="c1">// 等待物理更新</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitForFixedUpdate</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  <strong>Task的优势场景</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">TaskExamples</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="c1">// 复杂的异步操作组合</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ComplexAsyncOperation</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="c1">// 并行执行多个网络请求</span>
            <span class="kt">var</span> <span class="n">task1</span> <span class="p">=</span> <span class="nf">DownloadUserDataAsync</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">task2</span> <span class="p">=</span> <span class="nf">DownloadConfigAsync</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">task3</span> <span class="p">=</span> <span class="nf">DownloadAssetsAsync</span><span class="p">();</span>
            
            <span class="c1">// 等待所有请求完成</span>
            <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">,</span> <span class="n">task3</span><span class="p">);</span>
            
            <span class="c1">// 处理结果</span>
            <span class="nf">ProcessResults</span><span class="p">(</span><span class="n">results</span><span class="p">);</span>
            
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">HttpRequestException</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">HandleNetworkError</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">HandleCancellation</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 带超时的操作</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="nf">TryConnectWithTimeoutAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">using</span> <span class="nn">var</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">5</span><span class="p">));</span>
        
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">await</span> <span class="nf">ConnectToServerAsync</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="nf">when</span> <span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"连接超时"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  <strong>混合使用模式</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">HybridAsyncManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="c1">// 将Task转换为协程</span>
    <span class="k">public</span> <span class="n">Coroutine</span> <span class="n">StartTaskAsCoroutine</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">onComplete</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">TaskToCoroutine</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">onComplete</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="k">private</span> <span class="n">IEnumerator</span> <span class="n">TaskToCoroutine</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">onComplete</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 等待Task完成</span>
        <span class="k">while</span> <span class="p">(!</span><span class="n">task</span><span class="p">.</span><span class="n">IsCompleted</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">IsFaulted</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"Task失败: </span><span class="p">{</span><span class="n">task</span><span class="p">.</span><span class="n">Exception</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">IsCanceled</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Task被取消"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">onComplete</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 将协程转换为Task</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CoroutineToTask</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">IEnumerator</span> <span class="n">coroutine</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">getResult</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">tcs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskCompletionSource</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
        
        <span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">CoroutineWrapper</span><span class="p">());</span>
        
        <span class="n">IEnumerator</span> <span class="nf">CoroutineWrapper</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="nf">StartCoroutine</span><span class="p">(</span><span class="n">coroutine</span><span class="p">);</span>
            
            <span class="k">try</span> <span class="p">{</span>
                <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">getResult</span><span class="p">();</span>
                <span class="n">tcs</span><span class="p">.</span><span class="nf">SetResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tcs</span><span class="p">.</span><span class="nf">SetException</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">tcs</span><span class="p">.</span><span class="n">Task</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="性能考虑">性能考虑</h3>

<p>  <strong>Task分配优化</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PerformanceOptimizedTaskManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="c1">// 缓存常用的已完成Task</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_trueTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_falseTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Task</span> <span class="n">_completedTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
    
    <span class="c1">// 避免不必要的Task分配</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="nf">ValidateAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 同步验证，直接返回缓存的Task</span>
        <span class="k">if</span> <span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="nf">IsNullOrEmpty</span><span class="p">(</span><span class="n">input</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_falseTask</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">Length</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_falseTask</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">// 只有需要异步操作时才创建新Task</span>
        <span class="k">return</span> <span class="nf">ValidateAsyncInternal</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="nf">ValidateAsyncInternal</span><span class="p">(</span><span class="kt">string</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 实际的异步验证逻辑</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">input</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="s">"valid"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 使用ValueTask减少分配</span>
    <span class="k">public</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">GetCachedValueAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_cache</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">cachedValue</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// 同步路径，不分配Task对象</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">cachedValue</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// 异步路径，需要分配Task</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="nf">LoadValueAsync</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>编程散记</name></author><category term="CSharp" /><category term="Task" /><summary type="html"><![CDATA[任务是对象，其中封装了以异步方式执行的工作。这听起来有点儿耳熟，委托不也是封装了代码的对象吗？区别在于委托是同步的而任务是异步的。如果执行一个委托(例如一个Action)，当前线程的控制点会立即转移到委托的代码。]]></summary></entry><entry><title type="html">多线程编程基础篇-Thread(一)</title><link href="https://www.damonc.top/csharp/CSharp_Thread_Base.html" rel="alternate" type="text/html" title="多线程编程基础篇-Thread(一)" /><published>2025-06-03T20:00:00+00:00</published><updated>2025-06-03T20:00:00+00:00</updated><id>https://www.damonc.top/csharp/CSharp_Thread_Base</id><content type="html" xml:base="https://www.damonc.top/csharp/CSharp_Thread_Base.html"><![CDATA[<h2 id="多线程概念">多线程概念</h2>

<p>  现代应用程序可能要同时处理数据计算、画面渲染、文件读写等操作，同时要求操作系统要满足运行多个应用程序，后来随着现代CPU的从单核进化到多核，从物理核心进化到逻辑核心。就逐渐有了多任务执行概念。</p>

<h3 id="什么是多线程">什么是多线程？</h3>

<p>  多线程是一种软件编程概念，Intel提出了<a href="https://www.intel.cn/content/www/cn/zh/gaming/resources/hyper-threading.html">超线程技术（Hyper-Threading）</a>是实现多线程的硬件技术，将单个物理核心虚拟为多个逻辑核心，是对多线程的硬件支持。逻辑核心共享同一物理核心的硬件资源（如ALU、缓存），但拥有独立的寄存器组和线程状态‌，当某个线程因等待数据（如内存访问）暂停时，物理核心立即切换至另一线程执行，复用闲置资源以提升利用率‌。<strong>线程是操作系统调度的最小执行单元，是进程中的一条执行路径，每个线程有自己的代码执行路径和独立的堆栈空间，线程之间可以共享程序的数据段和代码段</strong>。一个进程中可以启动多个线程，实现‌并发‌（Concurrency）或‌并行‌（Parallelism）。</p>

<h3 id="线程的目标是什么">线程的目标是什么？</h3>

<p>  为了防止一个应用程序控制CPU而导致其他应用程序和操作系统本身永远被挂起这一可能情况，操作系统不得不使用某种方式将物理计算单元分割为一些虚拟的进程，并给予每个执行程序一定量的计算能力。此外，操作系统必须始终能够优先访问CPU，并能调整不同程序访问CPU的优先级。线程正是这一概念的实现。可以认为线程是一个虚拟进程，用于独立运行一个特定的程序。<strong>提高程序的响应速度，实现并行计算，以及提高CPU利用率。它可以让一个程序同时执行多个任务，从而更有效地利用系统资源，加快程序运行速度，并提升用户体验。</strong></p>

<h3 id="程序进程线程协程">程序、进程、线程、协程</h3>

<p>进程和线程是操作系统领域的两个重要概念，两者既有区别又有联系。</p>

<h4 id="可执行程序">可执行程序</h4>

<p>  C/C++源文件经过编译器（编译+链接）处理后，会产生可执行程序文件，不同系统有不同格式，比如Linux系统的ELF格式、Windows系统的EXE格式，可执行程序文件是一个静态的概念。</p>

<h4 id="进程是什么">进程是什么</h4>

<p>  可执行程序在操作系统上的一次执行对应一个进程，进程是一个动态的概念：<strong>进程是执行中的程序</strong>。同一份可执行文件执行多次，会产生多个进程，这跟一个类可以创建多个实例一样。进程是资源分配的基本单位。</p>

<h4 id="线程是什么">线程是什么</h4>

<p>  一个进程内的多个线程代表着多个执行流，这些线程以并发模式独立执行。操作系统中，被调度执行的最小单位是线程而非进程。进程是通过共享存储空间对用户呈现的逻辑概念，同一进程内的多个线程共享地址空间和文件描述符，共享地址空间意味着进程的代码（函数）区域、全局变量、堆、栈都被进程内的多个线程共享。</p>

<h4 id="进程和线程的关系">进程和线程的关系</h4>

<p>  启动一个程序，系统会在内存自动创建一个新的进程，进程是构成程序运行的资源集合，包括虚拟地址空间、文件句柄等。在进程内部系统会创建一个线程对象开始执行Main方法，该线程也被称为主线程。因此进程也是线程的一个集合。</p>

<ol>
  <li>默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束。</li>
  <li>主线程也可以继续派生线程，进程内可能含有不同状态的线程</li>
  <li>如果一个进程拥有多个线程，它们将共享进程资源</li>
  <li><strong>线程是操作系统调度的最小执行单元，是进程中的一条执行路径</strong></li>
</ol>

<h4 id="协程">协程</h4>

<p>  用户态的多执行流，上下文切换成本比线程更低，微信用协程改造后台系统后，获得了更大吞吐能力和更高稳定性。如今，协程库也进了C++20新标准。Unity的协程并非多线程，而是完全运行在Unity主线程上，通过迭代器（IEnumerator）和yield指令实现逻辑分帧执行，避免阻塞主线程的UI响应‌。</p>

<h2 id="线程简介">线程简介</h2>

<p>  现在的C#代码直接使用New Thread()创建线程，这是比较老旧的用法，C#更推荐使用Task、async/awit方式。但是要了解线程知识就要从c#的Thread线程说起。</p>

<h3 id="创建线程">创建线程</h3>

<p>  要创建并启动 一个线程，需要首先实例化Thread对象并调用Start方法。Thread的最简单的构造器接收一个ThreadStart无参委托或ParameterizedThreadStart有参委托。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">ThreadStart</span> <span class="n">start</span><span class="p">);</span>
<span class="k">public</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">ParameterizedThreadStart</span> <span class="n">start</span><span class="p">);</span>
<span class="k">public</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">ThreadStart</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxStackSize</span><span class="p">);</span>
<span class="k">public</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">ParameterizedThreadStart</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxStackSize</span><span class="p">);</span>

<span class="c1">//c#1.0</span>
<span class="k">public</span> <span class="k">delegate</span> <span class="k">void</span> <span class="nf">ThreadStart</span><span class="p">();</span>
<span class="c1">//c#2.0</span>
<span class="k">public</span> <span class="k">delegate</span> <span class="k">void</span> <span class="nf">ParameterizedThreadStart</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">);</span>
</code></pre></div></div>

<p>:一个无参数的方法，表示执行的起始位置，例如</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Test2</span><span class="p">(){</span>
    <span class="c1">//主线程打印x</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"x"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//子线程打印y</span>
    <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()=&gt;</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"y"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="nf">Start</span><span class="p">();</span>

    <span class="k">new</span> <span class="nf">Thread</span><span class="p">((</span><span class="n">y</span><span class="p">)=&gt;{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="nf">Start</span><span class="p">(</span><span class="s">"y"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 线程的参数传递 </div> </div> <div class="content"> <p>线程的参数传递需要使用ParameterizedThreadStart委托，并且需要将参数传递给Start方法。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 如果使用这种方式会异常</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="p">(()=&gt;{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}).</span><span class="nf">Start</span><span class="p">(</span><span class="s">"y"</span><span class="p">);</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">(</span><span class="kt">object</span> <span class="n">parameter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果m_Delegate是ThreadStart委托，则抛出异常</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_Delegate</span> <span class="k">is</span> <span class="n">ThreadStart</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="nf">GetResourceString</span><span class="p">(</span><span class="s">""</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>



 </div> </div>
<h3 id="线程的生命周期">线程的生命周期</h3>

<p>  线程有多个状态表示使用ThreadState表示，其中最重要的几个状态就是暂停等待(休眠)、终止<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Thread</span> <span class="n">thread</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;{});</span>
    <span class="n">thread</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">thread</span><span class="p">.</span><span class="n">Priority</span> <span class="p">=</span> <span class="n">ThreadPriority</span><span class="p">.</span><span class="n">Highest</span><span class="p">;</span>
    <span class="n">thread</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="n">thread</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="n">thread</span><span class="p">.</span><span class="nf">Interrupt</span><span class="p">();</span>
    <span class="n">thread</span><span class="p">.</span><span class="nf">Abort</span><span class="p">();</span>
</code></pre></div></div>

<ol>
  <li><strong>新建状态(New)</strong>‌ new Thread()创建线程对象时，线程处于新建状态，此时尚未分配系统资源‌。</li>
  <li><strong>前台/后台线程</strong> 显式创建的线程是前台线程，通过线程对象的IsBackground属性可以控制。<strong>进程会等待所有的前台线程完成后再结束工作，但是如果只剩下后台线程，则会直接结東工作。</strong></li>
  <li><strong>线程的优先级</strong> 前台线程的优先级大于后台线程，如果线程优先级设置过大，则可能会干涉到系统运行，如磁盘写入、鼠标点击等都是高速运转的，如果程序中有太多高优先级的线程，那么系统需要分配大量CPU时间运行这些线程的代码，可能会导致系统无响应或响应缓慢。</li>
  <li><strong>‌就绪状态(Runnable)</strong>‌ Start()方法调用后线程进入就绪队列，等待CPU调度执行‌。</li>
  <li><strong>‌运行状态(Running)‌</strong> 当线程获得CPU时间片时开始执行，示例中由于Lambda表达式为空，实际不执行操作‌。‌</li>
  <li><strong>阻塞状态(Blocked)‌</strong> Thread.Sleep(1000)使主线程休眠1秒，此时主线程处于定时等待状态‌。</li>
  <li><strong>阻塞状态(Blocked)‌</strong> Join(1000)使主线程等待目标线程完成，最多阻塞1秒‌。</li>
  <li>‌<strong>中断状态(Interrupted)‌</strong> Interrupt()向线程发送中断信号，若线程处于阻塞状态会抛出InterruptedException‌。</li>
  <li>‌<strong>终止状态(Aborted/Terminated)‌</strong> Abort()强制终止线程，会抛出ThreadAbortException异常‌。注意该方法在.NET中已过时，推荐使用协作式取消模式‌。</li>
</ol>

<p>  线程状态枚举ThreadState，线程状态的转换图如下：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">ThreadState</span>
<span class="p">{</span>
    <span class="n">Running</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="c1">// 线程正在运行</span>
    <span class="n">StopRequested</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="c1">// 线程请求停止</span>
    <span class="n">SuspendRequested</span> <span class="p">=</span> <span class="m">2</span><span class="p">,</span> <span class="c1">// 线程请求挂起</span>
    <span class="n">Background</span> <span class="p">=</span> <span class="m">4</span><span class="p">,</span> <span class="c1">// 线程是后台线程</span>
    <span class="n">Unstarted</span> <span class="p">=</span> <span class="m">8</span><span class="p">,</span> <span class="c1">// 线程未启动</span>
    <span class="n">Stopped</span> <span class="p">=</span> <span class="m">16</span><span class="p">,</span> <span class="c1">// 线程已停止</span>
    <span class="n">WaitSleepJoin</span> <span class="p">=</span> <span class="m">32</span><span class="p">,</span> <span class="c1">// 线程等待、休眠或加入</span>
    <span class="n">Suspended</span> <span class="p">=</span> <span class="m">64</span><span class="p">,</span> <span class="c1">// 线程挂起</span>
    <span class="n">AbortRequested</span> <span class="p">=</span> <span class="m">128</span><span class="p">,</span> <span class="c1">// 线程请求终止</span>
    <span class="n">Aborted</span> <span class="p">=</span> <span class="m">256</span><span class="p">,</span> <span class="c1">// 线程已终止</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts\2025\month6\thread_state.png" width="250" /><font size="2.5">
            <i>线程生命周期图示.</i>
        </font></center>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 线程终止警告 </div> </div> <div class="content"> <p>Interrupt()和Abort()的调用时机会影响线程状态转换结果，若线程已终止则这些操作无效‌。在多线程编程中应谨慎使用强制终止方法，可能引发资源未释放等问题‌。</p>



 </div> </div>
<h3 id="线程的同步和互斥">线程的同步和互斥</h3>

<p>  CLR运行时管理分配着每一个线程所需多独立内存栈，从而保证了局部变量的隔离。如果不同的线程拥有同一个对象的引用，则这些线程之间就共享了数据，编译器也会将Lambda表达式捕获的局部变量或匿名委托转换为字段，因此它们也可以被共享。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="n">ThreadTest</span><span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(){</span>
        <span class="kt">bool</span> <span class="n">done</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">ThreadStart</span> <span class="n">aciont</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span> <span class="nf">WriteLine</span> <span class="p">(</span><span class="s">"Done"</span><span class="p">);</span> <span class="n">done</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">new</span> <span class="nf">Thread</span> <span class="p">(</span><span class="n">action</span><span class="p">).</span><span class="nf">Start</span><span class="p">();</span>
        <span class="nf">action</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  上述代码，主线程调用了action，同时new了一个子线程绑定了匿名函数捕获了外部变量done，这个“Done”是有可能输出两次的。主线程正在打印“Done”时，子线程可能已经进入到匿名函数正在判定。</p>

<h4 id="lock线程锁">lock线程锁</h4>

<p>  锁有三种结构：Lock、Mutex和SpinLock，其中Lock是最常用最方便的锁结构。锁允许多个线程在同一时间内只有一个能够访问被锁定的资源，从而避免竞态条件和数据不一致的问题。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">object</span> <span class="n">lockObject</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span> <span class="c1">// 锁对象</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">sharedValue</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Thread</span> <span class="n">thread1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">IncrementSharedValue</span><span class="p">);</span>
        <span class="n">Thread</span> <span class="n">thread2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">IncrementSharedValue</span><span class="p">);</span>

        <span class="n">thread1</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
        <span class="n">thread2</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>

        <span class="n">thread1</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
        <span class="n">thread2</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Final shared value: "</span> <span class="p">+</span> <span class="n">sharedValue</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">IncrementSharedValue</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="k">lock</span> <span class="p">(</span><span class="n">lockObject</span><span class="p">)</span> <span class="c1">// 使用锁</span>
            <span class="p">{</span>
                <span class="n">sharedValue</span><span class="p">++;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  两个线程分别对sharedValue进行了100000次的增加操作，但由于使用了锁机制，它们不会交叉并发地修改sharedValue，从而确保了数据一致性。thread1.Join()与thread2.Join()简单理解就是把thread1/2合并到主线程，主线程默认是前台线程需要等待thread1/2执行完成后才能继续执行。如果不调用Join那么直接打印了Final shared value结果会不准确。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 锁的开销提示 </div> </div> <div class="content"> <p>使用锁机制可能会引入性能开销，因为在一个线程访问锁定代码块时，其他线程会被阻塞。因此，在设计多线程应用时，应根据实际需求和性能要求合理地使用锁机制，避免锁的过度使用导致性能问题。</p>



 </div> </div>
<h4 id="死锁">死锁</h4>

<p>  死锁将导致程序停止工作是最常见的多线程错误，下面是一个死锁示例：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">object</span> <span class="n">locker1</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>
<span class="kt">object</span> <span class="n">locker2</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span> 
<span class="n">Thread</span> <span class="n">threadA</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span> <span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">lock</span> <span class="p">(</span><span class="n">locker1</span><span class="p">){</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">locker2</span><span class="p">);</span> <span class="c1">//Deadlock</span>
    <span class="p">}</span>
    
<span class="p">});</span>
<span class="n">threadA</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>

<span class="k">lock</span> <span class="p">(</span><span class="n">locker2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span> <span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="k">lock</span> <span class="p">(</span><span class="n">locker1</span><span class="p">);</span> <span class="c1">//Deadlock</span>
<span class="p">}</span>

<span class="c1">//使用三个或者更多的线程则可能形成更加复杂的死锁链。</span>
</code></pre></div></div>

<p>  死锁的形成过程如下：</p>

<p><strong>初始状态</strong>：</p>
<ol>
  <li>创建了两个锁对象：locker1和locker2</li>
  <li>有两个线程：线程A（新创建的线程）和主线程</li>
</ol>

<p><strong>步骤1</strong>：线程启动（t=0ms）</p>
<ol>
  <li>线程A 开始执行，进入第一个lock(locker1)</li>
  <li>线程A 成功获取lock(locker1)的锁</li>
  <li>同时，主线程 执行到lock(locker2)</li>
  <li>主线程 成功获取lock(locker2)的锁</li>
</ol>

<p><strong>步骤2</strong>：延时阶段（t=0-1000ms）</p>
<ol>
  <li>线程A 持有lock(locker1)，执行Thread.Sleep(1000)</li>
  <li>主线程 持有lock(locker2)，执行Thread.Sleep(1000)</li>
  <li>此时两个线程都在睡眠，各自持有一个锁</li>
</ol>

<p><strong>步骤3</strong>：死锁形成（t=1000ms后）</p>
<ol>
  <li>线程A 从睡眠中醒来，尝试获取lock(locker2)，但是locker2已经被主线程持有，线程A被阻塞，等待lock(locker2)释放</li>
  <li>主线程 从睡眠中醒来，尝试获取lock(locker1)，但是locker1 已经被线程A持有，主线程被阻塞，等待lock(locker1)释放</li>
</ol>

<pre><code class="language-mermaid2">graph LR
    A[线程A] --&gt; |持有| L1[locker1]
    A --&gt; |等待| L2[locker2]
    B[主线程] --&gt; |持有| L2
    B --&gt; |等待| L1
    
    L1 -.-&gt; |阻塞| B
    L2 -.-&gt; |阻塞| A
    
    style A fill:#ff9999
    style B fill:#99ccff
    style L1 fill:#ffcc99
    style L2 fill:#ffcc99
</code></pre>

<h4 id="monitor锁定资源">Monitor锁定资源</h4>

<p>  Monitor是C#中用于实现线程同步和互斥的另一种机制，同时lock关键字是Monitor类的一种语法糖。它提供了更高级的方法TryEenter()。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">acquiredLock</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> 
<span class="k">try</span><span class="p">{</span>
    <span class="n">Monitor</span><span class="p">.</span><span class="nf">Enter</span><span class="p">(</span><span class="n">lockObject</span><span class="p">,</span> <span class="k">ref</span> <span class="n">acquiredLock</span><span class="p">);</span>
    <span class="c1">// Code that accesses resources that are protected by the lock.</span>
<span class="p">}</span>
<span class="k">finally</span><span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">acquiredLock</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Monitor</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="n">lockObject</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  Monitor类的使用方式相对于lock锁机制更灵活。以下是使用Monitor类的一个示例，展示如何在多个线程之间控制访问顺序：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="kt">object</span> <span class="n">syncLock</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">currentThread</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="c1">// 1表示线程1，2表示线程2</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">thread1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">Worker</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">thread2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">Worker</span><span class="p">);</span>

        <span class="n">thread1</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
        <span class="n">thread2</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>

        <span class="n">thread1</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
        <span class="n">thread2</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Worker</span><span class="p">(</span><span class="kt">object</span> <span class="n">threadIdObj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">threadId</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">threadIdObj</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="k">lock</span> <span class="p">(</span><span class="n">syncLock</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">currentThread</span> <span class="p">!=</span> <span class="n">threadId</span><span class="p">)</span>
                    <span class="n">Monitor</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="n">syncLock</span><span class="p">);</span>

                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Thread </span><span class="p">{</span><span class="n">threadId</span><span class="p">}</span><span class="s">: </span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
                <span class="n">currentThread</span> <span class="p">=</span> <span class="n">threadId</span> <span class="p">==</span> <span class="m">1</span> <span class="p">?</span> <span class="m">2</span> <span class="p">:</span> <span class="m">1</span><span class="p">;</span>
                <span class="n">Monitor</span><span class="p">.</span><span class="nf">Pulse</span><span class="p">(</span><span class="n">syncLock</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  两个线程同时访问Worker时通过判定线程ID是否一致确定该线程是否继续执行，不一致就使用Monitor.Wait()方法会使当前线程等待，直到其它线程完成访问Worker通过Monitor.Pulse()方法通知其他等待的线程可以继续执行。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> Monitor也会有死锁 </div> </div> <div class="content"> <p>使用Monitor类可以在更复杂的情况下控制线程之间的访问顺序，但也需要小心避免死锁等问题。这种方法需要线程之间相互配合，以确保正确的执行顺序。</p>



 </div> </div>
<h4 id="mutex同步">Mutex同步</h4>

<p>  Mutex和lock类似，但是它可以支持多个进程。其只对一个线程授予对共享资源的独占访问。Mutex类的WaitOne方法将获得该锁，ReleaseMutex方法将释放该锁。Mutex只能在获得锁的线程释放锁。释放Mutex需要大约一微秒的时间，大概比1ock要慢20倍<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">string</span> <span class="n">MutexName</span> <span class="p">=</span> <span class="s">"CSharpThreadingCookbook"</span><span class="p">;</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">m</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Mutex</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="n">MutexName</span><span class="p">)){</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">m</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">5</span><span class="p">),</span> <span class="k">false</span><span class="p">)){</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Second instance is running!"</span><span class="p">);</span>    
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Running!"</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
        <span class="n">m</span><span class="p">.</span><span class="nf">ReleaseMutex</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="semaphore信号量">Semaphore信号量</h4>

<p>  信号量是一种计数器，用于限制同时访问某个资源的线程数量。信号量可用于限制并发性，防止太多的线程同时执行特定的代码。在C#4.0引入了轻量级Semaphoreslim信号量，Semaphore在调用WaitOne和Release方法时大概会消耗1微秒的时间，而Semaphoreslim的开销只有前者的十分之一<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">Semaphoreslim</span> <span class="n">semaphore</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Semaphoreslim</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="n">Thread</span> <span class="n">thread</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">DoWork</span><span class="p">);</span>
            <span class="n">thread</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">DoWork</span><span class="p">(</span><span class="kt">object</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">semaphore</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span> <span class="c1">// 等待获取信号量</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thread "</span> <span class="p">+</span> <span class="n">id</span> <span class="p">+</span> <span class="s">" is working..."</span><span class="p">);</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thread "</span> <span class="p">+</span> <span class="n">id</span> <span class="p">+</span> <span class="s">" finished."</span><span class="p">);</span>
        <span class="n">semaphore</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span> <span class="c1">// 释放信号量</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="线程池">线程池</h2>

<p>  每当启动一个线程时，都需要一定时间(上百毫秒)来创建新的局部变量栈。如果使用线程池预先创建可回收线程可大幅降低创建开销。但是<strong>线程池的线程都是后台线程，阻塞线程池将会影响性能</strong>。Thread.CurrentThread.IsThreadPoolThread属性可确认当前线程是否属于线程池。</p>

<h3 id="线程池简介">线程池简介</h3>

<p>  线程池线程是后台线程。 每个线程使用默认堆栈大小，以默认优先级运行，并且位于多线程单元中。 线程池中的线程完成其任务后，它将返回到等待线程的队列。 从此刻起，可以重复使用它。 这样，应用程序就可以避免为每个任务创建新线程的成本。</p>

<p>  <strong>每个进程只有一个线程池实例。</strong></p>

<h3 id="线程池的使用">线程池的使用</h3>

<p>  通过System.Threading.ThreadPool类可以获取线程池中的线程，通过QueueUserWorkItem静态方法将任务添加到线程池队列中，该方法接受一个委托表示一个自定义的异步操作。在调用QueueUserWorkItem方法时，如果线程池中没有空闲线程，则该方法会创建一个新的线程来执行委托任务。如果过快调用QueueUserWorkItem方法，则线程池会创建过多的线程，新的委托操作将在队列中等待直到线程池中线程空闲，所以过快的调用会导致性能下降。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 线程池警告 </div> </div> <div class="content"> <ol>
  <li>线程池适合短时任务，不适合长时间运行且计算密集型操作。</li>
  <li>线程是被CLR管理的作为系统级资源，如果应用大量占用线程池线程导致阻塞，会显著拖慢进程的响应速度。</li>
</ol>



 </div> </div>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">delegate</span> <span class="kt">string</span> <span class="nf">RunTestThreadPool</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">threadId</span><span class="p">);</span>

<span class="c1">//public delegate void AsyncCallback(IAsyncResult ar);</span>
<span class="c1">//只要跟AsyncCallback委托的签名一致即可</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">FinishCallback</span><span class="p">(</span><span class="n">IAsyncResult</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"callback called"</span><span class="p">);</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"线程状态=</span><span class="p">{</span><span class="n">result</span><span class="p">.</span><span class="n">AsyncState</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"线程Id</span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">Test</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">threadId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Thread starting"</span><span class="p">);</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"Thread id = </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="n">threadId</span> <span class="p">=</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="s">$"Thread id = </span><span class="p">{</span><span class="n">threadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//入口函数</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">ThreadPoolStart</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">threadId</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="c1">// 使用Thread创建线程</span>
    <span class="kt">var</span> <span class="n">thread1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">((()</span> <span class="p">=&gt;</span> <span class="nf">Test</span><span class="p">(</span><span class="k">out</span> <span class="n">threadId</span><span class="p">)));</span>
    <span class="n">thread1</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
    <span class="c1">//创建线程id确定不是来自线程池的线程id</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"new Thread id </span><span class="p">{</span><span class="n">thread1</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// 使用线程池运行委托</span>
    <span class="n">RunTestThreadPool</span> <span class="n">poolDelegate</span> <span class="p">=</span> <span class="n">Test</span><span class="p">;</span>
    <span class="c1">// 接受一个回调函数和自定义参数，并理解返回IAsyncResult对象</span>
    <span class="n">IAsyncResult</span> <span class="n">thread2</span> <span class="p">=</span> <span class="n">poolDelegate</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="k">out</span> <span class="n">threadId</span><span class="p">,</span> <span class="n">FinishCallback</span><span class="p">,</span> <span class="s">"delegate async callback"</span><span class="p">);</span>
    <span class="c1">// 等待线程池线程完成，后面的代码开始挂起，允许继续其他工作</span>
    <span class="n">thread2</span><span class="p">.</span><span class="n">AsyncWaitHandle</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
    <span class="c1">// 获取线程池线程返回值</span>
    <span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">poolDelegate</span><span class="p">.</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">thread2</span><span class="p">);</span>
    <span class="c1">// 打印线程池线程id</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"thread pool threaId </span><span class="p">{</span><span class="n">threadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// 打印线程池线程返回值</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="c1">// 等待1秒</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  BeginInvoke/EndInvoke的前x个参数与委托的签名参数是要一致的，然后后一个参数是完成回调，最后是自定义object参数是在EndInvoke的返回值。使用Begin/End方法和IAsyncResult对象可以实现异步调用被称为异步编程模型<a href="../CSharp/CSharp_Thread_Pattern.html#apm模式">APM模型</a>。<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<div class="premonition error"> <div class="header"> <svg class="icon error" aria-hidden="true"> <use xlink:href="#icon-error"></use> </svg> <div class="title"> Thread已过时 </div> </div> <div class="content"> <p>现代C#不再推荐直接操作使用Thread、ThreadPool，C#在4.0以后推出了一套抽象程度更高的TPL的API将ThreadPool作为底层实现包装起来。</p>



 </div> </div>
<h4 id="线程池创建">线程池创建</h4>

<p>  观察创建线程需要的时间，线程池创建线程的效率比new Thread()创建线程的效率要高，因为线程池创建线程是可复用的，而new Thread()创建线程是每次都创建新的线程。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stopwatch</span> <span class="n">stopwatch</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Stopwatch</span><span class="p">();</span>
<span class="n">stopwatch</span><span class="p">.</span><span class="nf">Start</span><span class="p">();;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="c1">// new Thread(() =&gt; { }).Start();</span>
    <span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">((</span><span class="n">a</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">});</span>
<span class="p">}</span>
<span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"创建100个线程需要花费时间(毫秒)："</span> <span class="p">+</span> <span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>
</code></pre></div></div>
<p>  用我的Mac intel 6核CPU测试到直接New Thread创建消耗260ms，而线程池创建100个可复用的线程消耗只有3ms。</p>

<h4 id="线程池数量">线程池数量</h4>

<p>  线程池的线程数量是根据CPU核心数来决定的，默认情况下线程池的线程数量为CPU核心数，但是可以通过SetMinThreads()和 SetMaxThreads()设置线程池工作的最小和最大线程数。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">SetMinThreads</span> <span class="p">(</span><span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">SetMaxThreads</span> <span class="p">(</span><span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span>

<span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">GetMinThreads</span> <span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">GetMaxThreads</span> <span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span>
</code></pre></div></div>

<p>  <strong>workerThreads</strong>：工作线程数，这些线程用于处理一般的CPU密集型任务和普通的异步操作，默认值通常等于CPU核心数。</p>

<p>  <strong>completionPortThreads</strong>：I/O完成端口线程数，这些线程专门用于处理异步I/O操作的完成通知，处理文件读写、网络请求等I/O密集型操作的回调。
  <strong>返回值</strong>：Set工作线程数量返回值bool为true表示成功，失败false(系统参数为负、内存不足、超过受限值)。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 检查当前设置</span>
<span class="kt">int</span> <span class="n">currentWorker</span><span class="p">;</span> <span class="kt">int</span> <span class="n">currentIO</span><span class="p">;</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">GetMaxThreads</span><span class="p">(</span><span class="k">out</span> <span class="n">currentWorker</span><span class="p">,</span> <span class="k">out</span> <span class="n">currentIO</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"线程池最大线程数=</span><span class="p">{</span><span class="n">currentWorker</span><span class="p">}</span><span class="s"> completionPortThreads=</span><span class="p">{</span><span class="n">currentIO</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">maxWorker</span><span class="p">;</span> <span class="kt">int</span> <span class="n">maxIO</span><span class="p">;</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">GetMinThreads</span><span class="p">(</span><span class="k">out</span> <span class="n">maxWorker</span><span class="p">,</span> <span class="k">out</span> <span class="n">maxIO</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"线程池最小线程数=</span><span class="p">{</span><span class="n">maxWorker</span><span class="p">}</span><span class="s"> completionPortThreads=</span><span class="p">{</span><span class="n">maxIO</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="c1">// 安全设置最小线程数，不超过最大值</span>
<span class="kt">int</span> <span class="n">desiredWorker</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="m">50</span><span class="p">,</span> <span class="n">maxWorker</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">desiredIO</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="m">50</span><span class="p">,</span> <span class="n">maxIO</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(!</span><span class="n">ThreadPool</span><span class="p">.</span><span class="nf">SetMinThreads</span><span class="p">(</span><span class="n">desiredWorker</span><span class="p">,</span> <span class="n">desiredIO</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">// 处理失败情况</span>
<span class="p">}</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>
</code></pre></div></div>

<h4 id="线程池调度">线程池调度</h4>

<p>  <strong>线程池使用的一些注意事项：</strong></p>
<ol>
  <li>SetMaxThreads()设置的最大工作线程数或I/O线程数，不能小于SetMinThreads()设置的最小工作线程数或I/O线程数。</li>
  <li>SetMaxThreads()设置的工作线程或I/O完成线程数目不能设置为小于计算机上的处理器数。</li>
  <li>如果将线程池最小数设置得过大(SetMinThreads())，会导致任务切换开销变大，消耗更多得性能资源。</li>
  <li>如果加入的任务大于设置的最大线程数，那么将会进入等待队列。</li>
</ol>

<p>  线程池调度算法<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>，这个搜索了Google和AI：</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 线程调度 </div> </div> <div class="content"> <p>如果线程数设置过小，那么任务很多时，队列会有大量任务需要等待，这样可能会导致我们要执行的任务不能马上完成，很多要执行的函数阻塞等待。
c#线程池调度算法有工作窃取法演进到爬山算法。</p>



 </div> </div>
<h2 id="线程终止">线程终止</h2>

<p>  终止线程方式包括：任务完成自动终止、异常终止、超时终止、手动终止()。主要注意的手动终止方式方法。看了好几本关于线程的书籍都在强调不可轻易调用用Thread.Abort()。直接调用Abort并不能表明该线程就停止运行，根据<a href="../CSharp/CSharp_Thread_Pattern.html###线程的生命周期">线程生命周期图</a>和线程状态转换枚举，它仅仅是发出了AbortRequest请求CLR终止该线程，至于终止时机完全由CLR决定。线程终止后状态会变为Aborted，CLR会自动回收线程资源。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Thread</span> <span class="n">test</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">test</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>

<span class="c1">// 终止线程后获取状态</span>
<span class="n">test</span><span class="p">.</span><span class="nf">Abort</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">$"线程是否存活=</span><span class="p">{</span><span class="n">test</span><span class="p">.</span><span class="n">IsAlive</span><span class="p">}</span><span class="s">  线程状态=</span><span class="p">{</span><span class="n">test</span><span class="p">.</span><span class="n">ThreadState</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

<span class="c1">// 终止线程后并让主线程等待test线程完成，获取状态</span>
<span class="n">test</span><span class="p">.</span><span class="nf">Abort</span><span class="p">();</span>
<span class="n">test</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">$"线程是否存活=</span><span class="p">{</span><span class="n">test</span><span class="p">.</span><span class="n">IsAlive</span><span class="p">}</span><span class="s">  线程状态=</span><span class="p">{</span><span class="n">test</span><span class="p">.</span><span class="n">ThreadState</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="令牌方式终止">令牌方式终止</h3>

<p>  推荐使用CancellationTokenSource来终止线程。CancellationTokenSource类提供了一个CancellationToken对象，可以用于取消异步操作。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
<span class="n">Thread</span> <span class="n">test</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">((</span><span class="n">obj</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">CancellationToken</span> <span class="n">token</span> <span class="p">=</span> <span class="p">(</span><span class="n">CancellationToken</span><span class="p">)</span> <span class="n">obj</span><span class="p">;</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(!</span><span class="n">token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
            <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">test</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
<span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">Cancel</span><span class="p">();</span>
<span class="n">test</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"线程是否存活=</span><span class="p">{</span><span class="n">test</span><span class="p">.</span><span class="n">IsAlive</span><span class="p">}</span><span class="s">  线程状态=</span><span class="p">{</span><span class="n">test</span><span class="p">.</span><span class="n">ThreadState</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>
</code></pre></div></div>

<p>  CancellationTokenSource发出取消信号，CancellationToken.IsCancellationRequested检查是否请求取消，CancellationToken.ThrowIfCancellationRequested()在取消时抛出异常同时IsCancellationRequested设置为true。这里token.ThrowIfCancellationRequested()是否抛出异常根据实际需求来决定。</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>参考书籍：C#多线程编程实战。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>参考书籍：C#7.0本质论lock部分。 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>参考书籍：C#7.0本质论信号量。 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>参考<a href="https://learn.microsoft.com/zh-cn/dotnet/navigate/advanced-programming/">微软文档</a>。 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>参考书籍：C#5.0本质论线程调度算法原理。 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>编程散记</name></author><category term="CSharp" /><category term="Thread" /><summary type="html"><![CDATA[现代应用程序可能要同时处理数据计算、画面渲染、文件读写等操作，同时要求操作系统要满足运行多个应用程序，后来随着现代CPU的从单核进化到多核，从物理核心进化到逻辑核心。就逐渐有了多任务执行概念。]]></summary></entry><entry><title type="html">Unity Addressable System使用分析(三)</title><link href="https://www.damonc.top/unity3d/Unity_Addressable_Build.html" rel="alternate" type="text/html" title="Unity Addressable System使用分析(三)" /><published>2024-07-15T20:00:00+00:00</published><updated>2024-07-15T20:00:00+00:00</updated><id>https://www.damonc.top/unity3d/Unity_Addressable_Build</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Addressable_Build.html"><![CDATA[<h2 id="addressable初始化">Addressable初始化</h2>

<p>  AA初始化调用函数<code class="language-plaintext highlighter-rouge">Addressables.InitializeAsync(autoReleaseHandle)</code>，返回AsyncOperationHandle。参数autoReleaseHandle是控制Handle是否自动释放，默认是true会自动释放。虽然成功执行了初始化，但是想要拿到AsyncOperationHandle的结果就不能让它自动释放，如果访问会提示handle无效。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AsyncOperationHandle</span><span class="p">&lt;</span><span class="n">IResourceLocator</span><span class="p">&gt;</span> <span class="n">handle</span> <span class="p">=</span> <span class="n">Addressables</span><span class="p">.</span><span class="nf">InitializeAsync</span><span class="p">();</span>
<span class="k">yield</span> <span class="k">return</span> <span class="n">handle</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="p">.</span><span class="n">Status</span> <span class="p">!=</span> <span class="n">AsyncOperationStatus</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Initialization Error"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  AA初始化返回结果就是本地的Catalog.bundle对象，使用DefaultBuildScript打AssetBundle结果会保存在<code class="language-plaintext highlighter-rouge">Library/com.unity.addressables/aa/平台/</code>。Initial加载的就是本地最新的Catalog对象，如果是真机就会加载打包APK时最初打进包的Catalog对象。</p>

<h3 id="catalog结构">Catalog结构</h3>

<p>  Catalog加载后会构建成<code class="language-plaintext highlighter-rouge">ResourceLocationMap</code>对象，该数据对象就是记录了一个Bundle的所保存的地址信息(本地还是远程)。加载Catalog流程：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用户代码中调用</span>
<span class="n">Addressables</span><span class="p">.</span><span class="nf">InitializeAsync</span><span class="p">();</span>

<span class="c1">// 内部实际调用</span>
<span class="n">AddressablesImpl</span><span class="p">.</span><span class="nf">InitializeAsync</span><span class="p">()</span> <span class="err">→</span> <span class="n">ResourceManager</span><span class="p">.</span><span class="nf">StartOperation</span><span class="p">()</span>

<span class="c1">// 在 InitializeAsync 内部</span>
<span class="n">InitializationOperation</span> <span class="n">operation</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">InitializationOperation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="k">return</span> <span class="n">ResourceManager</span><span class="p">.</span><span class="nf">StartOperation</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="k">default</span><span class="p">);</span>

<span class="c1">// InitializationOperation 中</span>
<span class="c1">// 1. 首先加载主 Catalog 文件</span>
<span class="nf">LoadContentCatalogInternal</span><span class="p">(</span><span class="n">m_ResourceLocators</span><span class="p">,</span> <span class="n">s_Settings</span><span class="p">.</span><span class="n">catalogLocation</span><span class="p">,</span> <span class="p">...);</span>

<span class="c1">// 2. 然后加载额外的 Catalog 文件，包括远程的catalog(如果有配置)</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">catalogLocation</span> <span class="k">in</span> <span class="n">s_Settings</span><span class="p">.</span><span class="n">catalogLocations</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">LoadContentCatalogInternal</span><span class="p">(</span><span class="n">m_ResourceLocators</span><span class="p">,</span> <span class="n">catalogLocation</span><span class="p">,</span> <span class="p">...);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  当 Catalog 加载完成后，系统会解析其中的内容并构建 ResourceLocationMap：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在ContentCatalogProvider.cs 中</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ContentCatalogProvider</span> <span class="p">:</span> <span class="n">IResourceProvider</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnCatalogLoaded</span><span class="p">(</span><span class="n">ContentCatalogData</span> <span class="n">catalogData</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 创建 ResourceLocationMap</span>
        <span class="kt">var</span> <span class="n">locMap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ResourceLocationMap</span><span class="p">(</span><span class="n">catalogData</span><span class="p">);</span>
        
        <span class="c1">// 处理内部 ID 映射</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">kvp</span> <span class="k">in</span> <span class="n">catalogData</span><span class="p">.</span><span class="n">InternalIds</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 建立 key -&gt; location[]的映射</span>
            <span class="kt">string</span> <span class="n">key</span> <span class="p">=</span> <span class="n">kvp</span><span class="p">.</span><span class="n">Key</span><span class="p">;</span>
            <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">locations</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;();</span>
            
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">id</span> <span class="k">in</span> <span class="n">kvp</span><span class="p">.</span><span class="n">Value</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 为每个内部ID创建 ResourceLocation</span>
                <span class="kt">var</span> <span class="n">loc</span> <span class="p">=</span> <span class="nf">CreateLocationForCatalogEntry</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">catalogData</span><span class="p">);</span>
                <span class="n">locations</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">loc</span><span class="p">);</span>
            <span class="p">}</span>
            
            <span class="c1">// 将 locations 添加到 ResourceLocationMap 中</span>
            <span class="n">locMap</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">locations</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// 其他处理...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  <code class="language-plaintext highlighter-rouge">ResourceLocationMap</code>本质上是一个字典结构，它将用户可访问的键映射到对应的资源位置列表：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ResourceLocationMap 的简化结构</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ResourceLocationMap</span> <span class="p">:</span> <span class="n">IResourceLocator</span>
<span class="p">{</span>
    <span class="c1">// 核心数据结构：键 -&gt; 资源位置列表的映射</span>
    <span class="k">private</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;&gt;</span> <span class="n">m_Locations</span><span class="p">;</span>
    
    <span class="k">public</span> <span class="nf">ResourceLocationMap</span><span class="p">(</span><span class="n">ContentCatalogData</span> <span class="n">catalogData</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_Locations</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;&gt;();</span>
        <span class="c1">// 初始化其他元数据...</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">locations</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_Locations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="n">locations</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// IResourceLocator 接口实现</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Locate</span><span class="p">(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="n">Type</span> <span class="n">type</span><span class="p">,</span> <span class="k">out</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">locations</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_Locations</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="n">locations</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// 根据类型筛选位置...</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">locations</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  当所有 Catalog 都处理完成后，ResourceLocationMap 被注册到 Addressables 系统：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在初始化完成时</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">locator</span> <span class="k">in</span> <span class="n">m_ResourceLocators</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 将构建好的 ResourceLocationMap 注册到 ResourceManager</span>
    <span class="n">ResourceManager</span><span class="p">.</span><span class="nf">RegisterLocator</span><span class="p">(</span><span class="n">locator</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="加载远程catalog">加载远程Catalog</h2>

<p>  每次修改文件打包AssetBundle后Catalog是有差异的，为了得到最新AssetBundle就要先下载到最新的Catalog文件然后保存在本地Document目录。AA也提供加载指定地址的Catalog，可以是file:///，也可以是http(s)。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// remoteUrl -&gt; http://localhost:8000/</span>
<span class="n">AsyncOperationHandle</span><span class="p">&lt;</span><span class="n">IResourceLocator</span><span class="p">&gt;</span> <span class="n">remoteHandle</span> <span class="p">=</span> <span class="n">Addressables</span><span class="p">.</span><span class="nf">LoadContentCatalogAsync</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">remoteUrl</span><span class="p">}</span><span class="s">catalog.bundle"</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="k">yield</span> <span class="k">return</span> <span class="n">remoteHandle</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">remoteHandle</span><span class="p">.</span><span class="n">Status</span> <span class="p">!=</span> <span class="n">AsyncOperationStatus</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"InitRemoteLocation Error"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  本地模拟Server，把<code class="language-plaintext highlighter-rouge">Library/com.unity.addressables/aa/平台/</code>下面的Assetbundle和catalog复制到一个目录，在该目录打开cmd，输入python -m http.server 8000会模拟一个文件服务器。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/simulator_server.png" width="250" /><font size="2.5">
            <i>模拟文件服务器.</i>
        </font></center>
<p>  下载好之后就能获取到远程<code class="language-plaintext highlighter-rouge">ResourceLocationMap</code>。现在有了本地和远程Location信息，通过对比就能知道有哪些AssetBundle产生变化。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 缓存AssetBundle Location</span>
<span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_missingBundle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;();</span>
<span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_localBundle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;();</span>

<span class="k">private</span> <span class="n">IEnumerator</span> <span class="nf">CheckRemoteLocation</span><span class="p">(</span><span class="n">IResourceLocator</span> <span class="n">local</span><span class="p">,</span> <span class="n">IResourceLocator</span> <span class="n">remote</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="c1">// 检查本地资源在远程是否存在</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">key</span> <span class="k">in</span> <span class="n">remote</span><span class="p">.</span><span class="n">Keys</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 默认打包的AssetBundle文件后缀带了.bundle，如果修改AA代码就用自定义</span>
        <span class="c1">// 一定要增加一个标记，否则就不能区别bundle名和其他信息的描述名</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">key</span><span class="p">.</span><span class="nf">EndsWith</span><span class="p">(</span><span class="s">".bundle"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Type</span> <span class="n">iAbType</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IAssetBundleResource</span><span class="p">);</span>
        <span class="c1">// Locate定位remoteKey是否在local内，若有表示该AB文件没有差异不用更新</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">local</span><span class="p">.</span><span class="nf">Locate</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">iAbType</span><span class="p">,</span> <span class="k">out</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">localLocations</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// remoteKey不在local内，该AB有差异是最新的需要更新下载</span>
            <span class="n">remote</span><span class="p">.</span><span class="nf">Locate</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">iAbType</span><span class="p">,</span> <span class="k">out</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">remoteLocations</span><span class="p">);</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">remoteLoc</span> <span class="k">in</span> <span class="n">remoteLocations</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_missingBundle</span><span class="p">[</span><span class="n">remoteLoc</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">IResourceLocation</span> <span class="n">location</span> <span class="k">in</span> <span class="n">localLocations</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_localBundle</span><span class="p">[</span><span class="n">location</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新assetbundle">更新AssetBundle</h3>

<p>  现在拿到了<code class="language-plaintext highlighter-rouge">_missingBundle</code>和<code class="language-plaintext highlighter-rouge">_localBundle</code>，现在就要更新AssetBundle。更新AssetBundle就要获取它的最新地址，那么AA也提供了一个回调接口<code class="language-plaintext highlighter-rouge">Addressables.InternalIdTransformFunc</code>，只要注册了该回调，任何加载动作都会进入到该回调，就可以在回调里面进行处理。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Addressables</span><span class="p">.</span><span class="n">InternalIdTransformFunc</span> <span class="p">=</span> <span class="n">InternalIdTransformFunc</span><span class="p">;</span>

<span class="kt">string</span> <span class="nf">InternalIdTransformFunc</span><span class="p">(</span><span class="n">IResourceLocation</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_missingBundle</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">$"</span><span class="p">{</span><span class="n">remoteUrl</span><span class="p">}{</span><span class="n">arg</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_localBundle</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">arg</span><span class="p">.</span><span class="n">InternalId</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">arg</span><span class="p">.</span><span class="n">InternalId</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">IResourceLocation</code>有三个关键信息：<code class="language-plaintext highlighter-rouge">PrimaryKey</code>、<code class="language-plaintext highlighter-rouge">InternalId</code>、<code class="language-plaintext highlighter-rouge">ResourceType</code></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 资源加载名的主要标识符</span>
<span class="k">public</span> <span class="kt">object</span> <span class="n">PrimaryKey</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 资源加载地址</span>
<span class="k">public</span> <span class="kt">string</span> <span class="n">InternalId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 资源加载类型，重点处理IAssetBundleResource、catalog类型</span>
<span class="k">public</span> <span class="n">Type</span> <span class="n">ResourceType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>先处理如何下载、加载最新的catalog
  不管是Initial本地Catalog还是Load远程Catalog，只要注册<code class="language-plaintext highlighter-rouge">InternalIdTransformFunc</code>就可以在函数内处理：
    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="nf">InternalIdTransformFunc</span><span class="p">(</span><span class="n">IResourceLocation</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
 <span class="c1">// 如果argResourceType是catalog类型</span>
     <span class="c1">// 判定本地缓存目录是否有Catalog.bundle，计算bundle的hash是否与catalog.hash一致</span>
         <span class="c1">// 如果一致就加载，直接返回$"{缓存目录}/Catalog.bundle"</span>
         <span class="c1">// 如果没有Catalog.bundle就用包体内的Catalog直接返回arg.InternalId</span>

 <span class="c1">// 如果argResourceType是IAssetBundleResource类型</span>
     <span class="c1">// 判定缓存目录有该文件</span>
     <span class="c1">// 有，直接返回$"{缓存目录}/xxx.bundle"</span>
     <span class="c1">// 没有，直接返回$"{remoteUrl}/xxx.bundle"去下载</span>
 <span class="c1">// 只要能确保Catalog是最新，下载的AssetBundle文件是一定是最新的</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="复杂的更新策略">复杂的更新策略</h2>
<p>  上面我是演示用了一种最简单的更新策略，肯定是不能满足复杂需求的。如果设定Group打包使用hash of file name，也就是确保构建时每个AssetBundle名不变，文件内容hash会发生了变化。那么就要维护一份bundle名映射hash表，一个本地一个远程，每次启动就要检查两张表是否一致、是否有变化，同时检查缓存的最新文件有没有丢失。当然也还有其他的策略就不讨论了。</p>

<h2 id="踩坑">踩坑</h2>
<p>  1. 不能同时存在多个Catalog对象，就是InstantiateAsync了本地Catalog后获取了Result后最好是立即释放掉</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">localLocator</span> <span class="p">=</span> <span class="n">localHandle</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
<span class="n">Addressables</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="n">localHandle</span><span class="p">);</span>
<span class="n">Addressables</span><span class="p">.</span><span class="nf">RemoveResourceLocator</span><span class="p">(</span><span class="n">localLocator</span><span class="p">);</span>
</code></pre></div></div>
<p>  2. <code class="language-plaintext highlighter-rouge">Addressables.ClearResourceLocators()</code>不能随便调用，会丢弃所有Catalog对象。</p>

<p>  3. 游戏重启，如果是在游戏内重启就不能再次初始化<code class="language-plaintext highlighter-rouge">InstantiateAsync</code>了，内部标记了<code class="language-plaintext highlighter-rouge">hasStartedInitialization</code>。</p>]]></content><author><name>编程散记</name></author><category term="Unity3d" /><category term="Addressable System" /><summary type="html"><![CDATA[使用Unity Addressable System进行热更、加载AB包，本文Addressable后续简称AA。]]></summary></entry><entry><title type="html">Unity Addressable System使用分析(二)</title><link href="https://www.damonc.top/unity3d/Unity_Addressabel_Group.html" rel="alternate" type="text/html" title="Unity Addressable System使用分析(二)" /><published>2024-07-12T20:00:00+00:00</published><updated>2024-07-12T20:00:00+00:00</updated><id>https://www.damonc.top/unity3d/Unity_Addressabel_Group</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Addressabel_Group.html"><![CDATA[<h2 id="构建前置准备">构建前置准备</h2>

<p>  AA打包提供了自带脚本<strong><em>BuildScriptPackedMode</em></strong>打包入口有两个：</p>
<ol>
  <li>不带打包结果返回：AddressableAssetSettings.BuildPlayerContent();</li>
  <li>带打包结果的接口：AddressableAssetSettings.BuildPlayerContent(<code class="language-plaintext highlighter-rouge">out AddressablesPlayerBuildResult rst</code>);</li>
</ol>

<h3 id="开始构建">开始构建</h3>

<p>  AddressablesPlayerBuildResult主要记录了打包成功后获取到bundle列表信息，每份bundle都有生成，类似于以前的AssetBundle Menifest结构。这个结果可以序列化保存在本地，方便查看调试各资源之间依赖情况。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> AddressablesPlayerBuildResult结构 </div> </div> <div class="content"> 
<pre><code class="language-CSHARP">//bundle构建后的信息
class BundleBuildResult{
 public string FilePath;
 public string InternalBundleName;
 public AddressableAssetGroup SourceAssetGroup;
 public uint Crc;
 public string Hash;
}
public List&lt;BundleBuildResult&gt; AssetBundleBuildResults =&gt; m_AssetBundleBuildResults;
//catalog hash的路径
public string RemoteCatalogHashFilePath { get; internal set; }
//catalog json的路径
public string RemoteCatalogJsonFilePath { get; internal set; }
//content state的路径
public string ContentStateFilePath { get; internal set; }
</code></pre>



 </div> </div>
<p>  进入到<strong><em>BuildPlayerContent</em></strong>函数，最主要工作之一是对所有Group内的所有Entry资源在打包之前把<code class="language-plaintext highlighter-rouge">BundleFileId</code>置空，这个字段在编辑器打包时有用到。该变量值在打包时多次使用，非常重要！
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/bundle_field_id.png" width="250" /><font size="2.5">
            <i>Debug模式查看到BundleFileId.</i>
        </font></center>
<p>  进入到<strong><em>BuildPlayerContentImpl</em></strong>函数，主要做了三块工作。</p>
<ol>
  <li>检查Addressables BuildPath目录，存在就清空该目录。<code class="language-plaintext highlighter-rouge">BuildPath</code>就是构建bundle的存放目录，这里有一个<code class="language-plaintext highlighter-rouge">清空该目录</code>的操作。</li>
  <li>实例化<code class="language-plaintext highlighter-rouge">AddressablesDataBuilderInput</code>对象，该对象内部初始化：指定构建平台、构建版本号、FileRegistry容器、PreviousContentState置空。</li>
  <li>使用指定的<code class="language-plaintext highlighter-rouge">ActivePlayerDataBuilder</code>构建对象开始构建bundle。</li>
</ol>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 清空目录如何做到增量打包？ </div> </div> <div class="content"> <p>  对于之前使用<strong><em>BuildPipeline.BuildAssetBundles</em></strong>接口打包，默认自带增量打包参数，除非使用ForceRebuildAssetBundle参数指定。</p>

<p>  以前的增量打包的所需条件：</p>

<p>  <strong>(1)</strong>资源没变化且生成目录下的bundle包和对应manifest存在，不会重新打包；</p>

<p>  <strong>(2)</strong>资源没变化即使生成目录下的bundle包被删除了，不会重新打包；</p>

<p>  <strong>(3)</strong>只要生成目录下的bundle包对应的manifase被删除了，会重新打包；</p>

<p>  而现在即使删除了Bundle存放目录，对于增量打包的使用addressables_content_state文件和BuildCache信息组合判断。</p>



 </div> </div>
<p>  <code class="language-plaintext highlighter-rouge">ActivePlayerDataBuilder</code>分析：该对象一定要继承自BuildScriptBase。一定要放在Data Builders列表。一定要给ActivePlayerDataBuilderIndex赋值，或者在Settings的Data Builders列表放在第一位，读取ActivePlayerDataBuilderIndex优先级是高于列表顺序。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/build_play_scripts.png" width="250" /><font size="2.5">
            <i>Data Builders列表就是这个Scripts列表.</i>
        </font></center>

<p>  <code class="language-plaintext highlighter-rouge">FileRegistry</code>分析：文件注册表的作用在构建Bundle期间保存创建Bundle时的存放路径(带hash信息)，然后在Bundle构建的后处理使用ReplaceBundleEntry，使用无hash的路径替换带hash路径。暂时不重要。</p>

<p>  <code class="language-plaintext highlighter-rouge">AddressablesContentState</code>结构与<code class="language-plaintext highlighter-rouge">BundleFileId</code>分析：AddressablesContentState保存了当次构建时所有的Asset缓存信息和Bundle信息，以便在下次构建bundle时读取这些缓存信息。BundleFileId就包含在这些缓存信息内。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AddressablesContentState</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">playerVersion</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">editorVersion</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">CachedAssetState</span><span class="p">[]</span> <span class="n">cachedInfos</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">remoteCatalogLoadPath</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">CachedBundleState</span><span class="p">[]</span> <span class="n">cachedBundles</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CachedAssetState</span> <span class="p">:</span> <span class="n">IEquatable</span><span class="p">&lt;</span><span class="n">CachedAssetState</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">AssetState</span> <span class="n">asset</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">AssetState</span><span class="p">[]</span> <span class="n">dependencies</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">groupGuid</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">bundleFileId</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">CachedAssetState</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CachedBundleState</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">bundleFileId</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="初始化icontextobject">初始化IContextObject</h3>

<p>  进入<strong><em>BuildDataImplementation</em></strong>内，会继续初始化一些数据：调用场景保存(使用SBP管线构建Bundle前一定要保存场景)、初始化AddressableAssetsBuildContext对象、处理所有Group对象。这里有两个重要的数据结构：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ResourceManagerRuntimeData</code>：用于初始化AA的运行时数据，包含许多AA设置时的参数，每次构建都会重新生成。</li>
  <li><code class="language-plaintext highlighter-rouge">AddressableAssetsBuildContext</code>：用于构建过程中数据传递，在后面的Task流的会多次用到IContextObject或IAddressableAssetsBuildContext接口数据。</li>
</ol>

<p><span id="jump1"></span></p>

<h3 id="处理group">处理Group</h3>

<p>  对每个Group的Schema进行预处理，对Group内所有AssetEntry生成一份<code class="language-plaintext highlighter-rouge">ContentCatalogDataEntry</code>运行时寻址数据信息。</p>

<p>  <strong>(1)PlayerDataGroupSchema</strong>分别有场景内的资源和Resource目录内的资源。把该Schema内所有的AssetEntry执行GatherAllAssets：收集该Schema内所有资源(包括subAsset、sprite精灵)装入AddressableAssetEntry收集列表。遍历收集列表执行CreateCatalogEntries创建<code class="language-plaintext highlighter-rouge">ContentCatalogDataEntry</code>数据(IResourceLocation寻址数据，在运行时初始化AA和加载Catalog这一数据非常重要)。</p>

<p>  <strong>(2)BundledAssetGroupSchema</strong>构建bundle配置和包含在Entries列表里的资源，根据BundlePackingMode生成预定义Bundle名，三者的区别是寻址路径参数不一样，<strong>Bundle命名格式</strong>：<code class="language-plaintext highlighter-rouge">groupGuid + _assets_ + address + .bundle</code>。重点说一下PackTogetherByLabel，根据AssetEntry对象内的标签生成Bundle名，选择这个模式命名Bundle，没有特殊需求一般每个Asset只需要一个标签即可，这样一个标签对应多个资源就可以打成一个Bundle。三种模式都会生成一份AssetBundleBuild[]打包数据，然后把该份数据每个BundleName执行ReHash替换(这一步可以定制bundle name)。</p>

<h2 id="开始打包">开始打包</h2>

<p>  实例化ExtractDataTask对象，实例化AddressableAssetsBundleBuildParameters对象，初始化buildTasks，调用SBP管线ContentPipeline.BuildAssetBundles接口开始打包。</p>

<h3 id="contentpipeline">ContentPipeline</h3>

<p>  ContentPipeline是SBP打包管线入口的静态类。在调用BuildAssetBundles后进行了一系列的安全检查；把IBuildTask需要的数据装入BuildContext对象的m_ContextObjects字典；在执行RunTask之前先通过Inject函数操作Task成员变量的FieldInfo，再从BuildContext的m_ContextObjects根据成员变量类型取出Value并写入Field；执行Task Running操作；然后再把Task执行后更新的成员变量数据取出装入BuildContext值。</p>

<h2 id="task管线">Task管线</h2>

<p>  每个Task内的成员变量用属性标记，ContextUsage.In是从BuildContext取出，ContextUsage.InOut是输入输出双向，ContextUsage.Out输出。</p>

<h3 id="switchtobuildplatform">SwitchToBuildPlatform</h3>

<p>  切换到指定的打包平台(如果当前平台不是目标平台触发切换基本要好几十分钟吧).</p>

<h3 id="rebuildspriteatlascache">RebuildSpriteAtlasCache</h3>

<p>  触发所有Sprite Atlas Packing操作，生成所有精灵图集的缓存数据。</p>

<h3 id="buildplayerscripts">BuildPlayerScripts</h3>

<p>  触发所有脚本编译。</p>

<h3 id="postscriptscallback">PostScriptsCallback</h3>

<p>  编译脚本时的回调，要用到这个回调需要给ContentPipeline.BuildCallbacks注册。</p>

<h3 id="calculatescenedependencydata">CalculateSceneDependencyData</h3>

<p>  收集Scene的依赖资源信息。</p>

<h3 id="calculateassetdependencydata">CalculateAssetDependencyData</h3>

<p>  收集资源的依赖信息，有三个最重要的输出数据收集<code class="language-plaintext highlighter-rouge">IBuildResults、IBuildSpriteData、IBuildExtendedAssetData</code>传递给下一个Task，这里有许多Unity内部代码现在看不到，用这三个结果数据倒推这个收集流程，先看看这三个数据结构。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IBuildResults</span> <span class="p">:</span> <span class="n">IContextObject</span>
<span class="p">{</span>
    <span class="n">ScriptCompilationResult</span> <span class="n">ScriptResults</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">WriteResult</span><span class="p">&gt;</span> <span class="n">WriteResults</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">SerializedFileMetaData</span><span class="p">&gt;</span> <span class="n">WriteResultsMetaData</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">GUID</span><span class="p">,</span> <span class="n">AssetResultData</span><span class="p">&gt;</span> <span class="n">AssetResults</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">WriteResult</span><span class="p">{...}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SerializedFileMetaData</span><span class="p">{...}</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">AssetResultData</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GUID</span> <span class="n">Guid</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Hash128</span> <span class="n">Hash</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectIdentifier</span><span class="p">&gt;</span> <span class="n">IncludedObjects</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectIdentifier</span><span class="p">&gt;</span> <span class="n">ReferencedObjects</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">ObjectIdentifier</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Type</span><span class="p">[</span><span class="k">]&gt;</span> <span class="n">ObjectTypes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IBuildSpriteData</span> <span class="p">:</span> <span class="n">IContextObject</span>
<span class="p">{</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">GUID</span><span class="p">,</span> <span class="n">SpriteImporterData</span><span class="p">&gt;</span> <span class="n">ImporterData</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IBuildExtendedAssetData</span> <span class="p">:</span> <span class="n">IContextObject</span>
<span class="p">{</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">GUID</span><span class="p">,</span> <span class="n">ExtendedAssetData</span><span class="p">&gt;</span> <span class="n">ExtendedData</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>(1) 依赖数据新旧对比</strong>，先用TaskOutput的临时结构AssetOutput保存，AssetOutput包含有上述最重要三个数据。通过BuildCache接口根据Asset GUID获取资产信息，这里的缓存都是从Library下的BuildCache读取，若没有缓存会跳过后续的更新缓存数据操作，然后生成缓存保存；若有上次打包的缓存数据，则检查Sprite与Atlas的关联数据在这次打包前是否发生变化，把缓存中有过时的数据需要重新生成数据替换。</p>

<p><strong>(2) 依赖数据收集</strong>，(可跳过不阅读)，具体流程<strong>1)</strong>遍历每个Asset GUID获取Cache Info，如果Data[2]类型是Sprite就加入packedSprites表；<strong>2)</strong>获取该Asset CacheInfo Data[4]类型表并遍历，若是Spirte进入GetPlayerDependenciesForAsset检查其依赖；<strong>3)</strong>遍历所有includedObjects对象并使用ContentBuildInterface.GetPlayerDependenciesForObjects获取该对象的所有依赖，跳过input自身把其他依赖加入otherReferencedAssetObjectsHashSet表；<strong>4)</strong>使用objectLookingAt栈对收集到的依赖对象再次遍历查找，a.对于不是input自身且没有在explicitAssets表内就加入encounteredExplicitAssetDependencies，若是非打包精灵加入mainRepresentationNeeded，b.对于未处理过的隐式资源，更新或创建implicitOutput，查找缓存依赖，将新发现的依赖压入objectLookingAt栈中继续遍历；<strong>5)</strong>最后再执行合并collectedImmediateReferences表和mainRepresentationNeeded表返回最终的依赖信息。</p>

<p><strong>(3) 收集IBuildResults、IBuildSpriteData、IBuildExtendedAssetData</strong>，非Sprite资源走ProcessAsset处理，使用GetPlayerObjectIdentifiersInAsset获取includedObjects ID表，继续使用GetPlayerDependenciesForAsset收集依赖，然后收集资源的表示装入ExtendedAssetData，然后将依赖项扩展为显式资产。最后将assetOutput.asset装入各自的数据结构中。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">internal</span> <span class="k">struct</span> <span class="nc">AssetOutput</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GUID</span> <span class="n">asset</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Hash128</span> <span class="n">Hash</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">AssetLoadInfo</span> <span class="n">assetInfo</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectDependencyInfo</span><span class="p">&gt;</span> <span class="n">objectDependencyInfo</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">BuildUsageTagSet</span> <span class="n">usageTags</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">SpriteImporterData</span> <span class="n">spriteData</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">ExtendedAssetData</span> <span class="n">extendedData</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectTypes</span><span class="p">&gt;</span> <span class="n">objectTypes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CachedInfo</span> <span class="p">:</span> <span class="n">ICachedData</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">CacheEntry</span> <span class="n">Asset</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">CacheEntry</span><span class="p">[]</span> <span class="n">Dependencies</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="cm">/*
    [0]AssetLoadInfo
    [1]BuildUsageTagSet
    [2]SpriteImporterData
    [3]ExtendedAssetData
    [4]List&lt;ObjectTypes&gt;
    [5]List&lt;ObjectDependencyInfo&gt;
    */</span>
    <span class="k">public</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">Data</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="addhashtobundlenametask">AddHashToBundleNameTask</h3>

<p>  如果使用了UniqueBundleIds定义Bundle唯一的标识符，</p>

<h3 id="stripunusedspritesources">StripUnusedSpriteSources</h3>

<p>  剥离未使用的Spirite，从依赖分析的Task获取的IBuildSpriteData数据进行遍历，在m_DependencyData没有用到的Sprite统统剥离，并从IBuildExtendedAssetData的ExtendedData内删除。</p>

<h3 id="generatebundlepacking">GenerateBundlePacking</h3>

<p>  处理资源包打包生成内部文件名、收集资源的对象标识符、过滤和处理资源引用、记录资源到文件的映射，过滤逻辑移除默认资源引用、处理资源间的循环引用、去除重复或不必要的引用</p>

<h3 id="updatebundleobjectlayout">UpdateBundleObjectLayout</h3>

<p>  更新bundle的组织结构，最开始的数据是从ContentPipeline.BuildAssetBundles打包接口参数BundleBuildContent(m_AllBundleInputDefs)对象生成，通过Bundle Packing更新依赖数据后，这块的bundle内部结构数据也要更新。</p>

<h3 id="generatebundlecommands">GenerateBundleCommands</h3>

<p>  为资源和场景生成打包命令，处理自定义资源、遍历资源包布局，根据资源类型创建不同的命令：</p>
<ol>
  <li>资源包命令 (CreateAssetBundleCommand)：创建写入命令、创建使用的列表集、创建引用映射、处理依赖哈希并排序、生成资源包写入操作。</li>
  <li>场景包命令 (CreateSceneBundleCommand)：获取场景文件对象、创建写入命令、处理预加载对象、生成场景加载信息、创建场景包写入操作。</li>
  <li>场景数据命令 (CreateSceneDataCommand)：类似场景包命令、专门处理额外的场景数据。</li>
</ol>

<h3 id="generatesubassetpathmaps">GenerateSubAssetPathMaps</h3>

<p>  创建子资源的加载信息，资源包写入操作集转为internalName与Value的字典映射，遍历ExtendedData的guid数据，通过AssetToFiles取出主资源，通过主资源获取当前guid的info，根据info和资源表示形式CreateSubAssetLoadInfo，然后插入到主资源info的BundleAssets。</p>

<h3 id="generatebundlemaps">GenerateBundleMaps</h3>

<p>  对AssetBundle生成依赖映射和使用集合，BuildReferenceMap详细说明源包中的对象所依赖的其他包中存在哪些对象（前向依赖项）；BuildUsageTagSet 详细说明了源包中的对象需要写入的条件数据，该数据由其他包中的对象使用（反向依赖）。</p>

<h3 id="writeserializedfiles">WriteSerializedFiles</h3>

<p>  把资源包数据分段写入AssetBundle。通过TaskCachingUtility.RunCachedOperation注册本地回调函数分布操作写入：获取缓存、处理未缓存文件hash写入SerializedFileMetaData、保存MetaData数据与WriteResult数据。</p>

<h3 id="archiveandcompressbundles">ArchiveAndCompressBundles</h3>

<p>  压缩写入资源包，创建ArchiveWorkItem集、执行压缩Item的ResourceFiles所有文件并返回crc。</p>

<h3 id="generatelocationliststask">GenerateLocationListsTask</h3>

<p>  创建寻址资产的位置列表，用于描述资源在最终构建包中的位置和加载方式。每个位置列表条目包含以下信息：资源类型、加载路径、提供程序、其他元数据。</p>

<h2 id="打包后处理">打包后处理</h2>

<p>  遍历ContentCatalogDataEntry集合生成主键映射、Bundle ReName、Catalog ReMap、创建Catalog File、保存ContentState。</p>

<h3 id="bundle后处理">Bundle后处理</h3>

<p>  这一步在Bundle压缩写入后。创建下载信息AssetBundleRequestOptions是提供给AssetBundleProvider下载时使用。根据BundleNaming模式重构AssetBundleName，重构命名这一步会影响bundle命名格式，尤其会破坏<a href="#jump1"><code class="language-plaintext highlighter-rouge">1.3处理Group</code></a>这一步的预命名。</p>]]></content><author><name>编程散记</name></author><category term="Unity3d" /><category term="Addressable System" /><summary type="html"><![CDATA[总结在使用Unity Addressable System过程中遇到的一部分问题，该篇主要记录Addressable打AB包、加载AB包，本文Addressable后续简称AA。]]></summary></entry><entry><title type="html">Unity Addressable System使用分析(一)</title><link href="https://www.damonc.top/unity3d/Unity_Addressable_Editor.html" rel="alternate" type="text/html" title="Unity Addressable System使用分析(一)" /><published>2024-07-10T20:00:00+00:00</published><updated>2024-07-10T20:00:00+00:00</updated><id>https://www.damonc.top/unity3d/Unity_Addressable_Editor</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Addressable_Editor.html"><![CDATA[<h2 id="addressable安装">Addressable安装</h2>
<p>  总结在使用Unity Addressable System过程中遇到的一部分问题，该篇主要记录Addressable在Unity编辑器的各种组织结构，本文Addressable后续简称AA，基于1.21.19版本。</p>

<h3 id="package安装">Package安装</h3>
<p>  打开Unity Window - Package Manger，找到Addressable安装找一个合适的版本：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/addressable_win_pkg_mgr.png" width="250" /><font size="2.5">
            <i>Addressable Version Seleclt.</i>
        </font></center>

<h3 id="手动安装">手动安装</h3>
<p>  在Package Manager选择一个合适的Addressable版本还要结合Addressable更新log，打开<a href="https：//docs.unity3d.com/Packages/com.unity.addressables@1.21/changelog/CHANGELOG.html"><code class="language-plaintext highlighter-rouge">Addressable更新日志</code></a>，版本列表展示了Address able对应的Unity版本：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/addressable_version.png" width="250" /><font size="2.5">
            <i>Addressable Version List.</i>
        </font></center>
<p>  Unity这里分了两个分支维护Addressable，其中一个分支是1.21版本对应的Unity版本是2019+，另一个分支是2.0版本对应的Unity版本是2023+：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/addressable_1_21.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/addressable_2_0.png" width="250" /><font size="2.5">
            <i>Addressable Branch.</i>
        </font></center>

<p>  2.0以上版本也可以用在非2023版的引擎，主要还是针对2023+ Unity引擎支持新的API什么的。如果想把2.0版本合到1.21，开一Beyond Compare合并差异也行。打开<a href="https：//packages.unity.com/com.unity.addressables"><code class="language-plaintext highlighter-rouge">Addressable Package Json</code></a>，这里列明了每一个Addressable版本对应的Unity版本，结合<a href="https：//docs.unity3d.com/Packages/com.unity.addressables@1.21/changelog/CHANGELOG.html"><code class="language-plaintext highlighter-rouge">Addressable更新日志</code></a>找到一个Bug最少又符合对Unity版本要求的Addressable版本。找到合适的Addressable版本后，打开Packages/manifest.json，手动新增包”com.unity.addressables”:”1.21.19”。</p>

<h3 id="安装addressable依赖">安装Addressable依赖</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/addressable_deps.png" width="250" /><font size="2.5">
            <i>Addressable Dependencies.</i>
        </font></center>
<p>  Addressable最重要的依赖是ScriptableBuildPipeline，SBP这个包要更新到1.21.23或2.1.x以上，旧版SBP对SpriteAtlas图集打包会有冗余。打开Packages/manifest.json，强制指定SBP版本”com.unity.scriptablebuildpipeline”:”1.21.23”,
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/sbp_upgrade.png" width="250" /><font size="2.5">
            <i>SBP指定版本.</i>
        </font></center>

<h3 id="addressable结构预览">Addressable结构预览</h3>
<p>  安装好了AA之后，会在Assets生成以下目录：</p>

<table>
  <tbody>
    <tr>
      <td>目录</td>
      <td>说明</td>
    </tr>
    <tr>
      <td>AddressableAssetsData</td>
      <td>根目录也包含几个重要文件</td>
    </tr>
    <tr>
      <td>##Platform</td>
      <td>根据当前平台构建一次AB包后生成的目录</td>
    </tr>
    <tr>
      <td>AssetGroups</td>
      <td>给某资源设置寻址地址并指定Group后的Group描述文件</td>
    </tr>
    <tr>
      <td>Schemas</td>
      <td>Group组的配置包含逻辑结构和特性描述文件</td>
    </tr>
    <tr>
      <td>AssetGroupTemplates</td>
      <td>生成Group的模版描述文件</td>
    </tr>
    <tr>
      <td>DataBuilders</td>
      <td>自定义AssetBundle打包脚本目录</td>
    </tr>
  </tbody>
</table>

<h2 id="addressable各项配置">Addressable各项配置</h2>

<h3 id="addressableassetsettings">AddressableAssetSettings</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/addressable_assets_settings.png" width="250" /><font size="2.5">
            <i>AddressableAssetSettings预览.</i>
        </font></center>
<p>  AA的全局配置文件，涉及一些打包配置、热更配置、下载配置等等，下面是每项参数配置说明。</p>

<h3 id="profile">Profile</h3>

<p>  <strong>Profile</strong>主要作用是指定打包地址和加载地址，这里可以配置新增打包Ab的保存目录和HotUpdate热更资源目录的指定路径，建议自定义路径。</p>

<p>  这两个参数的使用地方在不同的AA版本有一点差别：1.20以前的版本在Content Update有用到，1.20以后的版本在Catalog有使用。见<a href="#jump1"><code class="language-plaintext highlighter-rouge">Catalog</code></a>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/profile_in_use.png" width="250" /><font size="2.5">
            <i>Profile预览.</i>
        </font></center>
<p>Profile In Use可以选择系统自带或自定义，其中自定义使用Manager按钮打开Profile Window，点击Create按钮新增变量等参数。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/profile_window.png" width="250" /><font size="2.5">
            <i>Profile Window.</i>
        </font></center>

<p><span id="jump1"></span></p>

<h3 id="catalog">Catalog</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/catalog_attribute.png" width="250" /><font size="2.5">
            <i>Catalog设置面板.</i>
        </font></center>
<p>  Catalog类似于根bundle，记录了当前构建bundle时的依赖和AA的各项设置。</p>
<ul>
  <li><strong>(1) Player Version Override</strong>： 这个参数会对构建好的catalog进行重命名，unity使用时间戳，我们自己可以用自己的构建版本号，格式可以是catalog_1.2.1720684396.json。</li>
  <li><strong>(2) Compress Local Catalog</strong>： 启用会将Catalog.json压缩成Catalog.bundle，显著减少文件size。</li>
  <li><strong>(3) Build Remote Catalog</strong>： 要热更Catalog就要启用。</li>
  <li><strong>(4) Build Path</strong>： 构建Assetbundle的保存地址。</li>
  <li><strong>(5) Load Path</strong>： 加载AssetBundle的地址，这里我是在Profiles设置成了相对地址，然后在加载脚本回调地址逻辑完成后组装完整的加载地址。</li>
  <li><strong>(6) Only Update catalogs manually</strong>： 手动控制更新Catalog时机和方式。</li>
</ul>

<h3 id="update-a-previous-build">Update a Previous Build</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/update_download.png" width="250" /><font size="2.5">
            <i>Update Downloads设置.</i>
        </font></center>

<ul>
  <li><strong>(1) Check for Update Issues</strong>：官方推荐使用List Restricted Assets，在更新过程中对使用了限制更新的Group有限制。</li>
  <li><strong>(2) Content State Build Path</strong>：指定addressables_content_state.bin的保存地址。</li>
</ul>

<p>  该content_state文件只在本地构建时读取进行增量打包，可以看看<a href="https：//docs.unity3d.com/Packages/com.unity.addressables@2.2/manual/content-update-builds-overview.html"><code class="language-plaintext highlighter-rouge">官方workflow</code></a>。简化描述就是要构建更新的AssetBundle，请运行Update a Previous Build脚本。此工具还使用到<code class="language-plaintext highlighter-rouge">addressables_content_state.bin</code>文件，它会重新构建所有内容并会生成到一个修改过的目录，该目录可以访问原始AssetBundle中未更改的内容以及新AssetBundle中更改过的内容。通过打开Groups面板Tools选项Check Content Update Restrictions窗口，只要Group内某个资源有修改，就会出现在这个列表中。但是如果玩家本地用户目录的bundle不小心损坏了或者需要回退资源版本，直接使用Unity这个方案就不好办。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/modify_update_remote.png" width="250" /><font size="2.5">
            <i>修改过的group列表.</i>
        </font></center>

<p>  由于我开了手动更新Catalog，同时自己维护了一套完整的更新列表，就禁用了这条属性。</p>

<h3 id="downloads">Downloads</h3>
<p>  自定义证书、下载并发数量、超时等设置</p>
<ul>
  <li><strong>(1) Custom certificate handler</strong>：自定义证书类要实现CertificateHandler。</li>
  <li><strong>(2) Max Concurrent Web Requests</strong>：设置Web并发下载数量官方建议2-4个。</li>
  <li><strong>(3) Catalog Download Timeout</strong>：超时设置。</li>
</ul>

<h3 id="builds">Builds</h3>

<p>  构建AB包的一些设置
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/setting_build.png" width="250" /><font size="2.5">
            <i>Build设置.</i>
        </font></center>
<ul>
  <li><strong>(1) Build Addressables on Player Build</strong>： 打APK的时候一起先打Assetbundle在打APK，这里我关了不需要，一般是单独出Bundle资源的。</li>
  <li><strong>(2) Ignore Invalid/Unsupported Files in Build</strong>： 构建时排除无效文件，如果未启用可能导致中断构建。</li>
  <li><strong>(3) Unique Bundle IDs</strong>： 指定每个Assetbundle生成唯一标识符。</li>
  <li><strong>(4) Contiguous Bundles</strong>： 定义的Assetbundle内容布局。</li>
  <li><strong>(5) Non-Recursive Dependency Calculation</strong>： 循环依赖计算耗费时间，开启只计算直接依赖。(某些情况下所有设置都正确却无法加载Bundle，一般是Group内的资源依赖有问题。)</li>
  <li><strong>(6) Strip Unity Version From AssetBundles</strong>： 裁剪Assetbundle内的unity版本号，启用。</li>
  <li><strong>(7) Disable Visible Sub Asset Representations</strong>： 不直接拖拽引用某个sprite，开启该项可以加快构建时间。</li>
</ul>

<h3 id="build-and-play-mode-scripts">Build And Play Mode Scripts</h3>

<p>  构建AB的一些脚本配置，可以实现IDataBuilder接口自定义打包流程。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/build_play_scripts.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/play_mode.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/build_mode.png" width="250" /><font size="2.5">
            <i>Build Bundle设置.</i>
        </font></center>
<p>  Play mode指定在编辑器是怎么加载资源，本地测试用</p>
<ul>
  <li><strong>(1) Fast Mode</strong>： 不打包直接加载文件，速度快但在Profiler中提供的信息较少</li>
  <li><strong>(2) Virtual Mode</strong>： 虚拟环境模拟类似于AssetBundle的行为，无需打包</li>
  <li><strong>(3) Packed Mode</strong>： 从实际的AssetBundle中加载资源，真实环境</li>
</ul>

<h2 id="addressablegroups分析">AddressableGroups分析</h2>

<h3 id="group配置">Group配置</h3>

<p>  AssetGroups是Addressable组织bundle的一种容器，必须要把资源加入Group才能参与打包。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/group_view.png" width="250" /><font size="2.5">
            <i>Group设置.</i>
        </font></center>

<ul>
  <li><strong>(1) Buildin&amp;Load Path</strong>：选择Local或Remote，一般选RemotRemotee以支持热更，基本上所有资源都可能会热更。</li>
  <li><strong>(2) AB Compression</strong>：指定AB包用哪种压缩算法：不压缩、LZ4、LZMA。</li>
  <li><strong>(3) Include In Build</strong>： 启用才能构建该组内所包含的Asset Entry。</li>
  <li><strong>(4) Force Unique Provider</strong>：是否指定唯一的Group加载实例，如果Group有上百个就不要勾选了。</li>
  <li><strong>(5) Use AB Cache</strong>：从远程下载的AB是否使用AA的缓存机制。(这个缓存包括AB资源和当前更新时的AA版本信息)</li>
  <li><strong>(6) Use UnityWebRequest for Local Asset Bundles</strong>：对于本地的AB资源是否使用UnityWebRequestAssetBundle GetAssetBundle加载，还是使用AssetBundle LoadFromFileAsync加载。</li>
  <li><strong>(7) Request Timeout</strong>：设置下载超时。</li>
  <li><strong>(8) Use Http Chunked Transfer</strong>：开启分块传输。</li>
  <li><strong>(9) Http Redirect Limit</strong>：设置重定向次数。</li>
  <li><strong>(9) Retry Count</strong>：设置下载失败重试次数。</li>
  <li><strong>(10) Include Addresses in Catalog</strong>： 禁用后构建bundle时不会包含在catalog.json。</li>
  <li><strong>(11) Include GUIDs in Catalog</strong>： 使用AssetReference拖拽引用就得启用。</li>
  <li><strong>(12) Include Labels in Catalog</strong>： 不通过label标签加载资源，我这里不使用label去加载资源。</li>
  <li><strong>(13) Internal Asset Naming Mode</strong>：AB包内资源的ID标识方式，有三种：Full Path(资源全路径)、Filename(资源名)、GUID(unity导入时设置的ID)、Dynamic(官方推荐使用)。这个模式影响Ab的CRC和HASH，设置该模式中任意一种也不会影响我们从AB包内读取某个资源。</li>
  <li><strong>(14) Cache Clear Behavior</strong>：设置APK包内缓存AA下载的AB资源时长，到期自动清除。</li>
  <li><strong>(15) Bundle Mode</strong>：构建AB的模式，有三种：Group内所有资源打成一个AB、Group内资源分别单独打成AB、根据组内标签打包。</li>
  <li><strong>(16) Bundle Naming Mode</strong>：设置AB名，有三种：Group名、 Group名追加HASH、使用Bundle的HASH(推荐-但要做组名与HASH之间的映射，加载Bundle先拿到组名映射的HASH去找Bundle加载)、使用Group组名的字符HASH。</li>
  <li><strong>(17) Asset Load Mode</strong>：资源加载模式，有两种：从bundle请求加载的资源及其依赖一起加载、bundle内所有的资源全部加载。</li>
  <li><strong>(18) Asset Provider</strong>：从Bundle内加载Asset，官方推荐使用自带的Asset from Bundle Provider,也可以根据Group内文件类型选择Json、Sprites等provider。</li>
  <li><strong>(19) Asset Bundle Provider</strong>：加载AssetBundle接口，官方推荐AssetBundle Provider，或者自己实现一套Provider(可以实现加密解密)。</li>
</ul>

<h3 id="content-update">Content Update</h3>
<ul>
  <li><strong>(1) Prevent Updates</strong>：是否启用禁止更新移动Asset。当使用了AA自带的<strong>Check for Content Update Restrictions tool</strong>，不启用时如果组内有资源发生变更，这个工具会把变更的资源移动到需要生成的Remote Group内。(我没有使用这个工具也没有启用这个选项，组内的资源移动实现了一个脚本规则检查)。</li>
</ul>

<h3 id="group-schema配置">Group Schema配置</h3>

<p>  BundledAssetGroupSchema主要是Group面板配置，一个Group会生成两份Schema，<strong>#GroupName_BundledAssetGroupSchema</strong>、<strong>#GroupName_BundledAssetGroupSchema</strong>。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/group_serialize.png" width="250" /><font size="2.5">
            <i>Group Debug模式.</i>
        </font></center>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/schema_serialize1.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2024/month7/addressable_system/schema_serialize2.png" width="250" /><font size="2.5">
            <i>Schema Debug模式.</i>
        </font></center>

<p>  通过Debug模式可以看到Group主要是保存了<strong>SerializeEntries</strong>资源、<strong>Schema</strong>配置，所以配置实际上是由Schema保存的。在写代码创建Group时，要把资源加入到Group内、配置写到Schema内。</p>
<pre><code class="language-CSHARP">//...
group = settings.CreateGroup(key, i == 0, false, false, null);
AddressableBuildUtil.CheckSchemaValue(group, _keyIdArray);
AddressableBuildUtil.CheckUpdateSchema(group);
//...

SetSchemaBuildLoadPath(schema, keyIds);
schema.ChunkedTransfer = true;
//disable crc 使用md5代替
schema.UseAssetBundleCrc = false;
schema.UseAssetBundleCrcForCachedBundles = false;
//disable guid
schema.IncludeGUIDInCatalog = false;
schema.IncludeLabelsInCatalog = false;
schema.RedirectLimit = 2;
schema.RetryCount = 2;
schema.Timeout = 30;

SetBundleCache(schema);
//load asset by name
SetSchemaNameMode(schema, BundledAssetGroupSchema.AssetNamingMode.Filename);
//pack mode打包模式
SetSchemaPackMode(schema, BundledAssetGroupSchema.BundlePackingMode.PackTogetherByLabel);
//bundle name
SetSchemaNameStyle(schema, BundledAssetGroupSchema.BundleNamingStyle.FileNameHash);
//bundle id
SetSchemaBundleIdMode(schema, BundledAssetGroupSchema.BundleInternalIdMode.GroupGuid);
//bundle compression
SetSchemaBundleCompressionMode(schema, BundledAssetGroupSchema.BundleCompressionMode.LZ4);

//设置Schema Value会触发Group dirty通知，要判断值有没有变再设置
if (schema.BundleMode ~= packMode)
{
    schema.BundleMode = packMode;
}
</code></pre>

<h2 id="assetgrouptemplates">AssetGroupTemplates</h2>
<p>  Group模版配置,可以预先设置好Group的配置，使用该模版创建Group。</p>

<h2 id="databuilders">DataBuilders</h2>
<p>  存放打包脚本和Editor测试加载脚本的目录，AA提供了四个自带脚本。</p>
<ul>
  <li><strong>(1) BuildScriptFastMode</strong>：对应<strong>Use Asset Database (fastest)</strong>按钮，快速加载模式，类似AssetdataBase加载资源。</li>
  <li><strong>(2) BuildScriptPackedMode</strong>：对应<strong>Default Build Script</strong>打包按钮，默认的打AB包脚本，可以根据这个脚本修改自己的打包前后流程。</li>
  <li><strong>(3) BuildScriptPackedPlayMode</strong>：对应<strong>Use Existing Build(#Platform)</strong>，真实完整的AB加载场景模式，在Editor测试AB是否正确。</li>
  <li><strong>(4) BuildScriptVirtualMode</strong>：对应<strong>Simulate Groups (advanced)</strong>按钮，不用打AB包可模拟加载AB模式。</li>
</ul>]]></content><author><name>编程散记</name></author><category term="Unity3d" /><category term="Addressable System" /><summary type="html"><![CDATA[总结在使用Unity Addressable System过程中遇到的一部分问题，该篇主要记录Addressable在Unity编辑器的各种组织结构，本文Addressable后续简称AA。]]></summary></entry><entry><title type="html">视差和法线、高度图回顾(翻译二十)</title><link href="https://www.damonc.top/Unity_Parallax_Normals_Heightmap.html" rel="alternate" type="text/html" title="视差和法线、高度图回顾(翻译二十)" /><published>2018-01-25T20:00:00+00:00</published><updated>2018-01-25T20:00:00+00:00</updated><id>https://www.damonc.top/Unity_Parallax_Normals_Heightmap</id><content type="html" xml:base="https://www.damonc.top/Unity_Parallax_Normals_Heightmap.html"><![CDATA[<p>由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外的景物，附近的物体看起来很大并且移动很快，而远处的背景看起来很小并且移动较慢。渲染时，相机使用透视模式时，也会出现视差。</p>

<h2 id="视差纹理">视差纹理</h2>

<p>之前翻译使用过法线贴图将表面不规则感添加到平滑表面。 它会影响照明，但不会影响表面的实际形状。 因此，该效果视差不明显，通过实现法线贴图基于视野深度的幻觉有许多限制。这一篇的目的就是解决该限制。</p>

<h3 id="法线贴图效果回顾">法线贴图效果回顾</h3>

<p>下面给出许多albedo map 和 normal map差异对比：</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200615181223145-1229624244.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200615181223966-473200226.png" width="250" /><font size="2.5">
            <i>albedo map 和 normal map.</i>
        </font></center>

<p>如果没有法线贴图，表面看起来很平坦。 添加法线贴图会使它看起来好像具有不规则的表面。 但是，高度海拔差异看起来不明显。 当从入射视角与表面的夹角越趋于0，高度差越不明显。如果高程差异较大，则表面特征的相对视觉位置应由于视差而发生很大变化，但不会发生变化。 我们看到的视差是平坦的表面。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200616191420845-1957506928.png" width="250" /><font size="2.5">
            <i>平坦的视角.</i>
        </font></center>

<p>虽然可以增加法线贴图的强度，但这不会改变视差。同样，当法线贴图变得太强时，它会看起来很奇怪。它影响了平坦表面的光线的明暗变换，而视差效果它们确实是平的。所以法线贴图只适用于小的变化，但不会表现出明显的视差。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200616191421654-712293996.png" width="250" /><font size="2.5">
            <i>法线贴图的光线变化.</i>
        </font></center>

<p>要获得真正的深度视差感，<strong>首先</strong>需要确定深度应该是多少。法线贴图不包含这些信息。所以我们需要一个高度图。这样，我们就可以创建一个基于高度信息的假视差效果，就像法线贴图创建一个假斜率一样。下面的贴图也称它是灰度图，黑色代表最低点，白色代表最高点。因为我们将使用这个贴图来创建一个视差效果，也称为视差图。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200616191422519-1710373191.png" width="250" /><font size="2.5">
            <i>高度图.</i>
        </font></center>

<p>确保在导入时禁用sRGB(颜色纹理)，这样在使用线性空间渲染时数据就不会被弄乱</p>

<h3 id="shader参数">Shader参数</h3>

<p>为了能够使用视差贴图，我们必须为它添加一个属性到着色器。也会给它一个强度参数来缩放效果。因为视差效果相当强，我们将其范围设置为(0 , 0.1)。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_ParallaxMap</span> <span class="p">(</span><span class="s">"Parallax"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"black"</span> <span class="p">{}</span>
<span class="n">_ParallaxStrength</span> <span class="p">(</span><span class="s">"Parallax Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>

<span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_OcclusionMap</span> <span class="p">(</span><span class="s">"Occlusion"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
<span class="n">_OcclusionStrength</span> <span class="p">(</span><span class="s">"Occlusion Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>视差贴图是一个着色器特性，我们将启用__PARALLAX_MAP_关键字。将必需的编译器指令添加到base pass、additive pass和deferred pass。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma shader_feature _NORMAL_MAP
#pragma shader_feature _PARALLAX_MAP
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>为什么不在ShadowCaster增加视差贴图？
当使用albedo贴图的alpha通道的透明度时，视差贴图只会影响阴影。即使是这样，在阴影贴图中的视差效果也很难被注意到。所以它通常不值得额外的计算时间。但是如果愿意，也可以将它添加到阴影施法者通道中。
</code></pre></div></div>

<p>为了访问新的属性，给我的照明添加相应的变量</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_ParallaxMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>

<span class="n">sampler2D</span> <span class="n">_OcclusionMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_OcclusionStrength</span><span class="p">;</span>
</code></pre></div></div>

<p>为了能够自定义配置材质，在Extend ShaderGUI扩展中增加相应Enable与Disanble key的方法。</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">DoParallax</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialProperty</span> <span class="n">map</span> <span class="p">=</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_ParallaxMap"</span><span class="p">);</span>
    <span class="n">Texture</span> <span class="n">tex</span> <span class="p">=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">;</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="nf">BeginChangeCheck</span><span class="p">();</span>
    <span class="n">editor</span><span class="p">.</span><span class="nf">TexturePropertySingleLine</span>
    <span class="p">(</span>
        <span class="nf">MakeLabel</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">"Parallax (G)"</span><span class="p">),</span> <span class="n">map</span><span class="p">,</span>
        <span class="n">tex</span> <span class="p">?</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_ParallaxStrength"</span><span class="p">)</span> <span class="p">:</span> <span class="k">null</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="nf">EndChangeCheck</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">tex</span> <span class="p">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">SetKeyword</span><span class="p">(</span><span class="s">"_PARALLAX_MAP"</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200616191423089-347056836.png" width="250" /></center>

<h3 id="坐标匹配">坐标匹配</h3>

<p>通过在fragment程序中调整纹理坐标，让平坦表面的某些部分看起来高低交错。创建一个应用视差函数，给它一个inout插值器参数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在fragment程序使用插入的数据之前调用视差函数。_会有点异常是LOD衰落，_因为这取决于屏幕位置。先不调整这些坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="n">ApplyParallax</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">GetAlpha</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#if defined(_RENDERING_CUTOUT)
</span>        <span class="nb">clip</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">_Cutoff</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>通过简单地向U坐标添加视差强度来调整纹理坐标。做一次偏移计算</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>改变视差强度会导致纹理偏移。增加U坐标会使纹理向负的U方向移动，V坐标同理。这看起来不是视差效果，因为这是一个与视角无关的均匀位移。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012938981-982216259.gif" width="250" /><font size="2.5">
            <i>u坐标移动.</i>
        </font></center>

<h3 id="随视角方向移动">随视角方向移动</h3>

<p>视差是由相对于观察者的透视投影，所以必须改变纹理坐标。这意味着必须基于视图的方向来移动坐标，而视图的方向对于表面上每个片段都是不同的。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192759952-594530144.png" width="250" /><font size="2.5">
            <i>varies across a surface.</i>
        </font></center>

<p>纹理坐标存在于切线空间中。为了调整这些坐标，需要知道视图在切线空间中的方向。这需要矩阵乘法对空间进行转换。在fragment-程序已经有了一个切线空间矩阵，但是它是用于从切线空间到世界空间的转换。在本例中，需要从对象空间转到切线空间。</p>

<p>视图方向向量定义为从表面到摄像机，需要归一化。我们可以在vertex程序中确定这个向量，转换它并将它传递给fragment程序。但是为了最终得到正确的方向，需要推迟归一化，直到插值完成后。添加切线空间视图方向作为一个新的插值成员变量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="kt">float3</span> <span class="n">tangentViewDir</span> <span class="o">:</span> <span class="n">TEXCOORD8</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="kt">float3</span> <span class="n">tangentViewDir</span> <span class="o">:</span> <span class="n">TEXCOORD8</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>寄存器数量限制是多少?
model 1与model 2都只支持8个Texture Coordinate Register -&gt;Texcoord[0-7]。当使用model 3时，可以使用TEXCOORD8。若硬件不支持model 3其机能也就不是很强大，所以不要使用视差映射。
</code></pre></div></div>

<p><strong>首先</strong>, 使用mesh网格数据中的原始顶点切向量和法向量，在顶点程序中创建一个从对象空间到切线空间的转换矩阵。因为我们只用它来变换一个向量而不是一个位置我们用一个3×3矩阵就足够了。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ComputeVertexLightColor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="cp">#if defined (_PARALLAX_MAP)
</span>        <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span><span class="p">(</span>
            <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
            <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
            <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
        <span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>然后</strong>，可以使用<code class="language-plaintext highlighter-rouge">ObjSpaceViewDir</code>函数得到对象空间中顶点位置的视图方向，再用矩阵变换它我们就得到了我们需要的切线空间下视图方向。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined (_PARALLAX_MAP)
</span>    <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span>
    <span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
        <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
    <span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">objectToTangent</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ObjSpaceViewDir内部实现?</span>
<span class="c1">//ObjSpaceViewDir函数是在UnityCG中定义的。它先将摄像机位置转换到对象空间，然后减去对象空间下顶点位置得到一个从顶点指向摄像机的向量，注意它还没有标准化.</span>

<span class="k">inline</span> <span class="kt">float3</span> <span class="nf">ObjSpaceViewDir</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float3</span> <span class="n">objSpaceCameraPos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToObject</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">objSpaceCameraPos</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>最后</strong>，我们可以在ApplyParallax函数使用切线空间视图方向了。首先，对它进行规格化normalize，把它变成一个合适的方向向量。然后，添加它的XY组件到纹理坐标，再由视差强度缩放。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>这能有效地将视图方向投影到纹理表面上。当以90度角直视表面时，在切空间中的视图方向等于表面法线(0,0,1)，这不会导致位移。视角越浅，投影越大，位移效果也越大。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192800432-1757806048.png" width="250" /><font size="2.5">
            <i>影视图方向用作UV偏移.</i>
        </font></center>

<p>所有这一切的影响是表面似乎被拉向上的切线空间，看起来比它实际上更高，基于视差强度。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012940748-384205609.gif" width="250" /><font size="2.5">
            <i>随投影视角方向移动UV.</i>
        </font></center>

<h3 id="基于高度滑动">基于高度滑动</h3>

<p>在基于高度这一点上，我们可以让表面看起来更高，但它仍然是一个均匀位移。下一步是使用视差贴图来缩放位移。采样贴图，使用它的G通道作为高度，应用视差强度，并使用它来调节位移。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
<span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012942351-290008046.gif" width="250" /><font size="2.5">
            <i>由高度调整的移动.</i>
        </font></center>

<p>低的区域现在保持不变，而高的区域被向上拉。standard shader抵消了这种效果，所以低的区域也向下移动，而在中间的区域保持他们原来的位置。这是通过从原始高度数据中减去差值来实现的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012944095-1997194416.gif" width="250" /><font size="2.5">
            <i>视差贴图效果 由合理到过量.</i>
        </font></center>

<p>这就产生了我们想要的视差效果，但它只在低强度下有效。不足的是位移位移变换的很快，会撕裂表面。</p>

<h3 id="偏移视差映射算法">偏移视差映射算法</h3>

<p>我们目前使用的视差映射技术被称为带偏移限制的视差映射。我们只是使用了视图方向的XY部分，它的最大长度是1。因此，纹理偏移量是有限的。这种效果不错，但不能代表正确的透视投影。</p>

<p>一个更精确的计算偏移量的物理方法是将高度场视为几何图形表面下的体积，并通过它拍摄一个视图射线。光线从相机发射到表面，从上面进入高度场体积，并持续发射直到它到达由场定义的表面。</p>

<p>如果高度场均匀为零，那么射线就会一直持续到体积的底部。它与物体的距离取决于光线进入物体时的角度。它没有限制。角度越浅，越远。最极端的情况是当视角趋于0时，光线射向无穷大。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192800958-1980748310.png" width="250" /><font size="2.5">
            <i>光线投射到底部，有限且正确.</i>
        </font></center>

<p>为了找到合适的偏移量，我们必须缩放视图方向向量，通过除以它自己的Z分量来使它的Z分量变成1。因为我们以后不需要用Z，我们只需要用X和Y除以Z。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
<span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</code></pre></div></div>

<p>虽然这样可以得到一个更正确的投影，但它确实会使浅视角的视差效果恶化。standard着色器通过增加0.42偏差到Z减轻浅视角的视差效果恶化，所以它永远不会接近零。这扭曲了透视图，但使工件更易于管理。我们再加上这个偏差.</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">42</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192802151-218582125.png" width="250" /><font size="2.5">
            <i>视差贴图像标准着色器.</i>
        </font></center>

<p>通过上述多个步骤修正后, 现在我们的着色器与标准着色器支持同样的视差效果。视差映射可以应用于任何表面，投影假设切线空间是均匀的。曲面具有弯曲的切线空间，因此会产生物理上不正确的结果。只要视差强度和曲率很小，你就可以摆脱它。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192802555-2049613835.png" width="250" /><font size="2.5">
            <i>球面视差贴图.</i>
        </font></center>

<p>同样，阴影坐标不会受到这个效果的影响。因此，阴影在强烈的视差的组合下看起来很奇怪，好像漂浮在表面上。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192803371-1931947503.png" width="250" /><font size="2.5">
            <i>阴影不受视差影响.</i>
        </font></center>

<h3 id="parallax-configuration">Parallax Configuration</h3>

<p>你不同意Unity使用0.42的偏移值吗?或者你想使用一个不同的值，还是让它保持在0?或者你想用偏移限制代替吗?它是可以配置!</p>

<p>当你想使用偏移限制，定义<code class="language-plaintext highlighter-rouge">PARALLAX_OFFSET_LIMITING</code>在着色器。或者，通过定义PARALLAX_BIAS来设置要使用的偏差。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>            <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>当没有定义时，假设偏差是0.42。在<code class="language-plaintext highlighter-rouge">ApplyParallax</code> 中定义它。注意，宏定义不关心函数作用域，它们总是全局的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>    <span class="cp">#if !defined(PARALLAX_BIAS)
</span>        <span class="cp">#define PARALLAX_BIAS 0.42
</span>    <span class="cp">#endif
</span>    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>现在我们可以通过着色器的CGINCLUDE块来微调我们的视差效果。添加无偏差和限制偏移的选项，但将它们转换为注释，以坚持默认选项。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGINCLUDE</span>
    <span class="cp">#define BINORMAL_PER_FRAGMENT
</span>    <span class="cp">#define FOG_DISTANCE
</span>
<span class="c1">//	#define PARALLAX_BIAS 0</span>
<span class="c1">//	#define PARALLAX_OFFSET_LIMITING</span>

<span class="n">ENDCG</span>
</code></pre></div></div>

<h3 id="detail-uv">Detail UV</h3>

<p>视差贴图可以在主贴图上工作，但是我们还没有注意到副贴图。我们必须应用纹理坐标偏移到细节UV上。</p>

<p>首先，下面是一个包含网格模式的详细地图。它可以很容易地验证效果是否正确地应用于细节。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192803893-1797850325.png" width="250" /><font size="2.5">
            <i>细节网格纹理.</i>
        </font></center>

<p>使用这个纹理作为材质的细节albedo贴图。设置二级贴图的平铺为10×10。这表明，细节紫外线确实仍然不受影响。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192804491-290326603.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192805295-1360127209.png" width="250" /><font size="2.5">
            <i>细节UV不受影响.</i>
        </font></center>

<p>Standard也简单地添加了UV偏移到细节UV，这是存储在UV插值器的ZW组件。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
<span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
</code></pre></div></div>

<p>细节可能有所变化，但是它们肯定还不匹配视差效果。 那是因为我们平铺了二级纹理。 这样会将细节UV缩放10倍，使视差偏移量变弱十倍。 我们还必须将细节拼贴应用到偏移量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
</code></pre></div></div>

<p>实际上，缩放应该相对于主UV平铺，以防它被设置为1×1以外的一些东西。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192806533-2106069113.png" width="250" /><font size="2.5">
            <i>正确的UV.</i>
        </font></center>

<h2 id="ray-marching-光线步进">Ray Marching-光线步进</h2>

<p>然而，除了上述的偏移视差映射还有另外的视差算法：发射射线与高度场体积相交，确定其交点在表面上的位置，然后对该位置采样。 它通过在射线进入体积时的交点，对高度图进行一次采样。 但是，当看向任意一个角度时，这并不能准确告诉射线实际上与高度场相交的高度。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192807160-2024700857.png" width="250" /><font size="2.5">
            <i>实际与预测的高度对比.</i>
        </font></center>

<p>先假设入口点的高度与交点的高度相同，但这实际上只有在入口点和交点具有相同的高度时才是正确的。当偏移量不大且高度场变化不大时，它的效果仍然很好。但是，当偏移量太大或高度变化太快时，该算法就会出现问题，而这很可能是错误的。这就会造成表面撕裂。</p>

<p>如果我们能算出射线实际到达的高度场的位置，那么总能找到真正的可见表面点。这不能通过单个纹理样本来实现，我们必须沿着视图射线逐步移动，并每次都采样高度场，直到射线到达表面。该技术是RayMarching。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200617192807679-1545265192.png" width="250" /><font size="2.5">
            <i>随视图射线前进.</i>
        </font></center>

<p>有各种不同的视差贴图使用raymarching。常见的是陡视差映射_Steep Parallax Mapping_、地形映射_Relief Mapping_和视差遮挡映射_Parallax Occlusion Mapping_。与使用单一纹理样本相比，它们能通过高度场来创建更好的视差效果。除此之外，它们还可以应用额外的阴影和技术来改进该算法。当我们做的匹配这些方法时，我会调用它。</p>

<h3 id="自定义视差函数">自定义视差函数</h3>

<p>标准着色器仅支持简单的偏移视差映射。 现在，我们要在自己的着色器中添加对视差光线Ray marching的支持。 但是，我们还要继续支持这种简单方法。 两者都需要采样height字段，因此将采样代码行放在单独的GetParallaxHeight函数中。 而且，两种方法的投影视图方向和偏移量的最终应用都相同。 因此，将偏移量计算也单独为一个函数。 它仅需要原始UV坐标和已处理的视图方向作为参数，结果返回要应用的UV偏移。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">GetParallaxHeight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="nf">ParallaxOffset</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>            <span class="cp">#if !defined(PARALLAX_BIAS)
</span>                <span class="cp">#define PARALLAX_BIAS 0.42
</span>            <span class="cp">#endif
</span>            <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
        <span class="cp">#endif
</span>
        <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">ParallaxOffset</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>现在，我们将应用视差函数宏替换对视差偏移的硬编码调用，从而使视差方法更加灵活。如果没有定义它，我们将它设置为使用偏移量方法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="c1">//...</span>
        <span class="cp">#if !defined(PARALLAX_FUNCTION)
</span>            <span class="cp">#define PARALLAX_FUNCTION ParallaxOffset
</span>        <span class="cp">#endif
</span>        <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">PARALLAX_FUNCTION</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>为RayMarching方法创建一个新函数。与ParallaxOffset函数类似的参数和返回类型。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxOffset</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在可以通过定义_PARALLAX_FUNCTION_来改变着色器中的视差方法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<h3 id="相交计算">相交计算</h3>

<p>为了找到视图射线到达高度场的点，我们需要对射线上的多个点进行采样并计算出在表面下方的位置。第一个采样点在顶部，我们在这里输入高度量，就像使用偏移方法一样。最后一个采样点就是射线到达体积底部的地方。我们会在这些端点之间均匀地添加额外的采样点。</p>

<p>假设每条射线进行10次采样。这意味着我们将对高度图采样10次而不是一次，所以这不是一个便宜计算方法。因为我们用了10个样本，所以步长是0.1。这是我们沿着视图射线移动的因子，也就是UV偏移增量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了应用视差强度，我们可以调整每一步采样的高度。但是缩放UV delta也有同样的效果，只需要计算一次。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>
</code></pre></div></div>

<p>通过这种方式，无论视差强度如何，我们都可以继续使用0–1作为高度场的范围。 因此，射线的第一步高度始终为1。低于或高于该高度的表面点的高度由高度场定义。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span><span class="c1">//步长</span>
<span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>
<span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//步高</span>
<span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
</code></pre></div></div>

<p>现在我们要沿着射线迭代。<strong>首先</strong>，每一步我们都会增加UV偏移量。视图向量指向摄像机，但我们是在向表面移动，所以我们需要减去UV delta。<strong>然后</strong>我们用步高来减小步长。<strong>然后</strong>我们再次对高度图采样。使用while循环重复上述步骤，直到采样完毕。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当编译时，会得到一个编译器警告和错误。这个警告告诉我们在循环中使用了梯度指令。这指的是循环中的纹理采样。GPU必须弄清楚使用哪个mipmap级别，它需要比较相邻片段使用的UV坐标。只有当所有片段执行相同的代码时，它才能对比。对于循环来说，这是不可能的，因为它可以提前终止，每个片段都可能不同。因此编译器将展开循环，这意味着它将一直执行所有9个步骤，而不管逻辑是否可以提前停止。相反，它随后使用确定性逻辑选择最终结果。</p>

<p>编译失败是因为编译器无法确定循环的最大迭代次数。它不知道这个最多是9。通过将while循环转换为执行限制的for循环来明确这一点。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012945572-448280189.png" width="250" /><font size="2.5">
            <i>Raymarching 步进10次 无偏差, 无限制.</i>
        </font></center>

<p>与简单的视差偏移方法相比，视差效果更加明显。较高的区域现在也正确地阻挡了我们后面较低区域的视野。我们还得到了明显的图层，总共10层。</p>

<h3 id="更多步进">更多步进</h3>

<p>这个基本的光线行进方法最适合陡峭的视差贴图。效果的质量是由我们的样本分辨率决定的。一些方法根据视角使用可变的步骤。较浅的角度需要更多的步长，因为光线较长。但我们的样本量是固定的，所以我们不会这样做。</p>

<p>提高质量的明显方法是增加采样的次数，因此让其可配置。使用_PARALLAX_RAYMARCHING_STEPS_，默认值为10，而不是固定的步长和迭代次数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if !defined(PARALLAX_RAYMARCHING_STEPS)
</span>        <span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
</span>    <span class="cp">#endif
</span>    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="n">PARALLAX_RAYMARCHING_STEPS</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>

    <span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span>
        <span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_STEPS</span> <span class="o">&amp;&amp;</span> <span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
        <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
        <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在我们可以在着色器中控制步数。对于真正的高质量，将PARALLAX_RAYMARCHING_STEPS定义为100。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 100
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012948054-536464296.png" width="250" /><font size="2.5">
            <i>Raymarching 100次采样.</i>
        </font></center>

<p>这让我们知道了它的效果能有多好，但它计算量太大了，一般不适合手机。所以把样本数设为10后，我们仍然可以看到视差效果看起来连续和平滑。然而，由视差遮挡引起的轮廓总是锯齿状的，MSAA并不能消除这一点，因为它只适用于几何图形的边缘，而不是纹理效果。只要不依赖深度缓冲区，后处理抗锯齿技术能解决。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>不能按片段写入深度缓冲区吗?
这在足够先进的硬件上确实是可能的，使它能够正确地与高度场相交并应用阴影。不过，它计算量太大。
</code></pre></div></div>

<p>我们当前的方法是沿着射线步进，直到到达表面以下的点，或者到达射线末端可能的最低点。然后我们用UV偏移处理那个点。但隐藏在表面之下的这个点，很可能会出现错误。这就是导致表面撕裂的原因。</p>

<p>增加步长数只会减少最大误差。使用足够的步骤，错误会变得更小，以至于我们无法再看到它。所以当一个表面总是从远处看，你可以用更少的步骤。距离越近，视角越小，需要的样本就越多。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012948690-1598196626.png" width="250" /><font size="2.5">
            <i>Raymarching 100次采样.</i>
        </font></center>

<h3 id="步长之间插值">步长之间插值</h3>

<p>提高质量的一种方法是根据经验预测光线真正到达表面的位置。比如第一步在表面之上，下一步在表面之下。在这两步之间的某个点射线一定到达了表面。</p>

<p>两个射线点、和两个射线点到表面最近的点，能定义两条线段。因为光线和表面碰撞，这两条线段会相交。所以如果我们跟踪前面的步骤，我们可以在循环之后执行直线交叉。我们可以用这个信息来近似出真正的交点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012949277-977122761.png" width="250" /><font size="2.5">
            <i>执行直线交叉.</i>
        </font></center>

<p>在for循环内，我们必须跟踪之前的UV偏移量、步长高度和表面高度。一般来说，这些等于循环之前的第一个样本。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="n">prevUVOffset</span> <span class="o">=</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="n">float</span> <span class="n">prevStepHeight</span> <span class="o">=</span> <span class="n">stepHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">prevSurfaceHeight</span> <span class="o">=</span> <span class="n">surfaceHeight</span><span class="p">;</span>
</code></pre></div></div>

<p>在循环之后，我们计算这些线的交点。我们可以使用这个插值之间的前点和后点的UV偏移。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
<span class="n">uvOffset</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">prevUVOffset</span><span class="p">,</span> <span class="n">uvOffset</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

<span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>数学原理：
这两个线段定义在两个样本步骤之间的空间内。我们将这个空间的宽度设置为1。从前一步到最后一步的直线由点(0，a)和点(1，b)定义，其中a是前一步的高度，b是后一步的高度。因此，可以用线性函数'v(t) = a + (b - a)t'来定义视图线。同样地，面线由点(0，c)和(1，d)定义，函数's(t) = hlsl + (d - hlsl)t'。

交点存在于s(t) = v(t)'处。那么t的值是多少?
c + (d - c)t = a + (b - a)t
(d - c)t - (b - a)t = a - c
(a - c + d - b)t = a - c
t = (a - c) / (a - c + d - b)
注意:a - c是在t = 0处直线高度的绝对差。d - b是t = 1处的绝对高度差。
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012950193-51635460.png" width="250" /><font size="2.5">
            <i>线段交点.</i>
        </font></center>

<p>实际上，在这种情况下，我们可以使用插值器来缩放我们要添加到上一点上的UV偏移量。它可以归结为相同的东西，只是用了更少的数学。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">-</span> <span class="n">difference</span><span class="p">);</span>
<span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012951620-360864955.png" width="250" /></center>

<p>效果看起来好多了。我们现在假设表面在样本点之间是线性的，这可以防止最明显的分层假象。然而，它不能帮助我们检测我们是否错过了步骤之间的交集。我们仍然需要很多的样本来处理小的特征，轮廓和浅角度。</p>

<p>有了这个技巧，我们的方法类似于视差遮挡映射。虽然这是一个相对便宜的改进，但通过定义_PARALLAX_RAYMARCHING_INTERPOLATE_，我们让它成为可选的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(PARALLAX_RAYMARCHING_INTERPOLATE)
</span>    <span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
    <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>在shader内定义PARALLAX_RAYMARCHING_INTERPOLATE。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<h3 id="步长搜索">步长搜索</h3>

<p>通过在两个步长之间进行线性插值，我们假定表面在两个步长之间是笔直的。 但是，通常情况并非如此。 为了更好地处理不规则的高度场，我们必须在两个步长之间搜索实际的交点。 或至少接近它。</p>

<p>完成循环后，不要使用最后的偏移量，而是将偏移量调整到最后两个步长的中间位置。对该点的高度进行采样。如果我们结束在表面以下，向表面之上方向移动四分之一，并再次采样。如果我们在表面上结束，向表面之下方向移动四分之，并再次采样。不断重复这个过程。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012952340-10743193.png" width="250" /><font size="2.5">
            <i>越来越接近交点.</i>
        </font></center>

<p>上述方法是二分查找的一个应用。它与地形测绘方法最匹配。每走一步，路程减半，直到到达目的地。在我们的例子中，我们将简单地做固定次数，以达到预期的解决方案。一步，得到0.5。两步，得到0.25、0.75。三步，是0.125、0.375、0.625、0.875。注意，从第二步开始，每次采样提升分的辨率将翻倍。</p>

<p>为了控制是否使用此方法，我们定义_PARALLAX_RAYMARCHING_SEARCH_STEPS_。默认情况下将其设置为零，这意味着我们根本不进行搜索。如果它被定义为大于0，我们将不得不使用另一个循环。注意，这种方法与_PARALLAX_RAYMARCHING_INTERPOLATE_是<strong>不兼容</strong>的，因为我们不能再保证表面是交叉的最后两个步骤。当我们搜索的时候，禁用插值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(PARALLAX_RAYMARCHING_SEARCH_STEPS)
</span>    <span class="cp">#define PARALLAX_RAYMARCHING_SEARCH_STEPS 0
#endif
#if PARALLAX_RAYMARCHING_SEARCH_STEPS &gt; 0
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="cp">#elif defined(PARALLAX_RAYMARCHING_INTERPOLATE)
</span>    <span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
    <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>此循环也执行与原始循环相同的基本工作。调整偏移量和步高，然后采样高度字段。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但每次迭代，UV增量和步长减半。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvDelta</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">stepSize</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>同样，如果点在表面之下，我们必须朝相反的方向移动。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uvDelta</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">stepSize</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">stepHeight</span> <span class="o">&lt;</span> <span class="n">surfaceHeight</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">+=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">+=</span> <span class="n">stepSize</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
</code></pre></div></div>

<p>调整着色器，所以它使用三个搜索步骤</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012953271-1061541462.png" width="250" /><font size="2.5">
            <i>10步长加上3个二分查找的最终效果.</i>
        </font></center>

<p>结果看起来相当不错，但仍不完美。二分法搜索可以比简单的插值处理较浅的角度，但仍然需要相当多的搜索步骤，以摆脱分层。所以这是一个试验的问题，找出哪种方法在特定情况下最有效，需要多少步骤。</p>

<h3 id="缩放对象和动态批处理">缩放对象和动态批处理</h3>

<p>尽管我们的视差映射方法似乎可行，但存在一个隐藏的错误。 而且还把错误显示出来了。它显示了何时使用动态批处理来组合已缩放的对象。 例如，给我们的四边形一个像\((10,10,10)\)的比例，然后复制它，将副本移到它下面一点。 假设在播放器设置中启用了此选项，这将触发Unity动态批处理四边形。</p>

<p>批处理开始时，视差效果将扭曲。 旋转相机时，这一点非常明显。 但是，这仅发生在游戏视图和构建中，而不发生在场景视图中。 请注意，standard着色器也存在此问题，但是当使用弱偏移视差效果时，您可能不会立即注意到它。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/1692664-20200618012954391-1540920343.png" width="250" /><font size="2.5">
            <i>动态批处理会产生奇怪的结果.</i>
        </font></center>

<p>在批处理将它们合并到一个单一的网格中之后，Unity不能标准化处理后的几何法向量和切向量。因此顶点数据正确的假设不再成立。</p>

<p>顶点法向量和切向量没有规范化不是什么大的问题，因为我们在顶点程序中将视图向量转换到切线空间。对于其他所有内容，数据在使用之前都要标准化。</p>

<p>解决方法是在构造对象转换到切线矩阵之前对向量进行归一化。 因为只有动态批处理的缩放几何才需要此选项，所以根据是否定义了PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING，将其设为可选。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined (_PARALLAX_MAP)
</span>    <span class="cp">#if defined(PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING)
</span>        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span><span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
        <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
    <span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">objectToTangent</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3
#define PARALLAX_FUNCTION ParallaxRaymarching
#define PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING
</span></code></pre></div></div>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender20/batched-correct.png" width="250" /><font size="2.5">
            <i>动态批量与正确的结果.</i>
        </font></center>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外的景物，附近的物体看起来很大并且移动很快，而远处的背景看起来很小并且移动较慢。渲染时，相机使用透视模式时，也会出现视差。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/posts/2018/month1/catRender20/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/posts/2018/month1/catRender20/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity GPU Instance(翻译十九)</title><link href="https://www.damonc.top/Unity_GPU_Instance.html" rel="alternate" type="text/html" title="Unity GPU Instance(翻译十九)" /><published>2018-01-24T20:00:00+00:00</published><updated>2018-01-24T20:00:00+00:00</updated><id>https://www.damonc.top/Unity_GPU_Instance</id><content type="html" xml:base="https://www.damonc.top/Unity_GPU_Instance.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>渲染大量球体-优化DrawCall</li>
  <li>支持GPU-Instance</li>
  <li>使用材质属性块</li>
  <li>LOD-Groups支持GPU-Instance</li>
</ul>

<h2 id="batching-instance-批处理">Batching Instance-批处理</h2>

<p>指示GPU绘制需要花时间；向其传递mesh和material属性也要花时间。现在已知两种节省Draw Call的方式：static和<a href="https://docs.unity3d.com/Manual/DrawCallBatching.html"><strong>dynamic batching</strong></a></p>

<p>Unity可以将多个静态物体的网格合并为一个更大的静态网格，从而减少draw call。 <strong>注意：</strong> 只有使用相同材质的对象才能以这种方式组合。 这是以必须存储更多网格数据为代价的。 启用动态批处理后，Unity在运行时会对视图中的动态对象执行相同的操作。 这仅适用于小型网格物体，否则开销将变得太大。</p>

<p>还有另一种组合draw call的方法：GPU instance或Geometry instance。与动态批处理一样，此操作在运行时针对可见对象。 它的目标是让GPU一次性渲染同一网格的多个副本。 因此，它不能组合不同的网格或材质。</p>

<h3 id="创建大量球体">创建大量球体</h3>

<div class="language-plaintext tip-info highlighter-rouge"><div class="highlight"><pre class="highlight"><code>im title?
test test test.
test test test.
test test test!!dfS:FDFH&amp;*YER#.
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">using</span> <span class="n">UnityEngine</span><span class="p">;</span>

<span class="kr">public</span> <span class="k">class</span> <span class="n">GPUInstancingTest</span> <span class="o">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="n">Transform</span> <span class="n">prefab</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">int</span> <span class="n">instances</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">50</span><span class="n">f</span><span class="p">;</span>
    <span class="c1">//单位圆内随机一点并放大坐标50倍，生成5000个球体</span>
    <span class="c1">//然后查看statistics统计的draw Call信息</span>
    <span class="kt">void</span> <span class="n">Start</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
            <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用forward render path统计到的draw call，去掉背景和camera Effect两个draw call：</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010902826-821880737.png" width="250" /><font size="2.5">
            <i>5000 draw call.</i>
        </font></center>

<p>但是当使用cube代替球体</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010904552-338192039.png" width="250" /><font size="2.5">
            <i>6 draw call.</i>
        </font></center>

<h3 id="支持instance">支持Instance</h3>

<p>默认情况下，GPU Instance不会开启，必须设计shader以支持它。 即使这样，也必须为每种材料显式启用实例化。 Unity的standard着色器有一个开关。像标准着色器的GUI一样，我们将为shader扩展面板创建“高级选项”部分。 可以通过调用MaterialEditor.EnableInstancingField方法来添加切换。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoAdvanced</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">GUILayout</span><span class="p">.</span><span class="n">Label</span><span class="p">(</span><span class="s">"Advanced Options"</span><span class="p">,</span> <span class="n">EditorStyles</span><span class="p">.</span><span class="n">boldLabel</span><span class="p">);</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">EnableInstancingField</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>仅当shader实际支持instance时，才会显示该切换。 我们可以通过将#pragma multi_compile_instancing指令添加到着色器base-pass启用此支持。 这将为一些关键字启用着色器变体，自定义关键字_INSTANCING_ON_，其他关键字也可以。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_fwdbase
#pragma multi_compile_fog
#pragma multi_compile_instancing
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010905493-1524350499.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010906722-1492830859.png" width="250" /><font size="2.5">
            <i>合并了，但是显示有错误.</i>
        </font></center>

<p>批处理数量已减少到42，这意味着现在仅用40个批处理即可渲染所有5000个球体。帧速率也高达80 fps，但是只有几个球体可见。<strong>错误原因</strong>：虽然5000个球体仍在渲染，但是在合批中同一批次的所有球体的顶点转换时都使用了同一个位置：它们都使用同一批次中第一个球的转换矩阵。 发生这种情况是因为现在同一批中所有球体的矩阵都作为数组发送到GPU。 在不告知着色器要使用哪个数组索引的情况下，它始终使用第一个索引。</p>

<h3 id="instance-ids">Instance IDs</h3>

<p>上述错误解决办法：每个Instance相对应的数组索引称为其Instance ID，GPU通过顶点数据将其传递到着色器的vertex程序。在大多数平台上，它是一个无符号整数，名为instanceID，具有SV_InstanceID语义。 我们可以简单地使用_UNITY_VERTEX_INPUT_INSTANCE_ID_宏将其包含在我们的VertexData结构中。 它在UnityCG中包含的_UnityInstancing.cginc_文件中定义。 它为我们提供了实例ID的正确定义，或者在未启用实例化时不提供任何内容。将其添加到VertexData结构。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>启用instance后，我们现在可以在顶点程序中访问instanceID。 有了它，我们可以在变换顶点位置时使用正确的矩阵。 但是，UnityObjectToClipPos函数没有矩阵参数，它函数内部始终使用unity_ObjectToWorld矩阵。要解决此问题，UnityInstancing包含文件会使用矩阵数组的宏覆盖unity_ObjectToWorld。 <em>这可以被认为是肮脏的宏技巧，但无需更改现有着色器代码即可工作，从而确保了向后兼容性</em>。</p>

<p>要使它工作，instance的数组索引必须对所有着色器代码全局可用。必须通过_UNITY_SETUP_INSTANCE_ID_宏进行手动设置，该宏必须在vertex程序最先计算，然后再执行其他的代码。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010908398-221325174.png" width="250" /><font size="2.5">
            <i>矩阵替换内部实现？.</i>
        </font></center>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//UnityInstancing中的实际代码要复杂得多。 它要处理平台差异，其他使用实例化的方法以及用于立</span>
<span class="c1">//体声渲染的特殊代码，从而导致间接定义的多个步骤。 它还必须重新定义UnityObjectToClipPos，因</span>
<span class="c1">//为UnityCG首先包含UnityShaderUtilities。</span>
<span class="c1">//缓冲区宏将在后面说明。</span>
<span class="k">static</span> <span class="n">uint</span> <span class="n">unity_InstanceID</span><span class="p">;</span>

<span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityDrawCallInfo</span><span class="p">)</span>
    <span class="c1">// Where the current batch starts within the instanced arrays.</span>
    <span class="n">int</span> <span class="n">unity_BaseInstanceID</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>

<span class="cp">#define UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;
</span>
<span class="cp">#define UNITY_SETUP_INSTANCE_ID(input) \
    unity_InstanceID = input.instanceID + unity_BaseInstanceID;
</span>
<span class="c1">// Redefine some of the built-in variables</span>
<span class="c1">// macros to make them work with instancing.</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">PerDraw0</span><span class="p">)</span>
    <span class="kt">float4x4</span> <span class="n">unity_ObjectToWorldArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
    <span class="kt">float4x4</span> <span class="n">unity_WorldToObjectArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
<span class="cp">#define unity_ObjectToWorld     unity_ObjectToWorldArray[unity_InstanceID]
#define unity_WorldToObject     unity_WorldToObjectArray[unity_InstanceID]
</span></code></pre></div></div>

<h3 id="批处理大小">批处理大小</h3>

<p>每台设备不一样，最终得到的批次数量可能与当前实验得到的数量不同。现在这情况下，以40批渲染5000个球体实例，这意味着每批125个球体。</p>

<p>每个批次都需要自己的矩阵数组。 此数据发送到GPU并存储在内存缓冲区中，在Direct3D中称为常量缓冲区，在OpenGL中称为统一缓冲区。 这些<strong>缓冲区具有最大大小</strong>，这限制了一批中可以容纳多少个实例。 假设台式机GPU每个缓冲区的限制为64KB。</p>

<p>一个矩阵由16个浮点数组成，每个浮点数均为4个字节。 因此，每个矩阵64个字节。 每个实例都需要一个对象到世界的转换矩阵。 但是，我们还需要一个世界到对象的矩阵来转换法线向量。 因此，最终每个实例有128个字节。 这导致最大批处理大小为“ 64000/128 = 500”，这只能在10个批处理中渲染5000个球体。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>内存单位是2进制，所以1KB表示1024字节，而不是1000。因此，'(64 * 1024)/ 128 = 512 '。UNITY_INSTANCED_ARRAY_SIZE默认定义为500，但您可以使用编译器指令覆盖它。例如，#pragma instancing_options maxcount:512将最大值设置为512。但是，这将导致断言失败错误，因此实际限制为511。到目前为止，500和512之间没有太大的差别。
</code></pre></div></div>

<p>即使假设台式机的最大容量为64KB成立，但是大多数移动设备的最大容量远远达不到64，可能仅为16KB。 Unity通过在针对OpenGL ES 3，OpenGL Core或Metal时将最大值除以四来解决此问题。 因为我在编辑器中使用的是OpenGL Core，所以最终的最大批处理大小为“ 500/4 = 125”。</p>

<p>可以通过添加编译器指令#pragma instancing_options force_same_maxcount_for_gl来禁用此自动减少功能。 多个instance选项组合在同一指令中。 但是，这可能会导致在部署到移动设备上时发生故障，因此请小心使用。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>那假设均等缩放选项呢？

可以使用#pragma instancing_options指示所有instance对象具有统一的缩放比例。 这消除了将世界到对象矩阵用于法线转换的需要(少存储一个矩阵)。 设置此选项后，虽然UnityObjectToWorldNormal函数确实会更改其行为，但它不会消除第二个矩阵数组。 因此，至少在Unity 2017.1.0中，此选项实际上没有任何作用。
</code></pre></div></div>

<h3 id="instance-shadows">Instance Shadows</h3>

<p>到目前为止，一直没有阴影。 重新打开主阴影的Soft shadow，并确保阴影距离足以包含所有球体</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010909964-776430193.png" width="250" /><font size="2.5">
            <i>批处理爆炸.</i>
        </font></center>

<p>为大量物体渲染阴影会增加GPU耗能。但是我们也可以在渲染球体阴影时使用GPU instance。在shadow caster-pass中添加instance指令；同时也增加<code class="language-plaintext highlighter-rouge">UNITY_VERTEX_INPUT_INSTANCE_ID</code> and <code class="language-plaintext highlighter-rouge">UNITY_SETUP_INSTANCE_ID</code></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_shadowcaster
#pragma multi_compile_instancing
</span><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
	<span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010911627-1161944067.png" width="250" /><font size="2.5">
            <i>instanced 阴影.</i>
        </font></center>

<h3 id="多光源">多光源</h3>

<p>我们仅在base-pass和shadow caster-pass中添加了instance支持。 因此，批处理不适用于其他光源。 要验证这一点，停用主光源并添加一些会影响多个球体的聚光灯或点光源。 不要为它们打开阴影，因为那样会降低帧速率。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010913312-1389275661.png" width="250" /><font size="2.5">
            <i>批处理爆炸.</i>
        </font></center>

<p>上图，完全不支持多光源批处理。 要将instance与多个光源结合使用，只能切换到延迟渲染路径。 为此，请将所需的编译器指令添加到着色器的延迟传递中。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_prepassfinal
#pragma multi_compile_instancing
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010914967-1310775534.png" width="250" /><font size="2.5">
            <i>多光源instance.</i>
        </font></center>

<h2 id="mixing-material-properties">Mixing Material Properties</h2>

<p>所有批处理都有一个限制：它们仅限于具有相同材料的对象。 当我们希望渲染的对象具有多样性时，此限制就会成为问题。</p>

<h3 id="随机着色">随机着色</h3>

<p>随机改变球体的颜色</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">MeshRenderer</span><span class="o">&gt;</span><span class="p">().</span><span class="n">material</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span>    <span class="kr">new</span> <span class="n">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010916576-490651101.png" width="250" /><font size="2.5">
            <i>球体与随机的颜色，没有批量和阴影.</i>
        </font></center>

<p>即使我们为物料启用了批处理，它也不再起作用。由于每个球体现在都有自己的材质，因此每个球体的着色器状态也必被更改。 这显示在统计面板中为SetPass call的数量。在这修改之前只有少量几个批次渲染，但是现在是5000加批次。</p>

<h3 id="材质属性块-material-property-blocks">材质属性块-Material Property Blocks</h3>

<p>除了为每个球体创建新的材质实例外，我们还可以使用材质属性块。 这些是小的修改，设置属性块的颜色并将其传递给球体的渲染器，而不是直接分配材质的颜色。<a href="http://docs.unity3d.com/Documentation/ScriptReference/MaterialPropertyBlock.html">MaterialPropertyBlock</a>官网介绍;</p>

<h3 id="property-buffers-属性缓冲区">Property Buffers-属性缓冲区</h3>

<p>渲染instance对象时，Unity通过数组形式将颜色数据传递到GPU内存并转换矩阵，Unity对存储在材料属性块中的属性执行相同的操作，但要使其起作用的话，我们必须在shader中定义一个instance的缓冲区。</p>

<p>声明instance缓冲区的工作类似于创建诸如插值器之类的结构，但是确切的语法因平台而异。 我们可以使用UNITY_INSTANCING_CBUFFER_START和UNITY_INSTANCING_CBUFFER_END宏来解决差异。 启用实例化后，它们将不执行任何操作。</p>

<p>将_Color变量的定义放在instance缓冲区中。 UNITY_INSTANCING_CBUFFER_START宏需要一个名称参数，实际名称无关紧要但要注意避免重名冲突。 宏以UNITY_INSTANCING_为其前缀。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="kt">float4</span> <span class="n">_Color</span><span class="p">;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div>

<p>像变换矩阵一样，启用instance后，颜色数据作为数组上传到GPU。UNITY_DEFINE_INSTANCED_PROP宏会为我们处理正确的声明语法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="c1">//float4 _Color;</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div>

<p>最后要访问fragment程序中的数组，我们还需要在其中知道instanceID。 因此，将其添加到插值器结构中。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在vertex顶点程序中，将ID从顶点数据复制到插值器。 启用实例化时，UNITY_TRANSFER_INSTANCE_ID宏定义此简单操作，否则不执行任何操作。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在片段程序的开头，使ID全局可用，就像在顶点程序中一样。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，我们必须在不使用instance时以_Color的形式访问颜色，而在启用实例化时以_Color [unity_InstanceID]的形式访问颜色。 使用UNITY_ACCESS_INSTANCED_PROP宏可同时支持上述两种访问。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="nf">GetAlbedo</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">albedo</span> <span class="o">=</span>
        <span class="nb">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>新版本如果编译有错误：
从2017.3及以上版本, UNITY_ACCESS_INSTANCED_PROP macro改了它需要的两个参数：buffer名，颜色名使用UNITY_ACCESS_INSTANCED_PROP(InstanceProperties, _Color).
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010918398-38688989.png" width="250" /></center>

<p>现在，我们的颜色随机的球再次被批处理。 我们<strong>可以用相同的方式使其他属性可变。 对于颜色，浮点数，矩阵和四分量浮点向量，这是可能的</strong>。 <strong>如果要改变纹理，可以使用单独的纹理数组</strong>，并将索引添加到实例化缓冲区。其他属性修改类似。</p>

<p>可以在同一个缓冲区中组合多个属性，但要牢记大小限制。 还应注意，缓冲区被划分为32位块，因此单个浮点数需要与向量相同的空间。 您也可以使用多个缓冲区，但是也有一个限制，它们不是免费提供的。 启用instance后，每个要缓冲的属性都将成为一个数组，因此仅对需要根据instance变化的属性执行此操作。</p>

<h3 id="阴影">阴影</h3>

<p>我们的阴影也取决于颜色。 调整shader阴影以便每个实例也可以支持唯一的颜色。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//float4 _Color;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>

<span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">float4</span> <span class="nf">MyShadowFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="lod-instance">LOD Instance</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialPropertyBlock</span> <span class="n">properties</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="p">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="nf">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="c1">//MaterialPropertyBlock properties = new MaterialPropertyBlock();</span>
        <span class="n">properties</span><span class="p">.</span><span class="nf">SetColor</span>
        <span class="p">(</span>
            <span class="s">"_Color"</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="c1">//t.GetComponent&lt;MeshRenderer&gt;().SetPropertyBlock(properties);</span>
        <span class="n">MeshRenderer</span> <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> 
        <span class="p">{</span>
            <span class="c1">//对LOD子对象设置颜色</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ci</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">ci</span> <span class="p">&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">childCount</span><span class="p">;</span> <span class="n">ci</span><span class="p">++)</span> <span class="p">{</span>
                <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">GetChild</span><span class="p">(</span><span class="n">ci</span><span class="p">).</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010919954-2006515171.png" width="250" /></center>

<p>不幸的是没有有效的批处理。Unity能够对以相同的LOD颜色球体进行批处理，但是如果可以像往常一样进行批处理会更好。 我们可以通过用缓冲数组替换unity_LODFade来实现。可以通过为支持实例化的每个过程添加lodfade实例化选项来指示Unity的着色器代码执行此操作。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_instancing
#pragma instancing_options lodfade
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender19/1692664-20200612010921540-656727216.png" width="250" /><font size="2.5">
            <i>instance LOD fading.</i>
        </font></center>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[还有另一种组合draw call的方法：GPU instance或Geometry instance。与动态批处理一样，此操作在运行时针对可见对象。 它的目标是让GPU一次性渲染同一网格的多个副本。 因此，它不能组合不同的网格或材质，但不仅限于小网格。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/posts/2018/month1/catRender19/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/posts/2018/month1/catRender19/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity 实时 GI &amp;amp; LPPV &amp;amp; LOD(翻译十八)</title><link href="https://www.damonc.top/Unity_RealTime_GI_LOD.html" rel="alternate" type="text/html" title="Unity 实时 GI &amp;amp; LPPV &amp;amp; LOD(翻译十八)" /><published>2018-01-23T20:00:00+00:00</published><updated>2018-01-23T20:00:00+00:00</updated><id>https://www.damonc.top/Unity_RealTime_GI_LOD</id><content type="html" xml:base="https://www.damonc.top/Unity_RealTime_GI_LOD.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>支持实时全局光照</li>
  <li>用动画控制发光对GI的贡献</li>
  <li>使用光照探针代理体LPPV</li>
  <li>LOD组与GI结合</li>
  <li>LOD之间的淡入淡出</li>
</ul>

<p>从这篇开始，这个系列教程将由Unity 2017.1.0f3来完成。后续的Shader新特性Unity的旧版本没有，因为我们要使用一个新的着色器函数。</p>

<h2 id="实时全局光照">实时全局光照</h2>

<p>　　烘焙光照在静态物体上工作的非常好，对于动态几何体，由于有光照探针的缘故，烘焙光照这种方法也能工作的非常好。<strong>但是</strong>，烘焙光照不能处理动态光源。混合模式的光源可以通过一些实时的调节来消除，但调节的太多使得烘焙出来的间接光照不会改变。所以当你有一个户外场景的话，使用烘焙光照这种方法太阳的光照就不能有变化。太阳不能像在现实生活中一样在天空中移动，因为如果需要太阳在天空中移动的话，就需要逐渐变化的全局光照。所以场景必须一直不变。</p>

<p>　　为了使间接光照能够在移动的太阳这样的情况发挥作用，Unity使用Enlighten系统来计算实时全局光照。除了在运行时计算光照和光照探针以外，它还采用烘焙间接光照一样的方式来工作。</p>

<p>　　了解间接光需要知道光在静态表面之间如何反射。重点在于哪些表面可能会受到其他表面的影响，以及程度如何。弄清这些关系需要做很多的工作，不能实时完成。所以这个数据由编辑器处理并存储在运行时使用。然后 Enlighten系统会使用这个数据来计算实时光照贴图和探针数据。即使如此，只有低分辨率的光照贴图才可以在实时情况下运行。</p>

<h3 id="启用全局光照">启用全局光照</h3>

<p>实时全局光照、烘焙全局光照都可以独立启用。你可以同时启用两个，或者启用其中的一个，或者两个都不启用。这两个选项都是通过“光照”窗口的“实时照光照”部分中的复选框启用。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605003217232-1241081746.png" width="250" /><font size="2.5">
            <i>实时全局光照和烘焙光照同时启用的状态.</i>
        </font></center>

<p>要实际查看实时全局光照，请将测试场景中的主光源的模式设置为实时模式。 由于我们没有其他光源，即使启用了烘焙光照也能有效地关闭。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605003333043-1240937953.png" width="250" /><font size="2.5">
            <i>主光源设置为实时模式.</i>
        </font></center>

<p>确保场景中的所有对象都使用我们的白色材质。 像上次一样，球体都是动态的，而其他的都是静态几何体。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605003421685-903339628.png" width="250" /><font size="2.5">
            <i>只有动态对象能接收实时的全局光照.</i>
        </font></center>

<p>事实证明，只有动态对象会受益于实时全局光照。静态物体会变的暗一点。这是因为光照探针自动并入实时全局光照。而静态对象必须对实时的光照贴图进行采样，而这些光照贴图与烘焙的光照贴图不同。我们的着色器还不支持。</p>

<h3 id="烘焙的全局光照">烘焙的全局光照</h3>

<p>Unity在编辑模式下已经生成了实时的光照贴图，所以你可以随时查看实时的全局光照贴图。在编辑模式和播放模式之间进行切换的时候，这些贴图不会被保留，但是它们最终会得到相同的结果。你可以通过“光照”窗口的“对象贴图”选项来选择一个光照贴图静态对象对实时光照贴图进行检查。 选择“实时强度“可以可视化的查看实时光照贴图的数据。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605003617860-357493611.png" width="250" /><font size="2.5">
            <i>实时光照贴图，屋顶被选中时候的状态.</i>
        </font></center>

<p>虽然实时光照贴图已经被烘焙出来，并且它们还可能显示正确，但我们的meta渲染通道实际上使用的是错误的坐标。实时全局光照具有自己的光照贴图坐标，最终可能与静态光照贴图的坐标不同。Unity会根据光照贴图和对象的设置来自动生成这些坐标。这些数据存储在第三套UV中。所以将这些数据添加到My Lightmapping中的VertexData里面。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv2</span> <span class="o">:</span> <span class="nb">TEXCOORD2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>现在，MyLightmappingVertexProgram必须使用第二个或是第三个UV坐标，以及静态或动态光照贴图的大小和偏移量。 我们可以依靠UnityMetaVertexPosition函数来使用正确的数据。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyLightmappingVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
<span class="c1">//    v.vertex.xy = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;</span>
<span class="c1">//    v.vertex.z = v.vertex.z &gt; 0 ? 0.0001 : 0;</span>
<span class="c1">//    i.pos = UnityObjectToClipPos(v.vertex);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityMetaVertexPosition</span><span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv2</span><span class="p">,</span> <span class="n">unity_LightmapST</span><span class="p">,</span> <span class="n">unity_DynamicLightmapST</span>
    <span class="p">);</span>

    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityMetaVertexPosition</span><span class="err">是什么样子的？</span>

<span class="err">它除了通过</span><span class="n">unity_MetaVertexControl</span><span class="err">提供的标志来决定使用哪些坐标集和光照贴图之外，它还做了我们以前做的工作。</span>
<span class="kt">float4</span> <span class="nf">UnityMetaVertexPosition</span> <span class="p">(</span>
    <span class="kt">float4</span> <span class="n">vertex</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uv1</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uv2</span><span class="p">,</span>
    <span class="kt">float4</span> <span class="n">lightmapST</span><span class="p">,</span> <span class="kt">float4</span> <span class="n">dynlightmapST</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaVertexControl</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">uv1</span> <span class="o">*</span> <span class="n">lightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">lightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
        <span class="c1">// OpenGL right now needs to actually use incoming vertex position,</span>
        <span class="c1">// so use it in a very dummy way</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">1.0e-4</span><span class="n">f</span> <span class="o">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaVertexControl</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">uv2</span> <span class="o">*</span> <span class="n">dynlightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">dynlightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
        <span class="c1">// OpenGL right now needs to actually use incoming vertex position,</span>
        <span class="c1">// so use it in a very dummy way</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">1.0e-4</span><span class="n">f</span> <span class="o">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>请注意，<strong>meta渲染通道既用于烘焙光照贴图，也用于实时光照贴图</strong>。所以当使用实时全局光照的时候，meta渲染通道也将被包含在构建中。</p>

<h3 id="对实时光照贴图进行采样">对实时光照贴图进行采样</h3>

<p>为了对实时光照贴图进行采样，我们还必须将第三个UV坐标添加到My Lightmapping中的VertexData里面。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="nb">NORMAL</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">tangent</span> <span class="o">:</span> <span class="nb">TANGENT</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv2</span> <span class="o">:</span> <span class="nb">TEXCOORD2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>当一张实时光照贴图被使用的时候，我们必须将这个光照贴图的坐标添加到我们的插值器中去。标准着色器在单个插值器中将两个光照贴图的坐标集合组合起来 - 与其他数据复用 - 但是我们可以为两者准备单独的插值器。当_DYNAMICLIGHTMAP_ON_关键字被定义的时候，我们知道有动态光照数据。它是multi_compile_fwdbase编译器指令的关键字列表的一部分。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> 
<span class="p">{</span>
    <span class="cp">#if defined(DYNAMICLIGHTMAP_ON)
</span>        <span class="kt">float2</span> <span class="n">dynamicLightmapUV</span> <span class="o">:</span> <span class="n">TEXCOORD7</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>填充坐标就像对静态光照贴图的坐标所做的事情一样，除了动态光照图的缩放比例和偏移量的设置以外，这些可以通过unity_DynamicLightmapST变得可用。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined(DYNAMICLIGHTMAP_ON)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">dynamicLightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv2</span> <span class="o">*</span> <span class="n">unity_DynamicLightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_DynamicLightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>对实时光照贴图的采样是在我们的CreateIndirectLight函数中完成的。复制 #if defined(LIGHTMAP_ON) 代码块并进行一些更改。 <strong>首先</strong>，新的部分是基于DYNAMICLIGHTMAP_ON关键字的。 <strong>此外</strong>，它应该使用DecodeRealtimeLightmap而不是DecodeLightmap，这是因为实时光照贴图使用不同的颜色格式。而且因为这些数据可能被添加到烘焙光照中，不要立即分配给indirectLight.diffuse，而是使用最后添加的中间变量。 <strong>最后</strong>，当不使用烘焙光照贴图和实时光照贴图的时候，我们只应该对球面谐波进行采样。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(LIGHTMAP_ON)
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span>    <span class="n">DecodeLightmap</span><span class="p">(</span><span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">));</span>
    <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>        <span class="kt">float4</span> <span class="n">lightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
            <span class="n">unity_LightmapInd</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span>
        <span class="p">);</span>
        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeDirectionalLightmap</span><span class="p">(</span>
            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">lightmapDirection</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span>
        <span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="n">ApplySubtractiveLighting</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">);</span>
   <span class="c1">// #else</span>
   <span class="c1">// indirectLight.diffuse += max(0, ShadeSH9(float4(i.normal, 1)));</span>
<span class="cp">#endif
</span>
<span class="cp">#if defined(DYNAMICLIGHTMAP_ON)
</span>    <span class="kt">float3</span> <span class="n">dynamicLightDiffuse</span> <span class="o">=</span> <span class="n">DecodeRealtimeLightmap</span><span class="p">(</span>
        <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_DynamicLightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">dynamicLightmapUV</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>        <span class="kt">float4</span> <span class="n">dynamicLightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
            <span class="n">unity_DynamicDirectionality</span><span class="p">,</span> <span class="n">unity_DynamicLightmap</span><span class="p">,</span>
            <span class="n">i</span><span class="p">.</span><span class="n">dynamicLightmapUV</span>
        <span class="p">);</span>
                <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="n">DecodeDirectionalLightmap</span><span class="p">(</span>
                    <span class="n">dynamicLightDiffuse</span><span class="p">,</span> <span class="n">dynamicLightmapDirection</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span>
                <span class="p">);</span>
    <span class="cp">#else
</span>        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="n">dynamicLightDiffuse</span><span class="p">;</span>
    <span class="cp">#endif
#endif
</span>
<span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013216623-414124444.png" width="250" /><font size="2.5">
            <i>把实时全局光照应用于一切物体之上.</i>
        </font></center>

<p>现在我们的着色器使用的是实时光照贴图。最初，当使用Distance Shadowmask模式的时候，它的效果可能看起来与使用混合光源的烘焙光照的效果相同。当在播放模式下关闭光源的时候，差异就变得非常明显。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013217805-1029939389.png" width="250" /><font size="2.5">
            <i>禁用混合光源以后，间接光照仍然被保留.</i>
        </font></center>

<p>禁用混合光源以后，其间接光照将保持不变。相比之下，实时光照的间接贡献就会消失，并重新出现 - 这是应该出现的情况。 不过，新情况的完全烘焙好可能需要一段时间。 Enlighten系统会逐步调整光照贴图和光照探针。 这种情况发生的速度取决于场景的复杂性和实时全局光照CPU质量设置。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013219337-640958770.gif" width="250" /><font size="2.5">
            <i>切换实时光与实时GI.</i>
        </font></center>

<p>所有实时光源都对实时全局光照有贡献。 然而，它的典型用途是那些仅在主要方向上存在光线的光源，比如可以代表太阳，因为它在天空中移动。它适用于方向光源。点光源和聚光光源也能工作，但只是没有阴影。所以<strong>当使用带有阴影的点光源或聚光光源的时候，你可能会遇到不正确的间接光照结果</strong>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013220298-1170450196.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013221104-52400640.png" width="250" /><font size="2.5">
            <i>没有影响的间接光源和实时的聚光光源.</i>
        </font></center>

<p>如果要从实时全局光照里面去掉一个实时光源，可以通过设置它的Indirect Multiplier将它的光强度设置为零。</p>

<h3 id="自发光光源">自发光光源</h3>

<p>实时全局光照也可以用于自发光的静态物体。这使得可以匹配实时间接光照来改变物体的自发光变得可能。让我们来试试看吧。向场景中添加一个静态球体，并赋予它一个使用我们着色器的材质，这个材质具有黑色的反照率和白色的自发光颜色。最初，我们只能看到通过静态光照贴图实现的自发光的间接效果。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013222060-1153434303.png" width="250" /><font size="2.5">
            <i>用自发光球来烘焙全局光照.</i>
        </font></center>

<p>要将自发光光源烘焙到静态光照贴图中，我们必须在我们的着色器的GUI中设置材质的全局光照标志。因为我们总是将标志设置为BakedEmissive，光源最终将以烘焙好的光照贴图的形式出现。如果自发光光源是恒定的这个效果是很不错的，但这样就不允许我们做动画控制。</p>

<p>为了同时对自发光光源支持烘焙和实时光照，我们必须使其可配置化。我们可以通过向MyLightingShaderGUI中添加一个选项来做到这一点，使用的是MaterialEditor.LightmapEmissionProperty方法。这个方法的单个参数是属性的缩进级别。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoEmission</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialProperty</span> <span class="n">map</span> <span class="o">=</span> <span class="n">FindProperty</span><span class="p">(</span><span class="s">"_EmissionMap"</span><span class="p">);</span>
    <span class="n">Texture</span> <span class="n">tex</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">;</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="n">BeginChangeCheck</span><span class="p">();</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">TexturePropertyWithHDRColor</span><span class="p">(</span>
        <span class="n">MakeLabel</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">"Emission (RGB)"</span><span class="p">),</span> <span class="n">map</span><span class="p">,</span> <span class="n">FindProperty</span><span class="p">(</span><span class="s">"_Emission"</span><span class="p">),</span>
        <span class="n">emissionConfig</span><span class="p">,</span> <span class="nb">false</span>
    <span class="p">);</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">LightmapEmissionProperty</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="n">EndChangeCheck</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tex</span> <span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">SetKeyword</span><span class="p">(</span><span class="s">"_EMISSION_MAP"</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">editor</span><span class="p">.</span><span class="n">targets</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">globalIlluminationFlags</span> <span class="o">=</span>
                <span class="n">MaterialGlobalIlluminationFlags</span><span class="p">.</span><span class="n">BakedEmissive</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>每次当自发光属性发生改变的时候，我们也必须停止覆盖这个标志位。其实真正要做的事情比这更复杂一点。其中一个标志选项是EmissiveIsBlack，这个表示表示的是自发光计算可以跳过。这个标志总是会针对新材质进行设置。要让间接自发光能够工作，我们必须保证这个标志不被设置，无论我们选择实时光照还是烘焙。我们可以通过总是屏蔽标志值的EmissiveIsBlack位来做到这一点。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">editor</span><span class="p">.</span><span class="n">targets</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">.</span><span class="n">globalIlluminationFlags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MaterialGlobalIlluminationFlags</span><span class="p">.</span><span class="n">EmissiveIsBlack</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013222795-276798177.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013223641-2073252267.png" width="250" /><font size="2.5">
            <i>带有自发光球的实时全局光照效果.</i>
        </font></center>

<p>烘焙全局光照和实时全局光照之间的视觉差异主要是因为实时光照贴图通常具有比烘焙全局光照更低的分辨率。所以当自发光不发生不变化的时候，你也可以使用烘焙全局光照，确保能够利用其更高的分辨率。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EmissiveIsBlack的目的是什么？

这是一个优化，使得计算可以跳过全局光照烘焙过程。然而，只有当自发光颜色确实是黑色的时候，它才依赖于标志。由于这个标志位由着色器的GUI进行设置，这是当材质在检视器里面进行编辑的时候确定的。或者至少，这是Unity的标准着色器的做法。因此，如果自发光颜色稍后被脚本或动画系统更改，则该标志位不会做相应的调整。这是许多人不理解为什么对自发光做动画不会影响到实时全局光照的原因。结果就是如果你想在运行时更改自发光颜色，那么就不要将自发光颜色设置为纯黑色。

我们没有使用这种方法，我们使用的是LightmapEmissionProperty，它还提供了对自发光完全关闭全局光照的选项。 所以这个选择对于用户来说是非常明确的，没有任何隐藏的行为。如果用户不要使用自发光？ 那么只要确保它的全局光照被设置为None就可以了。
</code></pre></div></div>

<h3 id="对自发光进行动画控制">对自发光进行动画控制</h3>

<p>用于自发光的实时全局光照只能用于静态对象。虽然物体是静态的，但其材质的自发光属性还是可以被动画化，并且<strong>将被全局光照系统所捕获到</strong>。让我们用一个在自发光颜色为白色和自发光颜色为黑色之间振荡的简单组件来尝试下这个事情。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">EmissiveOscillator</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="n">Material</span> <span class="n">emissiveMaterial</span><span class="p">;</span>
    <span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">emissiveMaterial</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;().</span><span class="n">material</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">Color</span> <span class="n">c</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span>
            <span class="n">Color</span><span class="p">.</span><span class="n">white</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">black</span><span class="p">,</span>
            <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">Time</span><span class="p">.</span><span class="n">time</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">PI</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5f</span> <span class="p">+</span> <span class="m">0.5f</span>
        <span class="p">);</span>
        <span class="n">emissiveMaterial</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="s">"_Emission"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>将这个组件添加到我们的自发光球体。在播放模式下，自发光将会动画化，但间接光照不受影响。我们必须通知实时光照系统，它有工作要做。这可以通过调用适当网格渲染器的Renderer.UpdateGIMaterials方法来完成。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MeshRenderer</span> <span class="n">emissiveRenderer</span><span class="p">;</span>
<span class="n">Material</span> <span class="n">emissiveMaterial</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">emissiveRenderer</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
    <span class="n">emissiveMaterial</span> <span class="p">=</span> <span class="n">emissiveRenderer</span><span class="p">.</span><span class="n">material</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">emissiveMaterial</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="s">"_Emission"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="n">emissiveRenderer</span><span class="p">.</span><span class="nf">UpdateGIMaterials</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013226755-1065411582.gif" width="250" /><font size="2.5">
            <i>动画控制实时GI.</i>
        </font></center>

<p>调用UpdateGIMaterials方法会触发物体自发光的完整更新，并<strong>使用其meta渲染通道进行渲染</strong>。当自发光比纯色更复杂的时候，这是必要的，举个简单的例子来说，比如说我们使用纹理。如果一个<strong>纯色</strong>就足够了，那么我们可以通过使用渲染器和自发光颜色<strong>调用DynamicGI.SetEmissive方法</strong>来得到一个比较快捷的计算方式。这<strong>比使用meta渲染通道来渲染物体更快</strong>，所以在能够使用的时候可以利用这种方法。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//emissiveRenderer.UpdateGIMaterials();</span>
<span class="n">DynamicGI</span><span class="p">.</span><span class="nf">SetEmissive</span><span class="p">(</span><span class="n">emissiveRenderer</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="光照探针">光照探针</h2>

<p>烘焙全局光照和实时全局光照都通过光照探针应用于动态对象。物体的位置用于对光探针数据进行插值，然后将其用于全局光照。这对于相当小的物体来说下效果很好，但对于较大的物体来说就太粗糙了。</p>

<p>举个简单的例子来是说，将做了比较大拉伸的立方体添加到测试场景，以便它可以受到不同的光照条件的影响。它应该使用我们的白色材质。由于它是一个动态立方体，所以最终使用一个点来确定它的全局光照贡献。让我们移动这个点的位置，使得这一点最终处于一个被遮蔽的位置，那么整个立方体就会变黑，这显然是错误的。为了使这一点非常明显，让我们使用一个烘焙主光源，所以所有光照都来自烘焙全局光照和实时全局光照的数据。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013229006-1893115114.png" width="250" /><font size="2.5">
            <i>对于大型动态物体来说，光照效果不好.</i>
        </font></center>

<p>为了使光照探针器适用于这样的情况，我们可以使用光照探针代理体，或者简称为LPPV。这可以通过向着色器发送插值后的探针器数据网格而不是单个插值后的探针器数据来做到。这需要具有线性滤波的浮点数3D纹理，这就将这个方法限制到只能在现代显卡上使用。此外，还要确保在图形层设置中启用LPPV（光照探针代理体）支持。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013229758-553683463.png" width="250" /><font size="2.5">
            <i>启用了LPPV（光照探针代理体）支持.</i>
        </font></center>

<h3 id="向物体中添加一个光照探针代理体">向物体中添加一个光照探针代理体</h3>

<p>光照探针代理体可以以各种方式设置，最直接的方法是在作为使用光照探针代理体的物体的一个组件。你可以通过Component / Rendering / Light Probe Proxy Volume来添加它。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013230509-1112003195.png" width="250" /><font size="2.5">
            <i>光照探针代理体组件.</i>
        </font></center>

<p>LPPV（光照探针代理体）通过在运行时在光照探针之间进行插值来工作，就好像它们是常规动态对象的网格一样。插值后得到的结果被缓存，刷新模式（Refresh Mode）控制在何时进行更新。默认值为“自动（Automatic）”，这意味着当动态全局光照更改和探针器组发生移动的时候会触发更新。包围盒模式（Bounding Box Mode）控制着代理体的定位。自动本地化（AutomaticLocal ）意味着它会去匹配其附着的对象的包围盒。这些默认设置适用于我们的立方体，因此我们将保留这些设置。</p>

<p>要使我们的立方体实际使用LPPV（光照探针代理体），我们必须将其网格渲染器的光照探针(Light Probes)模式设置为使用光照探针代理体（Use ProxyVolume）。默认行为是使用对象本身的LPPV（光照探针代理体）组件，但也可以强制使用另一个代理体。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013231203-999964017.png" width="250" /><font size="2.5">
            <i>使用一个光照探针代理体而不是常规的探针器.</i>
        </font></center>

<p>自动分辨率模式（automaticresolution mode）对于我们的拉伸立方体不起作用。 因此，将“分辨率模式（Resolution Mode ）”设置为“自定义（Custom ）”，并确保立方体的角上有采样点，并沿着其长边有多个样本点。当你选中这个对象的时候，可以看到这些采样点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013231870-1652713364.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013232779-1496013065.png" width="250" /><font size="2.5">
            <i>自定义探针器分辨率以适应拉伸的立方体.</i>
        </font></center>

<h3 id="对光照探针代理体进行采样">对光照探针代理体进行采样</h3>

<p>立方体已变黑，因为我们的着色器现在还不支持LPPV（光照探针代理体）采样。为了使其工作，我们必须在CreateIndirectLight函数内调整球面谐波代码。当使用LPPV（光照探针代理体）的时候，_UNITY_LIGHT_PROBE_PROXY_VOLUME_被定义为1。我们在这种情况下什么都不做，看看会发生什么。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
</span>    <span class="cp">#if UNITY_LIGHT_PROBE_PROXY_VOLUME
</span>    <span class="c1">//...</span>
    <span class="cp">#else
</span>        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013233601-1847365803.png" width="250" /><font size="2.5">
            <i>没有更多球面谐波的效果.</i>
        </font></center>

<p>得到的结果是所有的球面谐波被禁用，对于不使用LPPV（光照探针代理体）的动态对象也是如此。这是因为_UNITY_LIGHT_PROBE_PROXY_VOLUME_在项目范围内定义，而不是对每个对象实例进行定义。单个对象是否使用LPPV由UnityShaderVariables中定义的unity_ProbeVolumeParams的X分量指定。如果unity_ProbeVolumeParams的X分量设置为1，那么我们有一个LPPV（光照探针代理体），否则我们应该使用常规的球面谐波。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if UNITY_LIGHT_PROBE_PROXY_VOLUME
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="p">}</span>
<span class="cp">#else
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>要对光照探针代理体进行采样，我们可以使用SHEvalLinearL0L1_SampleProbeVolume函数而不是ShadeSH9。这个函数在UnityCG中进行定义，并且需要世界空间中的位置作为额外的参数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SHEvalLinearL0L1_SampleProbeVolume</span>
    <span class="p">(</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span>
    <span class="p">);</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SHEvalLinearL0L1_SampleProbeVolume如何工作？

_顾名思义，该函数仅包括前两个球面谐波带L0和L1。 Unity不使用LPPV（光照探针代理体）的第三个波带。所以我们得到较低质量的光照近似值，但是我们在多个世界空间中的样本之间进行插值，而不是使用单个点。下面是这个函数的代码。_
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">half3</span> <span class="nf">SHEvalLinearL0L1_SampleProbeVolume</span> <span class="p">(</span><span class="kt">half4</span> <span class="n">normal</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">float</span> <span class="n">transformToLocal</span> <span class="o">=</span> <span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">float</span> <span class="n">texelSizeX</span> <span class="o">=</span> <span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>

    <span class="c1">//The SH coefficients textures and probe occlusion</span>
    <span class="c1">// are packed into 1 atlas.</span>
    <span class="c1">//-------------------------</span>
    <span class="c1">//| ShR | ShG | ShB | Occ |</span>
    <span class="c1">//-------------------------</span>

    <span class="kt">float3</span> <span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="n">transformToLocal</span> <span class="o">==</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)</span> <span class="o">?</span>
        <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ProbeVolumeWorldToObject</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span> <span class="o">:</span>
        <span class="n">worldPos</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">texCoord</span> <span class="o">=</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">unity_ProbeVolumeMin</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">unity_ProbeVolumeSizeInv</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span><span class="p">;</span>

    <span class="c1">// We need to compute proper X coordinate to sample. Clamp the</span>
    <span class="c1">// coordinate otherwize we'll have leaking between RGB coefficients</span>
    <span class="n">float</span> <span class="n">texCoordX</span> <span class="o">=</span>
        <span class="nb">clamp</span><span class="p">(</span><span class="n">texCoord</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span> <span class="o">*</span> <span class="n">texelSizeX</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span> <span class="o">*</span> <span class="n">texelSizeX</span><span class="p">);</span>

    <span class="c1">// sampler state comes from SHr (all SH textures share the same sampler)</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoordX</span><span class="p">;</span>
    <span class="kt">half4</span> <span class="n">SHAr</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX3D_SAMPLER</span><span class="p">(</span>
        <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">texCoord</span>
    <span class="p">);</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoordX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">half4</span> <span class="n">SHAg</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX3D_SAMPLER</span><span class="p">(</span>
        <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">texCoord</span>
    <span class="p">);</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoordX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">half4</span> <span class="n">SHAb</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX3D_SAMPLER</span><span class="p">(</span>
        <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">texCoord</span>
    <span class="p">);</span>
    <span class="c1">// Linear + constant polynomial terms</span>
    <span class="kt">half3</span> <span class="n">x1</span><span class="p">;</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">SHAr</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">SHAg</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">SHAb</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">x1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013235369-787618137.png" width="250" /><font size="2.5">
            <i>采样后的LPPV（光照探针代理体）的效果，在伽马空间中的效果太暗.</i>
        </font></center>

<p>我们的着色器现在在需要的时候对LPPV（光照探针代理体）进行采样，但结果太暗了。至少在伽马颜色空间中工作就是这样的结果。这是因为球面谐波数据存储在线性空间中。因此，可能需要进行颜色的转换。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SHEvalLinearL0L1_SampleProbeVolume</span><span class="p">(</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span>
    <span class="p">);</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
    <span class="cp">#if defined(UNITY_COLORSPACE_GAMMA)
</span>               <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">LinearToGammaSpace</span><span class="p">(</span><span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
        <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013236310-749557848.png" width="250" /><font size="2.5">
            <i>采样后的LPPV（光照探针代理体）的效果，带有正确的颜色.</i>
        </font></center>

<h2 id="lod-groups">LOD Groups</h2>

<p>当一个对象最终只覆盖应用程序窗口的一小部分的时候，你不需要高度详细的网格来渲染它。你可以根据对象在视图中的大小使用不同的网格。这被称为细节层次，或简称LOD。Unity允许我们通过组件LOD组来实现这样的功能。</p>

<h3 id="创建一个lod层次结构">创建一个LOD层次结构</h3>

<p>这个想法是你在各种不同的LOD等级使用同一网格的多个版本。最高级 - LOD 0 - 具有最多的顶点、子对象、动画、复杂的材质等。随后的级别逐渐变得更简单，更容易计算。在理想情况下，相邻的LOD等级被设计为使得当Unity从一个LOD等级切换到另一个LOD等级的时候，你不能轻易地辨别出它们之间的区别。否则突然有LOD等级变化的时候就会让人很晕。但是在研究这种技术的时候，我们会使用明显的不同的网格。</p>

<p>创建一个空的游戏对象并给它两个子对象。第一个子对象是标准球体，第二个子对象是标准立方体，其大小设置为0.75。 预期的结果看起来像是一个重叠的球体和立方体。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013237093-2016130218.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013237695-361227834.png" width="250" /><font size="2.5">
            <i>球体和立方体作为一个对象.</i>
        </font></center>

<p>通过Component /Rendering / LOD Group将一个LOD组组件添加到父对象。你会得到一个具有默认设置的LOD组，它有三个LOD等级。 百分比是指由对象的包围盒覆盖的窗口的垂直部分。因此，当垂直尺寸下降到窗口高度的60％的时候，默认设置为切换到LOD 1，当垂直尺寸下降到窗口高度的30％的时候，默认设置为切换到LOD 2。当垂直尺寸下降到窗口高度的10％的时候，它根本不渲染。 你可以通过拖动LOD框的边来更改这些阈值。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013238446-1711254101.png" width="250" /><font size="2.5">
            <i>组件LOD组.</i>
        </font></center>

<p>这些阈值由LOD偏移（LOD Bias）进行修改，LOD偏移（LOD Bias）可以在组件检视器里面查看并修改。目前使用的是质量设置为2的默认值，这意味着阈值被减半。也可以设置为最大LOD等级，这将导致跳过最高级别。</p>

<p>为了使其工作，你必须告诉组件每个LOD等级都会使用哪些对象。这是通过选择一个LOD块并将对象添加到其“渲染器”列表中完成的。你可以在场景中添加任何对象，但一定要确保添加其子对象到LOD块的“渲染器”列表。让LOD 0的“渲染器”使用球体，让LOD 1的“渲染器”使用立方体。我们将LOD 2的“渲染器”留空，所以我们只有两个LOD等级。如果需要的话，你可以通过右键单击上下文菜单删除并插入LOD等级。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013239110-167141319.png" width="250" /><font size="2.5">
            <i>让球这个子物体使用LOD 0等级.</i>
        </font></center>

<p>一旦配置了LOD等级，你可以通过移动相机来查看它们的效果。如果物体足够大的话，它将使用球体，否则的话它将使用立方体，或根本不会渲染。</p>

<center>
    <video controls="" width="" loop="true" autoplay="true" preload="auto">
        <source src="https://thumbs.gfycat.com/ShyAffectionateFairyfly-mobile.mp4" type="video/mp4" />
    </video>
</center>
<font size="2.5">
        <center><i><b>LOD切换.</b></i></center>    
    </font>

<h3 id="烘焙全局光照和lod组">烘焙全局光照和LOD组</h3>

<p>因为LOD组是如何渲染的取决于它的<strong>视图大小</strong>，所以它们自然是动态的。但是，你仍然可以使其成为静态。对整个对象层次结构执行此操作，因此也包括了根节点和它的两个子节点。然后设置主光源为烘焙光源，看看会发生什么。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013240110-283978428.png" width="250" /><font size="2.5">
            <i>让球这个子物体使用LOD 0等级.</i>
        </font></center>

<p><em>使用烘焙光源得到的效果</em></p>

<p>看起来在烘焙静态光照贴图的时候使用的是LOD 0。 我们最终总是能够看到球体的阴影和间接光照的贡献，即使LOD组切换到一个立方体或是对自身做了剔除。但请注意，立方体也是使用了静态光照贴图。 所以它不使用光照探针，对吧？ 转动光照探针组就能发现这一点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013241019-1435398902.png" width="250" /><font size="2.5">
            <i>没有光照探针时候的烘焙光照.</i>
        </font></center>

<p>禁用光探针组会使得立方体变得更暗。这意味着他们不再接受间接光照。 这是因为在烘焙过程中确定间接光照的时候使用的是LOD 0。为了找到其他LOD等级下的间接光照， Unity可以做到的最好程度是依靠烘焙光照探针。 因此，即使在运行时我们不需要光照探针，我们也需要光照探针来为我们的立方体计算间接光照。</p>

<h3 id="实时全局光照和lod组">实时全局光照和LOD组</h3>

<p>当只使用实时全局光照的时候，方法是类似的，除了我们的立方体现在在运行时使用的是光照探针。你可以通过选择球体或立方体来验证这一点。选择立方体后，你可以看到小工具显示了哪些光照探针被使用。 球体不显示它们，因为它使用的是动态光照贴图。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013242971-183808454.png" width="250" /><font size="2.5">
            <i>LOD 1使用光照探针来计算实时全局光照.</i>
        </font></center>

<p>当烘焙全局光照和实时全局光照同时使用的时候，它会变得更加复杂。 在这种情况下，立方体应该对烘焙全局光照使用光照贴图，对实时全局光照使用光照探针。不幸的是，这是不可能的，这是因为光照贴图和和球面谐波不能同时使用。这是一个非此即彼的问题。因为光照贴图数据对于立方体来说是可用的，所以Unity最终会使用它。因此，立方体不受实时全局光照的影响。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013243831-1402316420.png" width="250" /><font size="2.5">
            <i>仅对LOD 1等级使用烘焙光照，使用的是低强度的主光源.</i>
        </font></center>

<p>一个重要的细节是，烘焙的LOD等级和渲染的LOD等级是完全独立的。 他们不需要使用相同的设置。如果实时全局光照最终比烘焙全局光照更重要，你可以强制立方体使用光照探针，确保它对于光照贴图来说不是静态的，同时保持球体静止。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013244794-1245713384.png" width="250" /><font size="2.5">
            <i>LOD 1强制使用光照探针.</i>
        </font></center>

<h3 id="lod淡入淡出功能">LOD淡入淡出功能</h3>

<p>LOD组这种方法的缺点是，当LOD等级发生变化的时候，它可以在视觉上很明显的表现出来。几何体会在视图中突然弹出、消失或改变形状。 这可以通过相邻LOD等级之间的淡入淡出来缓解，这通过将LOD组的渐变模式设置为淡入淡出来完成。还有另一种渐变模式，由Unity用于SpeedTree对象，我们不会使用这种模式。</p>

<p>当启用淡入淡出的时候，每个LOD等级都会显示一个淡入变换宽度（Fade Transition Width ）字段，用于控制其块的哪个部分用于衰落。举个简单的例子来说，当设置为0.5的时候，一半LOD范围将用于淡出到下一级。或者，淡入淡出过程可以是有动画的，在这种情况下，在LOD等级之间的切换需要大约半秒钟。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013245526-1175118666.png" width="250" /><font size="2.5">
            <i>带有0.5变换宽度的淡入淡出.</i>
        </font></center>

<p>当启用淡入淡出的时候，在LOD组之间进行转换的时候会同时渲染两个LOD等级。</p>

<h3 id="支持淡入淡出">支持淡入淡出</h3>

<p>Unity的标准着色器在默认情况下是不支持淡入淡出的。如果想要支持支持淡入淡出的话，你必须复制标准着色器并为LOD_FADE_CROSSFADE关键字添加一个多编译指令。添加这条指令还有一个原因是为了在My First Lighting着色器里面支持淡入淡出功能。让我们将这条指令添加到除了meta渲染通道以外的所有渲染通道。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ LOD_FADE_CROSSFADE
</span></code></pre></div></div>

<p>我们将使用抖动来在LOD等级之间进行转换。这种方法适用于前向渲染和延迟渲染，也适用于有阴影的情况。</p>

<p>在创建半透明阴影的时候，我们已经使用了抖动这种方法。它需要片段的屏幕空间坐标，这迫使我们为顶点程序和片段程序使用不同的插值器结构。所以让我们复制My Lighting 中的Interpolators结构，将其重命名为InterpolatorsVertex。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>

<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>

<span class="p">};</span>

<span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当我们必须进行淡入淡出处理的时候，片段程序的插值器里面必须包含vpos，否则我们可以使用同样的位置信息。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UNITY_VPOS_TYPE</span> <span class="n">vpos</span> <span class="o">:</span> <span class="nb">VPOS</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>我们可以在我们片段程序中开始的位置使用UnityApplyDitherCrossFade函数来执行淡入淡出操作。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnityApplyDitherCrossFade是如何工作的？

这个函数在UnityCG中进行定义。它的方法类似于我们在《渲染12:半透明阴影》中使用的抖动方法，区别只是整个对象的抖动级别是均匀的。 因此，不需要混合抖动级别。 它使用存储在4×64大小的二维纹理中的16个抖动级别，而不是4×4×16大小的三维纹理。
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>unity_LODFade变量在UnityShaderVariables中进行定义。它的Y分量包含的是对象的渐变量，共有十六步。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013246331-642394563.png" width="250" /><font size="2.5">
            <i>通过抖动方法得到的淡入淡出几何体.</i>
        </font></center>

<p>淡入淡出现在可以在几何体上正常工作了。为了使其适用于阴影，我们必须调整My Shadows着色器。 首先，当我们进行淡入淡出处理的时候，必须使用vpos。其次，我们还必须在片段程序开始的位置使用UnityApplyDitherCrossFade函数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if SHADOWS_SEMITRANSPARENT || defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UNITY_VPOS_TYPE</span> <span class="n">vpos</span> <span class="o">:</span> <span class="nb">VPOS</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">positions</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="kt">float4</span> <span class="nf">MyShadowFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013247225-2138491287.png" width="250" /><body></body>
        <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender18/1692664-20200605013249358-581600268.gif" width="250" /><font size="2.5">
            <i>对几何体和阴影都做了淡入淡出处理.</i>
        </font></center>

<p>因为立方体和球体相互交叉，所以我们在对它们做淡入淡出处理的时候，得到一些奇怪的自阴影效果。这对于看到淡入淡出处理能在阴影上起作用是很方便的，但是当你为实际游戏创建LOD几何体的时候，需要注意这些瑕疵。</p>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><category term="Unity3d API" /><summary type="html"><![CDATA[了解间接光需要知道光在静态表面之间如何反射。重点在于哪些表面可能会受到其他表面的影响，以及程度如何。弄清这些关系需要做很多的工作，不能实时完成。所以这个数据由编辑器处理并存储在运行时使用。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/posts/2018/month1/catRender18/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/posts/2018/month1/catRender18/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>