<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://www.damonc.top/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.damonc.top/" rel="alternate" type="text/html" /><updated>2025-03-26T00:08:55+08:00</updated><id>https://www.damonc.top/feed.xml</id><title type="html">仗剑天涯</title><subtitle>个人的一个技术博客站点，记录生活、工作、学习中的一些小事，以及一些比较有趣的事情，留点什么东西也挺不错的，偶尔会在这里停留。</subtitle><author><name>仗剑天涯</name></author><entry><title type="html">Unity Addressable System使用分析(三)</title><link href="https://www.damonc.top/unity3d/Unity_Addressable_Build.html" rel="alternate" type="text/html" title="Unity Addressable System使用分析(三)" /><published>2024-07-15T20:00:00+08:00</published><updated>2024-07-15T20:00:00+08:00</updated><id>https://www.damonc.top/unity3d/Unity_Addressable_Build</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Addressable_Build.html"><![CDATA[<h2 id="addressable初始化">Addressable初始化</h2>

<p>  AA初始化调用函数<code class="language-plaintext highlighter-rouge">Addressables.InitializeAsync(autoReleaseHandle)</code>，返回AsyncOperationHandle。参数autoReleaseHandle是控制Handle是否自动释放，默认是true会自动释放。虽然成功执行了初始化，但是想要拿到AsyncOperationHandle的结果就不能让它自动释放，如果访问会提示handle无效。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AsyncOperationHandle</span><span class="p">&lt;</span><span class="n">IResourceLocator</span><span class="p">&gt;</span> <span class="n">handle</span> <span class="p">=</span> <span class="n">Addressables</span><span class="p">.</span><span class="nf">InitializeAsync</span><span class="p">();</span>
<span class="k">yield</span> <span class="k">return</span> <span class="n">handle</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="p">.</span><span class="n">Status</span> <span class="p">!=</span> <span class="n">AsyncOperationStatus</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Initialization Error"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  AA初始化返回结果就是本地的Catalog.bundle对象，使用DefaultBuildScript打AssetBundle结果会保存在<code class="language-plaintext highlighter-rouge">Library/com.unity.addressables/aa/平台/</code>。Initial加载的就是本地最新的Catalog对象，如果是真机就会加载打包APK时最初打进包的Catalog对象。</p>

<h3 id="catalog结构">Catalog结构</h3>

<p>  Catalog加载后会构建成<code class="language-plaintext highlighter-rouge">ResourceLocationMap</code>对象，该数据对象就是记录了一个Bundle的所保存的地址信息(本地还是远程)。加载Catalog流程：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用户代码中调用</span>
<span class="n">Addressables</span><span class="p">.</span><span class="nf">InitializeAsync</span><span class="p">();</span>

<span class="c1">// 内部实际调用</span>
<span class="n">AddressablesImpl</span><span class="p">.</span><span class="nf">InitializeAsync</span><span class="p">()</span> <span class="err">→</span> <span class="n">ResourceManager</span><span class="p">.</span><span class="nf">StartOperation</span><span class="p">()</span>

<span class="c1">// 在 InitializeAsync 内部</span>
<span class="n">InitializationOperation</span> <span class="n">operation</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">InitializationOperation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="k">return</span> <span class="n">ResourceManager</span><span class="p">.</span><span class="nf">StartOperation</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="k">default</span><span class="p">);</span>

<span class="c1">// InitializationOperation 中</span>
<span class="c1">// 1. 首先加载主 Catalog 文件</span>
<span class="nf">LoadContentCatalogInternal</span><span class="p">(</span><span class="n">m_ResourceLocators</span><span class="p">,</span> <span class="n">s_Settings</span><span class="p">.</span><span class="n">catalogLocation</span><span class="p">,</span> <span class="p">...);</span>

<span class="c1">// 2. 然后加载额外的 Catalog 文件，包括远程的catalog(如果有配置)</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">catalogLocation</span> <span class="k">in</span> <span class="n">s_Settings</span><span class="p">.</span><span class="n">catalogLocations</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">LoadContentCatalogInternal</span><span class="p">(</span><span class="n">m_ResourceLocators</span><span class="p">,</span> <span class="n">catalogLocation</span><span class="p">,</span> <span class="p">...);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  当 Catalog 加载完成后，系统会解析其中的内容并构建 ResourceLocationMap：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在ContentCatalogProvider.cs 中</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ContentCatalogProvider</span> <span class="p">:</span> <span class="n">IResourceProvider</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnCatalogLoaded</span><span class="p">(</span><span class="n">ContentCatalogData</span> <span class="n">catalogData</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 创建 ResourceLocationMap</span>
        <span class="kt">var</span> <span class="n">locMap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ResourceLocationMap</span><span class="p">(</span><span class="n">catalogData</span><span class="p">);</span>
        
        <span class="c1">// 处理内部 ID 映射</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">kvp</span> <span class="k">in</span> <span class="n">catalogData</span><span class="p">.</span><span class="n">InternalIds</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 建立 key -&gt; location[]的映射</span>
            <span class="kt">string</span> <span class="n">key</span> <span class="p">=</span> <span class="n">kvp</span><span class="p">.</span><span class="n">Key</span><span class="p">;</span>
            <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">locations</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;();</span>
            
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">id</span> <span class="k">in</span> <span class="n">kvp</span><span class="p">.</span><span class="n">Value</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 为每个内部ID创建 ResourceLocation</span>
                <span class="kt">var</span> <span class="n">loc</span> <span class="p">=</span> <span class="nf">CreateLocationForCatalogEntry</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">catalogData</span><span class="p">);</span>
                <span class="n">locations</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">loc</span><span class="p">);</span>
            <span class="p">}</span>
            
            <span class="c1">// 将 locations 添加到 ResourceLocationMap 中</span>
            <span class="n">locMap</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">locations</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// 其他处理...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  <code class="language-plaintext highlighter-rouge">ResourceLocationMap</code>本质上是一个字典结构，它将用户可访问的键映射到对应的资源位置列表：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ResourceLocationMap 的简化结构</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ResourceLocationMap</span> <span class="p">:</span> <span class="n">IResourceLocator</span>
<span class="p">{</span>
    <span class="c1">// 核心数据结构：键 -&gt; 资源位置列表的映射</span>
    <span class="k">private</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;&gt;</span> <span class="n">m_Locations</span><span class="p">;</span>
    
    <span class="k">public</span> <span class="nf">ResourceLocationMap</span><span class="p">(</span><span class="n">ContentCatalogData</span> <span class="n">catalogData</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_Locations</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;&gt;();</span>
        <span class="c1">// 初始化其他元数据...</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">locations</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_Locations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="n">locations</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// IResourceLocator 接口实现</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Locate</span><span class="p">(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="n">Type</span> <span class="n">type</span><span class="p">,</span> <span class="k">out</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">locations</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_Locations</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="n">locations</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// 根据类型筛选位置...</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">locations</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  当所有 Catalog 都处理完成后，ResourceLocationMap 被注册到 Addressables 系统：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在初始化完成时</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">locator</span> <span class="k">in</span> <span class="n">m_ResourceLocators</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 将构建好的 ResourceLocationMap 注册到 ResourceManager</span>
    <span class="n">ResourceManager</span><span class="p">.</span><span class="nf">RegisterLocator</span><span class="p">(</span><span class="n">locator</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="加载远程catalog">加载远程Catalog</h2>

<p>  每次修改文件打包AssetBundle后Catalog是有差异的，为了得到最新AssetBundle就要先下载到最新的Catalog文件然后保存在本地Document目录。AA也提供加载指定地址的Catalog，可以是file:///，也可以是http(s)。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// remoteUrl -&gt; http://localhost:8000/</span>
<span class="n">AsyncOperationHandle</span><span class="p">&lt;</span><span class="n">IResourceLocator</span><span class="p">&gt;</span> <span class="n">remoteHandle</span> <span class="p">=</span> <span class="n">Addressables</span><span class="p">.</span><span class="nf">LoadContentCatalogAsync</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">remoteUrl</span><span class="p">}</span><span class="s">catalog.bundle"</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="k">yield</span> <span class="k">return</span> <span class="n">remoteHandle</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">remoteHandle</span><span class="p">.</span><span class="n">Status</span> <span class="p">!=</span> <span class="n">AsyncOperationStatus</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"InitRemoteLocation Error"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  本地模拟Server，把<code class="language-plaintext highlighter-rouge">Library/com.unity.addressables/aa/平台/</code>下面的Assetbundle和catalog复制到一个目录，在该目录打开cmd，输入python -m http.server 8000会模拟一个文件服务器。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/simulator_server.png" width="250" /><font size="2.5">
            <i>模拟文件服务器.</i>
        </font></center>
<p>  下载好之后就能获取到远程<code class="language-plaintext highlighter-rouge">ResourceLocationMap</code>。现在有了本地和远程Location信息，通过对比就能知道有哪些AssetBundle产生变化。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 缓存AssetBundle Location</span>
<span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_missingBundle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;();</span>
<span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_localBundle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;();</span>

<span class="k">private</span> <span class="n">IEnumerator</span> <span class="nf">CheckRemoteLocation</span><span class="p">(</span><span class="n">IResourceLocator</span> <span class="n">local</span><span class="p">,</span> <span class="n">IResourceLocator</span> <span class="n">remote</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="c1">// 检查本地资源在远程是否存在</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">key</span> <span class="k">in</span> <span class="n">remote</span><span class="p">.</span><span class="n">Keys</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 默认打包的AssetBundle文件后缀带了.bundle，如果修改AA代码就用自定义</span>
        <span class="c1">// 一定要增加一个标记，否则就不能区别bundle名和其他信息的描述名</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">key</span><span class="p">.</span><span class="nf">EndsWith</span><span class="p">(</span><span class="s">".bundle"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Type</span> <span class="n">iAbType</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IAssetBundleResource</span><span class="p">);</span>
        <span class="c1">// Locate定位remoteKey是否在local内，若有表示该AB文件没有差异不用更新</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">local</span><span class="p">.</span><span class="nf">Locate</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">iAbType</span><span class="p">,</span> <span class="k">out</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">localLocations</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// remoteKey不在local内，该AB有差异是最新的需要更新下载</span>
            <span class="n">remote</span><span class="p">.</span><span class="nf">Locate</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">iAbType</span><span class="p">,</span> <span class="k">out</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">remoteLocations</span><span class="p">);</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">remoteLoc</span> <span class="k">in</span> <span class="n">remoteLocations</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_missingBundle</span><span class="p">[</span><span class="n">remoteLoc</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">IResourceLocation</span> <span class="n">location</span> <span class="k">in</span> <span class="n">localLocations</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_localBundle</span><span class="p">[</span><span class="n">location</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新assetbundle">更新AssetBundle</h3>

<p>  现在拿到了<code class="language-plaintext highlighter-rouge">_missingBundle</code>和<code class="language-plaintext highlighter-rouge">_localBundle</code>，现在就要更新AssetBundle。更新AssetBundle就要获取它的最新地址，那么AA也提供了一个回调接口<code class="language-plaintext highlighter-rouge">Addressables.InternalIdTransformFunc</code>，只要注册了该回调，任何加载动作都会进入到该回调，就可以在回调里面进行处理。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Addressables</span><span class="p">.</span><span class="n">InternalIdTransformFunc</span> <span class="p">=</span> <span class="n">InternalIdTransformFunc</span><span class="p">;</span>

<span class="kt">string</span> <span class="nf">InternalIdTransformFunc</span><span class="p">(</span><span class="n">IResourceLocation</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_missingBundle</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">$"</span><span class="p">{</span><span class="n">remoteUrl</span><span class="p">}{</span><span class="n">arg</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_localBundle</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">arg</span><span class="p">.</span><span class="n">InternalId</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">arg</span><span class="p">.</span><span class="n">InternalId</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">IResourceLocation</code>有三个关键信息：<code class="language-plaintext highlighter-rouge">PrimaryKey</code>、<code class="language-plaintext highlighter-rouge">InternalId</code>、<code class="language-plaintext highlighter-rouge">ResourceType</code></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 资源加载名的主要标识符</span>
<span class="k">public</span> <span class="kt">object</span> <span class="n">PrimaryKey</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 资源加载地址</span>
<span class="k">public</span> <span class="kt">string</span> <span class="n">InternalId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 资源加载类型，重点处理IAssetBundleResource、catalog类型</span>
<span class="k">public</span> <span class="n">Type</span> <span class="n">ResourceType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>先处理如何下载、加载最新的catalog
  不管是Initial本地Catalog还是Load远程Catalog，只要注册<code class="language-plaintext highlighter-rouge">InternalIdTransformFunc</code>就可以在函数内处理：
    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="nf">InternalIdTransformFunc</span><span class="p">(</span><span class="n">IResourceLocation</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
 <span class="c1">// 如果argResourceType是catalog类型</span>
     <span class="c1">// 判定本地缓存目录是否有Catalog.bundle，计算bundle的hash是否与catalog.hash一致</span>
         <span class="c1">// 如果一致就加载，直接返回$"{缓存目录}/Catalog.bundle"</span>
         <span class="c1">// 如果没有Catalog.bundle就用包体内的Catalog直接返回arg.InternalId</span>

 <span class="c1">// 如果argResourceType是IAssetBundleResource类型</span>
     <span class="c1">// 判定缓存目录有该文件</span>
     <span class="c1">// 有，直接返回$"{缓存目录}/xxx.bundle"</span>
     <span class="c1">// 没有，直接返回$"{remoteUrl}/xxx.bundle"去下载</span>
 <span class="c1">// 只要能确保Catalog是最新，下载的AssetBundle文件是一定是最新的</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="复杂的更新策略">复杂的更新策略</h2>
<p>  上面我是演示用了一种最简单的更新策略，肯定是不能满足复杂需求的。如果设定Group打包使用hash of file name，也就是确保构建时每个AssetBundle名不变，文件内容hash会发生了变化。那么就要维护一份bundle名映射hash表，一个本地一个远程，每次启动就要检查两张表是否一致、是否有变化，同时检查缓存的最新文件有没有丢失。当然也还有其他的策略就不讨论了。</p>

<h2 id="踩坑">踩坑</h2>
<p>  1. 不能同时存在多个Catalog对象，就是InstantiateAsync了本地Catalog后获取了Result后最好是立即释放掉</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">localLocator</span> <span class="p">=</span> <span class="n">localHandle</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
<span class="n">Addressables</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="n">localHandle</span><span class="p">);</span>
<span class="n">Addressables</span><span class="p">.</span><span class="nf">RemoveResourceLocator</span><span class="p">(</span><span class="n">localLocator</span><span class="p">);</span>
</code></pre></div></div>
<p>  2. <code class="language-plaintext highlighter-rouge">Addressables.ClearResourceLocators()</code>不能随便调用，会丢弃所有Catalog对象。</p>

<p>  3. 游戏重启，如果是在游戏内重启就不能再次初始化<code class="language-plaintext highlighter-rouge">InstantiateAsync</code>了，内部标记了<code class="language-plaintext highlighter-rouge">hasStartedInitialization</code>。</p>]]></content><author><name>仗剑天涯</name></author><category term="Unity3d" /><category term="Addressable System" /><summary type="html"><![CDATA[使用Unity Addressable System进行热更、加载AB包，本文Addressable后续简称AA。]]></summary></entry><entry><title type="html">Unity Addressable System使用分析(二)</title><link href="https://www.damonc.top/unity3d/Unity_Addressabel_Group.html" rel="alternate" type="text/html" title="Unity Addressable System使用分析(二)" /><published>2024-07-12T20:00:00+08:00</published><updated>2024-07-12T20:00:00+08:00</updated><id>https://www.damonc.top/unity3d/Unity_Addressabel_Group</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Addressabel_Group.html"><![CDATA[<h2 id="构建前置准备">构建前置准备</h2>

<p>  AA打包提供了自带脚本<strong><em>BuildScriptPackedMode</em></strong>打包入口有两个：</p>
<ol>
  <li>不带打包结果返回：AddressableAssetSettings.BuildPlayerContent();</li>
  <li>带打包结果的接口：AddressableAssetSettings.BuildPlayerContent(<code class="language-plaintext highlighter-rouge">out AddressablesPlayerBuildResult rst</code>);</li>
</ol>

<h3 id="开始构建">开始构建</h3>

<p>  AddressablesPlayerBuildResult主要记录了打包成功后获取到bundle列表信息，每份bundle都有生成，类似于以前的AssetBundle Menifest结构。这个结果可以序列化保存在本地，方便查看调试各资源之间依赖情况。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> AddressablesPlayerBuildResult结构 </div> </div> <div class="content"> 
<pre><code class="language-CSHARP">//bundle构建后的信息
class BundleBuildResult{
 public string FilePath;
 public string InternalBundleName;
 public AddressableAssetGroup SourceAssetGroup;
 public uint Crc;
 public string Hash;
}
public List&lt;BundleBuildResult&gt; AssetBundleBuildResults =&gt; m_AssetBundleBuildResults;
//catalog hash的路径
public string RemoteCatalogHashFilePath { get; internal set; }
//catalog json的路径
public string RemoteCatalogJsonFilePath { get; internal set; }
//content state的路径
public string ContentStateFilePath { get; internal set; }
</code></pre>



 </div> </div>
<p>  进入到<strong><em>BuildPlayerContent</em></strong>函数，最主要工作之一是对所有Group内的所有Entry资源在打包之前把<code class="language-plaintext highlighter-rouge">BundleFileId</code>置空，这个字段在编辑器打包时有用到。该变量值在打包时多次使用，非常重要！
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/bundle_field_id.png" width="250" /><font size="2.5">
            <i>Debug模式查看到BundleFileId.</i>
        </font></center>
<p>  进入到<strong><em>BuildPlayerContentImpl</em></strong>函数，主要做了三块工作。</p>
<ol>
  <li>检查Addressables BuildPath目录，存在就清空该目录。<code class="language-plaintext highlighter-rouge">BuildPath</code>就是构建bundle的存放目录，这里有一个<code class="language-plaintext highlighter-rouge">清空该目录</code>的操作。</li>
  <li>实例化<code class="language-plaintext highlighter-rouge">AddressablesDataBuilderInput</code>对象，该对象内部初始化：指定构建平台、构建版本号、FileRegistry容器、PreviousContentState置空。</li>
  <li>使用指定的<code class="language-plaintext highlighter-rouge">ActivePlayerDataBuilder</code>构建对象开始构建bundle。</li>
</ol>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 清空目录如何做到增量打包？ </div> </div> <div class="content"> <p>  对于之前使用<strong><em>BuildPipeline.BuildAssetBundles</em></strong>接口打包，默认自带增量打包参数，除非使用ForceRebuildAssetBundle参数指定。</p>

<p>  以前的增量打包的所需条件：</p>

<p>  <strong>(1)</strong>资源没变化且生成目录下的bundle包和对应manifest存在，不会重新打包；</p>

<p>  <strong>(2)</strong>资源没变化即使生成目录下的bundle包被删除了，不会重新打包；</p>

<p>  <strong>(3)</strong>只要生成目录下的bundle包对应的manifase被删除了，会重新打包；</p>

<p>  而现在即使删除了Bundle存放目录，对于增量打包的使用addressables_content_state文件和BuildCache信息组合判断。</p>



 </div> </div>
<p>  <code class="language-plaintext highlighter-rouge">ActivePlayerDataBuilder</code>分析：该对象一定要继承自BuildScriptBase。一定要放在Data Builders列表。一定要给ActivePlayerDataBuilderIndex赋值，或者在Settings的Data Builders列表放在第一位，读取ActivePlayerDataBuilderIndex优先级是高于列表顺序。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/build_play_scripts.png" width="250" /><font size="2.5">
            <i>Data Builders列表就是这个Scripts列表.</i>
        </font></center>

<p>  <code class="language-plaintext highlighter-rouge">FileRegistry</code>分析：文件注册表的作用在构建Bundle期间保存创建Bundle时的存放路径(带hash信息)，然后在Bundle构建的后处理使用ReplaceBundleEntry，使用无hash的路径替换带hash路径。暂时不重要。</p>

<p>  <code class="language-plaintext highlighter-rouge">AddressablesContentState</code>结构与<code class="language-plaintext highlighter-rouge">BundleFileId</code>分析：AddressablesContentState保存了当次构建时所有的Asset缓存信息和Bundle信息，以便在下次构建bundle时读取这些缓存信息。BundleFileId就包含在这些缓存信息内。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AddressablesContentState</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">playerVersion</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">editorVersion</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">CachedAssetState</span><span class="p">[]</span> <span class="n">cachedInfos</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">remoteCatalogLoadPath</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">CachedBundleState</span><span class="p">[]</span> <span class="n">cachedBundles</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CachedAssetState</span> <span class="p">:</span> <span class="n">IEquatable</span><span class="p">&lt;</span><span class="n">CachedAssetState</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">AssetState</span> <span class="n">asset</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">AssetState</span><span class="p">[]</span> <span class="n">dependencies</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">groupGuid</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">bundleFileId</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">CachedAssetState</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CachedBundleState</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">bundleFileId</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="初始化icontextobject">初始化IContextObject</h3>

<p>  进入<strong><em>BuildDataImplementation</em></strong>内，会继续初始化一些数据：调用场景保存(使用SBP管线构建Bundle前一定要保存场景)、初始化AddressableAssetsBuildContext对象、处理所有Group对象。这里有两个重要的数据结构：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ResourceManagerRuntimeData</code>：用于初始化AA的运行时数据，包含许多AA设置时的参数，每次构建都会重新生成。</li>
  <li><code class="language-plaintext highlighter-rouge">AddressableAssetsBuildContext</code>：用于构建过程中数据传递，在后面的Task流的会多次用到IContextObject或IAddressableAssetsBuildContext接口数据。</li>
</ol>

<p><span id="jump1"></span></p>

<h3 id="处理group">处理Group</h3>

<p>  对每个Group的Schema进行预处理，对Group内所有AssetEntry生成一份<code class="language-plaintext highlighter-rouge">ContentCatalogDataEntry</code>运行时寻址数据信息。</p>

<p>  <strong>(1)PlayerDataGroupSchema</strong>分别有场景内的资源和Resource目录内的资源。把该Schema内所有的AssetEntry执行GatherAllAssets：收集该Schema内所有资源(包括subAsset、sprite精灵)装入AddressableAssetEntry收集列表。遍历收集列表执行CreateCatalogEntries创建<code class="language-plaintext highlighter-rouge">ContentCatalogDataEntry</code>数据(IResourceLocation寻址数据，在运行时初始化AA和加载Catalog这一数据非常重要)。</p>

<p>  <strong>(2)BundledAssetGroupSchema</strong>构建bundle配置和包含在Entries列表里的资源，根据BundlePackingMode生成预定义Bundle名，三者的区别是寻址路径参数不一样，<strong>Bundle命名格式</strong>：<code class="language-plaintext highlighter-rouge">groupGuid + _assets_ + address + .bundle</code>。重点说一下PackTogetherByLabel，根据AssetEntry对象内的标签生成Bundle名，选择这个模式命名Bundle，没有特殊需求一般每个Asset只需要一个标签即可，这样一个标签对应多个资源就可以打成一个Bundle。三种模式都会生成一份AssetBundleBuild[]打包数据，然后把该份数据每个BundleName执行ReHash替换(这一步可以定制bundle name)。</p>

<h2 id="开始打包">开始打包</h2>

<p>  实例化ExtractDataTask对象，实例化AddressableAssetsBundleBuildParameters对象，初始化buildTasks，调用SBP管线ContentPipeline.BuildAssetBundles接口开始打包。</p>

<h3 id="contentpipeline">ContentPipeline</h3>

<p>  ContentPipeline是SBP打包管线入口的静态类。在调用BuildAssetBundles后进行了一系列的安全检查；把IBuildTask需要的数据装入BuildContext对象的m_ContextObjects字典；在执行RunTask之前先通过Inject函数操作Task成员变量的FieldInfo，再从BuildContext的m_ContextObjects根据成员变量类型取出Value并写入Field；执行Task Running操作；然后再把Task执行后更新的成员变量数据取出装入BuildContext值。</p>

<h2 id="task管线">Task管线</h2>

<p>  每个Task内的成员变量用属性标记，ContextUsage.In是从BuildContext取出，ContextUsage.InOut是输入输出双向，ContextUsage.Out输出。</p>

<h3 id="switchtobuildplatform">SwitchToBuildPlatform</h3>

<p>  切换到指定的打包平台(如果当前平台不是目标平台触发切换基本要好几十分钟吧).</p>

<h3 id="rebuildspriteatlascache">RebuildSpriteAtlasCache</h3>

<p>  触发所有Sprite Atlas Packing操作，生成所有精灵图集的缓存数据。</p>

<h3 id="buildplayerscripts">BuildPlayerScripts</h3>

<p>  触发所有脚本编译。</p>

<h3 id="postscriptscallback">PostScriptsCallback</h3>

<p>  编译脚本时的回调，要用到这个回调需要给ContentPipeline.BuildCallbacks注册。</p>

<h3 id="calculatescenedependencydata">CalculateSceneDependencyData</h3>

<p>  收集Scene的依赖资源信息。</p>

<h3 id="calculateassetdependencydata">CalculateAssetDependencyData</h3>

<p>  收集资源的依赖信息，有三个最重要的输出数据收集<code class="language-plaintext highlighter-rouge">IBuildResults、IBuildSpriteData、IBuildExtendedAssetData</code>传递给下一个Task，这里有许多Unity内部代码现在看不到，用这三个结果数据倒推这个收集流程，先看看这三个数据结构。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IBuildResults</span> <span class="p">:</span> <span class="n">IContextObject</span>
<span class="p">{</span>
    <span class="n">ScriptCompilationResult</span> <span class="n">ScriptResults</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">WriteResult</span><span class="p">&gt;</span> <span class="n">WriteResults</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">SerializedFileMetaData</span><span class="p">&gt;</span> <span class="n">WriteResultsMetaData</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">GUID</span><span class="p">,</span> <span class="n">AssetResultData</span><span class="p">&gt;</span> <span class="n">AssetResults</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">WriteResult</span><span class="p">{...}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SerializedFileMetaData</span><span class="p">{...}</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">AssetResultData</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GUID</span> <span class="n">Guid</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Hash128</span> <span class="n">Hash</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectIdentifier</span><span class="p">&gt;</span> <span class="n">IncludedObjects</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectIdentifier</span><span class="p">&gt;</span> <span class="n">ReferencedObjects</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">ObjectIdentifier</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Type</span><span class="p">[</span><span class="k">]&gt;</span> <span class="n">ObjectTypes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IBuildSpriteData</span> <span class="p">:</span> <span class="n">IContextObject</span>
<span class="p">{</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">GUID</span><span class="p">,</span> <span class="n">SpriteImporterData</span><span class="p">&gt;</span> <span class="n">ImporterData</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IBuildExtendedAssetData</span> <span class="p">:</span> <span class="n">IContextObject</span>
<span class="p">{</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">GUID</span><span class="p">,</span> <span class="n">ExtendedAssetData</span><span class="p">&gt;</span> <span class="n">ExtendedData</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>(1) 依赖数据新旧对比</strong>，先用TaskOutput的临时结构AssetOutput保存，AssetOutput包含有上述最重要三个数据。通过BuildCache接口根据Asset GUID获取资产信息，这里的缓存都是从Library下的BuildCache读取，若没有缓存会跳过后续的更新缓存数据操作，然后生成缓存保存；若有上次打包的缓存数据，则检查Sprite与Atlas的关联数据在这次打包前是否发生变化，把缓存中有过时的数据需要重新生成数据替换。</p>

<p><strong>(2) 依赖数据收集</strong>，(可跳过不阅读)，具体流程<strong>1)</strong>遍历每个Asset GUID获取Cache Info，如果Data[2]类型是Sprite就加入packedSprites表；<strong>2)</strong>获取该Asset CacheInfo Data[4]类型表并遍历，若是Spirte进入GetPlayerDependenciesForAsset检查其依赖；<strong>3)</strong>遍历所有includedObjects对象并使用ContentBuildInterface.GetPlayerDependenciesForObjects获取该对象的所有依赖，跳过input自身把其他依赖加入otherReferencedAssetObjectsHashSet表；<strong>4)</strong>使用objectLookingAt栈对收集到的依赖对象再次遍历查找，a.对于不是input自身且没有在explicitAssets表内就加入encounteredExplicitAssetDependencies，若是非打包精灵加入mainRepresentationNeeded，b.对于未处理过的隐式资源，更新或创建implicitOutput，查找缓存依赖，将新发现的依赖压入objectLookingAt栈中继续遍历；<strong>5)</strong>最后再执行合并collectedImmediateReferences表和mainRepresentationNeeded表返回最终的依赖信息。</p>

<p><strong>(3) 收集IBuildResults、IBuildSpriteData、IBuildExtendedAssetData</strong>，非Sprite资源走ProcessAsset处理，使用GetPlayerObjectIdentifiersInAsset获取includedObjects ID表，继续使用GetPlayerDependenciesForAsset收集依赖，然后收集资源的表示装入ExtendedAssetData，然后将依赖项扩展为显式资产。最后将assetOutput.asset装入各自的数据结构中。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">internal</span> <span class="k">struct</span> <span class="nc">AssetOutput</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GUID</span> <span class="n">asset</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Hash128</span> <span class="n">Hash</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">AssetLoadInfo</span> <span class="n">assetInfo</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectDependencyInfo</span><span class="p">&gt;</span> <span class="n">objectDependencyInfo</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">BuildUsageTagSet</span> <span class="n">usageTags</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">SpriteImporterData</span> <span class="n">spriteData</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">ExtendedAssetData</span> <span class="n">extendedData</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectTypes</span><span class="p">&gt;</span> <span class="n">objectTypes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CachedInfo</span> <span class="p">:</span> <span class="n">ICachedData</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">CacheEntry</span> <span class="n">Asset</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">CacheEntry</span><span class="p">[]</span> <span class="n">Dependencies</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="cm">/*
    [0]AssetLoadInfo
    [1]BuildUsageTagSet
    [2]SpriteImporterData
    [3]ExtendedAssetData
    [4]List&lt;ObjectTypes&gt;
    [5]List&lt;ObjectDependencyInfo&gt;
    */</span>
    <span class="k">public</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">Data</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="addhashtobundlenametask">AddHashToBundleNameTask</h3>

<p>  如果使用了UniqueBundleIds定义Bundle唯一的标识符，</p>

<h3 id="stripunusedspritesources">StripUnusedSpriteSources</h3>

<p>  剥离未使用的Spirite，从依赖分析的Task获取的IBuildSpriteData数据进行遍历，在m_DependencyData没有用到的Sprite统统剥离，并从IBuildExtendedAssetData的ExtendedData内删除。</p>

<h3 id="generatebundlepacking">GenerateBundlePacking</h3>

<p>  处理资源包打包生成内部文件名、收集资源的对象标识符、过滤和处理资源引用、记录资源到文件的映射，过滤逻辑移除默认资源引用、处理资源间的循环引用、去除重复或不必要的引用</p>

<h3 id="updatebundleobjectlayout">UpdateBundleObjectLayout</h3>

<p>  更新bundle的组织结构，最开始的数据是从ContentPipeline.BuildAssetBundles打包接口参数BundleBuildContent(m_AllBundleInputDefs)对象生成，通过Bundle Packing更新依赖数据后，这块的bundle内部结构数据也要更新。</p>

<h3 id="generatebundlecommands">GenerateBundleCommands</h3>

<p>  为资源和场景生成打包命令，处理自定义资源、遍历资源包布局，根据资源类型创建不同的命令：</p>
<ol>
  <li>资源包命令 (CreateAssetBundleCommand)：创建写入命令、创建使用的列表集、创建引用映射、处理依赖哈希并排序、生成资源包写入操作。</li>
  <li>场景包命令 (CreateSceneBundleCommand)：获取场景文件对象、创建写入命令、处理预加载对象、生成场景加载信息、创建场景包写入操作。</li>
  <li>场景数据命令 (CreateSceneDataCommand)：类似场景包命令、专门处理额外的场景数据。</li>
</ol>

<h3 id="generatesubassetpathmaps">GenerateSubAssetPathMaps</h3>

<p>  创建子资源的加载信息，资源包写入操作集转为internalName与Value的字典映射，遍历ExtendedData的guid数据，通过AssetToFiles取出主资源，通过主资源获取当前guid的info，根据info和资源表示形式CreateSubAssetLoadInfo，然后插入到主资源info的BundleAssets。</p>

<h3 id="generatebundlemaps">GenerateBundleMaps</h3>

<p>  对AssetBundle生成依赖映射和使用集合，BuildReferenceMap详细说明源包中的对象所依赖的其他包中存在哪些对象（前向依赖项）；BuildUsageTagSet 详细说明了源包中的对象需要写入的条件数据，该数据由其他包中的对象使用（反向依赖）。</p>

<h3 id="writeserializedfiles">WriteSerializedFiles</h3>

<p>  把资源包数据分段写入AssetBundle。通过TaskCachingUtility.RunCachedOperation注册本地回调函数分布操作写入：获取缓存、处理未缓存文件hash写入SerializedFileMetaData、保存MetaData数据与WriteResult数据。</p>

<h3 id="archiveandcompressbundles">ArchiveAndCompressBundles</h3>

<p>  压缩写入资源包，创建ArchiveWorkItem集、执行压缩Item的ResourceFiles所有文件并返回crc。</p>

<h3 id="generatelocationliststask">GenerateLocationListsTask</h3>

<p>  创建寻址资产的位置列表，用于描述资源在最终构建包中的位置和加载方式。每个位置列表条目包含以下信息：资源类型、加载路径、提供程序、其他元数据。</p>

<h2 id="打包后处理">打包后处理</h2>

<p>  遍历ContentCatalogDataEntry集合生成主键映射、Bundle ReName、Catalog ReMap、创建Catalog File、保存ContentState。</p>

<h3 id="bundle后处理">Bundle后处理</h3>

<p>  这一步在Bundle压缩写入后。创建下载信息AssetBundleRequestOptions是提供给AssetBundleProvider下载时使用。根据BundleNaming模式重构AssetBundleName，重构命名这一步会影响bundle命名格式，尤其会破坏<a href="#jump1"><code class="language-plaintext highlighter-rouge">1.3处理Group</code></a>这一步的预命名。</p>]]></content><author><name>仗剑天涯</name></author><category term="Unity3d" /><category term="Addressable System" /><summary type="html"><![CDATA[总结在使用Unity Addressable System过程中遇到的一部分问题，该篇主要记录Addressable打AB包、加载AB包，本文Addressable后续简称AA。]]></summary></entry><entry><title type="html">Unity Addressable System使用分析(一)</title><link href="https://www.damonc.top/unity3d/Unity_Addressable_Editor.html" rel="alternate" type="text/html" title="Unity Addressable System使用分析(一)" /><published>2024-07-10T00:00:00+08:00</published><updated>2024-07-10T00:00:00+08:00</updated><id>https://www.damonc.top/unity3d/Unity_Addressable_Editor</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Addressable_Editor.html"><![CDATA[<h2 id="addressable安装">Addressable安装</h2>
<p>  总结在使用Unity Addressable System过程中遇到的一部分问题，该篇主要记录Addressable在Unity编辑器的各种组织结构，本文Addressable后续简称AA，基于1.21.19版本。</p>

<h3 id="package安装">Package安装</h3>
<p>  打开Unity Window - Package Manger，找到Addressable安装找一个合适的版本：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_win_pkg_mgr.png" width="250" /><font size="2.5">
            <i>Addressable Version Seleclt.</i>
        </font></center>

<h3 id="手动安装">手动安装</h3>
<p>  在Package Manager选择一个合适的Addressable版本还要结合Addressable更新log，打开<a href="https：//docs.unity3d.com/Packages/com.unity.addressables@1.21/changelog/CHANGELOG.html"><code class="language-plaintext highlighter-rouge">Addressable更新日志</code></a>，版本列表展示了Address able对应的Unity版本：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_version.png" width="250" /><font size="2.5">
            <i>Addressable Version List.</i>
        </font></center>
<p>  Unity这里分了两个分支维护Addressable，其中一个分支是1.21版本对应的Unity版本是2019+，另一个分支是2.0版本对应的Unity版本是2023+：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_1_21.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_2_0.png" width="250" /><font size="2.5">
            <i>Addressable Branch.</i>
        </font></center>

<p>  2.0以上版本也可以用在非2023版的引擎，主要还是针对2023+ Unity引擎支持新的API什么的。如果想把2.0版本合到1.21，开一Beyond Compare合并差异也行。打开<a href="https：//packages.unity.com/com.unity.addressables"><code class="language-plaintext highlighter-rouge">Addressable Package Json</code></a>，这里列明了每一个Addressable版本对应的Unity版本，结合<a href="https：//docs.unity3d.com/Packages/com.unity.addressables@1.21/changelog/CHANGELOG.html"><code class="language-plaintext highlighter-rouge">Addressable更新日志</code></a>找到一个Bug最少又符合对Unity版本要求的Addressable版本。找到合适的Addressable版本后，打开Packages/manifest.json，手动新增包”com.unity.addressables”:”1.21.19”。</p>

<h3 id="安装addressable依赖">安装Addressable依赖</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_deps.png" width="250" /><font size="2.5">
            <i>Addressable Dependencies.</i>
        </font></center>
<p>  Addressable最重要的依赖是ScriptableBuildPipeline，SBP这个包要更新到1.21.23或2.1.x以上，旧版SBP对SpriteAtlas图集打包会有冗余。打开Packages/manifest.json，强制指定SBP版本”com.unity.scriptablebuildpipeline”:”1.21.23”,
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/sbp_upgrade.png" width="250" /><font size="2.5">
            <i>SBP指定版本.</i>
        </font></center>

<h3 id="addressable结构预览">Addressable结构预览</h3>
<p>  安装好了AA之后，会在Assets生成以下目录：</p>

<table>
  <tbody>
    <tr>
      <td>目录</td>
      <td>说明</td>
    </tr>
    <tr>
      <td>AddressableAssetsData</td>
      <td>根目录也包含几个重要文件</td>
    </tr>
    <tr>
      <td>##Platform</td>
      <td>根据当前平台构建一次AB包后生成的目录</td>
    </tr>
    <tr>
      <td>AssetGroups</td>
      <td>给某资源设置寻址地址并指定Group后的Group描述文件</td>
    </tr>
    <tr>
      <td>Schemas</td>
      <td>Group组的配置包含逻辑结构和特性描述文件</td>
    </tr>
    <tr>
      <td>AssetGroupTemplates</td>
      <td>生成Group的模版描述文件</td>
    </tr>
    <tr>
      <td>DataBuilders</td>
      <td>自定义AssetBundle打包脚本目录</td>
    </tr>
  </tbody>
</table>

<h2 id="addressable各项配置">Addressable各项配置</h2>

<h3 id="addressableassetsettings">AddressableAssetSettings</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_assets_settings.png" width="250" /><font size="2.5">
            <i>AddressableAssetSettings预览.</i>
        </font></center>
<p>  AA的全局配置文件，涉及一些打包配置、热更配置、下载配置等等，下面是每项参数配置说明。</p>

<h3 id="profile">Profile</h3>

<p>  <strong>Profile</strong>主要作用是指定打包地址和加载地址，这里可以配置新增打包Ab的保存目录和HotUpdate热更资源目录的指定路径，建议自定义路径。</p>

<p>  这两个参数的使用地方在不同的AA版本有一点差别：1.20以前的版本在Content Update有用到，1.20以后的版本在Catalog有使用。见<a href="#jump1"><code class="language-plaintext highlighter-rouge">Catalog</code></a>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/profile_in_use.png" width="250" /><font size="2.5">
            <i>Profile预览.</i>
        </font></center>
<p>Profile In Use可以选择系统自带或自定义，其中自定义使用Manager按钮打开Profile Window，点击Create按钮新增变量等参数。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/profile_window.png" width="250" /><font size="2.5">
            <i>Profile Window.</i>
        </font></center>

<p><span id="jump1"></span></p>

<h3 id="catalog">Catalog</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/catalog_attribute.png" width="250" /><font size="2.5">
            <i>Catalog设置面板.</i>
        </font></center>
<p>  Catalog类似于根bundle，记录了当前构建bundle时的依赖和AA的各项设置。</p>
<ul>
  <li><strong>(1) Player Version Override</strong>： 这个参数会对构建好的catalog进行重命名，unity使用时间戳，我们自己可以用自己的构建版本号，格式可以是catalog_1.2.1720684396.json。</li>
  <li><strong>(2) Compress Local Catalog</strong>： 启用会将Catalog.json压缩成Catalog.bundle，显著减少文件size。</li>
  <li><strong>(3) Build Remote Catalog</strong>： 要热更Catalog就要启用。</li>
  <li><strong>(4) Build Path</strong>： 构建Assetbundle的保存地址。</li>
  <li><strong>(5) Load Path</strong>： 加载AssetBundle的地址，这里我是在Profiles设置成了相对地址，然后在加载脚本回调地址逻辑完成后组装完整的加载地址。</li>
  <li><strong>(6) Only Update catalogs manually</strong>： 手动控制更新Catalog时机和方式。</li>
</ul>

<h3 id="update-a-previous-build">Update a Previous Build</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/update_download.png" width="250" /><font size="2.5">
            <i>Update Downloads设置.</i>
        </font></center>

<ul>
  <li><strong>(1) Check for Update Issues</strong>：官方推荐使用List Restricted Assets，在更新过程中对使用了限制更新的Group有限制。</li>
  <li><strong>(2) Content State Build Path</strong>：指定addressables_content_state.bin的保存地址。</li>
</ul>

<p>  该content_state文件只在本地构建时读取进行增量打包，可以看看<a href="https：//docs.unity3d.com/Packages/com.unity.addressables@2.2/manual/content-update-builds-overview.html"><code class="language-plaintext highlighter-rouge">官方workflow</code></a>。简化描述就是要构建更新的AssetBundle，请运行Update a Previous Build脚本。此工具还使用到<code class="language-plaintext highlighter-rouge">addressables_content_state.bin</code>文件，它会重新构建所有内容并会生成到一个修改过的目录，该目录可以访问原始AssetBundle中未更改的内容以及新AssetBundle中更改过的内容。通过打开Groups面板Tools选项Check Content Update Restrictions窗口，只要Group内某个资源有修改，就会出现在这个列表中。但是如果玩家本地用户目录的bundle不小心损坏了或者需要回退资源版本，直接使用Unity这个方案就不好办。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/modify_update_remote.png" width="250" /><font size="2.5">
            <i>修改过的group列表.</i>
        </font></center>

<p>  由于我开了手动更新Catalog，同时自己维护了一套完整的更新列表，就禁用了这条属性。</p>

<h3 id="downloads">Downloads</h3>
<p>  自定义证书、下载并发数量、超时等设置</p>
<ul>
  <li><strong>(1) Custom certificate handler</strong>：自定义证书类要实现CertificateHandler。</li>
  <li><strong>(2) Max Concurrent Web Requests</strong>：设置Web并发下载数量官方建议2-4个。</li>
  <li><strong>(3) Catalog Download Timeout</strong>：超时设置。</li>
</ul>

<h3 id="builds">Builds</h3>

<p>  构建AB包的一些设置
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/setting_build.png" width="250" /><font size="2.5">
            <i>Build设置.</i>
        </font></center>
<ul>
  <li><strong>(1) Build Addressables on Player Build</strong>： 打APK的时候一起先打Assetbundle在打APK，这里我关了不需要，一般是单独出Bundle资源的。</li>
  <li><strong>(2) Ignore Invalid/Unsupported Files in Build</strong>： 构建时排除无效文件，如果未启用可能导致中断构建。</li>
  <li><strong>(3) Unique Bundle IDs</strong>： 指定每个Assetbundle生成唯一标识符。</li>
  <li><strong>(4) Contiguous Bundles</strong>： 定义的Assetbundle内容布局。</li>
  <li><strong>(5) Non-Recursive Dependency Calculation</strong>： 循环依赖计算耗费时间，开启只计算直接依赖。(某些情况下所有设置都正确却无法加载Bundle，一般是Group内的资源依赖有问题。)</li>
  <li><strong>(6) Strip Unity Version From AssetBundles</strong>： 裁剪Assetbundle内的unity版本号，启用。</li>
  <li><strong>(7) Disable Visible Sub Asset Representations</strong>： 不直接拖拽引用某个sprite，开启该项可以加快构建时间。</li>
</ul>

<h3 id="build-and-play-mode-scripts">Build And Play Mode Scripts</h3>

<p>  构建AB的一些脚本配置，可以实现IDataBuilder接口自定义打包流程。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/build_play_scripts.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/play_mode.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/build_mode.png" width="250" /><font size="2.5">
            <i>Build Bundle设置.</i>
        </font></center>
<p>  Play mode指定在编辑器是怎么加载资源，本地测试用</p>
<ul>
  <li><strong>(1) Fast Mode</strong>： 不打包直接加载文件，速度快但在Profiler中提供的信息较少</li>
  <li><strong>(2) Virtual Mode</strong>： 虚拟环境模拟类似于AssetBundle的行为，无需打包</li>
  <li><strong>(3) Packed Mode</strong>： 从实际的AssetBundle中加载资源，真实环境</li>
</ul>

<h2 id="addressablegroups分析">AddressableGroups分析</h2>

<h3 id="group配置">Group配置</h3>

<p>  AssetGroups是Addressable组织bundle的一种容器，必须要把资源加入Group才能参与打包。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/group_view.png" width="250" /><font size="2.5">
            <i>Group设置.</i>
        </font></center>

<ul>
  <li><strong>(1) Buildin&amp;Load Path</strong>：选择Local或Remote，一般选RemotRemotee以支持热更，基本上所有资源都可能会热更。</li>
  <li><strong>(2) AB Compression</strong>：指定AB包用哪种压缩算法：不压缩、LZ4、LZMA。</li>
  <li><strong>(3) Include In Build</strong>： 启用才能构建该组内所包含的Asset Entry。</li>
  <li><strong>(4) Force Unique Provider</strong>：是否指定唯一的Group加载实例，如果Group有上百个就不要勾选了。</li>
  <li><strong>(5) Use AB Cache</strong>：从远程下载的AB是否使用AA的缓存机制。(这个缓存包括AB资源和当前更新时的AA版本信息)</li>
  <li><strong>(6) Use UnityWebRequest for Local Asset Bundles</strong>：对于本地的AB资源是否使用UnityWebRequestAssetBundle GetAssetBundle加载，还是使用AssetBundle LoadFromFileAsync加载。</li>
  <li><strong>(7) Request Timeout</strong>：设置下载超时。</li>
  <li><strong>(8) Use Http Chunked Transfer</strong>：开启分块传输。</li>
  <li><strong>(9) Http Redirect Limit</strong>：设置重定向次数。</li>
  <li><strong>(9) Retry Count</strong>：设置下载失败重试次数。</li>
  <li><strong>(10) Include Addresses in Catalog</strong>： 禁用后构建bundle时不会包含在catalog.json。</li>
  <li><strong>(11) Include GUIDs in Catalog</strong>： 使用AssetReference拖拽引用就得启用。</li>
  <li><strong>(12) Include Labels in Catalog</strong>： 不通过label标签加载资源，我这里不使用label去加载资源。</li>
  <li><strong>(13) Internal Asset Naming Mode</strong>：AB包内资源的ID标识方式，有三种：Full Path(资源全路径)、Filename(资源名)、GUID(unity导入时设置的ID)、Dynamic(官方推荐使用)。这个模式影响Ab的CRC和HASH，设置该模式中任意一种也不会影响我们从AB包内读取某个资源。</li>
  <li><strong>(14) Cache Clear Behavior</strong>：设置APK包内缓存AA下载的AB资源时长，到期自动清除。</li>
  <li><strong>(15) Bundle Mode</strong>：构建AB的模式，有三种：Group内所有资源打成一个AB、Group内资源分别单独打成AB、根据组内标签打包。</li>
  <li><strong>(16) Bundle Naming Mode</strong>：设置AB名，有三种：Group名、 Group名追加HASH、使用Bundle的HASH(推荐-但要做组名与HASH之间的映射，加载Bundle先拿到组名映射的HASH去找Bundle加载)、使用Group组名的字符HASH。</li>
  <li><strong>(17) Asset Load Mode</strong>：资源加载模式，有两种：从bundle请求加载的资源及其依赖一起加载、bundle内所有的资源全部加载。</li>
  <li><strong>(18) Asset Provider</strong>：从Bundle内加载Asset，官方推荐使用自带的Asset from Bundle Provider,也可以根据Group内文件类型选择Json、Sprites等provider。</li>
  <li><strong>(19) Asset Bundle Provider</strong>：加载AssetBundle接口，官方推荐AssetBundle Provider，或者自己实现一套Provider(可以实现加密解密)。</li>
</ul>

<h3 id="content-update">Content Update</h3>
<ul>
  <li><strong>(1) Prevent Updates</strong>：是否启用禁止更新移动Asset。当使用了AA自带的<strong>Check for Content Update Restrictions tool</strong>，不启用时如果组内有资源发生变更，这个工具会把变更的资源移动到需要生成的Remote Group内。(我没有使用这个工具也没有启用这个选项，组内的资源移动实现了一个脚本规则检查)。</li>
</ul>

<h3 id="group-schema配置">Group Schema配置</h3>

<p>  BundledAssetGroupSchema主要是Group面板配置，一个Group会生成两份Schema，<strong>#GroupName_BundledAssetGroupSchema</strong>、<strong>#GroupName_BundledAssetGroupSchema</strong>。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/group_serialize.png" width="250" /><font size="2.5">
            <i>Group Debug模式.</i>
        </font></center>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/schema_serialize1.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/schema_serialize2.png" width="250" /><font size="2.5">
            <i>Schema Debug模式.</i>
        </font></center>

<p>  通过Debug模式可以看到Group主要是保存了<strong>SerializeEntries</strong>资源、<strong>Schema</strong>配置，所以配置实际上是由Schema保存的。在写代码创建Group时，要把资源加入到Group内、配置写到Schema内。</p>
<pre><code class="language-CSHARP">//...
group = settings.CreateGroup(key, i == 0, false, false, null);
AddressableBuildUtil.CheckSchemaValue(group, _keyIdArray);
AddressableBuildUtil.CheckUpdateSchema(group);
//...

SetSchemaBuildLoadPath(schema, keyIds);
schema.ChunkedTransfer = true;
//disable crc 使用md5代替
schema.UseAssetBundleCrc = false;
schema.UseAssetBundleCrcForCachedBundles = false;
//disable guid
schema.IncludeGUIDInCatalog = false;
schema.IncludeLabelsInCatalog = false;
schema.RedirectLimit = 2;
schema.RetryCount = 2;
schema.Timeout = 30;

SetBundleCache(schema);
//load asset by name
SetSchemaNameMode(schema, BundledAssetGroupSchema.AssetNamingMode.Filename);
//pack mode打包模式
SetSchemaPackMode(schema, BundledAssetGroupSchema.BundlePackingMode.PackTogetherByLabel);
//bundle name
SetSchemaNameStyle(schema, BundledAssetGroupSchema.BundleNamingStyle.FileNameHash);
//bundle id
SetSchemaBundleIdMode(schema, BundledAssetGroupSchema.BundleInternalIdMode.GroupGuid);
//bundle compression
SetSchemaBundleCompressionMode(schema, BundledAssetGroupSchema.BundleCompressionMode.LZ4);

//设置Schema Value会触发Group dirty通知，要判断值有没有变再设置
if (schema.BundleMode ~= packMode)
{
    schema.BundleMode = packMode;
}
</code></pre>

<h2 id="assetgrouptemplates">AssetGroupTemplates</h2>
<p>  Group模版配置,可以预先设置好Group的配置，使用该模版创建Group。</p>

<h2 id="databuilders">DataBuilders</h2>
<p>  存放打包脚本和Editor测试加载脚本的目录，AA提供了四个自带脚本。</p>
<ul>
  <li><strong>(1) BuildScriptFastMode</strong>：对应<strong>Use Asset Database (fastest)</strong>按钮，快速加载模式，类似AssetdataBase加载资源。</li>
  <li><strong>(2) BuildScriptPackedMode</strong>：对应<strong>Default Build Script</strong>打包按钮，默认的打AB包脚本，可以根据这个脚本修改自己的打包前后流程。</li>
  <li><strong>(3) BuildScriptPackedPlayMode</strong>：对应<strong>Use Existing Build(#Platform)</strong>，真实完整的AB加载场景模式，在Editor测试AB是否正确。</li>
  <li><strong>(4) BuildScriptVirtualMode</strong>：对应<strong>Simulate Groups (advanced)</strong>按钮，不用打AB包可模拟加载AB模式。</li>
</ul>]]></content><author><name>仗剑天涯</name></author><category term="Unity3d" /><category term="Addressable System" /><summary type="html"><![CDATA[总结在使用Unity Addressable System过程中遇到的一部分问题，该篇主要记录Addressable在Unity编辑器的各种组织结构，本文Addressable后续简称AA。]]></summary></entry><entry><title type="html">视差和法线、高度图回顾(翻译二十)</title><link href="https://www.damonc.top/Unity_Parallax_Normals_Heightmap.html" rel="alternate" type="text/html" title="视差和法线、高度图回顾(翻译二十)" /><published>2018-01-25T20:00:00+08:00</published><updated>2018-01-25T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_Parallax_Normals_Heightmap</id><content type="html" xml:base="https://www.damonc.top/Unity_Parallax_Normals_Heightmap.html"><![CDATA[<p>由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外的景物，附近的物体看起来很大并且移动很快，而远处的背景看起来很小并且移动较慢。渲染时，相机使用透视模式时，也会出现视差。</p>

<h2 id="视差纹理">视差纹理</h2>

<p>之前翻译使用过法线贴图将表面不规则感添加到平滑表面。 它会影响照明，但不会影响表面的实际形状。 因此，该效果视差不明显，通过实现法线贴图基于视野深度的幻觉有许多限制。这一篇的目的就是解决该限制。</p>

<h3 id="法线贴图效果回顾">法线贴图效果回顾</h3>

<p>下面给出许多albedo map 和 normal map差异对比：</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200615181223145-1229624244.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200615181223966-473200226.png" width="250" /><font size="2.5">
            <i>albedo map 和 normal map.</i>
        </font></center>

<p>如果没有法线贴图，表面看起来很平坦。 添加法线贴图会使它看起来好像具有不规则的表面。 但是，高度海拔差异看起来不明显。 当从入射视角与表面的夹角越趋于0，高度差越不明显。如果高程差异较大，则表面特征的相对视觉位置应由于视差而发生很大变化，但不会发生变化。 我们看到的视差是平坦的表面。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200616191420845-1957506928.png" width="250" /><font size="2.5">
            <i>平坦的视角.</i>
        </font></center>

<p>虽然可以增加法线贴图的强度，但这不会改变视差。同样，当法线贴图变得太强时，它会看起来很奇怪。它影响了平坦表面的光线的明暗变换，而视差效果它们确实是平的。所以法线贴图只适用于小的变化，但不会表现出明显的视差。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200616191421654-712293996.png" width="250" /><font size="2.5">
            <i>法线贴图的光线变化.</i>
        </font></center>

<p>要获得真正的深度视差感，<strong>首先</strong>需要确定深度应该是多少。法线贴图不包含这些信息。所以我们需要一个高度图。这样，我们就可以创建一个基于高度信息的假视差效果，就像法线贴图创建一个假斜率一样。下面的贴图也称它是灰度图，黑色代表最低点，白色代表最高点。因为我们将使用这个贴图来创建一个视差效果，也称为视差图。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200616191422519-1710373191.png" width="250" /><font size="2.5">
            <i>高度图.</i>
        </font></center>

<p>确保在导入时禁用sRGB(颜色纹理)，这样在使用线性空间渲染时数据就不会被弄乱</p>

<h3 id="shader参数">Shader参数</h3>

<p>为了能够使用视差贴图，我们必须为它添加一个属性到着色器。也会给它一个强度参数来缩放效果。因为视差效果相当强，我们将其范围设置为(0 , 0.1)。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_ParallaxMap</span> <span class="p">(</span><span class="s">"Parallax"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"black"</span> <span class="p">{}</span>
<span class="n">_ParallaxStrength</span> <span class="p">(</span><span class="s">"Parallax Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>

<span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_OcclusionMap</span> <span class="p">(</span><span class="s">"Occlusion"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
<span class="n">_OcclusionStrength</span> <span class="p">(</span><span class="s">"Occlusion Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>视差贴图是一个着色器特性，我们将启用__PARALLAX_MAP_关键字。将必需的编译器指令添加到base pass、additive pass和deferred pass。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma shader_feature _NORMAL_MAP
#pragma shader_feature _PARALLAX_MAP
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>为什么不在ShadowCaster增加视差贴图？
当使用albedo贴图的alpha通道的透明度时，视差贴图只会影响阴影。即使是这样，在阴影贴图中的视差效果也很难被注意到。所以它通常不值得额外的计算时间。但是如果愿意，也可以将它添加到阴影施法者通道中。
</code></pre></div></div>

<p>为了访问新的属性，给我的照明添加相应的变量</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_ParallaxMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>

<span class="n">sampler2D</span> <span class="n">_OcclusionMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_OcclusionStrength</span><span class="p">;</span>
</code></pre></div></div>

<p>为了能够自定义配置材质，在Extend ShaderGUI扩展中增加相应Enable与Disanble key的方法。</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">DoParallax</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialProperty</span> <span class="n">map</span> <span class="p">=</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_ParallaxMap"</span><span class="p">);</span>
    <span class="n">Texture</span> <span class="n">tex</span> <span class="p">=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">;</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="nf">BeginChangeCheck</span><span class="p">();</span>
    <span class="n">editor</span><span class="p">.</span><span class="nf">TexturePropertySingleLine</span>
    <span class="p">(</span>
        <span class="nf">MakeLabel</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">"Parallax (G)"</span><span class="p">),</span> <span class="n">map</span><span class="p">,</span>
        <span class="n">tex</span> <span class="p">?</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_ParallaxStrength"</span><span class="p">)</span> <span class="p">:</span> <span class="k">null</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="nf">EndChangeCheck</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">tex</span> <span class="p">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">SetKeyword</span><span class="p">(</span><span class="s">"_PARALLAX_MAP"</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200616191423089-347056836.png" width="250" /></center>

<h3 id="坐标匹配">坐标匹配</h3>

<p>通过在fragment程序中调整纹理坐标，让平坦表面的某些部分看起来高低交错。创建一个应用视差函数，给它一个inout插值器参数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在fragment程序使用插入的数据之前调用视差函数。_会有点异常是LOD衰落，_因为这取决于屏幕位置。先不调整这些坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="n">ApplyParallax</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">GetAlpha</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#if defined(_RENDERING_CUTOUT)
</span>        <span class="nb">clip</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">_Cutoff</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>通过简单地向U坐标添加视差强度来调整纹理坐标。做一次偏移计算</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>改变视差强度会导致纹理偏移。增加U坐标会使纹理向负的U方向移动，V坐标同理。这看起来不是视差效果，因为这是一个与视角无关的均匀位移。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012938981-982216259.gif" width="250" /><font size="2.5">
            <i>u坐标移动.</i>
        </font></center>

<h3 id="随视角方向移动">随视角方向移动</h3>

<p>视差是由相对于观察者的透视投影，所以必须改变纹理坐标。这意味着必须基于视图的方向来移动坐标，而视图的方向对于表面上每个片段都是不同的。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192759952-594530144.png" width="250" /><font size="2.5">
            <i>varies across a surface.</i>
        </font></center>

<p>纹理坐标存在于切线空间中。为了调整这些坐标，需要知道视图在切线空间中的方向。这需要矩阵乘法对空间进行转换。在fragment-程序已经有了一个切线空间矩阵，但是它是用于从切线空间到世界空间的转换。在本例中，需要从对象空间转到切线空间。</p>

<p>视图方向向量定义为从表面到摄像机，需要归一化。我们可以在vertex程序中确定这个向量，转换它并将它传递给fragment程序。但是为了最终得到正确的方向，需要推迟归一化，直到插值完成后。添加切线空间视图方向作为一个新的插值成员变量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="kt">float3</span> <span class="n">tangentViewDir</span> <span class="o">:</span> <span class="n">TEXCOORD8</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="kt">float3</span> <span class="n">tangentViewDir</span> <span class="o">:</span> <span class="n">TEXCOORD8</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>寄存器数量限制是多少?
model 1与model 2都只支持8个Texture Coordinate Register -&gt;Texcoord[0-7]。当使用model 3时，可以使用TEXCOORD8。若硬件不支持model 3其机能也就不是很强大，所以不要使用视差映射。
</code></pre></div></div>

<p><strong>首先</strong>, 使用mesh网格数据中的原始顶点切向量和法向量，在顶点程序中创建一个从对象空间到切线空间的转换矩阵。因为我们只用它来变换一个向量而不是一个位置我们用一个3×3矩阵就足够了。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ComputeVertexLightColor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="cp">#if defined (_PARALLAX_MAP)
</span>        <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span><span class="p">(</span>
            <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
            <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
            <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
        <span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>然后</strong>，可以使用<code class="language-plaintext highlighter-rouge">ObjSpaceViewDir</code>函数得到对象空间中顶点位置的视图方向，再用矩阵变换它我们就得到了我们需要的切线空间下视图方向。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined (_PARALLAX_MAP)
</span>    <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span>
    <span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
        <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
    <span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">objectToTangent</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ObjSpaceViewDir内部实现?</span>
<span class="c1">//ObjSpaceViewDir函数是在UnityCG中定义的。它先将摄像机位置转换到对象空间，然后减去对象空间下顶点位置得到一个从顶点指向摄像机的向量，注意它还没有标准化.</span>

<span class="k">inline</span> <span class="kt">float3</span> <span class="nf">ObjSpaceViewDir</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float3</span> <span class="n">objSpaceCameraPos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToObject</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">objSpaceCameraPos</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>最后</strong>，我们可以在ApplyParallax函数使用切线空间视图方向了。首先，对它进行规格化normalize，把它变成一个合适的方向向量。然后，添加它的XY组件到纹理坐标，再由视差强度缩放。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>这能有效地将视图方向投影到纹理表面上。当以90度角直视表面时，在切空间中的视图方向等于表面法线(0,0,1)，这不会导致位移。视角越浅，投影越大，位移效果也越大。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192800432-1757806048.png" width="250" /><font size="2.5">
            <i>影视图方向用作UV偏移.</i>
        </font></center>

<p>所有这一切的影响是表面似乎被拉向上的切线空间，看起来比它实际上更高，基于视差强度。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012940748-384205609.gif" width="250" /><font size="2.5">
            <i>随投影视角方向移动UV.</i>
        </font></center>

<h3 id="基于高度滑动">基于高度滑动</h3>

<p>在基于高度这一点上，我们可以让表面看起来更高，但它仍然是一个均匀位移。下一步是使用视差贴图来缩放位移。采样贴图，使用它的G通道作为高度，应用视差强度，并使用它来调节位移。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
<span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012942351-290008046.gif" width="250" /><font size="2.5">
            <i>由高度调整的移动.</i>
        </font></center>

<p>低的区域现在保持不变，而高的区域被向上拉。standard shader抵消了这种效果，所以低的区域也向下移动，而在中间的区域保持他们原来的位置。这是通过从原始高度数据中减去差值来实现的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012944095-1997194416.gif" width="250" /><font size="2.5">
            <i>视差贴图效果 由合理到过量.</i>
        </font></center>

<p>这就产生了我们想要的视差效果，但它只在低强度下有效。不足的是位移位移变换的很快，会撕裂表面。</p>

<h3 id="偏移视差映射算法">偏移视差映射算法</h3>

<p>我们目前使用的视差映射技术被称为带偏移限制的视差映射。我们只是使用了视图方向的XY部分，它的最大长度是1。因此，纹理偏移量是有限的。这种效果不错，但不能代表正确的透视投影。</p>

<p>一个更精确的计算偏移量的物理方法是将高度场视为几何图形表面下的体积，并通过它拍摄一个视图射线。光线从相机发射到表面，从上面进入高度场体积，并持续发射直到它到达由场定义的表面。</p>

<p>如果高度场均匀为零，那么射线就会一直持续到体积的底部。它与物体的距离取决于光线进入物体时的角度。它没有限制。角度越浅，越远。最极端的情况是当视角趋于0时，光线射向无穷大。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192800958-1980748310.png" width="250" /><font size="2.5">
            <i>光线投射到底部，有限且正确.</i>
        </font></center>

<p>为了找到合适的偏移量，我们必须缩放视图方向向量，通过除以它自己的Z分量来使它的Z分量变成1。因为我们以后不需要用Z，我们只需要用X和Y除以Z。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
<span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</code></pre></div></div>

<p>虽然这样可以得到一个更正确的投影，但它确实会使浅视角的视差效果恶化。standard着色器通过增加0.42偏差到Z减轻浅视角的视差效果恶化，所以它永远不会接近零。这扭曲了透视图，但使工件更易于管理。我们再加上这个偏差.</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">42</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192802151-218582125.png" width="250" /><font size="2.5">
            <i>视差贴图像标准着色器.</i>
        </font></center>

<p>通过上述多个步骤修正后, 现在我们的着色器与标准着色器支持同样的视差效果。视差映射可以应用于任何表面，投影假设切线空间是均匀的。曲面具有弯曲的切线空间，因此会产生物理上不正确的结果。只要视差强度和曲率很小，你就可以摆脱它。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192802555-2049613835.png" width="250" /><font size="2.5">
            <i>球面视差贴图.</i>
        </font></center>

<p>同样，阴影坐标不会受到这个效果的影响。因此，阴影在强烈的视差的组合下看起来很奇怪，好像漂浮在表面上。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192803371-1931947503.png" width="250" /><font size="2.5">
            <i>阴影不受视差影响.</i>
        </font></center>

<h3 id="parallax-configuration">Parallax Configuration</h3>

<p>你不同意Unity使用0.42的偏移值吗?或者你想使用一个不同的值，还是让它保持在0?或者你想用偏移限制代替吗?它是可以配置!</p>

<p>当你想使用偏移限制，定义<code class="language-plaintext highlighter-rouge">PARALLAX_OFFSET_LIMITING</code>在着色器。或者，通过定义PARALLAX_BIAS来设置要使用的偏差。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>            <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>当没有定义时，假设偏差是0.42。在<code class="language-plaintext highlighter-rouge">ApplyParallax</code> 中定义它。注意，宏定义不关心函数作用域，它们总是全局的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>    <span class="cp">#if !defined(PARALLAX_BIAS)
</span>        <span class="cp">#define PARALLAX_BIAS 0.42
</span>    <span class="cp">#endif
</span>    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>现在我们可以通过着色器的CGINCLUDE块来微调我们的视差效果。添加无偏差和限制偏移的选项，但将它们转换为注释，以坚持默认选项。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGINCLUDE</span>
    <span class="cp">#define BINORMAL_PER_FRAGMENT
</span>    <span class="cp">#define FOG_DISTANCE
</span>
<span class="c1">//	#define PARALLAX_BIAS 0</span>
<span class="c1">//	#define PARALLAX_OFFSET_LIMITING</span>

<span class="n">ENDCG</span>
</code></pre></div></div>

<h3 id="detail-uv">Detail UV</h3>

<p>视差贴图可以在主贴图上工作，但是我们还没有注意到副贴图。我们必须应用纹理坐标偏移到细节UV上。</p>

<p>首先，下面是一个包含网格模式的详细地图。它可以很容易地验证效果是否正确地应用于细节。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192803893-1797850325.png" width="250" /><font size="2.5">
            <i>细节网格纹理.</i>
        </font></center>

<p>使用这个纹理作为材质的细节albedo贴图。设置二级贴图的平铺为10×10。这表明，细节紫外线确实仍然不受影响。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192804491-290326603.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192805295-1360127209.png" width="250" /><font size="2.5">
            <i>细节UV不受影响.</i>
        </font></center>

<p>Standard也简单地添加了UV偏移到细节UV，这是存储在UV插值器的ZW组件。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
<span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
</code></pre></div></div>

<p>细节可能有所变化，但是它们肯定还不匹配视差效果。 那是因为我们平铺了二级纹理。 这样会将细节UV缩放10倍，使视差偏移量变弱十倍。 我们还必须将细节拼贴应用到偏移量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
</code></pre></div></div>

<p>实际上，缩放应该相对于主UV平铺，以防它被设置为1×1以外的一些东西。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192806533-2106069113.png" width="250" /><font size="2.5">
            <i>正确的UV.</i>
        </font></center>

<h2 id="ray-marching-光线步进">Ray Marching-光线步进</h2>

<p>然而，除了上述的偏移视差映射还有另外的视差算法：发射射线与高度场体积相交，确定其交点在表面上的位置，然后对该位置采样。 它通过在射线进入体积时的交点，对高度图进行一次采样。 但是，当看向任意一个角度时，这并不能准确告诉射线实际上与高度场相交的高度。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192807160-2024700857.png" width="250" /><font size="2.5">
            <i>实际与预测的高度对比.</i>
        </font></center>

<p>先假设入口点的高度与交点的高度相同，但这实际上只有在入口点和交点具有相同的高度时才是正确的。当偏移量不大且高度场变化不大时，它的效果仍然很好。但是，当偏移量太大或高度变化太快时，该算法就会出现问题，而这很可能是错误的。这就会造成表面撕裂。</p>

<p>如果我们能算出射线实际到达的高度场的位置，那么总能找到真正的可见表面点。这不能通过单个纹理样本来实现，我们必须沿着视图射线逐步移动，并每次都采样高度场，直到射线到达表面。该技术是RayMarching。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192807679-1545265192.png" width="250" /><font size="2.5">
            <i>随视图射线前进.</i>
        </font></center>

<p>有各种不同的视差贴图使用raymarching。常见的是陡视差映射_Steep Parallax Mapping_、地形映射_Relief Mapping_和视差遮挡映射_Parallax Occlusion Mapping_。与使用单一纹理样本相比，它们能通过高度场来创建更好的视差效果。除此之外，它们还可以应用额外的阴影和技术来改进该算法。当我们做的匹配这些方法时，我会调用它。</p>

<h3 id="自定义视差函数">自定义视差函数</h3>

<p>标准着色器仅支持简单的偏移视差映射。 现在，我们要在自己的着色器中添加对视差光线Ray marching的支持。 但是，我们还要继续支持这种简单方法。 两者都需要采样height字段，因此将采样代码行放在单独的GetParallaxHeight函数中。 而且，两种方法的投影视图方向和偏移量的最终应用都相同。 因此，将偏移量计算也单独为一个函数。 它仅需要原始UV坐标和已处理的视图方向作为参数，结果返回要应用的UV偏移。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">GetParallaxHeight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="nf">ParallaxOffset</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>            <span class="cp">#if !defined(PARALLAX_BIAS)
</span>                <span class="cp">#define PARALLAX_BIAS 0.42
</span>            <span class="cp">#endif
</span>            <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
        <span class="cp">#endif
</span>
        <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">ParallaxOffset</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>现在，我们将应用视差函数宏替换对视差偏移的硬编码调用，从而使视差方法更加灵活。如果没有定义它，我们将它设置为使用偏移量方法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="c1">//...</span>
        <span class="cp">#if !defined(PARALLAX_FUNCTION)
</span>            <span class="cp">#define PARALLAX_FUNCTION ParallaxOffset
</span>        <span class="cp">#endif
</span>        <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">PARALLAX_FUNCTION</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>为RayMarching方法创建一个新函数。与ParallaxOffset函数类似的参数和返回类型。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxOffset</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在可以通过定义_PARALLAX_FUNCTION_来改变着色器中的视差方法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<h3 id="相交计算">相交计算</h3>

<p>为了找到视图射线到达高度场的点，我们需要对射线上的多个点进行采样并计算出在表面下方的位置。第一个采样点在顶部，我们在这里输入高度量，就像使用偏移方法一样。最后一个采样点就是射线到达体积底部的地方。我们会在这些端点之间均匀地添加额外的采样点。</p>

<p>假设每条射线进行10次采样。这意味着我们将对高度图采样10次而不是一次，所以这不是一个便宜计算方法。因为我们用了10个样本，所以步长是0.1。这是我们沿着视图射线移动的因子，也就是UV偏移增量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了应用视差强度，我们可以调整每一步采样的高度。但是缩放UV delta也有同样的效果，只需要计算一次。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>
</code></pre></div></div>

<p>通过这种方式，无论视差强度如何，我们都可以继续使用0–1作为高度场的范围。 因此，射线的第一步高度始终为1。低于或高于该高度的表面点的高度由高度场定义。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span><span class="c1">//步长</span>
<span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>
<span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//步高</span>
<span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
</code></pre></div></div>

<p>现在我们要沿着射线迭代。<strong>首先</strong>，每一步我们都会增加UV偏移量。视图向量指向摄像机，但我们是在向表面移动，所以我们需要减去UV delta。<strong>然后</strong>我们用步高来减小步长。<strong>然后</strong>我们再次对高度图采样。使用while循环重复上述步骤，直到采样完毕。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当编译时，会得到一个编译器警告和错误。这个警告告诉我们在循环中使用了梯度指令。这指的是循环中的纹理采样。GPU必须弄清楚使用哪个mipmap级别，它需要比较相邻片段使用的UV坐标。只有当所有片段执行相同的代码时，它才能对比。对于循环来说，这是不可能的，因为它可以提前终止，每个片段都可能不同。因此编译器将展开循环，这意味着它将一直执行所有9个步骤，而不管逻辑是否可以提前停止。相反，它随后使用确定性逻辑选择最终结果。</p>

<p>编译失败是因为编译器无法确定循环的最大迭代次数。它不知道这个最多是9。通过将while循环转换为执行限制的for循环来明确这一点。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012945572-448280189.png" width="250" /><font size="2.5">
            <i>Raymarching 步进10次 无偏差, 无限制.</i>
        </font></center>

<p>与简单的视差偏移方法相比，视差效果更加明显。较高的区域现在也正确地阻挡了我们后面较低区域的视野。我们还得到了明显的图层，总共10层。</p>

<h3 id="更多步进">更多步进</h3>

<p>这个基本的光线行进方法最适合陡峭的视差贴图。效果的质量是由我们的样本分辨率决定的。一些方法根据视角使用可变的步骤。较浅的角度需要更多的步长，因为光线较长。但我们的样本量是固定的，所以我们不会这样做。</p>

<p>提高质量的明显方法是增加采样的次数，因此让其可配置。使用_PARALLAX_RAYMARCHING_STEPS_，默认值为10，而不是固定的步长和迭代次数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if !defined(PARALLAX_RAYMARCHING_STEPS)
</span>        <span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
</span>    <span class="cp">#endif
</span>    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="n">PARALLAX_RAYMARCHING_STEPS</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>

    <span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span>
        <span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_STEPS</span> <span class="o">&amp;&amp;</span> <span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
        <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
        <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在我们可以在着色器中控制步数。对于真正的高质量，将PARALLAX_RAYMARCHING_STEPS定义为100。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 100
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012948054-536464296.png" width="250" /><font size="2.5">
            <i>Raymarching 100次采样.</i>
        </font></center>

<p>这让我们知道了它的效果能有多好，但它计算量太大了，一般不适合手机。所以把样本数设为10后，我们仍然可以看到视差效果看起来连续和平滑。然而，由视差遮挡引起的轮廓总是锯齿状的，MSAA并不能消除这一点，因为它只适用于几何图形的边缘，而不是纹理效果。只要不依赖深度缓冲区，后处理抗锯齿技术能解决。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>不能按片段写入深度缓冲区吗?
这在足够先进的硬件上确实是可能的，使它能够正确地与高度场相交并应用阴影。不过，它计算量太大。
</code></pre></div></div>

<p>我们当前的方法是沿着射线步进，直到到达表面以下的点，或者到达射线末端可能的最低点。然后我们用UV偏移处理那个点。但隐藏在表面之下的这个点，很可能会出现错误。这就是导致表面撕裂的原因。</p>

<p>增加步长数只会减少最大误差。使用足够的步骤，错误会变得更小，以至于我们无法再看到它。所以当一个表面总是从远处看，你可以用更少的步骤。距离越近，视角越小，需要的样本就越多。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012948690-1598196626.png" width="250" /><font size="2.5">
            <i>Raymarching 100次采样.</i>
        </font></center>

<h3 id="步长之间插值">步长之间插值</h3>

<p>提高质量的一种方法是根据经验预测光线真正到达表面的位置。比如第一步在表面之上，下一步在表面之下。在这两步之间的某个点射线一定到达了表面。</p>

<p>两个射线点、和两个射线点到表面最近的点，能定义两条线段。因为光线和表面碰撞，这两条线段会相交。所以如果我们跟踪前面的步骤，我们可以在循环之后执行直线交叉。我们可以用这个信息来近似出真正的交点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012949277-977122761.png" width="250" /><font size="2.5">
            <i>执行直线交叉.</i>
        </font></center>

<p>在for循环内，我们必须跟踪之前的UV偏移量、步长高度和表面高度。一般来说，这些等于循环之前的第一个样本。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="n">prevUVOffset</span> <span class="o">=</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="n">float</span> <span class="n">prevStepHeight</span> <span class="o">=</span> <span class="n">stepHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">prevSurfaceHeight</span> <span class="o">=</span> <span class="n">surfaceHeight</span><span class="p">;</span>
</code></pre></div></div>

<p>在循环之后，我们计算这些线的交点。我们可以使用这个插值之间的前点和后点的UV偏移。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
<span class="n">uvOffset</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">prevUVOffset</span><span class="p">,</span> <span class="n">uvOffset</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

<span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>数学原理：
这两个线段定义在两个样本步骤之间的空间内。我们将这个空间的宽度设置为1。从前一步到最后一步的直线由点(0，a)和点(1，b)定义，其中a是前一步的高度，b是后一步的高度。因此，可以用线性函数'v(t) = a + (b - a)t'来定义视图线。同样地，面线由点(0，c)和(1，d)定义，函数's(t) = hlsl + (d - hlsl)t'。

交点存在于s(t) = v(t)'处。那么t的值是多少?
c + (d - c)t = a + (b - a)t
(d - c)t - (b - a)t = a - c
(a - c + d - b)t = a - c
t = (a - c) / (a - c + d - b)
注意:a - c是在t = 0处直线高度的绝对差。d - b是t = 1处的绝对高度差。
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012950193-51635460.png" width="250" /><font size="2.5">
            <i>线段交点.</i>
        </font></center>

<p>实际上，在这种情况下，我们可以使用插值器来缩放我们要添加到上一点上的UV偏移量。它可以归结为相同的东西，只是用了更少的数学。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">-</span> <span class="n">difference</span><span class="p">);</span>
<span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012951620-360864955.png" width="250" /></center>

<p>效果看起来好多了。我们现在假设表面在样本点之间是线性的，这可以防止最明显的分层假象。然而，它不能帮助我们检测我们是否错过了步骤之间的交集。我们仍然需要很多的样本来处理小的特征，轮廓和浅角度。</p>

<p>有了这个技巧，我们的方法类似于视差遮挡映射。虽然这是一个相对便宜的改进，但通过定义_PARALLAX_RAYMARCHING_INTERPOLATE_，我们让它成为可选的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(PARALLAX_RAYMARCHING_INTERPOLATE)
</span>    <span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
    <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>在shader内定义PARALLAX_RAYMARCHING_INTERPOLATE。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<h3 id="步长搜索">步长搜索</h3>

<p>通过在两个步长之间进行线性插值，我们假定表面在两个步长之间是笔直的。 但是，通常情况并非如此。 为了更好地处理不规则的高度场，我们必须在两个步长之间搜索实际的交点。 或至少接近它。</p>

<p>完成循环后，不要使用最后的偏移量，而是将偏移量调整到最后两个步长的中间位置。对该点的高度进行采样。如果我们结束在表面以下，向表面之上方向移动四分之一，并再次采样。如果我们在表面上结束，向表面之下方向移动四分之，并再次采样。不断重复这个过程。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012952340-10743193.png" width="250" /><font size="2.5">
            <i>越来越接近交点.</i>
        </font></center>

<p>上述方法是二分查找的一个应用。它与地形测绘方法最匹配。每走一步，路程减半，直到到达目的地。在我们的例子中，我们将简单地做固定次数，以达到预期的解决方案。一步，得到0.5。两步，得到0.25、0.75。三步，是0.125、0.375、0.625、0.875。注意，从第二步开始，每次采样提升分的辨率将翻倍。</p>

<p>为了控制是否使用此方法，我们定义_PARALLAX_RAYMARCHING_SEARCH_STEPS_。默认情况下将其设置为零，这意味着我们根本不进行搜索。如果它被定义为大于0，我们将不得不使用另一个循环。注意，这种方法与_PARALLAX_RAYMARCHING_INTERPOLATE_是<strong>不兼容</strong>的，因为我们不能再保证表面是交叉的最后两个步骤。当我们搜索的时候，禁用插值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(PARALLAX_RAYMARCHING_SEARCH_STEPS)
</span>    <span class="cp">#define PARALLAX_RAYMARCHING_SEARCH_STEPS 0
#endif
#if PARALLAX_RAYMARCHING_SEARCH_STEPS &gt; 0
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="cp">#elif defined(PARALLAX_RAYMARCHING_INTERPOLATE)
</span>    <span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
    <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>此循环也执行与原始循环相同的基本工作。调整偏移量和步高，然后采样高度字段。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但每次迭代，UV增量和步长减半。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvDelta</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">stepSize</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>同样，如果点在表面之下，我们必须朝相反的方向移动。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uvDelta</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">stepSize</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">stepHeight</span> <span class="o">&lt;</span> <span class="n">surfaceHeight</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">+=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">+=</span> <span class="n">stepSize</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
</code></pre></div></div>

<p>调整着色器，所以它使用三个搜索步骤</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012953271-1061541462.png" width="250" /><font size="2.5">
            <i>10步长加上3个二分查找的最终效果.</i>
        </font></center>

<p>结果看起来相当不错，但仍不完美。二分法搜索可以比简单的插值处理较浅的角度，但仍然需要相当多的搜索步骤，以摆脱分层。所以这是一个试验的问题，找出哪种方法在特定情况下最有效，需要多少步骤。</p>

<h3 id="缩放对象和动态批处理">缩放对象和动态批处理</h3>

<p>尽管我们的视差映射方法似乎可行，但存在一个隐藏的错误。 而且还把错误显示出来了。它显示了何时使用动态批处理来组合已缩放的对象。 例如，给我们的四边形一个像\((10,10,10)\)的比例，然后复制它，将副本移到它下面一点。 假设在播放器设置中启用了此选项，这将触发Unity动态批处理四边形。</p>

<p>批处理开始时，视差效果将扭曲。 旋转相机时，这一点非常明显。 但是，这仅发生在游戏视图和构建中，而不发生在场景视图中。 请注意，standard着色器也存在此问题，但是当使用弱偏移视差效果时，您可能不会立即注意到它。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012954391-1540920343.png" width="250" /><font size="2.5">
            <i>动态批处理会产生奇怪的结果.</i>
        </font></center>

<p>在批处理将它们合并到一个单一的网格中之后，Unity不能标准化处理后的几何法向量和切向量。因此顶点数据正确的假设不再成立。</p>

<p>顶点法向量和切向量没有规范化不是什么大的问题，因为我们在顶点程序中将视图向量转换到切线空间。对于其他所有内容，数据在使用之前都要标准化。</p>

<p>解决方法是在构造对象转换到切线矩阵之前对向量进行归一化。 因为只有动态批处理的缩放几何才需要此选项，所以根据是否定义了PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING，将其设为可选。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined (_PARALLAX_MAP)
</span>    <span class="cp">#if defined(PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING)
</span>        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span><span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
        <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
    <span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">objectToTangent</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3
#define PARALLAX_FUNCTION ParallaxRaymarching
#define PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING
</span></code></pre></div></div>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/batched-correct.png" width="250" /><font size="2.5">
            <i>动态批量与正确的结果.</i>
        </font></center>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外的景物，附近的物体看起来很大并且移动很快，而远处的背景看起来很小并且移动较慢。渲染时，相机使用透视模式时，也会出现视差。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender20/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender20/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity GPU Instance(翻译十九)</title><link href="https://www.damonc.top/Unity_GPU_Instance.html" rel="alternate" type="text/html" title="Unity GPU Instance(翻译十九)" /><published>2018-01-24T20:00:00+08:00</published><updated>2018-01-24T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_GPU_Instance</id><content type="html" xml:base="https://www.damonc.top/Unity_GPU_Instance.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>渲染大量球体-优化DrawCall</li>
  <li>支持GPU-Instance</li>
  <li>使用材质属性块</li>
  <li>LOD-Groups支持GPU-Instance</li>
</ul>

<h2 id="batching-instance-批处理">Batching Instance-批处理</h2>

<p>指示GPU绘制需要花时间；向其传递mesh和material属性也要花时间。现在已知两种节省Draw Call的方式：static和<a href="https://docs.unity3d.com/Manual/DrawCallBatching.html"><strong>dynamic batching</strong></a></p>

<p>Unity可以将多个静态物体的网格合并为一个更大的静态网格，从而减少draw call。 <strong>注意：</strong> 只有使用相同材质的对象才能以这种方式组合。 这是以必须存储更多网格数据为代价的。 启用动态批处理后，Unity在运行时会对视图中的动态对象执行相同的操作。 这仅适用于小型网格物体，否则开销将变得太大。</p>

<p>还有另一种组合draw call的方法：GPU instance或Geometry instance。与动态批处理一样，此操作在运行时针对可见对象。 它的目标是让GPU一次性渲染同一网格的多个副本。 因此，它不能组合不同的网格或材质。</p>

<h3 id="创建大量球体">创建大量球体</h3>

<div class="language-plaintext tip-info highlighter-rouge"><div class="highlight"><pre class="highlight"><code>im title?
test test test.
test test test.
test test test!!dfS:FDFH&amp;*YER#.
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">using</span> <span class="n">UnityEngine</span><span class="p">;</span>

<span class="kr">public</span> <span class="k">class</span> <span class="n">GPUInstancingTest</span> <span class="o">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="n">Transform</span> <span class="n">prefab</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">int</span> <span class="n">instances</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">50</span><span class="n">f</span><span class="p">;</span>
    <span class="c1">//单位圆内随机一点并放大坐标50倍，生成5000个球体</span>
    <span class="c1">//然后查看statistics统计的draw Call信息</span>
    <span class="kt">void</span> <span class="n">Start</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
            <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用forward render path统计到的draw call，去掉背景和camera Effect两个draw call：</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010902826-821880737.png" width="250" /><font size="2.5">
            <i>5000 draw call.</i>
        </font></center>

<p>但是当使用cube代替球体</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010904552-338192039.png" width="250" /><font size="2.5">
            <i>6 draw call.</i>
        </font></center>

<h3 id="支持instance">支持Instance</h3>

<p>默认情况下，GPU Instance不会开启，必须设计shader以支持它。 即使这样，也必须为每种材料显式启用实例化。 Unity的standard着色器有一个开关。像标准着色器的GUI一样，我们将为shader扩展面板创建“高级选项”部分。 可以通过调用MaterialEditor.EnableInstancingField方法来添加切换。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoAdvanced</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">GUILayout</span><span class="p">.</span><span class="n">Label</span><span class="p">(</span><span class="s">"Advanced Options"</span><span class="p">,</span> <span class="n">EditorStyles</span><span class="p">.</span><span class="n">boldLabel</span><span class="p">);</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">EnableInstancingField</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>仅当shader实际支持instance时，才会显示该切换。 我们可以通过将#pragma multi_compile_instancing指令添加到着色器base-pass启用此支持。 这将为一些关键字启用着色器变体，自定义关键字_INSTANCING_ON_，其他关键字也可以。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_fwdbase
#pragma multi_compile_fog
#pragma multi_compile_instancing
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010905493-1524350499.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010906722-1492830859.png" width="250" /><font size="2.5">
            <i>合并了，但是显示有错误.</i>
        </font></center>

<p>批处理数量已减少到42，这意味着现在仅用40个批处理即可渲染所有5000个球体。帧速率也高达80 fps，但是只有几个球体可见。<strong>错误原因</strong>：虽然5000个球体仍在渲染，但是在合批中同一批次的所有球体的顶点转换时都使用了同一个位置：它们都使用同一批次中第一个球的转换矩阵。 发生这种情况是因为现在同一批中所有球体的矩阵都作为数组发送到GPU。 在不告知着色器要使用哪个数组索引的情况下，它始终使用第一个索引。</p>

<h3 id="instance-ids">Instance IDs</h3>

<p>上述错误解决办法：每个Instance相对应的数组索引称为其Instance ID，GPU通过顶点数据将其传递到着色器的vertex程序。在大多数平台上，它是一个无符号整数，名为instanceID，具有SV_InstanceID语义。 我们可以简单地使用_UNITY_VERTEX_INPUT_INSTANCE_ID_宏将其包含在我们的VertexData结构中。 它在UnityCG中包含的_UnityInstancing.cginc_文件中定义。 它为我们提供了实例ID的正确定义，或者在未启用实例化时不提供任何内容。将其添加到VertexData结构。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>启用instance后，我们现在可以在顶点程序中访问instanceID。 有了它，我们可以在变换顶点位置时使用正确的矩阵。 但是，UnityObjectToClipPos函数没有矩阵参数，它函数内部始终使用unity_ObjectToWorld矩阵。要解决此问题，UnityInstancing包含文件会使用矩阵数组的宏覆盖unity_ObjectToWorld。 <em>这可以被认为是肮脏的宏技巧，但无需更改现有着色器代码即可工作，从而确保了向后兼容性</em>。</p>

<p>要使它工作，instance的数组索引必须对所有着色器代码全局可用。必须通过_UNITY_SETUP_INSTANCE_ID_宏进行手动设置，该宏必须在vertex程序最先计算，然后再执行其他的代码。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010908398-221325174.png" width="250" /><font size="2.5">
            <i>矩阵替换内部实现？.</i>
        </font></center>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//UnityInstancing中的实际代码要复杂得多。 它要处理平台差异，其他使用实例化的方法以及用于立</span>
<span class="c1">//体声渲染的特殊代码，从而导致间接定义的多个步骤。 它还必须重新定义UnityObjectToClipPos，因</span>
<span class="c1">//为UnityCG首先包含UnityShaderUtilities。</span>
<span class="c1">//缓冲区宏将在后面说明。</span>
<span class="k">static</span> <span class="n">uint</span> <span class="n">unity_InstanceID</span><span class="p">;</span>

<span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityDrawCallInfo</span><span class="p">)</span>
    <span class="c1">// Where the current batch starts within the instanced arrays.</span>
    <span class="n">int</span> <span class="n">unity_BaseInstanceID</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>

<span class="cp">#define UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;
</span>
<span class="cp">#define UNITY_SETUP_INSTANCE_ID(input) \
    unity_InstanceID = input.instanceID + unity_BaseInstanceID;
</span>
<span class="c1">// Redefine some of the built-in variables</span>
<span class="c1">// macros to make them work with instancing.</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">PerDraw0</span><span class="p">)</span>
    <span class="kt">float4x4</span> <span class="n">unity_ObjectToWorldArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
    <span class="kt">float4x4</span> <span class="n">unity_WorldToObjectArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
<span class="cp">#define unity_ObjectToWorld     unity_ObjectToWorldArray[unity_InstanceID]
#define unity_WorldToObject     unity_WorldToObjectArray[unity_InstanceID]
</span></code></pre></div></div>

<h3 id="批处理大小">批处理大小</h3>

<p>每台设备不一样，最终得到的批次数量可能与当前实验得到的数量不同。现在这情况下，以40批渲染5000个球体实例，这意味着每批125个球体。</p>

<p>每个批次都需要自己的矩阵数组。 此数据发送到GPU并存储在内存缓冲区中，在Direct3D中称为常量缓冲区，在OpenGL中称为统一缓冲区。 这些<strong>缓冲区具有最大大小</strong>，这限制了一批中可以容纳多少个实例。 假设台式机GPU每个缓冲区的限制为64KB。</p>

<p>一个矩阵由16个浮点数组成，每个浮点数均为4个字节。 因此，每个矩阵64个字节。 每个实例都需要一个对象到世界的转换矩阵。 但是，我们还需要一个世界到对象的矩阵来转换法线向量。 因此，最终每个实例有128个字节。 这导致最大批处理大小为“ 64000/128 = 500”，这只能在10个批处理中渲染5000个球体。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>内存单位是2进制，所以1KB表示1024字节，而不是1000。因此，'(64 * 1024)/ 128 = 512 '。UNITY_INSTANCED_ARRAY_SIZE默认定义为500，但您可以使用编译器指令覆盖它。例如，#pragma instancing_options maxcount:512将最大值设置为512。但是，这将导致断言失败错误，因此实际限制为511。到目前为止，500和512之间没有太大的差别。
</code></pre></div></div>

<p>即使假设台式机的最大容量为64KB成立，但是大多数移动设备的最大容量远远达不到64，可能仅为16KB。 Unity通过在针对OpenGL ES 3，OpenGL Core或Metal时将最大值除以四来解决此问题。 因为我在编辑器中使用的是OpenGL Core，所以最终的最大批处理大小为“ 500/4 = 125”。</p>

<p>可以通过添加编译器指令#pragma instancing_options force_same_maxcount_for_gl来禁用此自动减少功能。 多个instance选项组合在同一指令中。 但是，这可能会导致在部署到移动设备上时发生故障，因此请小心使用。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>那假设均等缩放选项呢？

可以使用#pragma instancing_options指示所有instance对象具有统一的缩放比例。 这消除了将世界到对象矩阵用于法线转换的需要(少存储一个矩阵)。 设置此选项后，虽然UnityObjectToWorldNormal函数确实会更改其行为，但它不会消除第二个矩阵数组。 因此，至少在Unity 2017.1.0中，此选项实际上没有任何作用。
</code></pre></div></div>

<h3 id="instance-shadows">Instance Shadows</h3>

<p>到目前为止，一直没有阴影。 重新打开主阴影的Soft shadow，并确保阴影距离足以包含所有球体</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010909964-776430193.png" width="250" /><font size="2.5">
            <i>批处理爆炸.</i>
        </font></center>

<p>为大量物体渲染阴影会增加GPU耗能。但是我们也可以在渲染球体阴影时使用GPU instance。在shadow caster-pass中添加instance指令；同时也增加<code class="language-plaintext highlighter-rouge">UNITY_VERTEX_INPUT_INSTANCE_ID</code> and <code class="language-plaintext highlighter-rouge">UNITY_SETUP_INSTANCE_ID</code></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_shadowcaster
#pragma multi_compile_instancing
</span><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
	<span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010911627-1161944067.png" width="250" /><font size="2.5">
            <i>instanced 阴影.</i>
        </font></center>

<h3 id="多光源">多光源</h3>

<p>我们仅在base-pass和shadow caster-pass中添加了instance支持。 因此，批处理不适用于其他光源。 要验证这一点，停用主光源并添加一些会影响多个球体的聚光灯或点光源。 不要为它们打开阴影，因为那样会降低帧速率。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010913312-1389275661.png" width="250" /><font size="2.5">
            <i>批处理爆炸.</i>
        </font></center>

<p>上图，完全不支持多光源批处理。 要将instance与多个光源结合使用，只能切换到延迟渲染路径。 为此，请将所需的编译器指令添加到着色器的延迟传递中。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_prepassfinal
#pragma multi_compile_instancing
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010914967-1310775534.png" width="250" /><font size="2.5">
            <i>多光源instance.</i>
        </font></center>

<h2 id="mixing-material-properties">Mixing Material Properties</h2>

<p>所有批处理都有一个限制：它们仅限于具有相同材料的对象。 当我们希望渲染的对象具有多样性时，此限制就会成为问题。</p>

<h3 id="随机着色">随机着色</h3>

<p>随机改变球体的颜色</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">MeshRenderer</span><span class="o">&gt;</span><span class="p">().</span><span class="n">material</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span>    <span class="kr">new</span> <span class="n">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010916576-490651101.png" width="250" /><font size="2.5">
            <i>球体与随机的颜色，没有批量和阴影.</i>
        </font></center>

<p>即使我们为物料启用了批处理，它也不再起作用。由于每个球体现在都有自己的材质，因此每个球体的着色器状态也必被更改。 这显示在统计面板中为SetPass call的数量。在这修改之前只有少量几个批次渲染，但是现在是5000加批次。</p>

<h3 id="材质属性块-material-property-blocks">材质属性块-Material Property Blocks</h3>

<p>除了为每个球体创建新的材质实例外，我们还可以使用材质属性块。 这些是小的修改，设置属性块的颜色并将其传递给球体的渲染器，而不是直接分配材质的颜色。<a href="http://docs.unity3d.com/Documentation/ScriptReference/MaterialPropertyBlock.html">MaterialPropertyBlock</a>官网介绍;</p>

<h3 id="property-buffers-属性缓冲区">Property Buffers-属性缓冲区</h3>

<p>渲染instance对象时，Unity通过数组形式将颜色数据传递到GPU内存并转换矩阵，Unity对存储在材料属性块中的属性执行相同的操作，但要使其起作用的话，我们必须在shader中定义一个instance的缓冲区。</p>

<p>声明instance缓冲区的工作类似于创建诸如插值器之类的结构，但是确切的语法因平台而异。 我们可以使用UNITY_INSTANCING_CBUFFER_START和UNITY_INSTANCING_CBUFFER_END宏来解决差异。 启用实例化后，它们将不执行任何操作。</p>

<p>将_Color变量的定义放在instance缓冲区中。 UNITY_INSTANCING_CBUFFER_START宏需要一个名称参数，实际名称无关紧要但要注意避免重名冲突。 宏以UNITY_INSTANCING_为其前缀。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="kt">float4</span> <span class="n">_Color</span><span class="p">;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div>

<p>像变换矩阵一样，启用instance后，颜色数据作为数组上传到GPU。UNITY_DEFINE_INSTANCED_PROP宏会为我们处理正确的声明语法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="c1">//float4 _Color;</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div>

<p>最后要访问fragment程序中的数组，我们还需要在其中知道instanceID。 因此，将其添加到插值器结构中。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在vertex顶点程序中，将ID从顶点数据复制到插值器。 启用实例化时，UNITY_TRANSFER_INSTANCE_ID宏定义此简单操作，否则不执行任何操作。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在片段程序的开头，使ID全局可用，就像在顶点程序中一样。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，我们必须在不使用instance时以_Color的形式访问颜色，而在启用实例化时以_Color [unity_InstanceID]的形式访问颜色。 使用UNITY_ACCESS_INSTANCED_PROP宏可同时支持上述两种访问。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="nf">GetAlbedo</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">albedo</span> <span class="o">=</span>
        <span class="nb">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>新版本如果编译有错误：
从2017.3及以上版本, UNITY_ACCESS_INSTANCED_PROP macro改了它需要的两个参数：buffer名，颜色名使用UNITY_ACCESS_INSTANCED_PROP(InstanceProperties, _Color).
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010918398-38688989.png" width="250" /></center>

<p>现在，我们的颜色随机的球再次被批处理。 我们<strong>可以用相同的方式使其他属性可变。 对于颜色，浮点数，矩阵和四分量浮点向量，这是可能的</strong>。 <strong>如果要改变纹理，可以使用单独的纹理数组</strong>，并将索引添加到实例化缓冲区。其他属性修改类似。</p>

<p>可以在同一个缓冲区中组合多个属性，但要牢记大小限制。 还应注意，缓冲区被划分为32位块，因此单个浮点数需要与向量相同的空间。 您也可以使用多个缓冲区，但是也有一个限制，它们不是免费提供的。 启用instance后，每个要缓冲的属性都将成为一个数组，因此仅对需要根据instance变化的属性执行此操作。</p>

<h3 id="阴影">阴影</h3>

<p>我们的阴影也取决于颜色。 调整shader阴影以便每个实例也可以支持唯一的颜色。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//float4 _Color;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>

<span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">float4</span> <span class="nf">MyShadowFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="lod-instance">LOD Instance</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialPropertyBlock</span> <span class="n">properties</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="p">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="nf">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="c1">//MaterialPropertyBlock properties = new MaterialPropertyBlock();</span>
        <span class="n">properties</span><span class="p">.</span><span class="nf">SetColor</span>
        <span class="p">(</span>
            <span class="s">"_Color"</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="c1">//t.GetComponent&lt;MeshRenderer&gt;().SetPropertyBlock(properties);</span>
        <span class="n">MeshRenderer</span> <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> 
        <span class="p">{</span>
            <span class="c1">//对LOD子对象设置颜色</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ci</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">ci</span> <span class="p">&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">childCount</span><span class="p">;</span> <span class="n">ci</span><span class="p">++)</span> <span class="p">{</span>
                <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">GetChild</span><span class="p">(</span><span class="n">ci</span><span class="p">).</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010919954-2006515171.png" width="250" /></center>

<p>不幸的是没有有效的批处理。Unity能够对以相同的LOD颜色球体进行批处理，但是如果可以像往常一样进行批处理会更好。 我们可以通过用缓冲数组替换unity_LODFade来实现。可以通过为支持实例化的每个过程添加lodfade实例化选项来指示Unity的着色器代码执行此操作。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_instancing
#pragma instancing_options lodfade
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010921540-656727216.png" width="250" /><font size="2.5">
            <i>instance LOD fading.</i>
        </font></center>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[还有另一种组合draw call的方法：GPU instance或Geometry instance。与动态批处理一样，此操作在运行时针对可见对象。 它的目标是让GPU一次性渲染同一网格的多个副本。 因此，它不能组合不同的网格或材质，但不仅限于小网格。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender19/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender19/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity 实时 GI &amp;amp; LPPV &amp;amp; LOD(翻译十八)</title><link href="https://www.damonc.top/Unity_RealTime_GI_LOD.html" rel="alternate" type="text/html" title="Unity 实时 GI &amp;amp; LPPV &amp;amp; LOD(翻译十八)" /><published>2018-01-23T20:00:00+08:00</published><updated>2018-01-23T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_RealTime_GI_LOD</id><content type="html" xml:base="https://www.damonc.top/Unity_RealTime_GI_LOD.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>支持实时全局光照</li>
  <li>用动画控制发光对GI的贡献</li>
  <li>使用光照探针代理体LPPV</li>
  <li>LOD组与GI结合</li>
  <li>LOD之间的淡入淡出</li>
</ul>

<p>从这篇开始，这个系列教程将由Unity 2017.1.0f3来完成。后续的Shader新特性Unity的旧版本没有，因为我们要使用一个新的着色器函数。</p>

<h2 id="实时全局光照">实时全局光照</h2>

<p>　　烘焙光照在静态物体上工作的非常好，对于动态几何体，由于有光照探针的缘故，烘焙光照这种方法也能工作的非常好。<strong>但是</strong>，烘焙光照不能处理动态光源。混合模式的光源可以通过一些实时的调节来消除，但调节的太多使得烘焙出来的间接光照不会改变。所以当你有一个户外场景的话，使用烘焙光照这种方法太阳的光照就不能有变化。太阳不能像在现实生活中一样在天空中移动，因为如果需要太阳在天空中移动的话，就需要逐渐变化的全局光照。所以场景必须一直不变。</p>

<p>　　为了使间接光照能够在移动的太阳这样的情况发挥作用，Unity使用Enlighten系统来计算实时全局光照。除了在运行时计算光照和光照探针以外，它还采用烘焙间接光照一样的方式来工作。</p>

<p>　　了解间接光需要知道光在静态表面之间如何反射。重点在于哪些表面可能会受到其他表面的影响，以及程度如何。弄清这些关系需要做很多的工作，不能实时完成。所以这个数据由编辑器处理并存储在运行时使用。然后 Enlighten系统会使用这个数据来计算实时光照贴图和探针数据。即使如此，只有低分辨率的光照贴图才可以在实时情况下运行。</p>

<h3 id="启用全局光照">启用全局光照</h3>

<p>实时全局光照、烘焙全局光照都可以独立启用。你可以同时启用两个，或者启用其中的一个，或者两个都不启用。这两个选项都是通过“光照”窗口的“实时照光照”部分中的复选框启用。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605003217232-1241081746.png" width="250" /><font size="2.5">
            <i>实时全局光照和烘焙光照同时启用的状态.</i>
        </font></center>

<p>要实际查看实时全局光照，请将测试场景中的主光源的模式设置为实时模式。 由于我们没有其他光源，即使启用了烘焙光照也能有效地关闭。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605003333043-1240937953.png" width="250" /><font size="2.5">
            <i>主光源设置为实时模式.</i>
        </font></center>

<p>确保场景中的所有对象都使用我们的白色材质。 像上次一样，球体都是动态的，而其他的都是静态几何体。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605003421685-903339628.png" width="250" /><font size="2.5">
            <i>只有动态对象能接收实时的全局光照.</i>
        </font></center>

<p>事实证明，只有动态对象会受益于实时全局光照。静态物体会变的暗一点。这是因为光照探针自动并入实时全局光照。而静态对象必须对实时的光照贴图进行采样，而这些光照贴图与烘焙的光照贴图不同。我们的着色器还不支持。</p>

<h3 id="烘焙的全局光照">烘焙的全局光照</h3>

<p>Unity在编辑模式下已经生成了实时的光照贴图，所以你可以随时查看实时的全局光照贴图。在编辑模式和播放模式之间进行切换的时候，这些贴图不会被保留，但是它们最终会得到相同的结果。你可以通过“光照”窗口的“对象贴图”选项来选择一个光照贴图静态对象对实时光照贴图进行检查。 选择“实时强度“可以可视化的查看实时光照贴图的数据。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605003617860-357493611.png" width="250" /><font size="2.5">
            <i>实时光照贴图，屋顶被选中时候的状态.</i>
        </font></center>

<p>虽然实时光照贴图已经被烘焙出来，并且它们还可能显示正确，但我们的meta渲染通道实际上使用的是错误的坐标。实时全局光照具有自己的光照贴图坐标，最终可能与静态光照贴图的坐标不同。Unity会根据光照贴图和对象的设置来自动生成这些坐标。这些数据存储在第三套UV中。所以将这些数据添加到My Lightmapping中的VertexData里面。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv2</span> <span class="o">:</span> <span class="nb">TEXCOORD2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>现在，MyLightmappingVertexProgram必须使用第二个或是第三个UV坐标，以及静态或动态光照贴图的大小和偏移量。 我们可以依靠UnityMetaVertexPosition函数来使用正确的数据。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyLightmappingVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
<span class="c1">//    v.vertex.xy = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;</span>
<span class="c1">//    v.vertex.z = v.vertex.z &gt; 0 ? 0.0001 : 0;</span>
<span class="c1">//    i.pos = UnityObjectToClipPos(v.vertex);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityMetaVertexPosition</span><span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv2</span><span class="p">,</span> <span class="n">unity_LightmapST</span><span class="p">,</span> <span class="n">unity_DynamicLightmapST</span>
    <span class="p">);</span>

    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityMetaVertexPosition</span><span class="err">是什么样子的？</span>

<span class="err">它除了通过</span><span class="n">unity_MetaVertexControl</span><span class="err">提供的标志来决定使用哪些坐标集和光照贴图之外，它还做了我们以前做的工作。</span>
<span class="kt">float4</span> <span class="nf">UnityMetaVertexPosition</span> <span class="p">(</span>
    <span class="kt">float4</span> <span class="n">vertex</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uv1</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uv2</span><span class="p">,</span>
    <span class="kt">float4</span> <span class="n">lightmapST</span><span class="p">,</span> <span class="kt">float4</span> <span class="n">dynlightmapST</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaVertexControl</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">uv1</span> <span class="o">*</span> <span class="n">lightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">lightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
        <span class="c1">// OpenGL right now needs to actually use incoming vertex position,</span>
        <span class="c1">// so use it in a very dummy way</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">1.0e-4</span><span class="n">f</span> <span class="o">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaVertexControl</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">uv2</span> <span class="o">*</span> <span class="n">dynlightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">dynlightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
        <span class="c1">// OpenGL right now needs to actually use incoming vertex position,</span>
        <span class="c1">// so use it in a very dummy way</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">1.0e-4</span><span class="n">f</span> <span class="o">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>请注意，<strong>meta渲染通道既用于烘焙光照贴图，也用于实时光照贴图</strong>。所以当使用实时全局光照的时候，meta渲染通道也将被包含在构建中。</p>

<h3 id="对实时光照贴图进行采样">对实时光照贴图进行采样</h3>

<p>为了对实时光照贴图进行采样，我们还必须将第三个UV坐标添加到My Lightmapping中的VertexData里面。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="nb">NORMAL</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">tangent</span> <span class="o">:</span> <span class="nb">TANGENT</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv2</span> <span class="o">:</span> <span class="nb">TEXCOORD2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>当一张实时光照贴图被使用的时候，我们必须将这个光照贴图的坐标添加到我们的插值器中去。标准着色器在单个插值器中将两个光照贴图的坐标集合组合起来 - 与其他数据复用 - 但是我们可以为两者准备单独的插值器。当_DYNAMICLIGHTMAP_ON_关键字被定义的时候，我们知道有动态光照数据。它是multi_compile_fwdbase编译器指令的关键字列表的一部分。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> 
<span class="p">{</span>
    <span class="cp">#if defined(DYNAMICLIGHTMAP_ON)
</span>        <span class="kt">float2</span> <span class="n">dynamicLightmapUV</span> <span class="o">:</span> <span class="n">TEXCOORD7</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>填充坐标就像对静态光照贴图的坐标所做的事情一样，除了动态光照图的缩放比例和偏移量的设置以外，这些可以通过unity_DynamicLightmapST变得可用。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined(DYNAMICLIGHTMAP_ON)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">dynamicLightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv2</span> <span class="o">*</span> <span class="n">unity_DynamicLightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_DynamicLightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>对实时光照贴图的采样是在我们的CreateIndirectLight函数中完成的。复制 #if defined(LIGHTMAP_ON) 代码块并进行一些更改。 <strong>首先</strong>，新的部分是基于DYNAMICLIGHTMAP_ON关键字的。 <strong>此外</strong>，它应该使用DecodeRealtimeLightmap而不是DecodeLightmap，这是因为实时光照贴图使用不同的颜色格式。而且因为这些数据可能被添加到烘焙光照中，不要立即分配给indirectLight.diffuse，而是使用最后添加的中间变量。 <strong>最后</strong>，当不使用烘焙光照贴图和实时光照贴图的时候，我们只应该对球面谐波进行采样。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(LIGHTMAP_ON)
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span>    <span class="n">DecodeLightmap</span><span class="p">(</span><span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">));</span>
    <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>        <span class="kt">float4</span> <span class="n">lightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
            <span class="n">unity_LightmapInd</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span>
        <span class="p">);</span>
        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeDirectionalLightmap</span><span class="p">(</span>
            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">lightmapDirection</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span>
        <span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="n">ApplySubtractiveLighting</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">);</span>
   <span class="c1">// #else</span>
   <span class="c1">// indirectLight.diffuse += max(0, ShadeSH9(float4(i.normal, 1)));</span>
<span class="cp">#endif
</span>
<span class="cp">#if defined(DYNAMICLIGHTMAP_ON)
</span>    <span class="kt">float3</span> <span class="n">dynamicLightDiffuse</span> <span class="o">=</span> <span class="n">DecodeRealtimeLightmap</span><span class="p">(</span>
        <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_DynamicLightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">dynamicLightmapUV</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>        <span class="kt">float4</span> <span class="n">dynamicLightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
            <span class="n">unity_DynamicDirectionality</span><span class="p">,</span> <span class="n">unity_DynamicLightmap</span><span class="p">,</span>
            <span class="n">i</span><span class="p">.</span><span class="n">dynamicLightmapUV</span>
        <span class="p">);</span>
                <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="n">DecodeDirectionalLightmap</span><span class="p">(</span>
                    <span class="n">dynamicLightDiffuse</span><span class="p">,</span> <span class="n">dynamicLightmapDirection</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span>
                <span class="p">);</span>
    <span class="cp">#else
</span>        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="n">dynamicLightDiffuse</span><span class="p">;</span>
    <span class="cp">#endif
#endif
</span>
<span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013216623-414124444.png" width="250" /><font size="2.5">
            <i>把实时全局光照应用于一切物体之上.</i>
        </font></center>

<p>现在我们的着色器使用的是实时光照贴图。最初，当使用Distance Shadowmask模式的时候，它的效果可能看起来与使用混合光源的烘焙光照的效果相同。当在播放模式下关闭光源的时候，差异就变得非常明显。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013217805-1029939389.png" width="250" /><font size="2.5">
            <i>禁用混合光源以后，间接光照仍然被保留.</i>
        </font></center>

<p>禁用混合光源以后，其间接光照将保持不变。相比之下，实时光照的间接贡献就会消失，并重新出现 - 这是应该出现的情况。 不过，新情况的完全烘焙好可能需要一段时间。 Enlighten系统会逐步调整光照贴图和光照探针。 这种情况发生的速度取决于场景的复杂性和实时全局光照CPU质量设置。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013219337-640958770.gif" width="250" /><font size="2.5">
            <i>切换实时光与实时GI.</i>
        </font></center>

<p>所有实时光源都对实时全局光照有贡献。 然而，它的典型用途是那些仅在主要方向上存在光线的光源，比如可以代表太阳，因为它在天空中移动。它适用于方向光源。点光源和聚光光源也能工作，但只是没有阴影。所以<strong>当使用带有阴影的点光源或聚光光源的时候，你可能会遇到不正确的间接光照结果</strong>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013220298-1170450196.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013221104-52400640.png" width="250" /><font size="2.5">
            <i>没有影响的间接光源和实时的聚光光源.</i>
        </font></center>

<p>如果要从实时全局光照里面去掉一个实时光源，可以通过设置它的Indirect Multiplier将它的光强度设置为零。</p>

<h3 id="自发光光源">自发光光源</h3>

<p>实时全局光照也可以用于自发光的静态物体。这使得可以匹配实时间接光照来改变物体的自发光变得可能。让我们来试试看吧。向场景中添加一个静态球体，并赋予它一个使用我们着色器的材质，这个材质具有黑色的反照率和白色的自发光颜色。最初，我们只能看到通过静态光照贴图实现的自发光的间接效果。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013222060-1153434303.png" width="250" /><font size="2.5">
            <i>用自发光球来烘焙全局光照.</i>
        </font></center>

<p>要将自发光光源烘焙到静态光照贴图中，我们必须在我们的着色器的GUI中设置材质的全局光照标志。因为我们总是将标志设置为BakedEmissive，光源最终将以烘焙好的光照贴图的形式出现。如果自发光光源是恒定的这个效果是很不错的，但这样就不允许我们做动画控制。</p>

<p>为了同时对自发光光源支持烘焙和实时光照，我们必须使其可配置化。我们可以通过向MyLightingShaderGUI中添加一个选项来做到这一点，使用的是MaterialEditor.LightmapEmissionProperty方法。这个方法的单个参数是属性的缩进级别。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoEmission</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialProperty</span> <span class="n">map</span> <span class="o">=</span> <span class="n">FindProperty</span><span class="p">(</span><span class="s">"_EmissionMap"</span><span class="p">);</span>
    <span class="n">Texture</span> <span class="n">tex</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">;</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="n">BeginChangeCheck</span><span class="p">();</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">TexturePropertyWithHDRColor</span><span class="p">(</span>
        <span class="n">MakeLabel</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">"Emission (RGB)"</span><span class="p">),</span> <span class="n">map</span><span class="p">,</span> <span class="n">FindProperty</span><span class="p">(</span><span class="s">"_Emission"</span><span class="p">),</span>
        <span class="n">emissionConfig</span><span class="p">,</span> <span class="nb">false</span>
    <span class="p">);</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">LightmapEmissionProperty</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="n">EndChangeCheck</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tex</span> <span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">SetKeyword</span><span class="p">(</span><span class="s">"_EMISSION_MAP"</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">editor</span><span class="p">.</span><span class="n">targets</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">globalIlluminationFlags</span> <span class="o">=</span>
                <span class="n">MaterialGlobalIlluminationFlags</span><span class="p">.</span><span class="n">BakedEmissive</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>每次当自发光属性发生改变的时候，我们也必须停止覆盖这个标志位。其实真正要做的事情比这更复杂一点。其中一个标志选项是EmissiveIsBlack，这个表示表示的是自发光计算可以跳过。这个标志总是会针对新材质进行设置。要让间接自发光能够工作，我们必须保证这个标志不被设置，无论我们选择实时光照还是烘焙。我们可以通过总是屏蔽标志值的EmissiveIsBlack位来做到这一点。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">editor</span><span class="p">.</span><span class="n">targets</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">.</span><span class="n">globalIlluminationFlags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MaterialGlobalIlluminationFlags</span><span class="p">.</span><span class="n">EmissiveIsBlack</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013222795-276798177.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013223641-2073252267.png" width="250" /><font size="2.5">
            <i>带有自发光球的实时全局光照效果.</i>
        </font></center>

<p>烘焙全局光照和实时全局光照之间的视觉差异主要是因为实时光照贴图通常具有比烘焙全局光照更低的分辨率。所以当自发光不发生不变化的时候，你也可以使用烘焙全局光照，确保能够利用其更高的分辨率。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EmissiveIsBlack的目的是什么？

这是一个优化，使得计算可以跳过全局光照烘焙过程。然而，只有当自发光颜色确实是黑色的时候，它才依赖于标志。由于这个标志位由着色器的GUI进行设置，这是当材质在检视器里面进行编辑的时候确定的。或者至少，这是Unity的标准着色器的做法。因此，如果自发光颜色稍后被脚本或动画系统更改，则该标志位不会做相应的调整。这是许多人不理解为什么对自发光做动画不会影响到实时全局光照的原因。结果就是如果你想在运行时更改自发光颜色，那么就不要将自发光颜色设置为纯黑色。

我们没有使用这种方法，我们使用的是LightmapEmissionProperty，它还提供了对自发光完全关闭全局光照的选项。 所以这个选择对于用户来说是非常明确的，没有任何隐藏的行为。如果用户不要使用自发光？ 那么只要确保它的全局光照被设置为None就可以了。
</code></pre></div></div>

<h3 id="对自发光进行动画控制">对自发光进行动画控制</h3>

<p>用于自发光的实时全局光照只能用于静态对象。虽然物体是静态的，但其材质的自发光属性还是可以被动画化，并且<strong>将被全局光照系统所捕获到</strong>。让我们用一个在自发光颜色为白色和自发光颜色为黑色之间振荡的简单组件来尝试下这个事情。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">EmissiveOscillator</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="n">Material</span> <span class="n">emissiveMaterial</span><span class="p">;</span>
    <span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">emissiveMaterial</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;().</span><span class="n">material</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">Color</span> <span class="n">c</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span>
            <span class="n">Color</span><span class="p">.</span><span class="n">white</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">black</span><span class="p">,</span>
            <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">Time</span><span class="p">.</span><span class="n">time</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">PI</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5f</span> <span class="p">+</span> <span class="m">0.5f</span>
        <span class="p">);</span>
        <span class="n">emissiveMaterial</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="s">"_Emission"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>将这个组件添加到我们的自发光球体。在播放模式下，自发光将会动画化，但间接光照不受影响。我们必须通知实时光照系统，它有工作要做。这可以通过调用适当网格渲染器的Renderer.UpdateGIMaterials方法来完成。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MeshRenderer</span> <span class="n">emissiveRenderer</span><span class="p">;</span>
<span class="n">Material</span> <span class="n">emissiveMaterial</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">emissiveRenderer</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
    <span class="n">emissiveMaterial</span> <span class="p">=</span> <span class="n">emissiveRenderer</span><span class="p">.</span><span class="n">material</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">emissiveMaterial</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="s">"_Emission"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="n">emissiveRenderer</span><span class="p">.</span><span class="nf">UpdateGIMaterials</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013226755-1065411582.gif" width="250" /><font size="2.5">
            <i>动画控制实时GI.</i>
        </font></center>

<p>调用UpdateGIMaterials方法会触发物体自发光的完整更新，并<strong>使用其meta渲染通道进行渲染</strong>。当自发光比纯色更复杂的时候，这是必要的，举个简单的例子来说，比如说我们使用纹理。如果一个<strong>纯色</strong>就足够了，那么我们可以通过使用渲染器和自发光颜色<strong>调用DynamicGI.SetEmissive方法</strong>来得到一个比较快捷的计算方式。这<strong>比使用meta渲染通道来渲染物体更快</strong>，所以在能够使用的时候可以利用这种方法。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//emissiveRenderer.UpdateGIMaterials();</span>
<span class="n">DynamicGI</span><span class="p">.</span><span class="nf">SetEmissive</span><span class="p">(</span><span class="n">emissiveRenderer</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="光照探针">光照探针</h2>

<p>烘焙全局光照和实时全局光照都通过光照探针应用于动态对象。物体的位置用于对光探针数据进行插值，然后将其用于全局光照。这对于相当小的物体来说下效果很好，但对于较大的物体来说就太粗糙了。</p>

<p>举个简单的例子来是说，将做了比较大拉伸的立方体添加到测试场景，以便它可以受到不同的光照条件的影响。它应该使用我们的白色材质。由于它是一个动态立方体，所以最终使用一个点来确定它的全局光照贡献。让我们移动这个点的位置，使得这一点最终处于一个被遮蔽的位置，那么整个立方体就会变黑，这显然是错误的。为了使这一点非常明显，让我们使用一个烘焙主光源，所以所有光照都来自烘焙全局光照和实时全局光照的数据。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013229006-1893115114.png" width="250" /><font size="2.5">
            <i>对于大型动态物体来说，光照效果不好.</i>
        </font></center>

<p>为了使光照探针器适用于这样的情况，我们可以使用光照探针代理体，或者简称为LPPV。这可以通过向着色器发送插值后的探针器数据网格而不是单个插值后的探针器数据来做到。这需要具有线性滤波的浮点数3D纹理，这就将这个方法限制到只能在现代显卡上使用。此外，还要确保在图形层设置中启用LPPV（光照探针代理体）支持。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013229758-553683463.png" width="250" /><font size="2.5">
            <i>启用了LPPV（光照探针代理体）支持.</i>
        </font></center>

<h3 id="向物体中添加一个光照探针代理体">向物体中添加一个光照探针代理体</h3>

<p>光照探针代理体可以以各种方式设置，最直接的方法是在作为使用光照探针代理体的物体的一个组件。你可以通过Component / Rendering / Light Probe Proxy Volume来添加它。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013230509-1112003195.png" width="250" /><font size="2.5">
            <i>光照探针代理体组件.</i>
        </font></center>

<p>LPPV（光照探针代理体）通过在运行时在光照探针之间进行插值来工作，就好像它们是常规动态对象的网格一样。插值后得到的结果被缓存，刷新模式（Refresh Mode）控制在何时进行更新。默认值为“自动（Automatic）”，这意味着当动态全局光照更改和探针器组发生移动的时候会触发更新。包围盒模式（Bounding Box Mode）控制着代理体的定位。自动本地化（AutomaticLocal ）意味着它会去匹配其附着的对象的包围盒。这些默认设置适用于我们的立方体，因此我们将保留这些设置。</p>

<p>要使我们的立方体实际使用LPPV（光照探针代理体），我们必须将其网格渲染器的光照探针(Light Probes)模式设置为使用光照探针代理体（Use ProxyVolume）。默认行为是使用对象本身的LPPV（光照探针代理体）组件，但也可以强制使用另一个代理体。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013231203-999964017.png" width="250" /><font size="2.5">
            <i>使用一个光照探针代理体而不是常规的探针器.</i>
        </font></center>

<p>自动分辨率模式（automaticresolution mode）对于我们的拉伸立方体不起作用。 因此，将“分辨率模式（Resolution Mode ）”设置为“自定义（Custom ）”，并确保立方体的角上有采样点，并沿着其长边有多个样本点。当你选中这个对象的时候，可以看到这些采样点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013231870-1652713364.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013232779-1496013065.png" width="250" /><font size="2.5">
            <i>自定义探针器分辨率以适应拉伸的立方体.</i>
        </font></center>

<h3 id="对光照探针代理体进行采样">对光照探针代理体进行采样</h3>

<p>立方体已变黑，因为我们的着色器现在还不支持LPPV（光照探针代理体）采样。为了使其工作，我们必须在CreateIndirectLight函数内调整球面谐波代码。当使用LPPV（光照探针代理体）的时候，_UNITY_LIGHT_PROBE_PROXY_VOLUME_被定义为1。我们在这种情况下什么都不做，看看会发生什么。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
</span>    <span class="cp">#if UNITY_LIGHT_PROBE_PROXY_VOLUME
</span>    <span class="c1">//...</span>
    <span class="cp">#else
</span>        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013233601-1847365803.png" width="250" /><font size="2.5">
            <i>没有更多球面谐波的效果.</i>
        </font></center>

<p>得到的结果是所有的球面谐波被禁用，对于不使用LPPV（光照探针代理体）的动态对象也是如此。这是因为_UNITY_LIGHT_PROBE_PROXY_VOLUME_在项目范围内定义，而不是对每个对象实例进行定义。单个对象是否使用LPPV由UnityShaderVariables中定义的unity_ProbeVolumeParams的X分量指定。如果unity_ProbeVolumeParams的X分量设置为1，那么我们有一个LPPV（光照探针代理体），否则我们应该使用常规的球面谐波。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if UNITY_LIGHT_PROBE_PROXY_VOLUME
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="p">}</span>
<span class="cp">#else
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>要对光照探针代理体进行采样，我们可以使用SHEvalLinearL0L1_SampleProbeVolume函数而不是ShadeSH9。这个函数在UnityCG中进行定义，并且需要世界空间中的位置作为额外的参数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SHEvalLinearL0L1_SampleProbeVolume</span>
    <span class="p">(</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span>
    <span class="p">);</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SHEvalLinearL0L1_SampleProbeVolume如何工作？

_顾名思义，该函数仅包括前两个球面谐波带L0和L1。 Unity不使用LPPV（光照探针代理体）的第三个波带。所以我们得到较低质量的光照近似值，但是我们在多个世界空间中的样本之间进行插值，而不是使用单个点。下面是这个函数的代码。_
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">half3</span> <span class="nf">SHEvalLinearL0L1_SampleProbeVolume</span> <span class="p">(</span><span class="kt">half4</span> <span class="n">normal</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">float</span> <span class="n">transformToLocal</span> <span class="o">=</span> <span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">float</span> <span class="n">texelSizeX</span> <span class="o">=</span> <span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>

    <span class="c1">//The SH coefficients textures and probe occlusion</span>
    <span class="c1">// are packed into 1 atlas.</span>
    <span class="c1">//-------------------------</span>
    <span class="c1">//| ShR | ShG | ShB | Occ |</span>
    <span class="c1">//-------------------------</span>

    <span class="kt">float3</span> <span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="n">transformToLocal</span> <span class="o">==</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)</span> <span class="o">?</span>
        <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ProbeVolumeWorldToObject</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span> <span class="o">:</span>
        <span class="n">worldPos</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">texCoord</span> <span class="o">=</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">unity_ProbeVolumeMin</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">unity_ProbeVolumeSizeInv</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span><span class="p">;</span>

    <span class="c1">// We need to compute proper X coordinate to sample. Clamp the</span>
    <span class="c1">// coordinate otherwize we'll have leaking between RGB coefficients</span>
    <span class="n">float</span> <span class="n">texCoordX</span> <span class="o">=</span>
        <span class="nb">clamp</span><span class="p">(</span><span class="n">texCoord</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span> <span class="o">*</span> <span class="n">texelSizeX</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span> <span class="o">*</span> <span class="n">texelSizeX</span><span class="p">);</span>

    <span class="c1">// sampler state comes from SHr (all SH textures share the same sampler)</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoordX</span><span class="p">;</span>
    <span class="kt">half4</span> <span class="n">SHAr</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX3D_SAMPLER</span><span class="p">(</span>
        <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">texCoord</span>
    <span class="p">);</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoordX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">half4</span> <span class="n">SHAg</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX3D_SAMPLER</span><span class="p">(</span>
        <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">texCoord</span>
    <span class="p">);</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoordX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">half4</span> <span class="n">SHAb</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX3D_SAMPLER</span><span class="p">(</span>
        <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">texCoord</span>
    <span class="p">);</span>
    <span class="c1">// Linear + constant polynomial terms</span>
    <span class="kt">half3</span> <span class="n">x1</span><span class="p">;</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">SHAr</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">SHAg</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">SHAb</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">x1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013235369-787618137.png" width="250" /><font size="2.5">
            <i>采样后的LPPV（光照探针代理体）的效果，在伽马空间中的效果太暗.</i>
        </font></center>

<p>我们的着色器现在在需要的时候对LPPV（光照探针代理体）进行采样，但结果太暗了。至少在伽马颜色空间中工作就是这样的结果。这是因为球面谐波数据存储在线性空间中。因此，可能需要进行颜色的转换。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SHEvalLinearL0L1_SampleProbeVolume</span><span class="p">(</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span>
    <span class="p">);</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
    <span class="cp">#if defined(UNITY_COLORSPACE_GAMMA)
</span>               <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">LinearToGammaSpace</span><span class="p">(</span><span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
        <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013236310-749557848.png" width="250" /><font size="2.5">
            <i>采样后的LPPV（光照探针代理体）的效果，带有正确的颜色.</i>
        </font></center>

<h2 id="lod-groups">LOD Groups</h2>

<p>当一个对象最终只覆盖应用程序窗口的一小部分的时候，你不需要高度详细的网格来渲染它。你可以根据对象在视图中的大小使用不同的网格。这被称为细节层次，或简称LOD。Unity允许我们通过组件LOD组来实现这样的功能。</p>

<h3 id="创建一个lod层次结构">创建一个LOD层次结构</h3>

<p>这个想法是你在各种不同的LOD等级使用同一网格的多个版本。最高级 - LOD 0 - 具有最多的顶点、子对象、动画、复杂的材质等。随后的级别逐渐变得更简单，更容易计算。在理想情况下，相邻的LOD等级被设计为使得当Unity从一个LOD等级切换到另一个LOD等级的时候，你不能轻易地辨别出它们之间的区别。否则突然有LOD等级变化的时候就会让人很晕。但是在研究这种技术的时候，我们会使用明显的不同的网格。</p>

<p>创建一个空的游戏对象并给它两个子对象。第一个子对象是标准球体，第二个子对象是标准立方体，其大小设置为0.75。 预期的结果看起来像是一个重叠的球体和立方体。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013237093-2016130218.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013237695-361227834.png" width="250" /><font size="2.5">
            <i>球体和立方体作为一个对象.</i>
        </font></center>

<p>通过Component /Rendering / LOD Group将一个LOD组组件添加到父对象。你会得到一个具有默认设置的LOD组，它有三个LOD等级。 百分比是指由对象的包围盒覆盖的窗口的垂直部分。因此，当垂直尺寸下降到窗口高度的60％的时候，默认设置为切换到LOD 1，当垂直尺寸下降到窗口高度的30％的时候，默认设置为切换到LOD 2。当垂直尺寸下降到窗口高度的10％的时候，它根本不渲染。 你可以通过拖动LOD框的边来更改这些阈值。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013238446-1711254101.png" width="250" /><font size="2.5">
            <i>组件LOD组.</i>
        </font></center>

<p>这些阈值由LOD偏移（LOD Bias）进行修改，LOD偏移（LOD Bias）可以在组件检视器里面查看并修改。目前使用的是质量设置为2的默认值，这意味着阈值被减半。也可以设置为最大LOD等级，这将导致跳过最高级别。</p>

<p>为了使其工作，你必须告诉组件每个LOD等级都会使用哪些对象。这是通过选择一个LOD块并将对象添加到其“渲染器”列表中完成的。你可以在场景中添加任何对象，但一定要确保添加其子对象到LOD块的“渲染器”列表。让LOD 0的“渲染器”使用球体，让LOD 1的“渲染器”使用立方体。我们将LOD 2的“渲染器”留空，所以我们只有两个LOD等级。如果需要的话，你可以通过右键单击上下文菜单删除并插入LOD等级。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013239110-167141319.png" width="250" /><font size="2.5">
            <i>让球这个子物体使用LOD 0等级.</i>
        </font></center>

<p>一旦配置了LOD等级，你可以通过移动相机来查看它们的效果。如果物体足够大的话，它将使用球体，否则的话它将使用立方体，或根本不会渲染。</p>

<center>
    <video controls="" width="" loop="true" autoplay="true" preload="auto">
        <source src="https://thumbs.gfycat.com/ShyAffectionateFairyfly-mobile.mp4" type="video/mp4" />
    </video>
</center>
<font size="2.5">
        <center><i><b>LOD切换.</b></i></center>    
    </font>

<h3 id="烘焙全局光照和lod组">烘焙全局光照和LOD组</h3>

<p>因为LOD组是如何渲染的取决于它的<strong>视图大小</strong>，所以它们自然是动态的。但是，你仍然可以使其成为静态。对整个对象层次结构执行此操作，因此也包括了根节点和它的两个子节点。然后设置主光源为烘焙光源，看看会发生什么。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013240110-283978428.png" width="250" /><font size="2.5">
            <i>让球这个子物体使用LOD 0等级.</i>
        </font></center>

<p><em>使用烘焙光源得到的效果</em></p>

<p>看起来在烘焙静态光照贴图的时候使用的是LOD 0。 我们最终总是能够看到球体的阴影和间接光照的贡献，即使LOD组切换到一个立方体或是对自身做了剔除。但请注意，立方体也是使用了静态光照贴图。 所以它不使用光照探针，对吧？ 转动光照探针组就能发现这一点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013241019-1435398902.png" width="250" /><font size="2.5">
            <i>没有光照探针时候的烘焙光照.</i>
        </font></center>

<p>禁用光探针组会使得立方体变得更暗。这意味着他们不再接受间接光照。 这是因为在烘焙过程中确定间接光照的时候使用的是LOD 0。为了找到其他LOD等级下的间接光照， Unity可以做到的最好程度是依靠烘焙光照探针。 因此，即使在运行时我们不需要光照探针，我们也需要光照探针来为我们的立方体计算间接光照。</p>

<h3 id="实时全局光照和lod组">实时全局光照和LOD组</h3>

<p>当只使用实时全局光照的时候，方法是类似的，除了我们的立方体现在在运行时使用的是光照探针。你可以通过选择球体或立方体来验证这一点。选择立方体后，你可以看到小工具显示了哪些光照探针被使用。 球体不显示它们，因为它使用的是动态光照贴图。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013242971-183808454.png" width="250" /><font size="2.5">
            <i>LOD 1使用光照探针来计算实时全局光照.</i>
        </font></center>

<p>当烘焙全局光照和实时全局光照同时使用的时候，它会变得更加复杂。 在这种情况下，立方体应该对烘焙全局光照使用光照贴图，对实时全局光照使用光照探针。不幸的是，这是不可能的，这是因为光照贴图和和球面谐波不能同时使用。这是一个非此即彼的问题。因为光照贴图数据对于立方体来说是可用的，所以Unity最终会使用它。因此，立方体不受实时全局光照的影响。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013243831-1402316420.png" width="250" /><font size="2.5">
            <i>仅对LOD 1等级使用烘焙光照，使用的是低强度的主光源.</i>
        </font></center>

<p>一个重要的细节是，烘焙的LOD等级和渲染的LOD等级是完全独立的。 他们不需要使用相同的设置。如果实时全局光照最终比烘焙全局光照更重要，你可以强制立方体使用光照探针，确保它对于光照贴图来说不是静态的，同时保持球体静止。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013244794-1245713384.png" width="250" /><font size="2.5">
            <i>LOD 1强制使用光照探针.</i>
        </font></center>

<h3 id="lod淡入淡出功能">LOD淡入淡出功能</h3>

<p>LOD组这种方法的缺点是，当LOD等级发生变化的时候，它可以在视觉上很明显的表现出来。几何体会在视图中突然弹出、消失或改变形状。 这可以通过相邻LOD等级之间的淡入淡出来缓解，这通过将LOD组的渐变模式设置为淡入淡出来完成。还有另一种渐变模式，由Unity用于SpeedTree对象，我们不会使用这种模式。</p>

<p>当启用淡入淡出的时候，每个LOD等级都会显示一个淡入变换宽度（Fade Transition Width ）字段，用于控制其块的哪个部分用于衰落。举个简单的例子来说，当设置为0.5的时候，一半LOD范围将用于淡出到下一级。或者，淡入淡出过程可以是有动画的，在这种情况下，在LOD等级之间的切换需要大约半秒钟。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013245526-1175118666.png" width="250" /><font size="2.5">
            <i>带有0.5变换宽度的淡入淡出.</i>
        </font></center>

<p>当启用淡入淡出的时候，在LOD组之间进行转换的时候会同时渲染两个LOD等级。</p>

<h3 id="支持淡入淡出">支持淡入淡出</h3>

<p>Unity的标准着色器在默认情况下是不支持淡入淡出的。如果想要支持支持淡入淡出的话，你必须复制标准着色器并为LOD_FADE_CROSSFADE关键字添加一个多编译指令。添加这条指令还有一个原因是为了在My First Lighting着色器里面支持淡入淡出功能。让我们将这条指令添加到除了meta渲染通道以外的所有渲染通道。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ LOD_FADE_CROSSFADE
</span></code></pre></div></div>

<p>我们将使用抖动来在LOD等级之间进行转换。这种方法适用于前向渲染和延迟渲染，也适用于有阴影的情况。</p>

<p>在创建半透明阴影的时候，我们已经使用了抖动这种方法。它需要片段的屏幕空间坐标，这迫使我们为顶点程序和片段程序使用不同的插值器结构。所以让我们复制My Lighting 中的Interpolators结构，将其重命名为InterpolatorsVertex。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>

<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>

<span class="p">};</span>

<span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当我们必须进行淡入淡出处理的时候，片段程序的插值器里面必须包含vpos，否则我们可以使用同样的位置信息。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UNITY_VPOS_TYPE</span> <span class="n">vpos</span> <span class="o">:</span> <span class="nb">VPOS</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>我们可以在我们片段程序中开始的位置使用UnityApplyDitherCrossFade函数来执行淡入淡出操作。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnityApplyDitherCrossFade是如何工作的？

这个函数在UnityCG中进行定义。它的方法类似于我们在《渲染12:半透明阴影》中使用的抖动方法，区别只是整个对象的抖动级别是均匀的。 因此，不需要混合抖动级别。 它使用存储在4×64大小的二维纹理中的16个抖动级别，而不是4×4×16大小的三维纹理。
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>unity_LODFade变量在UnityShaderVariables中进行定义。它的Y分量包含的是对象的渐变量，共有十六步。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013246331-642394563.png" width="250" /><font size="2.5">
            <i>通过抖动方法得到的淡入淡出几何体.</i>
        </font></center>

<p>淡入淡出现在可以在几何体上正常工作了。为了使其适用于阴影，我们必须调整My Shadows着色器。 首先，当我们进行淡入淡出处理的时候，必须使用vpos。其次，我们还必须在片段程序开始的位置使用UnityApplyDitherCrossFade函数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if SHADOWS_SEMITRANSPARENT || defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UNITY_VPOS_TYPE</span> <span class="n">vpos</span> <span class="o">:</span> <span class="nb">VPOS</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">positions</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="kt">float4</span> <span class="nf">MyShadowFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013247225-2138491287.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013249358-581600268.gif" width="250" /><font size="2.5">
            <i>对几何体和阴影都做了淡入淡出处理.</i>
        </font></center>

<p>因为立方体和球体相互交叉，所以我们在对它们做淡入淡出处理的时候，得到一些奇怪的自阴影效果。这对于看到淡入淡出处理能在阴影上起作用是很方便的，但是当你为实际游戏创建LOD几何体的时候，需要注意这些瑕疵。</p>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><category term="Unity3d API" /><summary type="html"><![CDATA[了解间接光需要知道光在静态表面之间如何反射。重点在于哪些表面可能会受到其他表面的影响，以及程度如何。弄清这些关系需要做很多的工作，不能实时完成。所以这个数据由编辑器处理并存储在运行时使用。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender18/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender18/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity 混合光照(翻译十七)</title><link href="https://www.damonc.top/Unity_Mix_Lighting.html" rel="alternate" type="text/html" title="Unity 混合光照(翻译十七)" /><published>2018-01-21T20:00:00+08:00</published><updated>2018-01-21T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_Mix_Lighting</id><content type="html" xml:base="https://www.damonc.top/Unity_Mix_Lighting.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>只烘焙间接光</li>
  <li>混合烘焙阴影和实时阴影</li>
  <li>处理代码的变化和问题</li>
  <li>支持消减光照（subtractivelighting）</li>
</ul>

<h2 id="烘焙间接光">烘焙间接光</h2>

<p>光照贴图可以提供预计算光照：以纹理内存为代价减少了GPU在实时中的工作量；还加入了间接光。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>烘焙光的限制
    1.高光不能被烘焙
    2.烘焙光只通过光照探头影响动态物体
    3.烘焙光不产生实时阴影
</code></pre></div></div>

<p>你可以在下面的截图中看到完全实时光照和完全烘焙光照之间的区别。<a href="https://www.damonc.top/2018/01/19/Unity_Static_Lightting/">前一篇</a>教程中的一个场景，唯一的不同是我将所有的球体都设置为动态并重新改变了一些球体的位置。其它一切都是静态的。这是使用前向渲染的方法。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002309942-1932595350.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002311276-1707091650.png" width="250" /><font size="2.5">
            <i>完全实时和完全烘焙光照.</i>
        </font></center>

<h3 id="混合模式">混合模式</h3>

<p>烘焙光照有间接光而没有实时光照，因为间接光需要光照贴图。由于间接光可以为场景加入很大的真实感，如果我们可以将它和实时光照融合在一起就再好不过了。这是可以的，但也意味着着色的开销会增加。我们需要将混合光（Mixed Lighting）的光照模式（Lighting Mode）设置为烘焙间接（Baked Indirect）。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002312394-324532807.png" width="250" /><font size="2.5">
            <i>混合光照，烘焙间接.</i>
        </font></center>

<p>我们已经在<a href="https://www.damonc.top/2018/01/19/Unity_Static_Lightting/">前一篇</a>教程中切换到这个模式了，但是之前我们只使用了完全烘焙光照。虽然表现结果与完全烘焙光照相同，混合光照模式没有任何区别。为了使用混合光照，光源的模式必须要设置为混合。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002313374-471117722.png" width="250" /><font size="2.5">
            <i>混合模式的主光源.</i>
        </font></center>

<p>在将主定向光改为混合光后，两件事会发生：</p>

<p>第一，Unity会再次烘焙光照贴图。这一次光照贴图只会存储间接光，所以它会比之前的暗很多。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002314496-2053721233.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002315595-1655913714.png" width="250" /><font size="2.5">
            <i>完全烘焙的光照贴图 vs 只有间接光的光照贴图.</i>
        </font></center>

<p>第二，所有物体都会像主光源被设置为实时那样被照亮。只有一点不同：光照贴图被用来为静态物体添加间接光，而不是球谐光或探头。动态物体的间接光仍要使用光照探头。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002316908-68636833.png" width="250" /><font size="2.5">
            <i>混合光照，实时直接光照烘焙间接光.</i>
        </font></center>

<p>我们不需要改变我们的着色器来支持这点，因为前向基础通道（forward base pass）已经融合了光照贴图数据和主定向光源。和往常一样，额外的光照会得到附加通道（additive pass）。当使用延迟渲染通道时，主光源也会得到一个通道。</p>

<p><strong>混合光可以在运行时调整吗？</strong><br />
是的，因为它们被用于实时光照。但是，它们的烘焙数据时静态的。所以在运行时你只能稍微调整光照，比如稍微调整它的强度。更大的变化会使人明显看出烘焙光照和实时光照之间的不同步。_</p>

<h3 id="更新着色器">更新着色器</h3>

<p>刚开始一切似乎正常运行。但是，定向光的阴影衰减发生了错误。我们通过极大降低阴影距离观察到阴影被剪掉了。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002318408-928334072.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002319957-145579115.png" width="250" /><font size="2.5">
            <i>阴影衰减，标准着色器vs我们的着色器.</i>
        </font></center>

<p>虽然Unity很长一段时间都有混合光照模式，但实际上它在Unity5中就不起作用了。Unity5.6中新加入了一个混合光照模式，即我们现在使用的这个。当该新模式被加入时，_UNITY_LIGHT_ATTENUATION_宏下面的代码发生了变化。我们在使用完全烘焙光照或者实时光照时没有注意到这一点，但是我们必须更新我们的代码以适应混合光照的新方法。由于这是最近的一个巨大的变化，我们必须要注意它所带来的问题。</p>

<p>我们要改变的第一点是不再使用_SHADOW_COORDS_宏来定义阴影坐标的插值（interpolater）。我们必须使用新的_UNITY_SHADOW_COORDS_宏来代替它。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span>
<span class="p">{</span>
    <span class="c1">//SHADOW_COORDS(5)</span>
    <span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div></div>

<p>同样，<em>TRANSFER_SHADOW_应该替换为_UNITY_TRANSFER_SHADOW</em></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//TRANSFER_SHADOW(i);</span>
    <span class="n">UNITY_TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   
<span class="p">}</span>
</code></pre></div></div>

<p>然而，这会产生一个编译错误，因为该宏需要一个额外的参数。从Unity 5.6开始，只有定向阴影的屏幕空间坐标中被放入一个插值。点光源和聚光源的阴影坐标现在在片段程序（fragment program）中进行计算。有个新变化：在一些情况中光照贴图的坐标被用在阴影蒙版（shadow mask）中，我们会在后面讲解这一点。为了该宏能正常工作，我们必须为它提供第二个UV通道中的数据，其中包含光照贴图的坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">);</span>

</code></pre></div></div>

<p>这样会再次产生一个编译错误。这是因为在一些情况下_UNITY_SHADOW_COORDS_错误地创建了一个插值，尽管实际上并不需要。在这种情况下，_TRANSFER_SHADOW_不会初始化它，因而导致错误。这个问题出现在5.6.0中，一直到5.6.2和2017.1.0beta版本中都有。</p>

<p>人们通常不会注意到这个问题，因为Unity的标准着色器使用_UNITY_INITIALIZE_OUTPUT_宏来完全地初始化它的插值结构体。因为我们不使用这个宏，所以出现了问题。为了解决它，我们使用_UNITY_INITIALIZE_OUTPUT_宏来初始化我们的插值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>  
<span class="p">}</span>
</code></pre></div></div>

<p>_UNITY_INITIALIZE_OUTPUT_有什么作用？</p>

<p>它只是为变量分配数值0，将其转换为正确的类型。至少是当程序支持该宏时会这样，否则它不会做任何事。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Initialize arbitrary structure with zero values.</span>
<span class="c1">// Not supported on some backends</span>
<span class="c1">// (e.g. Cg-based particularly with nested structs).</span>
<span class="c1">// hlsl2glsl would almost support it, except with structs that have</span>
<span class="n">arrays</span>
<span class="c1">// -- so treat as not supported there either :(</span>
<span class="cp">#if defined(UNITY_COMPILER_HLSL) || defined(SHADER_API_PSSL) || \\
</span><span class="n">defined</span><span class="p">(</span><span class="n">UNITY_COMPILER_HLSLCC</span><span class="p">)</span>
    <span class="cp">#define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
#else
</span>    <span class="cp">#define UNITY_INITIALIZE_OUTPUT(type,name)
#endif
</span></code></pre></div></div>

<p><strong>通常我们倾向于只使用显式赋值，很少使用这个初始化插值宏。</strong></p>

<h3 id="手动衰减阴影">手动衰减阴影</h3>

<p>现在我们正确地使用了新的宏定义，但是主光源的阴影仍然没有按照它们应该的那样衰减。结果我们发现当同时使用定向阴影和光照贴图时，<em>UNITY_LIGHT_ATTENUATION</em> 不会对光源进行衰减。使用混合模式的主定向光源就会产生这个问题。所以我们必须手动设置。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>为什么在这个例子中阴影没有衰减？

1、UNITY_LIGHT_ATTENUATION宏之前是独立使用的，但是自从Unity5. 6它开始和Unity的标准全局光照函数一同使用。我们没有采用同样的方法，因此它不能正常工作。  
2、至于为什么要做这个改动，唯一的线索就是AutoLight中的一段注释：“为了性能的原因以GI函数的深度处理阴影”。由于着色器编译器会随意地移动代码。
</code></pre></div></div>

<p>对于我们的延迟光照着色器，我们已经有了进行阴影衰减的代码。将相关代码片段从MyDeferredShading中复制到My Lighting中的一个新函数中。唯一实际的区别在于我们必须使用视图向量和视图矩阵构建viewZ。我们只需要Z分量，所以无需进行一次完整的矩阵乘法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">viewZ</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">UNITY_MATRIX_V</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该手动衰减必须在使用了_UNITY_LIGHT_ATTENUATION初始化完成_之后。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>只有当 <em>HANDLE_SHADOW_BLENDING_IN_GI</em> 在UnityShadowLibrary.cginc文件中有定义时，FadeShadows才会开始计算。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI
</span>        <span class="c1">// UNITY_LIGHT_ATTENUATION doesn't fade shadows for us.</span>
        <span class="n">float</span> <span class="n">viewZ</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">UNITY_MATRIX_V</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后，我们的阴影如它们应该的那样正常衰减了。</p>

<h2 id="使用阴影蒙版">使用阴影蒙版</h2>

<p>烘焙间接光的混合模式成本很高。它们需要实时光照外加间接光的光照贴图那么大的工作量。它和完全烘焙光照相比最重要的是加入了实时阴影。幸运的是，有一个方法仍可以将阴影烘焙到光照贴图中，将其和实时阴影综合起来。为了开启这个功能，我们将混合光照模式改为Shadowmask。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002321275-2134383138.png" width="250" /><font size="2.5">
            <i>Shadowmask模式.</i>
        </font></center>

<p>在这个模式中，混合光照的间接光和阴影衰减都存储在了光照贴图中。阴影被存储在一张额外的贴图（即阴影蒙版）。当只有主定向光源时，红色的阴影蒙版决定是否过滤被照亮的物体。红色是因为阴影信息被存储在纹理的R通道中。事实上，贴图中至多可以储存四个光照的阴影，因为它只有四个通道。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002322323-849349388.png" width="250" /><font size="2.5">
            <i>烘焙的强度以及阴影蒙版.</i>
        </font></center>

<p>在Unity创建了阴影蒙版后，静态物体的阴影投射会消失。只有光照探头仍会处理它们。动态物体的阴影不受影响。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002323536-1775535799.png" width="250" /><font size="2.5">
            <i>没有烘焙阴影.</i>
        </font></center>

<h3 id="对阴影蒙版采样">对阴影蒙版采样</h3>

<p>为了重新得到烘焙阴影，我们必须对阴影蒙版采样样。Unity的宏已经对点光源和聚光源进行了取样，不过我们必须也要将它包含在我们的FadeShadows函数中。为此我们可以使用UnityShadowLibrary中的UnitySampleBakedOcclusions函数。它需要光照贴图的UV坐标和世界位置作为输入参数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI
</span>        
        <span class="n">float</span> <span class="n">bakedAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleBakedOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnitySampleBakedOcclusion是什么样子的？

它使用光照贴图坐标对阴影蒙版取样，然后选择适当的通道。unity_OcclusionMaskSelector变量是一个含有一个分量的向量，该分量被设置为1以匹配当前正在被着色的光源。
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed</span> <span class="nf">UnitySampleBakedOcclusion</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightmapUV</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">fixed4</span> <span class="n">rawOcclusionMask</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
                <span class="n">unity_ShadowMask</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">lightmapUV</span><span class="p">.</span><span class="n">xy</span>
            <span class="p">);</span>
        <span class="cp">#else
</span>            <span class="n">fixed4</span> <span class="n">rawOcclusionMask</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_ShadowMask</span><span class="p">,</span> <span class="n">lightmapUV</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="cp">#endif
</span>        <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">rawOcclusionMask</span><span class="p">,</span> <span class="n">unity_OcclusionMaskSelector</span><span class="p">));</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p><em>该函数还处理了光照探头代理体积的衰减，但是我们还没有支持这点所以我去掉了那部分的代码。这就是为什么该函数有一个世界位置的参数。</em></p>

<p>当使用阴影蒙版时，_UnitySampleBakedOcclusions_提供给我们烘焙阴影衰减，在其他情况下它的值都为1。现在我们必须将它和我们已经有的衰减综合起来然后对阴影进行衰减。UnityMixRealtimeAndBakedShadows函数为我们实现了这些。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">bakedAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleBakedOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
<span class="c1">//attenuation = saturate(attenuation shadowFade);</span>
<span class="n">attenuation</span> <span class="o">=</span> <span class="n">UnityMixRealtimeAndBakedShadows</span>
<span class="p">(</span>
    <span class="n">attenuation</span><span class="p">,</span> <span class="n">bakedAttenuation</span><span class="p">,</span> <span class="n">shadowFade</span>
<span class="p">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnityMixRealtimeAndBakedShadows是如何工作的？

它也是UnityShadowLibrary中的一个函数。它还处理光照探头代理体积以及一些其他极端情况。那些情况和我们无关，所以我删除了一些内容。
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inline</span> <span class="n">half</span> <span class="nf">UnityMixRealtimeAndBakedShadows</span> <span class="p">(</span>
    <span class="n">half</span> <span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">half</span> <span class="n">bakedShadowAttenuation</span><span class="p">,</span> <span class="n">half</span> <span class="n">fade</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if !defined(SHADOWS_DEPTH) &amp;&amp; !defined(SHADOWS_SCREEN) &amp;&amp; \\
</span>        <span class="o">!</span><span class="n">defined</span><span class="p">(</span><span class="n">SHADOWS_CUBE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bakedShadowAttenuation</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="cp">#if defined (LIGHTMAP_SHADOW_MIXING)
</span>            <span class="n">realtimeShadowAttenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span> <span class="o">+</span> <span class="n">fade</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">bakedShadowAttenuation</span><span class="p">);</span>
        <span class="cp">#else
</span>            <span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span>
                <span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">bakedShadowAttenuation</span><span class="p">,</span> <span class="n">fade</span>
            <span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#else //no shadowmask
</span>        <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span> <span class="o">+</span> <span class="n">fade</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p><strong>如果没有动态阴影，那么结果将得到烘焙的衰减。这意味着动态物体没有阴影，以及被映射到光照贴图上的物体没有烘焙阴影。</strong></p>

<p>当没有使用阴影蒙版时，它会进行原来的衰减。否则，它会根据我们是否做了阴影混合进行表现，我们后面再讲。现在，它只是在实时衰减和烘焙衰减之间进行一个插值。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002325094-888038969.png" width="250" /><font size="2.5">
            <i>实时阴影和阴影蒙版阴影.</i>
        </font></center>

<p>现在静态物体有了实时阴影和烘焙阴影，且它们正确地混合。实时阴影的衰减仍然超过了阴影距离，但是烘焙阴影没有。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002326606-1972314102.png" width="250" /><font size="2.5">
            <i>只有实时阴影衰减了.</i>
        </font></center>

<h3 id="添加一个阴影蒙版g-buffer">添加一个阴影蒙版G-Buffer</h3>

<p>现在阴影蒙版可用于前向渲染路径，但是我们需要使它也可用于延迟渲染：添加阴影蒙版信息作为一个额外的G-缓存。所以当_SHADOWS_SHADOWMASK_被定义时，在_FragmentOutput_结构体中添加一个缓存。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">FragmentOutput</span> <span class="p">{</span>
    <span class="cp">#if defined(DEFERRED_PASS)
</span>        <span class="kt">float4</span> <span class="n">gBuffer0</span> <span class="o">:</span> <span class="n">SV_Target0</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer1</span> <span class="o">:</span> <span class="n">SV_Target1</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer2</span> <span class="o">:</span> <span class="n">SV_Target2</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer3</span> <span class="o">:</span> <span class="n">SV_Target3</span><span class="p">;</span>

        <span class="cp">#if defined(SHADOWS_SHADOWMASK)
</span>            <span class="kt">float4</span> <span class="n">gBuffer4</span> <span class="o">:</span> <span class="n">SV_Target4</span><span class="p">;</span>
        <span class="cp">#endif
</span>    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">SV_Target</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>添加的第五个G-缓存，会使显存增大，并不是所有的平台(mobile)都支持它。Unity只在有足够多的渲染目标可用时才支持阴影蒙版，因此我们也应该这样做。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>    <span class="kt">float4</span> <span class="n">gBuffer4</span> <span class="o">:</span> <span class="n">SV_Target4</span><span class="p">;</span>
<span class="cp">#endif
</span>
</code></pre></div></div>

<p>我们只需在G-缓存中存储采样得到的阴影蒙版数据，而且没有一个确切的光照，为此我们可以使用_UnityGetRawBakedOcclusions_函数，它与_UnitySampleBakedOcclusion_相似，唯一不同在于它没有选择某个纹理通道。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="n">output</span><span class="p">;</span>
<span class="cp">#if defined(DEFERRED_PASS)
</span>    <span class="cp">#if !defined(UNITY_HDR_ON)
</span>        <span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">exp2</span><span class="p">(</span><span class="o">-</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer0</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">albedo</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer0</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">GetOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer1</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">specularTint</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer1</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">GetSmoothness</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer2</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer3</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>        <span class="n">output</span><span class="p">.</span><span class="n">gBuffer4</span> <span class="o">=</span> <span class="n">UnityGetRawBakedOcclusions</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="cp">#endif
#else
</span>    <span class="n">output</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">ApplyFog</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>为了可以在没有光照贴图的时候也能成功编译，当光照贴图坐标不可用时我们使用0代替它。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>    <span class="kt">float2</span> <span class="n">shadowUV</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="n">shadowUV</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer4</span> <span class="o">=</span> <span class="n">UnityGetRawBakedOcclusions</span><span class="p">(</span><span class="n">shadowUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="cp">#endif
</span>
</code></pre></div></div>

<h3 id="使用阴影蒙版g-缓存">使用阴影蒙版G-缓存</h3>

<p>调整MyDeferredShading延迟渲染着色器。</p>

<p>第一步先添加额外的一个G-buffer变量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture0</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture1</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture2</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture4</span><span class="p">;</span>
</code></pre></div></div>

<p>第二步，创建一个函数来得到适当的阴影衰减。如果有了阴影蒙版，可通过对纹理采样然后和_unity_OcclusionMaskSelector_进行一次颜色饱和点乘。这个变量是在_UnityShaderVariables.cginc_中定义的，包含了一个用于选择当前正在被渲染的光照通道的向量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">GetShadowMaskAttenuation</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="kt">float4</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_CameraGBufferTexture4</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">unity_OcclusionMaskSelector</span><span class="p">));</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在CreateLight中，即使当前光照没有实时阴影，我们在有阴影蒙版时也要衰减阴影。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">,</span> <span class="n">float</span> <span class="n">viewZ</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(SHADOWS_SHADOWMASK)
</span>        <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> 
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了正确地包含烘焙阴影，再次使用UnityMixRealtimeAndBakedShadows代替之前的衰减计算。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
<span class="c1">//  shadowAttenuation = saturate(shadowAttenuation + shadowFade);</span>
    <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="n">UnityMixRealtimeAndBakedShadows</span><span class="p">(</span>
        <span class="n">shadowAttenuation</span><span class="p">,</span> <span class="n">GetShadowMaskAttenuation</span><span class="p">(</span><span class="n">uv</span><span class="p">),</span> <span class="n">shadowFade</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在也可以使用自定义的延迟光照着色器得到正确的烘焙阴影了。例外，即当我们的优化分支被使用时会跳过阴影混合。该捷径在阴影蒙版被使用时不可用。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="cp">#if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT)
</span>        <span class="cp">#if !defined(SHADOWS_SHADOWMASK)
</span>            <span class="n">UNITY_BRANCH</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">shadowFade</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="阴影蒙版-距离模式-distance-shadowmask">阴影蒙版-距离模式 DIstance Shadowmask</h3>

<p>虽然使用阴影蒙版模式我们可以得到不错的静态物体的烘焙阴影，动态物体却不能从中获利。动态物体只能接收到实时阴影以及光照探头数据。如果我们希望得到动态物体的阴影，那么静态物体必须也要投射实时阴影。这里的混合光照模式我们要用到距离阴影蒙版（Distance Shadowmask）了。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002327719-433885054.png" width="250" /><font size="2.5">
            <i>距离阴影蒙版模式.</i>
        </font></center>

<p><em>在2017及以上，使用哪个阴影蒙版模式是通过质量设置进行控制。</em></p>

<p>当使用DistanceShadowmask模式时，所有物体都使用实时阴影。第一眼看去，好像和Baked Indirect模式完全一样。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002329008-1483902900.png" width="250" /><font size="2.5">
            <i>所有物体都有实时阴影.</i>
        </font></center>

<p>不过这里仍有一个阴影蒙版。在这个模式中，烘焙阴影和光照探头的使用超出了阴影距离。因此该模式是成本最高的模式，在阴影距离范围内等价于烘焙间接模式，超出该范围则等价于阴影蒙版模式。</p>

<p>前面已经支持这个模式了，因为我们正在使用UnityMixRealtimeAndBakedShadows。为了正确地混合完全实时阴影和烘焙阴影，它像往常那样衰减实时阴影，然后取其和烘焙阴影的最小值。</p>

<h3 id="多重光照">多重光照</h3>

<p>因为阴影蒙版有四个通道，它可以最多同时支持4个光照体积重叠在一起</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002330331-1413395037.png" width="250" /><font size="2.5">
            <i>四个光源，都是混合光.</i>
        </font></center>

<p><strong>主方向光源的阴影仍存储在R通道中</strong>。你还能够看到存储在G通道和B通道中的聚光源的阴影，最后一个聚光源的阴影存储在A通道中。</p>

<p>当光照体积不重叠时，它们使用相同的通道来存储它们的阴影数据。所以你可以有任意多个混合光照。但是你必须<strong>确保至多四个光照体积彼此重叠</strong>。如果有太多个混合光影响同一篇区域，那么一些就会改回到完全烘焙模式。为了说明这一点，下面这张截图显示的是在多加入一个聚光源以后的光照贴图。你可以在强度贴图中清楚地看到其中一个已经变成了烘焙光。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002332758-586177298.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002333778-925731185.png" width="250" /><font size="2.5">
            <i>5个重叠的光照，其中一个为完全烘焙光.</i>
        </font></center>

<h3 id="支持多个有蒙版的定向光">支持多个有蒙版的定向光</h3>

<p>不幸的是，阴影蒙版只有当包含至多一个混合模式的方向光源存在时才能正常工作。对于额外的方向光，阴影衰减会发生错误，至少是在使用前向渲染通道时。延迟渲染倒没有问题。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002335110-966052747.png" width="250" /><font size="2.5">
            <i>两个方向光源产生错误的衰减.</i>
        </font></center>

<p>这是使用UNITY_LIGHT_ATTENUATION的新方法中的一个漏洞：Unity使用通过UNITY_SHADOW_COORDS定义的阴影插值来存储方向阴影的屏幕空间坐标，或者其它拥有阴影蒙版的光源的光照贴图坐标。</p>

<p>使用阴影蒙版的方向光还需要光照贴图坐标。在forward-render中，这些坐标会被包含，因为LIGHTMAP_ON会在需要的时候被定义。然而，LIGHTMAP_ON在additional-pass中永远不会被定义。这意味着多余的方向光没有可用的光照贴图坐标。结果UNITY_LIGHT_ATTENUATION在这种情况下只会使用0，导致错误的光照贴图采样</p>

<p>所以我们不能依靠UNITY_LIGHT_ATTENUATION额外获得使用阴影蒙版的方向光源。用屏幕空间的方向阴影</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2)
</span>    
<span class="cp">#endif
#if !defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; !defined(UNITY_NO_SCREENSPACE_SHADOWS)
</span>        <span class="cp">#define ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS 1
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>接下来，对那些额外有蒙版的定向阴影，我们也要包含光照贴图坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="kt">float2</span> <span class="n">lightmapUV</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span>    
<span class="p">}</span>
</code></pre></div></div>

<p>当光照贴图坐标可用时，我们可以再次使用FadeShadows函数进行我们自己控制的衰减。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是，这仍然不正确，因为我们为其输入了错误的衰减数据。我们必须绕开UNITY_LIGHT_ATTENUATION，只得到烘焙后的衰减，在这个情况中我们可以使用SHADOW_ATTENUATION宏。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="c1">//UNITY_LIGHT_ATTENUATION doesn't fade shadows for us.</span>
        <span class="cp">#if ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>            <span class="n">attenuation</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="cp">#endif
</span>        
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002336571-896877423.png" width="250" /><font size="2.5">
            <i>两个定向光源正确的衰减.</i>
        </font></center>

<h2 id="消减阴影-subtractive-shadows">消减阴影-Subtractive Shadows</h2>

<p>混合光照很好，但是它不像完全烘焙光照那样成本低廉。如果以低性能硬件为目标，那么混合光照不太可行。烘焙光照会管用，但是事实上你<strong>也许需要动态物体对静态物体投射阴影。那样的话，你可以使用消减混合光照模式</strong>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002337701-173459592.png" width="250" /><font size="2.5">
            <i>消减模式.</i>
        </font></center>

<p>在切换到消减模式后，场景会亮很多。这是由于静态物体现在同时使用完全烘焙的光照贴图和方向光源。这是因为动态物体仍然会同时使用光照探头和方向光源。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002338965-1025220581.png" width="250" /><font size="2.5">
            <i>静态物体受到两次光照.</i>
        </font></center>

<p><strong>消减模式只可用于前向渲染</strong>。当使用延迟渲染路径时，相关的物体会回到前向渲染路径，就像透明物体那样。</p>

<h3 id="消减光照">消减光照</h3>

<p>在消减模式中，静态物体通过光照贴图被照亮，同时还将动态阴影考虑在内。这是通过降低光照贴图在阴影区域的强度来实现的。为此，着色器需要使用光照贴图和实时阴影。它还需要使用实时光照来计算出要将光照贴图调暗多少。这就是为什么我们在切换到这个模式后得到了双重光照。</p>

<p><strong>消减光照是一个近似，只在一个单一定向光下起作用，因此它只支持主方向光的阴影</strong>。另外，我们必须以某种方式了解在动态着色区域内间接光的环境是什么。由于我们使用的是一个完全烘焙的光照贴图，我们没有这个信息。Unity没有包含一个额外的只有间接光的光照贴图，而是使用了一个统一的颜色对环境光取近似值。即实时阴影颜色（Realtime Shadow Color），你可以在混合光照选项中调整它。</p>

<p>在着色器中，我们知道_当LIGHTMAP_ON_，<em>SHADOWS_SCREEN</em>，和_LIGHTMAP_SHADOW_MIXING_关键词被定义而_SHADOWS_SHADOWMASK_没有被定义时我们应该使用消减光照。如果这样的话我们定义_SUBTRACTIVE_LIGHTING_，以便更容易使用它。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; !defined(UNITY_NO_SCREENSPACE_SHADOWS)
</span>        <span class="cp">#define ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS 1
</span>    <span class="cp">#endif
#endif
</span>
<span class="cp">#if defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK)
</span>        <span class="cp">#define SUBTRACTIVE_LIGHTING 1
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>在做其他事情之前，我们必须去除掉双重阴影。为此我们可以关闭动态光照，就像我们对延迟通道所做的那样。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>

    <span class="cp">#if defined(DEFERRED_PASS) || SUBTRACTIVE_LIGHTING
</span>        <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="kt">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cp">#else
</span>        
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002340399-1575340233.png" width="250" /><font size="2.5">
            <i>静态物体只有烘焙光.</i>
        </font></center>

<h3 id="为烘焙光打阴影">为烘焙光打阴影</h3>

<p>为了应用消减阴影，我们创建一个函数以在需要的时候调整间接光。通常它不会做任何事。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplySubtractiveLighting</span> <span class="p">(</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">UnityIndirect</span> <span class="n">indirectLight</span>
<span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<p>我们在获取光照贴图数据后要调用该函数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityIndirect</span> <span class="nf">CreateIndirectLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeLightmap</span><span class="p">(</span><span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">));</span>

            <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>                
            <span class="cp">#endif
</span>
            <span class="n">ApplySubtractiveLighting</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">);</span>
        <span class="cp">#else
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="cp">#endif
</span>        
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">indirectLight</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果有消减光照，那么我们必须获取阴影衰减。我们可以简单地从CreateLight中将代码复制过来。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplySubtractiveLighting</span> <span class="p">(</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">UnityIndirect</span> <span class="n">indirectLight</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if SUBTRACTIVE_LIGHTING
</span>        <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>下一步，我们要计算出如果使用实时光照的话我们可以接收到多少光。我们假设该信息和烘焙在光照贴图中的信息相吻合。由于光照贴图只包含漫射光，我们只需计算定向光的Lambert。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if SUBTRACTIVE_LIGHTING
</span>    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">ndotl</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>为了达到阴影光照的强度，我们必须将兰伯特项乘以衰减。但是我们已经有了完全不含阴影的烘焙光照。因此我们估算一下有多少光被阴影挡住了。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">ndotl</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
<span class="kt">float3</span> <span class="n">shadowedLightEstimate</span> <span class="o">=</span> <span class="n">ndotl</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">attenuation</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</code></pre></div></div>

<p>通过从烘焙光中减去该估值，我们最终得到了调整好的光照。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">shadowedLightEstimate</span> <span class="o">=</span> <span class="n">ndotl</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">attenuation</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">subtractedLight</span> <span class="o">=</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="err">–</span> <span class="n">shadowedLightEstimate</span><span class="p">;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002341952-1577870051.png" width="250" /><font size="2.5">
            <i>减去后得到的光照.</i>
        </font></center>

<p>无论在什么环境光场景中，这总会产生纯黑色阴影。为了更好地符合场景的需要，我们可以使用我们的消减阴影颜色，可以通过unity_ShadowColor实现。阴影区域不应比这个颜色更暗，不过它们可以更亮些。所以我们取计算出的光照和阴影颜色的最大值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">subtractedLight</span> <span class="o">=</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">-</span> <span class="n">shadowedLightEstimate</span><span class="p">;</span>
<span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">unity_ShadowColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</code></pre></div></div>

<p>我们还要考虑到阴影强度被设置为小于1这个情况。为了应用阴影强度，在有阴影和无阴影光照之间基于_LightShadowData的X分量做插值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">unity_ShadowColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
<span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002343602-223725225.png" width="250" /><font size="2.5">
            <i>有颜色的阴影.</i>
        </font></center>

<p>因为我们的场景的环境强度（ambient intensity）被设置为0，所以默认的阴影颜色和场景不太搭配。但是可以很轻松地发现消减阴影，因此我没有调整它。还有一点非常明显，即阴影颜色现在覆盖了所有的烘焙阴影，而实际不应该这样。它应该只影响那些接收动态阴影的区域，不应该使烘焙阴影变亮。为此，使用消减光照和烘焙光照的最小值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//indirectLight.diffuse = subtractedLight;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002345136-2052798411.png" width="250" /><font size="2.5">
            <i>正确的消减阴影.</i>
        </font></center>

<p>现在只要我们使用适当的阴影颜色，我们就会得到正确的消减阴影。但是记住这只是一个近似，而且它不太适用于多重光照。例如，其它的烘焙光会产生错误的阴影。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002346714-785287043.png" width="250" /><font size="2.5">
            <i>多重光照错误的消减.</i>
        </font></center>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[烘焙光照有间接光而没有实时光照，因为间接光需要光照贴图。由于间接光可以为场景加入很大的真实感，如果我们可以将它和实时光照融合在一起就再好不过了。这是可以的，但也意味着着色的开销会增加。我们需要将混合光（Mixed Lighting）的光照模式（Lighting Mode）设置为烘焙间接（Baked Indirect）。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender17/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender17/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity 光照烘焙(翻译十六)</title><link href="https://www.damonc.top/Unity_Static_Lightting.html" rel="alternate" type="text/html" title="Unity 光照烘焙(翻译十六)" /><published>2018-01-19T20:00:00+08:00</published><updated>2018-01-19T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_Static_Lightting</id><content type="html" xml:base="https://www.damonc.top/Unity_Static_Lightting.html"><![CDATA[<p>实时光照计算的开销非常昂贵。根据翻译13，延迟渲染允许程序员使用的光源可以多于Forward渲染，但阴影的开销仍然对性能有一个限制。如果我们的场景是动态的，那么没有办法来避免执行这些计算。但是如果光源和几何物体位置都是不变的，那么我们可以只计算一次光照并重复使用。这使得我们可以在场景中放置许多光源，而不必在运行的时候再渲染它们。这种方法也可以使用那些不能用作实时光源的区域光源(area lighting)。</p>

<h2 id="光照贴图-lightingmapping">光照贴图-Lightingmapping</h2>

<p>为了尝试光照贴图，我创建了一个简单的测试场景，它具有一个简单的结构，可以提供阴影，还有一些放置在其内部的球体。一切物体都使用默认的Unity材质。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224543545-885823133.png" width="250" /><font size="2.5">
            <i>针对光照贴图的一个测试场景.</i>
        </font></center>

<h3 id="烘焙光源-baked-lights">烘焙光源-Baked Lights</h3>

<p>要开始使用光照贴图，将唯一的光源对象的模式改为“Baked（烘焙）”而不是“Realtime（实时）”。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224544162-1495985851.png" width="250" /><font size="2.5">
            <i>使用烘焙模式的主方向光源.</i>
        </font></center>

<p><strong>将主方向光源变成烘培光源后，就不被纳入动态光照计算。从动态对象的角度来看，光源是不存在的。 唯一仍然不变的是环境光照，它仍然是基于主方向光源的。</strong></p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224544847-451474149.png" width="250" /><font size="2.5">
            <i>没有直接光照的效果.</i>
        </font></center>

<p>要实际启用光照贴图，请在lighting窗口的“混合光照（<em>Mixed Lighting</em>）”中打开“烘培全局光照(<em>BakedGlobal Illumination</em>)”。 然后<strong>将光照模式设置为“烘培间接光照（<em>BakedIndirect</em>）”。 尽管它的名字说的是烘培间接光照，但是它也包括了直接光照</strong>。 它通常用于向场景添加间接光照。另外，确保实时全局光照（<em>Realtime Global Illumination</em>）被禁用，因为我们还没有支持到这一点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224545646-2048168292.png" width="250" /><font size="2.5">
            <i>烘培间接光照模式.</i>
        </font></center>

<h3 id="静态几何体">静态几何体</h3>

<p>场景的对象都应该是固定的：它们位置永远不会移动。要将这一个信息传达给Unity，请将这些对象标记为静态。你可以通过启用检视器窗口右上角的“静态”切换键来做到这一点。</p>

<p><strong>光源也必须被标记为静态吗？</strong></p>
<ul>
  <li>不需要。光源只需要设置为适当的模式。</li>
</ul>

<p>有各种子系统关心物体是否是静态的。“静态（static）”还有一个下拉菜单，你可以使用它来微调哪些系统会将这个对象视为静态的。现在我们只关心光照贴图，但最简单的做法是使一切都完全是静态的。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224546220-2118005287.png" width="250" /><font size="2.5">
            <i>静态标签设定.</i>
        </font></center>

<p>一个物体对于光照贴图来说是否是静态的，也可以通过其网格渲染器的检视器来进行查看和编辑。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224546912-1870383195.png" width="250" /><font size="2.5">
            <i>对于光照贴图来说是静态的物体.</i>
        </font></center>

<p>现在，所有的物体都是静态的，它们将被包含在光照贴图的处理过程中。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224547954-1770311194.png" width="250" /><font size="2.5">
            <i>使用烘焙光照的场景.</i>
        </font></center>

<p><strong>必须注意</strong>，使用光照贴图得到的结果不如使用实时照明得到的结果亮度那么高。这是因为缺失了镜面高光，只剩下了漫反射光照。镜面高光取决于视角，因此取决于相机的角度。正是由于相机是移动的，因此它不能包含在光照贴图中。(使用场景推荐)这种限制意味着光照贴图可以用于微弱的光线和暗淡的表面，但不能用于强直射光或有光泽的表面。如果你想要镜面高光，你将不得不使用实时光源。所以你经常会使用烘烤光源和实时光源的混合。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>为什么没有立即得到烘焙光源？
为了确保在需要的时候光照贴图可以实际生成和更新，请在光照窗口的底部启用“自动生成（Auto Generate）”。 否则，你必须手动生成新的光照贴图。
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224548501-1138122298.png" width="250" /><font size="2.5">
            <i>自动烘焙.</i>
        </font></center>

<h3 id="光照贴图设置-lightingmapping-setting">光照贴图设置-Lightingmapping Setting</h3>

<p>光照烘焙窗口包含专门用于光照贴图设置的部分。在这里，你可以在<strong>质量</strong>、<strong>尺寸</strong>和<strong>烘烤时间</strong>之间取得平衡。你还可以在光照贴图烘焙算法引擎：Enlighten和Progressive lightmapper之间进行切换。后者会增量地生成光照贴图，优先考虑场景视图中可见的内容，这在编辑的时候很方便。本教程中使用的是Enlighten光照贴图引擎。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224549324-867042323.png" width="250" /><font size="2.5">
            <i>默认的光照贴图设置.</i>
        </font></center>

<p>在做任何事情之前，请将“DirectionalMode“设置为”Non-Direction“。 稍后我们会处理其他模式。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224549936-119016943.png" width="250" /><font size="2.5">
            <i>使用“Non-directional”模式的光照贴图.</i>
        </font></center>

<p>烘烤的光照存储在纹理中。 你可以通过将光照窗口从“场景（Scene）“切换到”全局地图（<em>Global Maps</em>）“模式来进行查看。 使用默认设置，我的测试场景很容易与一张1024×1024贴图相匹配。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224550735-1332475026.png" width="250" /><font size="2.5">
            <i>得到光照贴图.</i>
        </font></center>

<p>Unity自带的Objects物体都有用于光照贴图的UV坐标。对于手动导入的模型，可以自己提供UV坐标，也可以让Unity生成。烘烤后可以在光照贴图中看到展开的纹理。它们需要多少空间取决于场景中物体的大小和光照贴图的分辨率设置。 如果质量要求高分辨率太大，一张贴图涨不下，Unity会创建额外的贴图存储，直至完成。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224551453-953456979.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224552186-1643111793.png" width="250" /><font size="2.5">
            <i>光照贴图的分辨率的不同会带来很大的差异.</i>
        </font></center>

<p>对于每个项目来说，最佳设置都是不同。 你必须不断的调整烘焙参数，直到达成很好的效果及平衡。需要注意的是，视觉质量也很大程度上取决于用于光照贴图的纹理展开的质量。不存在纹理接缝可能会产生明显的瑕疵。Unity的默认球体就是一个很好的例子。它不适用于光照贴图。</p>

<h3 id="间接光源">间接光源</h3>

<p>烘焙光照会失去镜面高光，只能获得的是间接光照，它是在到达人眼之前会在多个表面反射的光。烘焙光会在拐角周围区域反射，那些本来会被遮挡的区域仍然会被照亮。我们不能实时计算镜面高光这个信息(本节1.2有说明)，但是我们可以在烘焙的时候包括反射光。</p>

<p>要清楚地看到实时光照和烘培光照之间的差异：将环境光照的强度设置为零，去掉天空盒的影响，所有的光都只是来自方向光。比对</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224552903-1416086887.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224553660-737254829.png" width="250" /><font size="2.5">
            <i>没有环境光照，realtime vs. lightmapped.</i>
        </font></center>

<p>每次光子反射的时候，它都会失去一些能量，它会被一些需要的材质采样着色。Unity在烘焙间接光照的时候，物体会根据附近的颜色进行着色。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224554555-1690717767.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224555273-1136371525.png" width="250" /><font size="2.5">
            <i>绿色的地面，realtime vs. lightmapped.</i>
        </font></center>

<p>自发光表面也会影响烘焙光照。它们会成为间接光源。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224556002-270644308.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224556791-2131078685.png" width="250" /><font size="2.5">
            <i>自发光的地面，realtime vs. lightmapped.</i>
        </font></center>

<p>间接光照的一个特殊设置是AO环境遮挡：这是指在角落和转折中发生的间接光照造成的阴影。这是一种人为的提升，可以增强深度方面的视觉。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224557440-355583450.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224558173-2138402443.png" width="250" /><font size="2.5">
            <i>使用环境遮挡的效果.</i>
        </font></center>

<p>环境遮挡效果完全基于物体表面。它不考虑光线实际来自哪里。烘焙时并不总是正确，举个简单的例子：当与自发光表面组合的时候就会产生一些错误的结果。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224558930-1992313410.png" width="250" /><font size="2.5">
            <i>显然是错误的环境遮挡效果.</i>
        </font></center>

<h3 id="透明度-transparency">透明度-Transparency</h3>

<p>光照贴图在一定程度上可以处理半透明表面。 光将通过它们，尽管光的颜色不会被它们所过滤。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224559715-1180880317.png" width="250" /><font size="2.5">
            <i>半透明的屋顶.</i>
        </font></center>

<p>镂空材质也可以在光照贴图中正常工作。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224600513-791335188.png" width="250" /><font size="2.5">
            <i>镂空的屋顶.</i>
        </font></center>

<p>但 这仅在使用封闭曲面的时候有效。当使用像是quad这样的单面几何，光线将在不存在的一面损坏。<em>当另外一面没有任何东西的时候，这是很好的，但是当使用单面透明表面的时候会导致问题</em>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224601275-358793307.png" width="250" /><font size="2.5">
            <i>四边形上有一个错误.</i>
        </font></center>

<p>为了处理这个问题，必须告诉光照贴图系统将这些表面视为透明的。 这可以通过自定义光照贴图设置完成</p>

<ol>
  <li>通过Asset / Create / Lightmap参数来创建这些数据。这些资源允许你自定义每个对象的光照贴图计算。在这种情况下，我们只想表明我们正在处理一个透明的对象。所以启用“它是透明的（<em>Is Transparent</em>）“。 下面它是一个全局作用预计算实时全局光照（<em>Precomputed Realtime GI</em>）部分中的一部分，它会影响所有烘烤光照。</li>
</ol>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224602678-564328235.png" width="250" /><font size="2.5">
            <i>指示这是透明的.</i>
        </font></center>

<ol>
  <li>单独设置：通过物体的网格渲染器检视器来选择它们。你的资源名字将显示在Lightmap参数的下拉列表中。</li>
</ol>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224603354-539689204.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224604232-1056111478.png" width="250" /><font size="2.5">
            <i>为透明四边形使用自定义参数.</i>
        </font></center>

<p>将物体标记为透明也会改变它对间接光照的贡献。透明物体让间接光通过，而不透明物体则会阻挡间接光。</p>

<h2 id="使用光照贴图">使用光照贴图</h2>

<p>现在我们知道光照贴图是如何工作的，我们可以为Shader着色器添加对光照贴图的支持。第一步是对光照贴图进行采样。调整场景中的球体，以便我们的着色器使用白色材质。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224605139-922193658.png" width="250" /><font size="2.5">
            <i>使用我们的白色材质的球体.</i>
        </font></center>

<h3 id="光照贴图的着色器变体">光照贴图的着色器变体</h3>

<p>当一个着色器被认为应该使用光照贴图的时候，Unity会寻找与LIGHTMAP_ON关键字关联的变体。 所以我们必须为这个关键字添加一个多编译指令。 当使用forward-render-path的时候，仅在base-pass中采样光照贴图。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ SHADOWS_SCREEN
#pragma multi_compile _ VERTEXLIGHT_ON
#pragma multi_compile _ LIGHTMAP_ON
#pragma multi_compile_fog
</span></code></pre></div></div>

<p>当使用光照贴图的时候，Unity不会包含顶点光源。他们的关键字是_相互排斥_的。所以我们不需要一个会同时使用_VERTEXLIGHT_ON_和_LIGHTMAP_ON_的变体。（互斥）</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ SHADOWS_SCREEN
</span><span class="c1">//#pragma multi_compile _ VERTEXLIGHT_ON</span>
<span class="c1">//#pragma multi_compile _ LIGHTMAP_ON</span>
<span class="cp">#pragma multi_compile _ LIGHTMAP_ON VERTEXLIGHT_ON
#pragma multi_compile_fog
</span></code></pre></div></div>

<p>延迟渲染路径中也支持光照贴图，因此也可以将这个关键字添加到延迟渲染通道中。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ UNITY_HDR_ON
#pragma multi_compile _ LIGHTMAP_ON
</span></code></pre></div></div>

<h3 id="光照贴图的坐标">光照贴图的坐标</h3>

<p>用于采样光照贴图的坐标存储在TEXCOORD1。 所以将此通道添加到shader中的VertexData结构体中。Unity给出了uv使用说明表：Shader中是uv0、uv1、uv2、uv3；C#中是UV、UV2、UV3、UV4</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span>
<span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="nb">NORMAL</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">tangent</span> <span class="o">:</span> <span class="nb">TANGENT</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>光照贴图坐标也必须进行插值。因为它们与顶点光源互斥，所以都可以使用TEXCOORD6。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span>
<span class="p">{</span>
    <span class="err">…</span>
    <span class="cp">#if defined(VERTEXLIGHT_ON)
</span>        <span class="kt">float3</span> <span class="n">vertexLightColor</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="kt">float2</span> <span class="n">lightmapUV</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>来自模型顶点数据的坐标定义了用于光照贴图的纹理展开(第二套uv)。但是它并没有告诉我们这个展开位置在哪里，展开尺寸大小。我们必须缩放和偏移坐标才能得到最终的光照贴图坐标。这种方法类似于常规纹理坐标的转换，除了转换是特定于对象的，而这里的方法是特定于材质的。在_UnityShaderVariables_中将光照贴图的纹理定义为_unity_Lightmap_。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">);</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>不幸的是，我们不能使用方便的_TRANSFORM_TEX_宏，因为它假定光照贴图的变换被被定义为_unity_Lightmap_ST_，而实际上是被定义为_unity_LightmapST_。由于这种不一致，我们必须手动进行这个变换。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span><span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="对光照贴图进行采样-sampling-lightmap">对光照贴图进行采样-Sampling Lightmap</h3>

<p>因为光照贴图的数据被认为是间接光照，我们将在CreateIndirectLight函数中进行采样。当光照贴图可用的时候，必须将它们用作间接光而不是球面谐波。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityIndirect</span> <span class="nf">CreateIndirectLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(VERTEXLIGHT_ON)
</span>        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">vertexLightColor</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cp">#else
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="cp">#endif
</span>        <span class="kt">float3</span> <span class="n">reflectionDir</span> <span class="o">=</span> <span class="nb">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>

    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">indirectLight</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>为什么indirectLight.diffuse的值被赋值而不是加起来？光照贴图从来没有与顶点光源组合起来。</em></p>

<p>unity_Lightmap的确切形式取决于目标平台。 它被定义为UNITY_DECLARE_TEX2D（unity_Lightmap）。要对它进行采样，我们将使用UNITY_SAMPLE_TEX2D宏而不是tex2D。这是根据不同平台决定。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224605941-2016281613.png" width="250" /><font size="2.5">
            <i>使用原始光照图数据的效果.</i>
        </font></center>

<p>我们现在得到了烘焙的间接光照，但效果看起来不对。这是因为光照贴图数据已被编码。颜色以RGBM格式或是半强度格式进行存储，以支持高强度的光。UnityCG的DecodeLightmap函数负责为我们解码。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeLightmap</span>
<span class="p">(</span>
    <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224606764-748268587.png" width="250" /><font size="2.5">
            <i>使用解码后光照图数据的效果.</i>
        </font></center>

<h2 id="创建光照贴图">创建光照贴图</h2>

<p><em>目前，光照贴图会将场景对象总是视为不透明和纯白色的物体。我们必须对我们的着色器进行一些调整，添加一个渲染通道来完全支持光照贴图。</em></p>

<p><em>从现在开始，对场景中的所有对象使用我们自己的着色器。也不再使用默认的材质。</em></p>

<h3 id="半透明的阴影-semitransparent-shadow">半透明的阴影-Semitransparent Shadow</h3>

<p>光照贴图不使用实时渲染管道，因此现有自写的shader不能支持。 当尝试使用半透明阴影的时候，这是最明显的。通过设置屋顶立方体材质的色调alpha分量小于1来赋予屋顶立方体半透明度。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224607620-2057696906.png" width="250" /><font size="2.5">
            <i>半透明的屋顶，效果不正确.</i>
        </font></center>

<p><strong>光照贴图</strong>仍然把屋顶看成是实心物体，这是不正确的。它<strong>使用材质的渲染类型来确定如何处理表面</strong>，这应该告诉光照贴图我们的对象是半透明的。事实上，它确实知道屋顶是半透明的，它只是把它看作是完全不透明的而已。这是因为<strong>它</strong>采用Unity的命名约定<strong>_Color材质属性的alpha组件以及主纹理来设置不透明度</strong>。</p>

<p>用_Color替换_Tint。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Properties</span>
<span class="p">{</span>
    <span class="c1">// _Tint ("Tint", Color) = (1, 1, 1, 1)</span>
    <span class="n">_Color</span> <span class="p">(</span><span class="s">"Tint"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后，为了保证我们的着色器的功能，我们还必须在shader文件、cg文件替换，而且我们还要调整GUI拓展。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224608540-1659292184.png" width="250" /><font size="2.5">
            <i>半透明的屋顶，正确的效果.</i>
        </font></center>

<h3 id="镂空部分的阴影-cutout-shadow">镂空部分的阴影-Cutout Shadow</h3>

<p>镂空部分的阴影也有类似的问题。光照贴图程序期望透明度的阈值存储在_Cutoff属性中，但是我们使用的是_AlphaCutoff。 因此，它使用默认阈值1。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224609483-570537720.png" width="250" /><font size="2.5">
            <i>镂空的屋顶，效果不正确.</i>
        </font></center>

<p>解决方案是再次<strong>采用Unity的命名约定_Cutoff材质属性</strong>。所以替换shader、cg文件、GUI拓展。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224611382-1243752544.png" width="250" /><font size="2.5">
            <i>镂空的屋顶，正确的效果.</i>
        </font></center>

<h3 id="添加一个meta渲染通道-add-meta-pass">添加一个Meta渲染通道-Add Meta Pass</h3>

<p><strong>渲染光照贴图正确的表面反照率和自发光</strong>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224612151-595484578.png" width="250" /><font size="2.5">
            <i>绿色的地板，效果不正确.</i>
        </font></center>

<p>要采样物体的表面颜色，光照贴图程序会将它的光照模式设置为Meta来寻找一个着色器渲染通道。这个渲染通道仅由光照贴图程序使用，不使用剔除。所以让我们在我们的着色器上添加一个渲染通道。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Tags</span> <span class="p">{</span>
        <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"Meta"</span>
    <span class="p">}</span>
    <span class="n">Cull</span> <span class="n">Off</span>

    <span class="n">CGPROGRAM</span>

    <span class="cp">#pragma vertex MyLightmappingVertexProgram
</span>    <span class="cp">#pragma fragment MyLightmappingFragmentProgram
</span>    <span class="cp">#include</span> <span class="cpf">"My Lightmapping.cginc"</span><span class="cp">
</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在我们<strong>需要确定反照率、镜面高光颜色、平滑度、自发光</strong>。只需要顶点的位置和uv坐标，以及需要vertexProgram中的光照贴图坐标。不使用法线和切线。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(MY_LIGHTMAPPING_INCLUDED)
#define MY_LIGHTMAPPING_INCLUDED
</span>
<span class="cp">#include</span> <span class="cpf">"UnityPBSLighting.cginc"</span><span class="cp">
</span>
<span class="kt">float4</span> <span class="n">_Color</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">,</span> <span class="n">_DetailMask</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">_MainTex_ST</span><span class="p">,</span> <span class="n">_DetailTex_ST</span><span class="p">;</span>

<span class="n">sampler2D</span> <span class="n">_MetallicMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_Metallic</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_Smoothness</span><span class="p">;</span>

<span class="n">sampler2D</span> <span class="n">_EmissionMap</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">_Emission</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">float</span> <span class="nf">GetDetailMask</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="kt">float3</span> <span class="nf">GetAlbedo</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetMetallic</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetSmoothness</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="kt">float3</span> <span class="nf">GetEmission</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>GetEmission函数去除_FORWARD_BASE_PASS_和_DEFERRED_PASS_限制。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="nf">GetEmission</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//    #if defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)</span>
    <span class="cp">#if defined(_EMISSION_MAP)
</span>        <span class="k">return</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_EmissionMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">)</span> <span class="o">*</span><span class="n">_Emission</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="n">_Emission</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="c1">//    #else</span>
<span class="c1">//        return 0;</span>
<span class="c1">//    #endif</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这些函数只有在定义了适当的关键字时才会起作用，因此可以在渲染通道中为其添加着色功能。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma vertex MyLightmappingVertexProgram
#pragma fragment MyLightmappingFragmentProgram
</span>
<span class="cp">#pragma shader_feature _METALLIC_MAP
#pragma shader_feature _ _SMOOTHNESS_ALBEDO _SMOOTHNESS_METALLIC
#pragma shader_feature _EMISSION_MAP
#pragma shader_feature _DETAIL_MASK
#pragma shader_feature _DETAIL_ALBEDO_MAP
</span>
<span class="cp">#include</span> <span class="cpf">"My Lightmapping.cginc"</span><span class="cp">
</span></code></pre></div></div>

<h3 id="顶点程序-vertex-program">顶点程序-Vertex Program</h3>

<p>这个pass的vertex 程序很简单。只是转换位置、转换纹理坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyLightmappingVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>

    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>计算2.2提到的映射偏移，我们必须使用光照贴图uv坐标而不是顶点位置，然后进行适当的转换把纹理uv坐标作为模型顶点的屏幕位置，模型的UV映射必须要正确：纹理上的每个点必须映射为模型上的唯一点。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span><span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
</code></pre></div></div>

<p>v.vertex.z = 0，不是所有机器上都能支持，顶点位置的Z坐标必须以某种方式使用，即使我们不使用它也是如此。Unity的着色器为此使用虚拟值，所以我们将简单地做同样的事情。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span><span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span><span class="p">.</span><span class="mo">0001</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="片段程序-fragment-program">片段程序-Fragment Program</h3>

<p>在<strong>片段程序中</strong>，计算<strong>输出反照率和自发光颜色</strong>。光照贴图程序将通过<strong>执行两次渲染</strong>来做到这一点，<strong>每次</strong>执行<strong>有一个输出</strong>。为了使这个过程更容易，我们可以使用_UnityMetaPass.cginc文_件中定义的_UnityMetaFragment_函数。它使用_<strong>UnityMetaInput</strong>_结构<strong>作为参数</strong>，其中<strong>包含反照率和自发光颜色</strong>。 该函数将决定要输出反照率和自发光颜色中的哪一个以及如何编码输出结果。</p>

<p>UnityMetaInput也包含镜面高光颜色，即使它不存储在光照贴图中。它用于一些编辑器可视化，我们先忽略它。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"UnityPBSLighting.cginc"</span><span class="cp">
#include</span> <span class="cpf">"UnityMetaPass.cginc"</span><span class="cp">
</span><span class="err">…</span>
<span class="kt">float4</span> <span class="nf">MyLightmappingFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">UnityMetaInput</span> <span class="n">surfaceData</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">Emission</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">SpecularColor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">UnityMetaFragment</span><span class="p">(</span><span class="n">surfaceData</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>UnityMetaFragment是什么样子的？</em></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//unity_MetaFragmentControl变量包含一个标记，这个标记会告诉函数是否输出反照率或是自发光颜色。还有一段有关</span>
<span class="c1">//编辑器可视化变体的代码，但是我把它删掉了，因为与这里的内容不相关。</span>
<span class="kt">half4</span> <span class="nf">UnityMetaFragment</span> <span class="p">(</span><span class="n">UnityMetaInput</span> <span class="n">IN</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">half4</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaFragmentControl</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="kt">half4</span><span class="p">(</span><span class="n">IN</span><span class="p">.</span><span class="n">Albedo</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

        <span class="c1">// d3d9 shader compiler doesn't like NaNs and infinity.</span>
        <span class="n">unity_OneOverOutputBoost</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">unity_OneOverOutputBoost</span><span class="p">);</span>

        <span class="c1">// Apply Albedo Boost from LightmapSettings.</span>
        <span class="n">res</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">clamp</span><span class="p">(</span>
            <span class="nb">pow</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">unity_OneOverOutputBoost</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unity_MaxOutputValue</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaFragmentControl</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">half3</span> <span class="n">emission</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unity_UseLinearSpace</span><span class="p">)</span>
            <span class="n">emission</span> <span class="o">=</span> <span class="n">IN</span><span class="p">.</span><span class="n">Emission</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">emission</span> <span class="o">=</span> <span class="n">GammaToLinearSpace</span> <span class="p">(</span><span class="n">IN</span><span class="p">.</span><span class="n">Emission</span><span class="p">);</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">UnityEncodeRGBM</span><span class="p">(</span><span class="n">emission</span><span class="p">,</span> <span class="n">EMISSIVE_RGBM_SCALE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224612936-832867814.png" width="250" /><font size="2.5">
            <i>间接光照设置为0的效果.</i>
        </font></center>

<p>要<strong>获得自发光颜色</strong>，我们可以简单的<strong>使用GetEmission函数</strong>。要<strong>获得反照率</strong>，我们必须再次<strong>使用_DiffuseAndSpecularFromMetallic_函数</strong>。 该函数具有镜面高光颜色和反射率作为输出参数，即使我们现在不使用它们，我们也必须提供这些参数。我们可以使用<strong>surfaceData.SpecularColor来捕获镜面高光颜色</strong>。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="nf">MyLightmappingFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span>
<span class="p">{</span>
    <span class="n">UnityMetaInput</span> <span class="n">surfaceData</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">Emission</span> <span class="o">=</span> <span class="n">GetEmission</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">oneMinusReflectivity</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">=</span> <span class="n">DiffuseAndSpecularFromMetallic</span>
    <span class="p">(</span>
        <span class="n">GetAlbedo</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">GetMetallic</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
        <span class="n">surfaceData</span><span class="p">.</span><span class="n">SpecularColor</span><span class="p">,</span> <span class="n">oneMinusReflectivity</span>
    <span class="p">);</span>
    <span class="c1">//surfaceData.SpecularColor = 0;</span>
    <span class="k">return</span> <span class="n">UnityMetaFragment</span><span class="p">(</span><span class="n">surfaceData</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224613700-1556141393.png" width="250" /><font size="2.5">
            <i>间接光照着色的效果.</i>
        </font></center>

<p>但自发光光照可能还没有出现在光照贴图中。这是因为光照贴图程序并不总是包含一个自发光光照的渲染通道。<strong>材质必须表明它们具有自发光光照属性，</strong>以对烘焙过程做出贡献。这是<strong>通过Material.globalIlluminationFlags属性</strong>完成的。扩展GUI设置：当自发光光照编辑的时候，它应该被烘焙进光照贴图。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoEmission</span> <span class="p">()</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="n">EndChangeCheck</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tex</span> <span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">SetKeyword</span><span class="p">(</span><span class="s">"_EMISSION_MAP"</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">editor</span><span class="p">.</span><span class="n">targets</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">globalIlluminationFlags</span> <span class="o">=</span> <span class="n">MaterialGlobalIlluminationFlags</span><span class="p">.</span><span class="n">BakedEmissive</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="粗糙的金属-rough-metals">粗糙的金属-Rough Metals</h3>

<p>我们的shader现在看起来可以正常工作了，但它与标准着色器的结果不完全匹配。 <strong>当使用平滑度非常低的有色金属的时候，物体表面不太明亮</strong>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224614488-83217782.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224615215-1831739305.png" width="250" /><font size="2.5">
            <i>粗糙的绿色金属，standard vs. our.</i>
        </font></center>

<p>标准着色器通过<strong>将反射率的一部分加到镜面高光颜色</strong>进行补偿（高亮）。它使用_UnityStandardBRDF.cginc_的_SmoothnessToRoughness函数_来确定基于平滑度的粗糙度值，将其缩小一半，并使用它来缩放镜面高光颜色。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">roughness</span> <span class="o">=</span> <span class="n">SmoothnessToRoughness</span><span class="p">(</span><span class="n">GetSmoothness</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">surfaceData</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">+=</span> <span class="n">surfaceData</span><span class="p">.</span><span class="n">SpecularColor</span> <span class="o">*</span><span class="n">roughness</span><span class="p">;</span>

<span class="k">return</span> <span class="nf">UnityMetaFragment</span><span class="p">(</span><span class="n">surfaceData</span><span class="p">);</span>
</code></pre></div></div>

<p><em>SmoothnessToRoughness计算了什么东西？</em></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//转换：减去平滑度值，然后平方。 从平滑度到粗糙度的平方映射最终会产生比仅仅做线性转换更好的结果。</span>
<span class="c1">// Smoothness is the user facing name</span>
<span class="c1">// it should be perceptualSmoothness</span>
<span class="c1">// but we don't want the user to have to deal with this name</span>
<span class="n">half</span> <span class="nf">SmoothnessToRoughness</span><span class="p">(</span><span class="n">half</span> <span class="n">smoothness</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">smoothness</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">smoothness</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224616025-563552905.png" width="250" /><font size="2.5">
            <i>调整反照率后的效果.</i>
        </font></center>

<h2 id="方向光照贴图-directinal-lightmap">方向光照贴图-Directinal Lightmap</h2>

<p>光照贴图程序只使用物体的顶点数据，不考虑物体的法线贴图。光照贴图的分辨率太低，无法捕获由典型法线贴图提供的细节。这意味着静态光照将是平坦的。当使用具有法线贴图的材质的时候，这变得非常明显。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224616867-1000562908.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224617705-756171309.png" width="250" /><font size="2.5">
            <i>使用了法线贴图，standard vs. our.</i>
        </font></center>

<p>当从实时光照切换到烘焙光时，法线贴图的影响几乎完全消失。这是因为它要求环境反射才能看到它们。</p>

<h3 id="方向性-directionality">方向性-Directionality</h3>

<p>通过将“<em>DirectionalMode</em>”改回“<em>Directional</em>”，可以让法线贴图与烘焙光照一起工作。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224618490-889208576.png" width="250" /><font size="2.5">
            <i>再次启用定向光照贴图.</i>
        </font></center>

<p>当使用方向光照贴图的时候，Unity将创建两个贴图。第一张贴图包含通常的光照信息，称为强度图。 第二张贴图被称为方向图。 它包含大部分烘烤光来自的方向。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224619243-972818284.png" width="250" /><font size="2.5">
            <i>强度图和方向图.</i>
        </font></center>

<p>当方向图可用的时候，用它来对烘焙光进行简单的<strong>漫反射阴影计算</strong>。这使得它可用于法线贴图之上。注意，只有一个光方向是已知的，所以阴影将是一个近似。至少有一个主方向光照的时候，结果就会很好。</p>

<h3 id="对方向进行采样">对方向进行采样</h3>

<p>当方向光照贴图可用的时候，Unity将使用_LIGHTMAP_ON_和_DIRLIGHTMAP_COMBINED_关键字查找着色器变体。我们可以在forward-base-pass通道中使用#pragma multi_compile_fwdbase，而不是为手动添加多编译指令。它会负责解决所有的光照贴图关键字，以及VERTEXLIGHT_ON关键字。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//#pragma multi_compile _ SHADOWS_SCREEN</span>
<span class="c1">//#pragma multi_compile _ LIGHTMAP_ON VERTEXLIGHT_ON</span>

<span class="cp">#pragma multi_compile_fwdbase
#pragma multi_compile_fog
</span></code></pre></div></div>

<p>我们可以为deferred-pass必须使用#pragma multi_compile_prepassfinal指令。 它解决了光照贴图和高动态光照渲染的关键字。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//#pragma multi_compile _ UNITY_HDR_ON</span>
<span class="c1">//#pragma multi_compile _ LIGHTMAP_ON</span>
<span class="cp">#pragma multi_compile_prepassfinal
</span></code></pre></div></div>

<p><em>prepassfinal是什么东西?</em><br />
Unity 4使用了一种与以后的版本不同的延迟渲染管线。 在Unity 5中，它被称为传统延迟光照。 这种方法有更多的渲染通道。Prepass决定是当时的术语。不需要引入新的指令，#pragma multi_compile_prepassfinal也用于当前的延迟渲染通道。</p>

<p>在CreateIndirectLight函数中，在检索烘焙光源本身后，需要直接获得烘焙光的方向。方向贴图可以通过unity_LightmapInd获得。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(LIGHTMAP_ON)
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeLightmap</span><span class="p">(</span><span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">));</span>
    <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>        <span class="kt">float4</span> <span class="n">lightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D</span>
        <span class="p">(</span>
            <span class="n">unity_LightmapInd</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span>
        <span class="p">);</span>
    <span class="cp">#endif
#else
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>但是，这将导致编译错误。这是因为一个纹理变量实际上由两部分组成。 有纹理资源，还有采样器状态。采样器状态决定纹理的采样方式，包括滤波器和截取模式。 通常，每个纹理都定义了这两个部分，但这并不是所有平台都需要的。 也可以将这两个部分分开，这允许我们为多个纹理定义单个采样器状态。</p>

<p>因为强度和方向贴图总是以相同的方式进行采样，所以在可能的情况下，Unity使用单个采样器状态。 这就是为什么我们在采样强度贴图的时候必须使用UNITY_SAMPLE_TEX2D宏。方向贴图已经定义，没有采样器。 要对其进行采样，我们必须使用UNITY_SAMPLE_TEX2D_SAMPLER宏来明确地告诉它要使用哪个采样器。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="n">lightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span>
<span class="p">(</span>
    <span class="n">unity_LightmapInd</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="使用方向贴图">使用方向贴图</h3>

<p>要使用方向：1、解码 2、对法向量执行点积，找到漫反射因子并将其应用于颜色。</p>

<p>但是方向贴图并没有包含单位长度的方向，而是比单位长度的方向会大一些。 幸运的是可以使用UnityCG的DecodeDirectionLightmap函数来解码方向数据。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="n">lightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span>
<span class="p">(</span>
    <span class="n">unity_LightmapInd</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span>
<span class="p">);</span>

<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeDirectionalLightmap</span>
<span class="p">(</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">lightmapDirection</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span>
<span class="p">);</span>

</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224620025-25891459.png" width="250" /><font size="2.5">
            <i>使用带有方向的光照贴图的效果.</i>
        </font></center>

<p><em>DecodeDirectionLightmap内部做了什么？</em></p>

<p><code class="language-plaintext highlighter-rouge">DecodeDirectionLightmap实际上并不计算正确的漫射照明因子。 相反，它使用的是半Lambert。 这种方法可以有效地将光照射在表面周围，照亮阴影的区域会更多。这么做是有必要的，这是因为烘烤的光照不是来自于单个方向.</code></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inline</span> <span class="kt">half3</span> <span class="nf">DecodeDirectionalLightmap</span> <span class="p">(</span>
    <span class="kt">half3</span> <span class="n">color</span><span class="p">,</span> <span class="n">fixed4</span> <span class="n">dirTex</span><span class="p">,</span> <span class="kt">half3</span> <span class="n">normalWorld</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="c1">// In directional (non-specular) mode Enlighten bakes dominant light</span>
    <span class="c1">// direction in a way, that using it for half Lambert and then dividing</span>
    <span class="c1">// by a "rebalancing coefficient" gives a result close to plain diffuse</span>
    <span class="c1">// response lightmaps, but normalmapped.</span>

    <span class="c1">// Note that dir is not unit length on purpose. Its length is</span>
    <span class="c1">// "directionality", like for the directional specular lightmaps.</span>

    <span class="n">half</span> <span class="n">halfLambert</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">normalWorld</span><span class="p">,</span> <span class="n">dirTex</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">color</span> <span class="o">*</span><span class="n">halfLambert</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1e-4</span><span class="n">h</span><span class="p">,</span> <span class="n">dirTex</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>代码的注释中提到镜面高光。 这些是支持镜面高光的光照贴图，但需要更多的纹理，使用起来也更昂贵，并且在大多数情况下没有产生良好的效果。自Unity 5.6起，它们已被删除了。</em></p>

<h2 id="光照探针-light-probes">光照探针-Light Probes</h2>

<p>光照贴图仅适用于静态对象，而不适用于动态对象。 因此，动态对象不适合带有烘烤光照的场景。当没有实时光源的时候，这是非常明显的。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224620869-2011940708.png" width="250" /></center>

<p>为了更好地混合静态和动态对象，我们必须以某种方式将烘焙的光照应用于动态对象。为了解决这个问题，Unity有光照探针。 光照探针是对空间中的一个点包含该位置的光照信息。 它是用球面谐波来存储这些信息而不是用纹理。 如果可用的话，这些光照探针将用于动态对象，而不是全局环境数据。所以我们要做的就是创建一些探针，等到烘焙的时候，我们的着色器就会自动使用它们。</p>

<h3 id="创建光照探针组">创建光照探针组</h3>

<p>通过GameObject / Light /Light Probe Group将一组光探测器添加到场景中。 这将创建一个新的游戏对象，在立方体的形状中共有八个光探测器。 它们将在渲染动态对象的时候立即使用。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224621611-72687147.png" width="250" /><font size="2.5">
            <i>一个新的光探测器组.</i>
        </font></center>

<p>通过检视器，可以在启用“编辑探针”模式后编辑光探测器组。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224622328-105716559.png" width="250" /></center>

<h3 id="放置光照探针">放置光照探针</h3>

<p>光照探针组将其包围的体积分成四个区域。四个探测器定义了四面体的角。 这些探测器被进行插值以确定用于动态物体的最终球谐函数，这取决于其在四面体内的位置。这意味着动态对象被视为一个单一的点，因此这种方法只对相当小的对象有效。在编辑探测器的时候，会自动生成四面体。 你不需要知道他们的配置，但它们的可视化信息可以帮助你查看探测器的相对位置。放置光照探针需要你去调整他们的位置，直到你得到一个你可以接受的结果，就像光照贴图的设置一样。首先封装将要包含动态对象的区域。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224623082-2091379510.png" width="250" /><font size="2.5">
            <i>封装区域.</i>
        </font></center>

<p>然后根据光照条件如何变化来添加更多的探针。你不必将它们放置在静态几何中。 也不要把它们放在不透明的单面几何体错误的那一面。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224623843-1380403562.png" width="250" /><font size="2.5">
            <i>放置更多的探测器.</i>
        </font></center>

<p>继续添加和移动探测器，直到你在所有区域都有了合理的光照条件，并且在它们之间发生的转换是可以接受的。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224624739-928043347.png" width="250" /><font size="2.5">
            <i>调整探测器的位置.</i>
        </font></center>

<p>可以通过移动动态对象来测试探针。当选择一个动态对象的时候，也会显示当前正在发挥作用的探针。探针将显示其光照，而不仅仅是黄色球体。你还可以看到用于动态对象的内插数据。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224702732-797999005.gif" width="250" /><font size="2.5">
            <i>移动动态对象.</i>
        </font></center>

<p>通过不同的光照探头，物体的明暗变化明显。</p>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[为什么没有立即得到烘焙光源？为了确保在需要的时候光照贴图可以实际生成和更新，请在光照窗口的底部启用“自动生成（Auto Generate）”。 否则，你必须手动生成新的光照贴图。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender16/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender16/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity Deferred Lights-延迟光照(翻译十五)</title><link href="https://www.damonc.top/Unity_Deferred_Lights.html" rel="alternate" type="text/html" title="Unity Deferred Lights-延迟光照(翻译十五)" /><published>2018-01-17T20:00:00+08:00</published><updated>2018-01-17T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_Deferred_Lights</id><content type="html" xml:base="https://www.damonc.top/Unity_Deferred_Lights.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>自定义灯光渲染</li>
  <li>解码LDR颜色</li>
  <li>增加独立Pass渲染光</li>
  <li>支持方向光、点光源、聚光灯</li>
  <li>手动采样阴影纹理</li>
</ul>

<h2 id="光照light-shader">光照Light Shader</h2>

<p>在G-Buffers填充完毕后，然后渲染光。本篇先介绍Unity是如何渲染光，以及实现自己的渲染光的Shader。在Edit / Project Settings / Graphics 去掉默认的Shader。</p>

<h3 id="using-a-custom-shader">Using a Custom Shader</h3>

<p>每个deferred光都是在一个独立的Pass修改屏幕图像(后处理Image)完成渲染。创建一个Shader然后指定到Built-In shader settings</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200519084812390-1178609122.png" width="250" /><font size="2.5">
            <i>修改内置的Shader.</i>
        </font></center>

<h3 id="第二个passa-second-pass">第二个PassA Second Pass</h3>

<p>修改之后，编辑器大量报错.</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200519084812964-728132925.png" width="250" /><font size="2.5">
            <i>least 2 passes.</i>
        </font></center>

<p>先简单复制第一个Pass解决错误，结果是屏幕内除了天空盒外所有物体被渲染成黑色了。这是因为使用了stencil-buffer。</p>

<p><strong>报错的原因</strong>：为什么需要第二个Pass？</p>
<ul>
  <li>当HDR禁用时，光照数据会被使用对数编码计算，然后在(第二个)最终的pass解码该数据。所以必须要增加Pass。<em>当禁用HDR时就能调用第二个Pass，但此时天空也变黑了。</em></li>
</ul>

<h3 id="avoiding-the-sky">Avoiding the Sky</h3>

<p>当在LDR（HDR禁用）模式，天空变黑了。这是因为转换过程中没有正确使用stencil-buffer模板掩码。在<strong>第二个Pass中配置</strong>：应该只渲染不属于背景的片段，可通过_StencilNonBackground提供适当的模板值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">Stencil</span>
    <span class="p">{</span>
        <span class="n">Ref</span><span class="p">[</span><span class="n">_StencilNonBackground</span><span class="p">]</span>
        <span class="n">ReadMask</span><span class="p">[</span><span class="n">_StencilNonBackground</span><span class="p">]</span>
        <span class="n">CompBack</span> <span class="n">Equal</span>
        <span class="n">CompFront</span> <span class="n">Equal</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="颜色转换converting-colors">颜色转换Converting Colors</h3>

<p>在第二个Pass的light-buffer转换光照数据，方法就似Fog shader：用输入源的Image UV坐标采样buffer来绘制一个覆盖全屏的quad</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Interpolators</span> <span class="nf">VertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该light buffer通过名为_LightBuffer变量提供给Shader</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_LightBuffer</span><span class="p">;</span>
<span class="c1">//...</span>
<span class="kt">float4</span> <span class="nf">FragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_LightBuffer</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>LDR颜色使用指数编码:\(2^{-C}\)，使用对数解码\(-log2^C\)</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="o">-</span><span class="nb">log2</span><span class="p">(</span><span class="nb">tex2D</span><span class="p">(</span><span class="n">_LightBuffer</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">));</span>
</code></pre></div></div>

<h2 id="directional-lights">Directional Lights</h2>

<p>新增一个cginc文件，引入第一个pass。要把渲染的光照增加到图像上，必须确保不能擦除已渲染的图像，因此改变混合模式要完全合并源颜色和目标颜色。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Blend</span> <span class="n">One</span> <span class="n">One</span>
</code></pre></div></div>

<p>也需要所有可能的光照配置shader variants变体，该编译指令：multi_compile_lightpass会创建所有包含的变体。然后再增加一个HDR_ON的指令。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_lightpass
#pragma multi_compile _ UNITY_HDR_ON
</span></code></pre></div></div>

<h3 id="g-buffer-uv-coordinates">G-Buffer UV Coordinates</h3>

<p>需要用UV坐标从G-buffers采样，不幸的是，该light pass通道unity不支持提供该坐标。解决办法：从clip-space传递过来，使用ComputeScreenPos函数计算，返回一个float4的齐次坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v2f</span> <span class="nf">VertexProgram</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>  
<span class="p">{</span>  
     <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>  
     <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>  
     <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">ComputeScreenPos</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">pos</span><span class="p">);</span>  
     <span class="k">return</span> <span class="n">o</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div></div>

<p>然后在fragment就能计算最终的2D坐标。必须在fragment计算。见翻译7</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed4</span> <span class="nf">FragmentProgram</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="坐标转换world-position">坐标转换World Position</h3>

<p>与上篇deferred fog中相似，需要计算从相机到片元的距离：从相机原点发射射线通过片元(给定方向)到达far-plane，然后再用fragment深度缩放射线。用该方法<strong>重建片元的世界坐标</strong>。</p>

<ol>
  <li>首先。对于方向光，从quad的四顶点发出的射线作为法向量提供。所以可以通过顶点程序对射线进行插值。</li>
</ol>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="nb">NORMAL</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">ray</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Interpolators</span> <span class="nf">VertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">ComputeScreenPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">ray</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>其次。在fragment函数通过采样_CameraDepthTexture纹理和线性化计算可以得到depth值，类似于deferred fog计算</li>
</ol>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Unity提供的声明函数，等于 sampler2D _CameraDepthTexture; 定义在UnityCG</span>
<span class="n">UNITY_DECLARE_DEPTH_TEXTURE</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">);</span>

<span class="kt">float4</span> <span class="nf">FragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">Linear01Depth</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>然后。与deferred fog最大的不同：fog shader需要射线到达far plane；而本shader的射线只能到达near plane。所以必须要缩放射线以便它能达到far-plane：缩放射线使Z坐标变为1，并与远平面距离相乘。</li>
</ol>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">depth</span> <span class="o">=</span> <span class="n">Linear01Depth</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
<span class="kt">float3</span> <span class="n">rayToFarPlane</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">ray</span> <span class="o">*</span> <span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">i</span><span class="p">.</span><span class="n">ray</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</code></pre></div></div>

<ol>
  <li>再接着。按深度值缩放射线一次得到一个坐标。该射线被定义在视图空间，它是camera的本地空间。因此，射线也以片段在视图空间中的坐标结束。</li>
</ol>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">rayToFarPlane</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">ray</span> <span class="o">*</span> <span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">i</span><span class="p">.</span><span class="n">ray</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">viewPos</span> <span class="o">=</span> <span class="n">rayToFarPlane</span> <span class="o">*</span> <span class="n">depth</span><span class="p">;</span>
</code></pre></div></div>

<ol>
  <li>最后。再使用unity_CameraToWorld内置矩阵从view视图空间转换到world世界坐标，该矩阵定义在ShaderVariables.cginc</li>
</ol>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">viewPos</span> <span class="o">=</span> <span class="n">rayToFarPlane</span> <span class="o">*</span> <span class="n">depth</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">worldPos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_CameraToWorld</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">viewPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="读取g-buff-reading-g-buffer-data">读取G-Buff Reading G-Buffer Data</h3>

<p>获取World Pos后。通过访问G-buffer检索properties，该buffer可从内置的_CamearGBufferTexture变量获取</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture0</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture1</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture2</span><span class="p">;</span>
</code></pre></div></div>

<p>在上一篇Defferred Shading中也手动计算过G-buffer,这次直接读取_CameraGBufferTexture现成的albedo、specular、smoothness、normal</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">worldPos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_CameraToWorld</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">viewPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">albedo</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_CameraGBufferTexture0</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">specularTint</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_CameraGBufferTexture1</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span><span class="c1">//合并</span>
<span class="kt">float3</span> <span class="n">smoothness</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_CameraGBufferTexture1</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">a</span><span class="p">;</span><span class="c1">//合并</span>
<span class="kt">float3</span> <span class="n">normal</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_CameraGBufferTexture2</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="计算brd-computing-brdf">计算BRD Computing BRDF</h3>

<p>引入BRDF函数，定义在UnityPBSLighting.cginc中</p>

<p>首先计算视野方向</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">worldPos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_CameraToWorld</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">viewPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">worldPos</span><span class="p">);</span>
</code></pre></div></div>

<p>其次是表面反射，这可从specular颜色获取，使用SpecularStrength函数提取。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//...</span>
<span class="n">float</span> <span class="n">oneMinusReflectivity</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">SpecularStrength</span><span class="p">(</span><span class="n">specularTint</span><span class="p">);</span>
</code></pre></div></div>

<p>然后传递光照数据，初始化直接光和间接光</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">oneMinusReflectivity</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">SpecularStrength</span><span class="p">(</span><span class="n">specularTint</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">UnityIndirect</span> <span class="n">indirectLight</span><span class="p">;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">specular</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>最后计算最终的颜色</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">indirectLight</span><span class="p">.</span><span class="n">specular</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">UNITY_BRDF_PBS</span>
<span class="p">(</span>
    <span class="n">albedo</span><span class="p">,</span> <span class="n">specularTint</span><span class="p">,</span> <span class="n">oneMinusReflectivity</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">,</span>
    <span class="n">normal</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">,</span> <span class="n">light</span><span class="p">,</span> <span class="n">indirectLight</span>
<span class="p">);</span>
<span class="k">return</span> <span class="n">color</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="光源配置-configuring-the-light">光源配置 Configuring the Light</h3>

<p>因为间接光呈现的是黑色的，在这里不适用。但是直接光必须被配置成与当前渲染的光相匹配。对于方向光，需要它的颜色和方向。这两个变量可以通过_LightColor和_LightDir变量获得。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="n">_LightColor</span><span class="p">,</span> <span class="n">_LightDir</span><span class="p">;</span>

<span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">_LightDir</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_LightColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>

    <span class="n">UnityLight</span> <span class="n">light</span> <span class="o">=</span> <span class="n">CreateLight</span><span class="p">();</span>
<span class="c1">//    light.color = 0;</span>
<span class="c1">//    light.dir = 0;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011132912-1838344751.png" width="250" /><font size="2.5">
            <i>光照方向错误.</i>
        </font></center>

<p>计算得到最终的光照，但光的方向错误了。原因：_LightDir是光到表面的方向。在CreateLight计算中需要表面到光的方向</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="o">-</span><span class="n">_LightDir</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011133845-1557873589.png" width="250" /><font size="2.5">
            <i>正确，没有阴影.</i>
        </font></center>

<h3 id="阴影-shadows">阴影 Shadows</h3>

<p>在自己的cginc文件中，我们依靠AutoLight中的宏来确定由阴影引起的光衰减。 不幸的是，该文件在编写时并没有考虑到延迟的光线。 现在将自己进行阴影采样，可通过_ShadowMapTexture变量访问阴影贴图。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_ShadowMapTexture</span><span class="p">;</span>
</code></pre></div></div>

<p>但是，我们不能随意声明此变量。 它已经在UnityShadowLibrary中为点和聚光灯阴影定义了它。 因此，我们不应该自己定义它，除非使用方向光阴影。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined (SHADOWS_SCREEN)
</span>    <span class="n">sampler2D</span> <span class="n">_ShadowMapTexture</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>要应用方向光阴影，需要采样阴影纹理并使用它来减弱光色即可。 在CreateLight中计算就需要把UV坐标参数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="o">-</span><span class="n">_LightDir</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_LightColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">shadowAttenuation</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">UnityLight</span> <span class="n">light</span> <span class="o">=</span> <span class="n">CreateLight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011134639-175464244.png" width="250" /><font size="2.5">
            <i>有阴影的方向光.</i>
        </font></center>

<p>当然，这仅在定向光启用了阴影时才有效。 如果不是，则阴影衰减始终为1。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#if defined(SHADOWS_SCREEN)
</span>    <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_LightColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">shadowAttenuation</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="fading-shadows">Fading Shadows</h3>

<p>阴影贴图应该是有限的，它覆盖的面积越大，阴影的分辨率越低。 Unity提供了绘制阴影的最大距离，此距离可以通过_Edit / Project Settings / Quality_进行调整。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011135350-727795272.png" width="250" /><font size="2.5">
            <i>阴影距离配置.</i>
        </font></center>

<p>当阴影几乎快达到了该限定距离就会淡出，Unity内置的shader是这样设定并计算。由于我将手动采样该阴影纹理，当到达纹理的边缘时阴影会被截取，结果是阴影虽然消失了，但有被急剧切割的生硬画面。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011136133-1319763420.png" width="250" /><font size="2.5">
            <i>长、短距离阴影对比.</i>
        </font></center>

<p>要渐隐阴影，<strong>首先</strong>要知道的是阴影完全消失的距离。该距离又依赖于阴影投射方向。在Stable Fit模式下，以map的中心点呈球面形开始渐隐消失阴影；在Close Fit模式它是依赖于视野深度。</p>

<p>UnityComputeShadowFadeDistance函数能计算出正确距离，它需要两个参数：world pos 和 view depth；<strong>然后</strong>返回距离A。 注意：该距离A是从阴影纹理的中心点位置或者未更改的视野深度开始计算的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">,</span> <span class="n">float</span> <span class="n">viewZ</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="o">-</span><span class="n">_LightDir</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="cp">#if defined(SHADOWS_SCREEN)
</span>        <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
        <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_LightColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">shadowAttenuation</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>阴影应该是快要接近渐隐距离时开始消失，一旦到达就完全消失。UnityComputeShadowFade函数计算合适的消失因子。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
<span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
</code></pre></div></div>

<p><em>UnityComputeShadowFade</em> 定义在UnityShadowLibrary.cginc，见下：</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">UnityComputeShadowFadeDistance</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">wpos</span><span class="p">,</span> <span class="n">float</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">sphereDist</span> <span class="o">=</span> <span class="nb">distance</span><span class="p">(</span><span class="n">wpos</span><span class="p">,</span> <span class="n">unity_ShadowFadeCenterAndType</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">sphereDist</span><span class="p">,</span> <span class="n">unity_ShadowFadeCenterAndType</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">half</span> <span class="nf">UnityComputeShadowFade</span><span class="p">(</span><span class="n">float</span> <span class="n">fadeDist</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">fadeDist</span> <span class="o">*</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>阴影渐隐值范围是[0, 1]，该值决定了阴影要消失多少。实际的消失值可以加到阴影衰减之上并限定在[0, 1]之内</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
<span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">shadowAttenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
</code></pre></div></div>

<p>最后，提供世界坐标和视图深度在片元程序中创建光照。视图深度是片元在视图空间中的位置的Z分量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="n">light</span> <span class="o">=</span> <span class="n">CreateLight</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">worldPos</span><span class="p">,</span> <span class="n">viewPos</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011136822-531625316.png" width="250" /><font size="2.5">
            <i>阴影渐隐.</i>
        </font></center>

<h3 id="light-cookies">Light Cookies</h3>

<p>支持Cookies纹理，使用变量__LightTexture0_访问；同时还要从world-space转换到light-space，最后采样。转换矩阵使用_unity_WorldToLight_矩阵变量</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_LightTexture0</span><span class="p">;</span>
<span class="kt">float4x4</span> <span class="n">unity_WorldToLight</span><span class="p">;</span>
</code></pre></div></div>

<p>在_CreateLight_，使用上述矩阵变量转换world-space到light-space；然后使用转换后的坐标采样cookie纹理。cookie也要衰减，需要单独定义并使用。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="o">-</span><span class="n">_LightDir</span><span class="p">;</span>
<span class="n">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">float</span> <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#if defined(DIRECTIONAL_COOKIE)
</span>    <span class="kt">float2</span> <span class="n">uvCookie</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToLight</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_LightTexture0</span><span class="p">,</span> <span class="n">uvCookie</span><span class="p">).</span><span class="n">w</span><span class="p">;</span>
<span class="cp">#endif
</span>    <span class="c1">//...</span>
<span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_LightColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="p">(</span><span class="n">attenuation</span> <span class="o">*</span> <span class="n">shadowAttenuation</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011137698-104613306.png" width="250" /><font size="2.5">
            <i>带有cookie的方向光.</i>
        </font></center>

<p>整体结果似乎可以，但是观察边缘似乎有硬边</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011138369-1638016260.png" width="250" /><font size="2.5">
            <i>硬边过渡.</i>
        </font></center>

<p>相邻片元的cookie坐标的巨大差异就会导致该问题出现。在这种情况下，GPU选择的mipmap级别对于最近的表面是low level。解决办法之一就是：在采样mip映射时应用偏移。<a href="http://aras-p.info/blog/2010/01/07/screenspace-vs-mip-mapping/">大v的总结</a></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">tex2Dbias</span><span class="p">(</span><span class="n">_LightTexture0</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">uvCookie</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">)).</span><span class="n">w</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011138941-1152817269.png" width="250" /><font size="2.5">
            <i>偏移采样.</i>
        </font></center>

<h3 id="支持ldr-supporting-ldr">支持LDR Supporting LDR</h3>

<p>上述只支持HDR，现在来支持LDR。步骤如下：</p>

<p>首先，编码后的LDR颜色要乘如light-buffer，而不是加法。这可以用：Blend DstColor Zero实现。<strong>注意</strong>只用该Blend mode会引起HDR的错误。所以需要灵活配置：Blend [_SrcBlend] [_DstBlend]</p>

<p>然后，使用\(2^{-c}\)函数解码</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">UNITY_BRDF_PBS</span><span class="p">(</span>
        <span class="n">albedo</span><span class="p">,</span> <span class="n">specularTint</span><span class="p">,</span> <span class="n">oneMinusReflectivity</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">,</span>
        <span class="n">normal</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">,</span> <span class="n">light</span><span class="p">,</span> <span class="n">indirectLight</span>
<span class="p">);</span>
    <span class="cp">#if !defined(UNITY_HDR_ON)
</span>        <span class="n">color</span> <span class="o">=</span> <span class="nb">exp2</span><span class="p">(</span><span class="o">-</span><span class="n">color</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="k">return</span> <span class="n">color</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="聚光源-spotlights">聚光源 Spotlights</h2>

<p>因为方向光会影响到场景内所有物体，所以被画成全屏quad。相比之下，聚光灯只会影响位于圆锥体内的部分物体。通常不需要计算整个图像的聚光灯光照，将绘制一个与聚光灯的影响范围相匹配的金字塔体。</p>

<h3 id="drawing-a-pyramid">Drawing a Pyramid</h3>

<p>禁用方向灯，改用聚光灯。因为着色器只对方向光正确工作，那么现在的结果会出现错误。但是它仍可以让你看到金字塔的哪些部分被渲染了。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011139705-601577612.png" width="250" /><font size="2.5">
            <i>渲染范围.</i>
        </font></center>

<p>根据上图，金字塔是作为一个普通的3D对象呈现的。它的背面被剔除，所以我们可以看到金字塔的正面。只有当它前面没有东西的时候，它才会被画出来。除此之外，还添加了一个pass，用于设置模板缓冲区，以将绘图限制为位于金字塔卷内的片段。您可以通过frame-debugger来验证。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011140292-1380890338.png" width="250" /><font size="2.5">
            <i>剔除方式.</i>
        </font></center>

<p>这意味着我们的着色器的culling和z-test设置被否弃了。 因此将其从着色器中删除。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Blend</span> <span class="p">[</span><span class="n">_SrcBlend</span><span class="p">]</span> <span class="p">[</span><span class="n">_DstBlend</span><span class="p">]</span>
<span class="c1">//Cull Off</span>
<span class="c1">//ZTest Always</span>
<span class="n">ZWrite</span> <span class="n">Off</span>
</code></pre></div></div>

<p>当聚光灯的体积距离相机足够远时，此方法适用。 但是，当聚光灯离摄像机太近时，它会失败。 发生这种情况时，相机可能会进入了该体积内。 甚至有可能将近平面的一部分置于其内部，而将其余部分置于其外部，与近平面相交了。 在这些情况下，模板缓冲区不能用于限制渲染。</p>

<p>仍然渲染光照的技巧是绘制金字塔的内表面，而不是金字塔的外表面。 这是通过渲染其背面而不是其正面来完成的。 而且，仅当这些表面最终位于已渲染的表面之后时才渲染它们。 这种方法还涵盖了聚光灯体积内的所有片段。 但这最终导致渲染了太多的碎片，因为通常金字塔的通常隐藏部分也将被渲染。 因此，仅在必要时执行。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011141041-480459935.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011141704-455701372.png" width="250" /><font size="2.5">
            <i>当靠近相机时，要绘制背面才正确.</i>
        </font></center>

<h3 id="支持多光源-supporting-multiple-light-types">支持多光源 Supporting Multiple Light Types</h3>

<p>目前，CreateLight只能用于方向光。让我们确保特定于方向灯的代码只在适当的时候使用。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">,</span> <span class="n">float</span> <span class="n">viewZ</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>
    <span class="c1">//light.dir = -_LightDir;</span>
    <span class="n">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="cp">#if defined(DIRECTIONAL) || defined(DIRECTIONAL_COOKIE)
</span>        <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="o">-</span><span class="n">_LightDir</span><span class="p">;</span>

        <span class="cp">#if defined(DIRECTIONAL_COOKIE)
</span>            <span class="kt">float2</span> <span class="n">uvCookie</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToLight</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xy</span><span class="p">;</span>
            <span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">tex2Dbias</span><span class="p">(</span><span class="n">_LightTexture0</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">uvCookie</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">)).</span><span class="n">w</span><span class="p">;</span>
        <span class="cp">#endif
</span>
        <span class="cp">#if defined(SHADOWS_SCREEN)
</span>            <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
            <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
            <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
            <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">shadowAttenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#else
</span>        <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_LightColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="p">(</span><span class="n">attenuation</span> <span class="o">*</span> <span class="n">shadowAttenuation</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>尽管阴影衰落基于方向阴影贴图，但是其他类型的阴影也应该会被渐隐。 这样可以确保所有阴影都以相同的方式渐隐，而不仅仅是某些阴影。 因此，只要有阴影，阴影淡入淡出代码便适用于所有灯光。 因此，让我们将该代码移到特定于光源的块之外。</p>

<p>我们可以使用布尔值来控制是否使用阴影淡出代码。由于布尔值是一个常数值，如果它仍然为假，代码将被删除。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">,</span> <span class="n">float</span> <span class="n">viewZ</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="cp">#if defined(DIRECTIONAL) || defined(DIRECTIONAL_COOKIE)
</span>        <span class="c1">//省略代码</span>
        <span class="cp">#if defined(SHADOWS_SCREEN)
</span>            <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
        <span class="c1">// float shadowFadeDistance = UnityComputeShadowFadeDistance(worldPos, viewZ);</span>
        <span class="c1">// float shadowFade = UnityComputeShadowFade(shadowFadeDistance);</span>
        <span class="c1">// shadowAttenuation = saturate(shadowAttenuation + shadowFade);</span>
        <span class="cp">#endif
</span>    <span class="cp">#else
</span>        <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
        <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">shadowAttenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_LightColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="p">(</span><span class="n">attenuation</span> <span class="o">*</span> <span class="n">shadowAttenuation</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>非方向灯光都有一个position变量。它通过内置的_LightPos提供。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="n">_LightColor</span><span class="p">,</span> <span class="n">_LightDir</span><span class="p">,</span> <span class="n">_LightPos</span><span class="p">;</span>
</code></pre></div></div>

<p>现在可以确定聚光灯的光向量得出光方向。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#else
</span>    <span class="kt">float3</span> <span class="n">lightVec</span> <span class="o">=</span> <span class="n">_LightPos</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">worldPos</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">lightVec</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h3 id="world-position-agin">World Position Agin</h3>

<p>结果为黑色，似乎光线方向不正确。 发生这种情况是因为聚光灯的世界位置计算不正确。 当我们在场景中的某个地方渲染金字塔时，不像方向光那样渲染全屏quad将光线存储在normal通道中。 而必须是经由Vertex-Program从顶点的位置发射射线，通过将顶点的pos转换到view-space完成计算，为此，我们可以使用UnityObjectToViewPos函数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">ray</span> <span class="o">=</span> <span class="n">UnityObjectToViewPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
</code></pre></div></div>

<p>然而，这会产生方向错误的光线。我们要消去它们的X和Y坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">ray</span> <span class="o">=</span> <span class="n">UnityObjectToViewPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">)</span> <span class="o">*</span> <span class="nf">float3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527011142595-16646437.png" width="250" /><font size="2.5">
            <i>正确的世界位置.</i>
        </font></center>

<p>再次看看UnityObjectToViewPos内部实现</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inline</span> <span class="kt">float3</span> <span class="nf">UnityObjectToViewPos</span> <span class="p">(</span><span class="k">in</span> <span class="kt">float3</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_V</span><span class="p">,</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">))).</span><span class="n">xyz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当渲染方向光时，应该只使用顶点法线。当渲染非方向灯以外的光几何时，需要把顶点pos转到view-space计算。Unity通过__LightAsQuad_变量告诉我们正在处理哪种情况。</p>

<p>如果__LightAsQuad_被设为1，则处理的是方向光quad并且可以使用法线。否则，我们必须使用UnityObjectToViewPos。插值好过if ==&gt; from + (to – from) * t, t为1直接使用法线，为0直接计算到view-space</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">ray</span> <span class="o">=</span> <span class="nb">lerp</span>
<span class="p">(</span>
    <span class="n">UnityObjectToViewPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">)</span> <span class="o">*</span> <span class="nf">float3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span>
    <span class="n">_LightAsQuad</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="锥形衰减-cookie-attenuation">锥形衰减 Cookie Attenuation</h3>

<p>聚光灯的锥形衰减是通过cookie纹理创建的，无论是默认的圆形还是定制的cookie。我们可以从复制定向光的cookie代码，仿照着写。也是存储在_LightTexture0</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">lightVec</span> <span class="o">=</span> <span class="n">_LightPos</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">worldPos</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">lightVec</span><span class="p">);</span>
<span class="kt">float2</span> <span class="n">uvCookie</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToLight</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xy</span><span class="p">;</span>
<span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">tex2Dbias</span><span class="p">(</span><span class="n">_LightTexture0</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">uvCookie</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">)).</span><span class="n">w</span><span class="p">;</span>
</code></pre></div></div>

<p>但是，聚光灯Cookie越远离灯光位置，它就会变得越大。 这是由于通过透视变换造成的。 因此，矩阵乘法会产生4D齐次坐标。 为了得到规则的2D坐标，我们必须将X和Y除以W。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="n">uvCookie</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToLight</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="n">uvCookie</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="n">uvCookie</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">tex2Dbias</span><span class="p">(</span><span class="n">_LightTexture0</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">uvCookie</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">)).</span><span class="n">w</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527012302994-353496315.png" width="250" /><font size="2.5">
            <i>cookie衰减.</i>
        </font></center>

<p>上图实际上产生了两个光锥，一个向前一个向后。 后向圆锥通常在渲染区域之外结束，但这并不能保证。我们只需要前向锥，它对应于负的W坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">tex2Dbias</span><span class="p">(</span><span class="n">_LightTexture0</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">uvCookie</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">)).</span><span class="n">w</span><span class="p">;</span>
<span class="n">attenuation</span> <span class="o">*=</span> <span class="n">uvCookie</span><span class="p">.</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="距离衰减-distance-attenuation">距离衰减 Distance Attenuation</h3>

<p>聚光灯发出的光也会根据距离衰减。此衰减存储在查找纹理中，可通过__LightTextureB0_使用该纹理。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_LightTexture0</span><span class="p">,</span> <span class="n">_LightTextureB0</span><span class="p">;</span>
</code></pre></div></div>

<p>纹理被设计成必须使用光的距离的平方，并按光的范围进行缩放，作为UV进行采样。范围存储在_LightPos的第四个分量中。采样得到的纹理应该使用哪个通道在不同的平台，由_UNITY_ATTEN_CHANNEL_宏定义。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">lightVec</span><span class="p">);</span>
<span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">tex2D</span>
<span class="p">(</span>
    <span class="n">_LightTextureB0</span><span class="p">,</span>
    <span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">lightVec</span><span class="p">,</span> <span class="n">lightVec</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightPos</span><span class="p">.</span><span class="n">w</span><span class="p">).</span><span class="n">rr</span>
<span class="p">).</span><span class="n">UNITY_ATTEN_CHANNEL</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">uvCookie</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToLight</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527085923716-1558484014.png" width="250" /><font size="2.5">
            <i>cookie 和 distance衰减.</i>
        </font></center>

<h3 id="shadows">Shadows</h3>

<p>当聚光灯有阴影时，定义SHADOWS_DEPTH关键字。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//在CreateLight中</span>
<span class="kt">float4</span> <span class="n">uvCookie</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToLight</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="n">uvCookie</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="n">uvCookie</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">tex2Dbias</span><span class="p">(</span><span class="n">_LightTexture0</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">uvCookie</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">)).</span><span class="n">w</span><span class="p">;</span>

<span class="cp">#if defined(SHADOWS_DEPTH)
</span>    <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>聚光灯和方向灯使用相同的变量来采样阴影贴图。在聚光灯的情况下，可以使用内置UnitySampleShadowmap来处理采样硬阴影或软阴影的细节。参数：阴影空间中的片元位置。unity_WorldToShadow_(4x4)_矩阵中第一个数组可以用来将世界空间转换为阴影空间。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleShadowmap</span><span class="p">(</span>
    <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToShadow</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="点光源-point-lights">点光源 Point Lights</h3>

<p>点光源使用与聚光灯相同的光向量、方向和距离衰减。这样他们就可以共享代码。应该只在定义SPOT关键字时使用spotlight代码的其余部分。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(DIRECTIONAL) || defined(DIRECTIONAL_COOKIE)
</span>    <span class="c1">//...</span>
<span class="cp">#else
</span>    <span class="kt">float3</span> <span class="n">lightVec</span> <span class="o">=</span> <span class="n">_LightPos</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">worldPos</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">lightVec</span><span class="p">);</span>

    <span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">tex2D</span><span class="p">(</span>
        <span class="n">_LightTextureB0</span><span class="p">,</span>
        <span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">lightVec</span><span class="p">,</span> <span class="n">lightVec</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightPos</span><span class="p">.</span><span class="n">w</span><span class="p">).</span><span class="n">rr</span>
    <span class="p">).</span><span class="n">UNITY_ATTEN_CHANNEL</span><span class="p">;</span>

    <span class="cp">#if defined(SPOT)
</span>        <span class="kt">float4</span> <span class="n">uvCookie</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToLight</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">uvCookie</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="n">uvCookie</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
        <span class="n">attenuation</span> <span class="o">*=</span>
            <span class="nb">tex2Dbias</span><span class="p">(</span><span class="n">_LightTexture0</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">uvCookie</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">)).</span><span class="n">w</span><span class="p">;</span>
        <span class="n">attenuation</span> <span class="o">*=</span> <span class="n">uvCookie</span><span class="p">.</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cp">#if defined(SHADOWS_DEPTH)
</span>            <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleShadowmap</span><span class="p">(</span>
                <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToShadow</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>这已经足够让点光源工作了。它们被渲染成和聚光灯一样的效果，除了渲染范围使用的是球形而不是锥形。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527085924576-1982519938.png" width="250" /><font size="2.5">
            <i>高亮.</i>
        </font></center>

<h3 id="shadows-1">Shadows</h3>

<p>点光源的阴影存储在一个CubeMap。内置UnitySampleShadowmap可采样。参数：光的方向。一个从光到表面的向量。它是光的相反方向。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SPOT)
</span><span class="c1">//...</span>
<span class="cp">#else
</span>    <span class="cp">#if defined(SHADOWS_CUBE)
</span>        <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleShadowmap</span><span class="p">(</span><span class="o">-</span><span class="n">lightVec</span><span class="p">);</span>
    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527085925412-308331709.png" width="250" /><font size="2.5">
            <i>点光源阴影.</i>
        </font></center>

<h3 id="cookies">Cookies</h3>

<p>Point light cookie也可以通过_LightTexture0获得。需要的是一个cubeMap映射，而不是常规的纹理。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//sampler2D _LightTexture0, _LightTextureB0;</span>
<span class="cp">#if defined(POINT_COOKIE)
</span>    <span class="n">samplerCUBE</span> <span class="n">_LightTexture0</span><span class="p">;</span>
<span class="cp">#else
</span>    <span class="n">sampler2D</span> <span class="n">_LightTexture0</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="n">sampler2D</span> <span class="n">_LightTextureB0</span><span class="p">;</span>
<span class="kt">float4x4</span> <span class="n">unity_WorldToLight</span><span class="p">;</span>
</code></pre></div></div>

<p>要对cookie进行采样，请将片段的world-space转换为light-space，并使用光照空间对立方体映射进行采样。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#else
</span>    <span class="cp">#if defined(POINT_COOKIE)
</span>        <span class="kt">float3</span> <span class="n">uvCookie</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToLight</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
        <span class="n">attenuation</span> <span class="o">*=</span> <span class="nb">texCUBEbias</span><span class="p">(</span><span class="n">_LightTexture0</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">uvCookie</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">)).</span><span class="n">w</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined(SHADOWS_CUBE)
</span>        <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleShadowmap</span><span class="p">(</span><span class="o">-</span><span class="n">lightVec</span><span class="p">);</span>
    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender15/1692664-20200527085926193-2066682458.png" width="250" /><font size="2.5">
            <i>点光源cookie.</i>
        </font></center>

<h3 id="skipping-shadows">Skipping Shadows</h3>

<p>现在，我们可以使用自己的着色器渲染所有动态光源。 尽管我们目前并未对优化进行太多关注，但仍有一项潜在的大型优化<strong>值得考虑</strong>：<strong>最终超出阴影渐隐距离的片元将不会被阴影化</strong>。 但是现在仍在采样它们的阴影，这可能很昂贵。 我们可以通过基于阴影衰落因子进行_UNITY_BRANCH_分支来避免这种情况。 它接近1，那么我们可以完全跳过阴影衰减。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
    <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">shadowAttenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="n">UNITY_BRANCH</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shadowFade</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是，即使用了_UNITY_BRANCH_分支它本身也很昂贵。除了靠近阴影区域的边缘，所有碎片都落在阴影区域的内部或外部。 但这仅在GPU可以利用这一点的情况下才重要。 在这种情况下，使用HLSLSupport.cginc定义UNITY_FAST_COHERENT_DYNAMIC_BRANCHING宏。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING)
</span>    <span class="n">UNITY_BRANCH</span>
    <span class="nf">if</span> <span class="p">(</span><span class="n">shadowFade</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>即使这样，仅当阴影需要多个纹理样本时才值得使用。 <strong>对于柔和的聚光灯和点光源阴影，进一步使用用SHADOWS_SOFT关键字指示</strong>。 而方向光阴影始终只需要单个纹理，因此它性能很便宜。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT)
</span>    <span class="n">UNITY_BRANCH</span>
    <span class="nf">if</span> <span class="p">(</span><span class="n">shadowFade</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[当阴影几乎快达到了该限定距离就会淡出，Unity内置的shader是这样设定并计算。由于我将手动采样该阴影纹理，当到达纹理的边缘时阴影会被截取，结果是阴影虽然消失了，但有被急剧切割的生硬画面。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender15/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender15/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity Shader Fog(翻译十四)</title><link href="https://www.damonc.top/UNity_Shader_Fog.html" rel="alternate" type="text/html" title="Unity Shader Fog(翻译十四)" /><published>2018-01-15T20:00:00+08:00</published><updated>2018-01-15T20:00:00+08:00</updated><id>https://www.damonc.top/UNity_Shader_Fog</id><content type="html" xml:base="https://www.damonc.top/UNity_Shader_Fog.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>应用雾到游戏对象</li>
  <li>基于距离或深度的雾</li>
  <li>支持deferred fog</li>
</ul>

<h2 id="前向渲染雾-forward-fog">前向渲染雾-Forward Fog</h2>

<p>在14之前，一直假定着光线在真空中传播，在真空中可能是精确的。但是当光线穿过大气或水就不一样了，光线在击中物体表面时会发生被吸收、散射和反射。</p>

<p>一个精确的大气干扰光线渲染将需要及其昂贵的体积测量方法，那是大多数现代GPU负担不起的。相反，勉强采用一些常量雾参数近似模拟。</p>

<h3 id="标准雾-standard-fog">标准雾-Standard Fog</h3>

<p>Unity光照设置包含了场景雾设置选项，默认是不启用。启用后，默认是灰色雾。Unity自带的雾只适用于使用了Forward渲染路径的物体。若激活Deferred path，提示：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235158162-487991047.png" width="250" /><font size="2.5">
            <i>deferred 提示.</i>
        </font></center>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235158998-641873984.png" width="250" /><font size="2.5">
            <i>不明显的雾.</i>
        </font></center>

<h3 id="线性雾-linear-fog">线性雾-Linear Fog</h3>

<p>图2不明显，是因为Fog color灰色雾将散射和反射更多的光线，吸收较少。把Fog Color改为纯黑色试试
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235159582-1089337078.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235200361-31174269.png" width="250" /><font size="2.5">
            <i>linear fog.</i>
        </font></center>

<p>雾的浓度是随视距线性增长的，在视距开头正常显示，超过这个距离就只有雾的颜色可见。</p>

<p><strong>线性雾公式</strong>：
\(f = { {E-c} \over {E-s} }\)</p>

<p>c 是雾坐标；<br />
s 是视距起始距离；<br />
E 是视距终止距离；<br />
f值 被限定在[0, 1]范围，被用在雾和物体着色之间插值。</p>

<p>最终计算在fragment color着色到物体对象上，雾不会影响到skybox</p>

<h3 id="指数雾-exponential-fog">指数雾-Exponential Fog</h3>

<p>更接近真实感的雾
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235201459-832769226.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235203426-304224456.png" width="250" /><font size="2.5">
            <i>指数雾.</i>
        </font></center>

<p><strong>指数雾公式</strong>：
\(f = {1 \over {2^{cd}}}\)
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235204598-417023262.png" width="150" /></center>

<p>d 是fog的密度因子；<br />
c 是距离因子。</p>

<h3 id="指数平方雾-exponential-squared-fog">指数平方雾-Exponential Squared Fog</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235205400-412540608.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235206302-247343724.png" width="250" /><font size="2.5">
            <i>指数平方雾.</i>
        </font></center>

<p><strong>指数平方雾公式</strong>：
\(f = {1 \over {2^{(cd)^2}}}\)
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235207307-166956062.png" width="150" /></center>

<h3 id="渲染雾-adding-fog">渲染雾-Adding Fog</h3>

<p>增加Fog到自己的shader中，增加Fog需要使用内置关键字：<em>multi_compile_fog_指令。该指令的变体会额外增加：_FOG_LINEAR、FOG_EXP、FOG_EXP2</em></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_fog
</span></code></pre></div></div>

<p>新增ApplyFog()函数，用于在Fragment计算最终着色：获取当前颜色和插值数据作为参数，返回最终颜色。</p>

<p>计算步骤：<br />
任何雾公式都是基于视距的，首先计算出视距值备用；<br />
然后使用UnityCG.cginc宏_UNITY_CALC_FOG_FACTOR_RAW_根据具体雾公式计算出雾因子。<br />
最后根据雾因子，在fog_color和当前color取插值返回。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float4</span> <span class="nf">ApplyFOG</span><span class="p">(</span><span class="n">float4</span> <span class="n">color</span><span class="p">,</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">viewDistance</span> <span class="p">=</span> <span class="nf">length</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="p">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
    <span class="nf">UNITY_CALC_FOG_FACTOR_RAW</span><span class="p">(</span><span class="n">viewDistance</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">learp</span><span class="p">(</span><span class="n">unity_FogColor</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">unityFogFactor</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//宏UNITY_CALC_FOG_FACTOR_RAW</span>
<span class="cp">#if defined(FOG_LINEAR)
</span>    <span class="c1">// factor = (end-z)/(end-start) = z \* (-1/(end-start)) + (end/(end-start))</span>
    <span class="err">#</span><span class="n">define</span> <span class="nf">UNITY_CALC_FOG_FACTOR_RAW</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="kt">float</span> <span class="n">unityFogFactor</span> <span class="p">=</span> <span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="err">\</span><span class="p">*</span> <span class="n">unity_FogParams</span><span class="p">.</span><span class="n">z</span> <span class="p">+</span> <span class="n">unity_FogParams</span><span class="p">.</span><span class="n">w</span>
<span class="cp">#elif defined(FOG_EXP)
</span>    <span class="c1">// factor = exp(-density\*z)</span>
    <span class="err">#</span><span class="n">define</span> <span class="nf">UNITY_CALC_FOG_FACTOR_RAW</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="kt">float</span> <span class="n">unityFogFactor</span> <span class="p">=</span> <span class="n">unity_FogParams</span><span class="p">.</span><span class="n">y</span> <span class="err">\</span><span class="p">*</span> <span class="p">(</span><span class="n">coord</span><span class="p">);</span> <span class="n">unityFogFactor</span> <span class="p">=</span> <span class="nf">exp2</span><span class="p">(-</span><span class="n">unityFogFactor</span><span class="p">)</span>
<span class="cp">#elif defined(FOG_EXP2)
</span>    <span class="c1">// factor = exp(-(density\*z)^2)</span>
    <span class="err">#</span><span class="n">define</span> <span class="nf">UNITY_CALC_FOG_FACTOR_RAW</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="kt">float</span> <span class="n">unityFogFactor</span> <span class="p">=</span> <span class="n">unity_FogParams</span><span class="p">.</span><span class="n">x</span> <span class="err">\</span><span class="p">*</span> <span class="p">(</span><span class="n">coord</span><span class="p">);</span> <span class="n">unityFogFactor</span> <span class="p">=</span> <span class="nf">exp2</span><span class="p">(-</span><span class="n">unityFogFactor</span><span class="err">\</span><span class="p">*</span><span class="n">unityFogFactor</span><span class="p">)</span>
<span class="cp">#else
</span>    <span class="err">#</span><span class="n">define</span> <span class="nf">UNITY_CALC_FOG_FACTOR_RAW</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="kt">float</span> <span class="n">unityFogFactor</span> <span class="p">=</span> <span class="m">0.0</span>
<span class="cp">#endif
</span>
<span class="c1">//宏UNITY_CALC_FOG_FACTOR</span>
<span class="cp">#define UNITY_CALC_FOG_FACTOR(coord) UNITY_CALC_FOG_FACTOR_RAW(UNITY_Z_0_FAR_FROM_CLIPSPACE(coord))
</span>
<span class="c1">//unity_FogParams 定义在ShaderVariables</span>
<span class="c1">// x = density / sqrt(ln(2)), useful for Exp2 mode</span>
<span class="c1">// y = density / ln(2), useful for Exp mode</span>
<span class="c1">// z = -1/(end-start), useful for Linear mode</span>
<span class="c1">// w = end/(end-start), useful for Linear mode</span>
<span class="n">float4</span> <span class="n">unity_FogParams</span><span class="p">;</span>
</code></pre></div></div>

<p>注意雾因子必须限定在[0,1]</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="nf">learp</span><span class="p">(</span><span class="n">unity_FogColor</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="nf">saturate</span><span class="p">(</span><span class="n">unityFogFactor</span><span class="p">));</span>
</code></pre></div></div>

<p>同时雾也不能影响Alpha值</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="nf">learp</span><span class="p">(</span><span class="n">unity_FogColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="nf">saturate</span><span class="p">(</span><span class="n">unityFogFactor</span><span class="p">));</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235208597-1924410952.png" width="350" /><font size="2.5">
            <i>linear：standard vs. mine.</i>
        </font></center>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235209833-525170101.png" width="350" /><font size="2.5">
            <i>exp：standard vs. mine.</i>
        </font></center>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235210707-599317063.png" width="350" /><font size="2.5">
            <i>exp2：standard vs. mine.</i>
        </font></center>

<h3 id="深度雾-depth-based-fog">深度雾-Depth-Based Fog</h3>

<p>增加深度雾支持。与Standard Shader不同的原因是计算fog坐标方法不同。虽然使用world-space视图距离是有意义的，但标准着色器使用裁剪空间深度值。因此视角不影响雾坐标。此外，在某些情况下，距离是受相机的近裁切面距离的影响，这将把雾推开一点。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235211359-387262789.png" width="250" /><font size="2.5">
            <i>深度 (三角) vs. 距离(园).</i>
        </font></center>

<p><strong>基于深度代替距离的优点</strong>是：不必计算平方根，计算速度更快，适用于非真实渲染。<strong>缺点</strong>是：忽略视角，也即相机以原点旋转会影响雾密度，因为旋转时密度会改变。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200516235212013-881187042.png" width="250" /><font size="2.5">
            <i>红到蓝旋转，深度改变密度.</i>
        </font></center>

<p>支持depth-based深度雾 ，必须把clip-pass裁剪空间深度值传递到片元函数。定义一个关键字：FOG_DEPTH.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2)
</span>    <span class="err">#</span><span class="n">define</span> <span class="n">FOG_DEPTH</span> <span class="m">1</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>由于需要多存储一个z值，但又不能新增一个独立的变量，就把worldPos改为float4</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(FOG_DEPTH)
</span>    <span class="n">float4</span> <span class="n">worldPos</span> <span class="p">:</span> <span class="n">TEXCOORD4</span><span class="p">;</span>
<span class="cp">#else
</span>    <span class="n">float3</span> <span class="n">worldPos</span> <span class="p">:</span> <span class="n">TEXCOORD4</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>然后要替换i.worldPos的所有用法为i.worldPos.xyz。将剪贴空间深度值赋给i.worldPos.w，在fragment传递给viewDistance。它只是齐次剪贴空间位置的Z坐标，所以在它被转换为0-1范围内的值之前。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004339507-1542612657.png" width="250" /><font size="2.5">
            <i>错误.</i>
        </font></center>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004340429-1853847721.png" width="250" /><font size="2.5">
            <i>正确.</i>
        </font></center>

<p>不正确的原因：可能会有反向裁剪空间Z的情况，需要转换。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(UNITY_REVERSED_Z)
</span>    <span class="c1">//D3d with reversed Z =&gt;</span>
    <span class="c1">//z clip range is [near, 0] -&gt; remapping to [0, far]</span>
    <span class="c1">//max is required to protect ourselves from near plane not being</span>
    <span class="c1">//correct/meaningfull in case of oblique matrices.</span>
    <span class="err">#</span><span class="n">define</span> <span class="nf">UNITY_Z_0_FAR_FROM_CLIPSPACE</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="err">\\</span>
        <span class="nf">max</span><span class="p">(((</span><span class="m">1.0</span><span class="p">-(</span><span class="n">coord</span><span class="p">)/</span><span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="err">\</span><span class="p">*</span><span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">z</span><span class="p">),</span><span class="m">0</span><span class="p">)</span>
<span class="cp">#elif UNITY_UV_STARTS_AT_TOP
</span>    <span class="c1">//D3d without reversed z =&gt; z clip range is [0, far] -&gt; nothing to do</span>
    <span class="err">#</span><span class="n">define</span> <span class="nf">UNITY_Z_0_FAR_FROM_CLIPSPACE</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="p">(</span><span class="n">coord</span><span class="p">)</span>
<span class="cp">#else
</span>    <span class="c1">//Opengl =&gt; z clip range is [-near, far] -&gt; should remap in theory</span>
    <span class="c1">//but dont do it in practice to save some perf (range is close enought)</span>
    <span class="err">#</span><span class="n">define</span> <span class="nf">UNITY_Z_0_FAR_FROM_CLIPSPACE</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="p">(</span><span class="n">coord</span><span class="p">)</span>
<span class="cp">#endif
</span>
<span class="cp">#define UNITY_CALC_FOG_FACTOR(coord) \\
</span>    <span class="nf">UNITY_CALC_FOG_FACTOR_RAW</span><span class="p">(</span><span class="nf">UNITY_Z_0_FAR_FROM_CLIPSPACE</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="裁剪空间与世界空间-clip-space-depth-vs-world-space-distance">裁剪空间与世界空间-Clip-Space Depth vs World-Space Distance</h3>

<p>增加双支持！FOG_DISTANCE 和 FOG_DEPTH。用宏代替feature指令，仿照_BINORMAL_PER_FRAGMENT_定义_FOG_DISTANCE，_默认就是它。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGINCLUDE</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">BINORMAL_PER_FRAGMENT</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">FOG_DISTANCE</span>
<span class="n">ENDCG</span>
</code></pre></div></div>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//在shader中，要切换到基于距离的雾，如果FOG_DISTANCE已经被定义,我们要做的就是去掉FOG_DEPTH的定义。</span>
<span class="cp">#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2)
</span>    <span class="err">#</span><span class="k">if</span> <span class="p">!</span><span class="nf">defined</span><span class="p">(</span><span class="n">FOG_DISTANCE</span><span class="p">)</span>
        <span class="err">#</span><span class="n">define</span> <span class="n">FOG_DEPTH</span> <span class="m">1</span>
    <span class="err">#</span><span class="n">endif</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h3 id="disabling-fog">Disabling Fog</h3>

<p>增加支持禁用。只在需要时使用雾，增加FOG_ON宏</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2)
</span>    <span class="err">#</span><span class="k">if</span> <span class="p">!</span><span class="nf">defined</span><span class="p">(</span><span class="n">FOG_DISTANCE</span><span class="p">)</span>
        <span class="err">#</span><span class="n">define</span> <span class="n">FOG_DEPTH</span> <span class="m">1</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">FOG_ON</span> <span class="m">1</span>
<span class="cp">#endif
</span>
<span class="n">float4</span> <span class="nf">ApplyFog</span> <span class="p">(</span><span class="n">float4</span> <span class="n">color</span><span class="p">,</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">FOG_ON</span>
        <span class="kt">float</span> <span class="n">viewDistance</span> <span class="p">=</span> <span class="nf">length</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="p">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="err">#</span><span class="k">if</span> <span class="n">FOG_DEPTH</span>
            <span class="n">viewDistance</span> <span class="p">=</span> <span class="nf">UNITY_Z_0_FAR_FROM_CLIPSPACE</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
        <span class="err">#</span><span class="n">endif</span>
        <span class="nf">UNITY_CALC_FOG_FACTOR_RAW</span><span class="p">(</span><span class="n">viewDistance</span><span class="p">);</span>
        <span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">unity_FogColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="nf">saturate</span><span class="p">(</span><span class="n">unityFogFactor</span><span class="p">));</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="多光源-multiple-lights">多光源-Multiple Lights</h3>

<p>增加支持多光源。但是变得更亮了，这是因为每个光的颜色都叠加到了雾色之上，所以黑色雾是没问题。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004341631-1514085003.png" width="250" /><font size="2.5">
            <i>太亮.</i>
        </font></center>

<p>解决办法就是：对additive pass使用黑色雾，这样就会淡化一部分颜色。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float3</span> <span class="n">fogColor</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="cp">#if defined(FORWARD_BASE_PASS)
</span>    <span class="n">fogColor</span> <span class="p">=</span> <span class="n">unity_FogColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">fogColor</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="nf">saturate</span><span class="p">(</span><span class="n">unityFogFactor</span><span class="p">));</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004342819-161700675.png" width="250" /><font size="2.5">
            <i>太亮.</i>
        </font></center>

<h2 id="延迟雾渲染-deferred-fog">延迟雾渲染-Deferred Fog</h2>

<p>deferred路径没有雾，这是因为所有的光照计算完成后，才会计算雾。为了能够在deferred渲染雾，见2.1</p>

<h3 id="后处理效果-image-effects">后处理效果-Image Effects</h3>

<p>要增加雾渲染，需要等所有光照计算直到它们完成后，在其他pass再次渲染雾。该pass不在shader内部，属于屏幕ImageEffects(后处理)阶段。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ExecuteInEditMode</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">DeferredFogRender</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这是增加了一个全屏后处理pass。如果有多个这样实现了OnRenderImage脚本，将会按顺序依次执行。</p>

<p><em>OnRenderImage(RenderTexture source, RenderTexture destination)</em> 两个参数：<br />
source        是已计算好最终颜色<br />
destination   输出雾。若为空直接进入帧缓冲区</p>

<p>方法内部必须调用Graphics.Blit函数，它会画一个全屏面片输出到Destination</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnRenderImage</span> <span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004343465-563203657.png" width="250" /><font size="2.5">
            <i>后处理pass.</i>
        </font></center>

<h3 id="fog-shader">Fog Shader</h3>

<p>2.1只是做了简单的拷贝，没什么用。必须要新建一个处理sourceTexture的shader来渲染雾。基本框架：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Custom/MyDeferredFog"</span>
<span class="p">{</span>
    <span class="n">Properties</span>
    <span class="p">{</span>
        <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="c1">// No culling or depth</span>
        <span class="n">Cull</span> <span class="n">Off</span>
        <span class="n">ZWrite</span> <span class="n">Off</span>
        <span class="n">ZTest</span> <span class="n">Always</span>
        <span class="n">Pass</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后用后处理脚本需要引用该Shader</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">CGPROGRAM</span>
    <span class="err">#</span><span class="n">pragma</span> <span class="n">vertex</span>   <span class="n">VertexProgram</span>
    <span class="err">#</span><span class="n">pragma</span> <span class="n">fragment</span> <span class="n">FragmentProgram</span>
    <span class="err">#</span><span class="n">pragma</span> <span class="n">multi_compile_fog</span>
    <span class="err">#</span><span class="n">include</span> <span class="s">"UnityCG.cginc"</span>
    <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">modelData</span>
    <span class="p">{</span>
        <span class="n">float4</span> <span class="n">vertex</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span>
        <span class="n">float2</span> <span class="n">uv</span>      <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="nc">Interpolarters</span>
    <span class="p">{</span>
        <span class="n">float4</span> <span class="n">position</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
        <span class="n">float2</span> <span class="n">uv</span>        <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">Interpolarters</span> <span class="nf">VertexProgram</span><span class="p">(</span><span class="n">modelData</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Interpolarters</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="nf">UnityObjectToClipPos</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="p">=</span> <span class="n">m</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">float4</span> <span class="nf">FragmentProgram</span><span class="p">(</span><span class="n">Interpolarters</span> <span class="n">i</span><span class="p">)</span> <span class="p">:</span><span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="n">float3</span> <span class="n">sourceColor</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">sourceColor</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="深度雾采样-depth-based-fog">深度雾采样-Depth-Based Fog</h3>

<p>增加深度雾。Unity自带深度buffer变量__CameraDepthTexture_, 然后使用指令_SAMPLE_DEPTH_TEXTURE_采样深度：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">UNITY_DECLARE_DEPTH_TEXTURE</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">);</span>

<span class="n">float4</span> <span class="nf">FragmentProgram</span><span class="p">(</span><span class="n">Interpolarters</span> <span class="n">i</span><span class="p">)</span> <span class="p">:</span><span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">depth</span> <span class="p">=</span> <span class="nf">SAMPLE_DEPTHE_TEXTURE</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">sourceColor</span>  <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">sourceColor</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>！首先。可以使用在UnityCG中定义的Linear01Depth函数将其转换为一个线性范围。这是因为从深度缓冲区得到原始数据后，需要从齐次坐标转换为[0,1]范围的clip-space坐标。我们必须转换这个值，使它成为世界空间中的一个线性深度值。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">depth</span> <span class="p">=</span> <span class="nf">SAMPLE_DEPTH_TEXTURE</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
<span class="n">depth</span> <span class="p">=</span> <span class="nf">Linear01Depth</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
</code></pre></div></div>

<p>Linear01Depth内部实现：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Z buffer to linear 0..1 depth</span>
<span class="n">inline</span> <span class="kt">float</span> <span class="nf">Linear01Depth</span><span class="p">(</span> <span class="kt">float</span> <span class="n">z</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="m">1.0</span> <span class="p">/</span> <span class="p">(</span><span class="n">_ZBufferParams</span><span class="p">.</span><span class="n">x</span> <span class="err">\</span><span class="p">*</span> <span class="n">z</span> <span class="p">+</span> <span class="n">_ZBufferParams</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Values used to linearize the Z buffer</span>
<span class="c1">// (http://www.humus.name/temp/Linearize%20depth.txt)</span>
<span class="c1">// x = 1-far/near</span>
<span class="c1">// y = far/near</span>
<span class="c1">// z = x/far</span>
<span class="c1">// w = y/far</span>
<span class="n">float4</span> <span class="n">_ZBufferParams</span><span class="p">;</span>
</code></pre></div></div>

<p>！然后。需要使用far_clip平面距离缩放该depth值，得到真实的深度视距。clip_space裁剪空间可通过float4 <em>ProjectionParams变量获得, 定义在_UnityShaderVariables.cginc中</em>。其中Z分量就是远平面far_clip距离。。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">depth</span> <span class="p">=</span> <span class="nf">Linear01Depth</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">distance</span> <span class="p">=</span> <span class="n">depth</span> <span class="err">\</span><span class="p">*</span> <span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</code></pre></div></div>

<p>！最后，计算实际的fog。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">viewDistance</span> <span class="p">=</span> <span class="n">depth</span> <span class="err">\</span><span class="p">*</span> <span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="nf">UNITY_CALC_FOG_FACTOR_RAW</span><span class="p">(</span><span class="n">viewDistance</span><span class="p">);</span>
<span class="n">unityFogFactor</span> <span class="p">=</span> <span class="nf">saturate</span><span class="p">(</span><span class="n">unityFogFactor</span><span class="p">);</span>
<span class="n">float3</span> <span class="n">sourceColor</span>  <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="n">float3</span> <span class="n">color</span> <span class="p">=</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">unity_FogColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">sourceColor</span><span class="p">,</span> <span class="n">unityFogFactor</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004344659-491057751.png" width="250" /><font size="2.5">
            <i>不太明显的雾.</i>
        </font></center>

<h3 id="雾混合-fixing-the-fog">雾混合-Fixing the Fog</h3>

<p>对比图15，就像把雾蒙在了物体上方。解决办法就是在绘制物体之前，绘制雾。使用<code class="language-plaintext highlighter-rouge">_ImageEffectOpaque_属性绘制</code></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">ImageEffectOpaque</span><span class="p">]</span>
<span class="k">void</span> <span class="nf">OnRenderImage</span> <span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">fogMate</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004345386-585512243.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004346464-2132954797.png" width="250" /><font size="2.5">
            <i>不太明显的雾.</i>
        </font></center>

<p>处理近平面（非精确处理），near plane存储在Y值中</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">viewDistance</span> <span class="p">=</span> <span class="n">depth</span> <span class="err">\</span><span class="p">*</span> <span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">z</span> <span class="p">-</span><span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="距离场雾-distance-based-fog">距离场雾-Distance-Based Fog</h3>

<p>deferred灯光的着色，从depth-buffer中重建世界空间位置，以便计算灯光。我们也可以这样仿照这样计算雾。</p>

<p>透视相机的clip-space空间定义了一个梯形区域，如果忽略near-plane就得到的是一个以相机world-pos为顶点的三角形区域。它的高是far-plaen距离，那么线性化后的depth范围：顶点为0，底边为1。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004347033-483399479.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004347679-1381640131.png" width="250" /><font size="2.5">
            <i>金字塔区域.</i>
        </font></center>

<p>对于渲染的后处理图形Image的每个像素，都能通过从顶点到底边发射一条射线(从屏幕射向3D空间)，检测是否击中任何物体，击中渲染，未击中不渲染。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004348280-181627301.png" width="250" /><font size="2.5">
            <i>Image每个像素发射一条射线.</i>
        </font></center>

<p>若击中某个物体，那么对应像素的深度就要小于1. 如果，该射线在半道击中了物体，射线对应的像素深度值就是1/2.这就意味着 $射线对应的Z值 ={射线击中物体时的长度\over射线总长度}$。范围[0, 1]。又由于射线的方向都是一致的，X和Y坐标也应该减半。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004348844-1867477460.png" width="250" /><font size="2.5">
            <i>射线的缩放.</i>
        </font></center>

<p>一旦得到该射线，就能从相机的位置出发，寻找可能会被渲染的物体表面的世界坐标(若击中)。同时，也要得到该射线的长度。</p>

<p>要使用上述方法，必须知道从相机到平面的每一个像素的射线。但实际上，只需要4条射线，金字塔的每个角都需要一条射线。用插值可给出中间所有像素的光线。</p>

<h3 id="距离检测-calculating-rays">距离检测-Calculating Rays</h3>

<p>基于相机远平面和视角计算光线，同时相机的方向和位置与距离无关，所以可以忽略变换。Camera提供了一个函数：<code class="language-plaintext highlighter-rouge">CalculateFrustumCorners</code>，四个参数<br />
    矩形面积(image rect)<br />
    光线投射距离(相机far-plane)<br />
    立体渲染(相机自带)<br />
    4个元素的3D向量组</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">deferredCamera</span><span class="p">.</span><span class="nf">CalculateFrustumCorners</span>
<span class="p">(</span>
    <span class="n">rectArea</span><span class="p">,</span>
    <span class="n">deferredCamera</span><span class="p">.</span><span class="n">farClipPlane</span><span class="p">,</span>
    <span class="n">deferredCamera</span><span class="p">.</span><span class="n">stereoActiveEye</span><span class="p">,</span>
    <span class="n">corners</span>
<span class="p">);</span>
</code></pre></div></div>

<p>下一步传递该数据至Shader，同时也得改变索引顺序。相机提供的是：左下、左上、右上、右下。shader需要：左下、右下、左上、右上</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//corners vectex index: b-l, u-l, u-r, b-r</span>
<span class="c1">//shader vectex index : b-l, b-r, u-l, u-r</span>
<span class="n">frustumCorners</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">corners</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
<span class="n">frustumCorners</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">corners</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
<span class="n">frustumCorners</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">corners</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
<span class="n">frustumCorners</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">=</span> <span class="n">corners</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>

<span class="n">fogMate</span><span class="p">.</span><span class="nf">SetVectorArray</span><span class="p">(</span><span class="s">"__FustumCorners"</span><span class="p">,</span> <span class="n">frustumCorners</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="计算距离-deriving-distances">计算距离-Deriving Distances</h3>

<p>Shader需要一个接收变量，同时定义一个FOG_DISTANCE宏，当需要使用距离时再计算光线。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define FOG_DISTANCE
</span>
<span class="k">struct</span> <span class="nc">Interpolators</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">uv</span>       <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
<span class="cp">#if FOG_DISTANCE
</span>    <span class="n">float3</span> <span class="n">ray</span> <span class="p">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>根据UV坐标计算获取数组中对应的光线，传进shader的数组排列：(0,0) (1,0) (0,1) (1,1)，使用U+2V可得</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if FOG_DISTANCE
</span>    <span class="n">i</span><span class="p">.</span><span class="n">ray</span> <span class="p">=</span> <span class="n">_FustumCorners</span><span class="p">[</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="m">2</span> <span class="err">\</span><span class="p">*</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">y</span><span class="p">];</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>最后在Fragment函数替换基于深度计算的雾，使用基于距离计算</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">viewDistance</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="cp">#if defined(FOG_DISTANCE)
</span>    <span class="n">viewDistance</span> <span class="p">=</span> <span class="nf">length</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">ray</span> <span class="err">\</span><span class="p">*</span> <span class="n">depth</span><span class="p">);</span>
<span class="cp">#else
</span>    <span class="n">viewDistance</span> <span class="p">=</span> <span class="n">depth</span> <span class="err">\</span><span class="p">*</span> <span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">z</span> <span class="p">-</span> <span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004349963-1740626309.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004351071-1952278624.png" width="250" /><font size="2.5">
            <i>基于距离的雾 standard vs deferrd.</i>
        </font></center>

<h3 id="天空盒-fogged-skybox">天空盒-Fogged Skybox</h3>

<p>解放天空盒。两个不同渲染路径渲染的雾会有显著差异。延迟雾也会影响天空盒。它的作用就像far-plane是一个固体屏障，受到雾的影响。当深度值接近1时，表明已经到达了远平面。如果不想给天空盒蒙上雾，可以通过将雾因子设置为1来防止。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="p">&gt;</span> <span class="m">0.999</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">unityFogFactor</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender14/1692664-20200518004352199-224022866.png" width="250" /><font size="2.5">
            <i>基于距离的雾 standard vs deferrd.</i>
        </font></center>

<h3 id="no-fog">No Fog</h3>

<p>最后考虑如何停止渲染雾。解决方案是当没有设置任何雾关键字，通过设置雾因子为1即可。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(FOG_LINEAR) || !defined(FOG_EXP) || !defined(FOG_EXP2)
</span>    <span class="n">unityFogFactor</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[一个精确的大气干扰光线渲染将需要及其昂贵的体积测量方法，那是大多数现代GPU负担不起的。相反，勉强采用一些常量雾参数近似模拟。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender14/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender14/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>