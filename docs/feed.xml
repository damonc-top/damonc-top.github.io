<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://www.damonc.top/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.damonc.top/" rel="alternate" type="text/html" /><updated>2025-08-28T19:40:54+08:00</updated><id>https://www.damonc.top/feed.xml</id><title type="html">编程散记</title><subtitle>个人的一个技术博客站点，记录生活、工作、学习中的一些小事，以及一些比较有趣的事情，留点什么东西也挺不错的，偶尔会在这里停留。</subtitle><author><name>编程散记</name></author><entry><title type="html">多线程编程模型篇(二)</title><link href="https://www.damonc.top/csharp/CSharp_Thread_Pattern.html" rel="alternate" type="text/html" title="多线程编程模型篇(二)" /><published>2025-06-06T10:00:00+08:00</published><updated>2025-06-06T10:00:00+08:00</updated><id>https://www.damonc.top/csharp/CSharp_Thread_Pattern</id><content type="html" xml:base="https://www.damonc.top/csharp/CSharp_Thread_Pattern.html"><![CDATA[<h2 id="多线程的演进">多线程的演进</h2>

<h2 id="apm模式">APM模式</h2>

<h2 id="eap模式">EAP模式</h2>

<h2 id="tap模式">TAP模式</h2>

<h2 id="asyncawait异步模式">async/await异步模式</h2>

<h2 id="tpl并行库">TPL并行库</h2>]]></content><author><name>编程散记</name></author><category term="CSharp" /><category term="Thread" /><summary type="html"><![CDATA[多线程的演进]]></summary></entry><entry><title type="html">多线程编程基础篇(一)</title><link href="https://www.damonc.top/csharp/CSharp_Thread_Base.html" rel="alternate" type="text/html" title="多线程编程基础篇(一)" /><published>2025-06-03T20:00:00+08:00</published><updated>2025-06-03T20:00:00+08:00</updated><id>https://www.damonc.top/csharp/CSharp_Thread_Base</id><content type="html" xml:base="https://www.damonc.top/csharp/CSharp_Thread_Base.html"><![CDATA[<h2 id="多线程概念">多线程概念</h2>

<p>  现代应用程序可能要同时处理数据计算、画面渲染、文件读写等操作，同时要求操作系统要满足运行多个应用程序，后来随着现代CPU的从单核进化到多核，从物理核心进化到逻辑核心。就逐渐有了多任务执行概念。</p>

<h3 id="什么是多线程">什么是多线程？</h3>

<p>  Intel提出了<a href="https://www.intel.cn/content/www/cn/zh/gaming/resources/hyper-threading.html">超线程技术（Hyper-Threading）</a>，将单个物理核心虚拟为多个逻辑核心。逻辑核心共享同一物理核心的硬件资源（如ALU、缓存），但拥有独立的寄存器组和线程状态‌，当某个线程因等待数据（如内存访问）暂停时，物理核心立即切换至另一线程执行，复用闲置资源以提升利用率‌。<strong>线程是操作系统调度的最小执行单元，是进程中的一条执行路径，每个线程有自己的代码执行路径和独立的堆栈空间，线程之间可以共享程序的数据段和代码段</strong>。一个进程中可以启动多个线程，实现‌并发‌（Concurrency）或‌并行‌（Parallelism）。</p>

<h3 id="线程的目标是什么">线程的目标是什么？</h3>

<p>  为了防止一个应用程序控制CPU而导致其他应用程序和操作系统本身永远被挂起这一可能情况，操作系统不得不使用某种方式将物理计算单元分割为一些虚拟的进程，并给予每个执行程序一定量的计算能力。此外，操作系统必须始终能够优先访问CPU，并能调整不同程序访问CPU的优先级。线程正是这一概念的实现。可以认为线程是一个虚拟进程，用于独立运行一个特定的程序。<strong>提高程序的响应速度，实现并行计算，以及提高CPU利用率。它可以让一个程序同时执行多个任务，从而更有效地利用系统资源，加快程序运行速度，并提升用户体验。</strong></p>

<h3 id="程序进程线程协程">程序、进程、线程、协程</h3>

<p>进程和线程是操作系统领域的两个重要概念，两者既有区别又有联系。</p>

<h4 id="可执行程序">可执行程序</h4>

<p>  C/C++源文件经过编译器（编译+链接）处理后，会产生可执行程序文件，不同系统有不同格式，比如Linux系统的ELF格式、Windows系统的EXE格式，可执行程序文件是一个静态的概念。</p>

<h4 id="进程是什么">进程是什么</h4>

<p>  可执行程序在操作系统上的一次执行对应一个进程，进程是一个动态的概念：<strong>进程是执行中的程序</strong>。同一份可执行文件执行多次，会产生多个进程，这跟一个类可以创建多个实例一样。进程是资源分配的基本单位。</p>

<h4 id="线程是什么">线程是什么</h4>

<p>  一个进程内的多个线程代表着多个执行流，这些线程以并发模式独立执行。操作系统中，被调度执行的最小单位是线程而非进程。进程是通过共享存储空间对用户呈现的逻辑概念，同一进程内的多个线程共享地址空间和文件描述符，共享地址空间意味着进程的代码（函数）区域、全局变量、堆、栈都被进程内的多个线程共享。</p>

<h4 id="进程和线程的关系">进程和线程的关系</h4>

<p>  启动一个程序，系统会在内存自动创建一个新的进程，进程是构成程序运行的资源集合，包括虚拟地址空间、文件句柄等。在进程内部系统会创建一个线程对象开始执行Main方法，该线程也被称为主线程。因此进程也是线程的一个集合。</p>

<ol>
  <li>默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束。</li>
  <li>主线程也可以继续派生线程，进程内可能含有不同状态的线程</li>
  <li>如果一个进程拥有多个线程，它们将共享进程资源</li>
  <li><strong>线程是操作系统调度的最小执行单元，是进程中的一条执行路径</strong></li>
</ol>

<h4 id="协程">协程</h4>

<p>  用户态的多执行流，上下文切换成本比线程更低，微信用协程改造后台系统后，获得了更大吞吐能力和更高稳定性。如今，协程库也进了C++20新标准。Unity的协程并非多线程，而是完全运行在Unity主线程上，通过迭代器（IEnumerator）和yield指令实现逻辑分帧执行，避免阻塞主线程的UI响应‌。</p>

<h2 id="线程简介">线程简介</h2>

<p>  现在的C#代码直接使用New Thread()创建线程，这是比较老旧的用法，C#更推荐使用Task、async/awit方式。但是要了解线程知识就要从c#的Thread线程说起。</p>

<h3 id="创建线程">创建线程</h3>

<p>  要创建并启动 一个线程，需要首先实例化Thread对象并调用Start方法。Thread的最简单的构造器接收一个ThreadStart无参委托或ParameterizedThreadStart有参委托。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">ThreadStart</span> <span class="n">start</span><span class="p">);</span>
<span class="k">public</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">ParameterizedThreadStart</span> <span class="n">start</span><span class="p">);</span>
<span class="k">public</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">ThreadStart</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxStackSize</span><span class="p">);</span>
<span class="k">public</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">ParameterizedThreadStart</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxStackSize</span><span class="p">);</span>

<span class="c1">//c#1.0</span>
<span class="k">public</span> <span class="k">delegate</span> <span class="k">void</span> <span class="nf">ThreadStart</span><span class="p">();</span>
<span class="c1">//c#2.0</span>
<span class="k">public</span> <span class="k">delegate</span> <span class="k">void</span> <span class="nf">ParameterizedThreadStart</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">);</span>
</code></pre></div></div>

<p>:一个无参数的方法，表示执行的起始位置，例如</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Test2</span><span class="p">(){</span>
    <span class="c1">//主线程打印x</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"x"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//子线程打印y</span>
    <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()=&gt;</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"y"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="nf">Start</span><span class="p">();</span>

    <span class="k">new</span> <span class="nf">Thread</span><span class="p">((</span><span class="n">y</span><span class="p">)=&gt;{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="nf">Start</span><span class="p">(</span><span class="s">"y"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 线程的参数传递 </div> </div> <div class="content"> <p>线程的参数传递需要使用ParameterizedThreadStart委托，并且需要将参数传递给Start方法。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 如果使用这种方式会异常</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="p">(()=&gt;{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}).</span><span class="nf">Start</span><span class="p">(</span><span class="s">"y"</span><span class="p">);</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">(</span><span class="kt">object</span> <span class="n">parameter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果m_Delegate是ThreadStart委托，则抛出异常</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_Delegate</span> <span class="k">is</span> <span class="n">ThreadStart</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="nf">GetResourceString</span><span class="p">(</span><span class="s">""</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>



 </div> </div>
<h3 id="线程的生命周期">线程的生命周期</h3>

<p>  线程有多个状态表示使用ThreadState表示，其中最重要的几个状态就是暂停等待(休眠)、终止<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Thread</span> <span class="n">thread</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;{});</span>
    <span class="n">thread</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">thread</span><span class="p">.</span><span class="n">Priority</span> <span class="p">=</span> <span class="n">ThreadPriority</span><span class="p">.</span><span class="n">Highest</span><span class="p">;</span>
    <span class="n">thread</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="n">thread</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="n">thread</span><span class="p">.</span><span class="nf">Interrupt</span><span class="p">();</span>
    <span class="n">thread</span><span class="p">.</span><span class="nf">Abort</span><span class="p">();</span>
</code></pre></div></div>

<ol>
  <li><strong>新建状态(New)</strong>‌ new Thread()创建线程对象时，线程处于新建状态，此时尚未分配系统资源‌。</li>
  <li><strong>前台/后台线程</strong> 显式创建的线程是前台线程，通过线程对象的IsBackground属性可以控制。<strong>进程会等待所有的前台线程完成后再结束工作，但是如果只剩下后台线程，则会直接结東工作。</strong></li>
  <li><strong>线程的优先级</strong> 前台线程的优先级大于后台线程，如果线程优先级设置过大，则可能会干涉到系统运行，如磁盘写入、鼠标点击等都是高速运转的，如果程序中有太多高优先级的线程，那么系统需要分配大量CPU时间运行这些线程的代码，可能会导致系统无响应或响应缓慢。</li>
  <li><strong>‌就绪状态(Runnable)</strong>‌ Start()方法调用后线程进入就绪队列，等待CPU调度执行‌。</li>
  <li><strong>‌运行状态(Running)‌</strong> 当线程获得CPU时间片时开始执行，示例中由于Lambda表达式为空，实际不执行操作‌。‌</li>
  <li><strong>阻塞状态(Blocked)‌</strong> Thread.Sleep(1000)使主线程休眠1秒，此时主线程处于定时等待状态‌。</li>
  <li><strong>阻塞状态(Blocked)‌</strong> Join(1000)使主线程等待目标线程完成，最多阻塞1秒‌。</li>
  <li>‌<strong>中断状态(Interrupted)‌</strong> Interrupt()向线程发送中断信号，若线程处于阻塞状态会抛出InterruptedException‌。</li>
  <li>‌<strong>终止状态(Aborted/Terminated)‌</strong> Abort()强制终止线程，会抛出ThreadAbortException异常‌。注意该方法在.NET中已过时，推荐使用协作式取消模式‌。</li>
</ol>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts\2025\month6\thread_state.png" width="250" /><font size="2.5">
            <i>线程生命周期图示.</i>
        </font></center>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 线程终止警告 </div> </div> <div class="content"> <p>Interrupt()和Abort()的调用时机会影响线程状态转换结果，若线程已终止则这些操作无效‌。在多线程编程中应谨慎使用强制终止方法，可能引发资源未释放等问题‌。</p>



 </div> </div>
<h3 id="线程的同步和互斥">线程的同步和互斥</h3>

<p>  CLR为每一个线程分配了独立的内存栈，从而保证了局部变量的隔离。如果不同的线程拥有同一个对象的引用，则这些线程之间就共享了数据，编译器也会将Lambda表达式捕获的局部变量或匿名委托转换为字段，因此它们也可以被共享。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="n">ThreadTest</span><span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(){</span>
        <span class="kt">bool</span> <span class="n">done</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">ThreadStart</span> <span class="n">aciont</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span> <span class="nf">WriteLine</span> <span class="p">(</span><span class="s">"Done"</span><span class="p">);</span> <span class="n">done</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">new</span> <span class="nf">Thread</span> <span class="p">(</span><span class="n">action</span><span class="p">).</span><span class="nf">Start</span><span class="p">();</span>
        <span class="nf">action</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  上述代码，主线程调用了action，同时new了一个子线程绑定了匿名函数捕获了外部变量done，这个“Done”是有可能输出两次的。主线程正在打印“Done”时，子线程可能已经进入到匿名函数正在判定。</p>

<h4 id="lock线程锁">lock线程锁</h4>

<p>  锁有三种结构：Lock、Mutex和SpinLock，其中Lock是最常用最方便的锁结构。锁允许多个线程在同一时间内只有一个能够访问被锁定的资源，从而避免竞态条件和数据不一致的问题。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">object</span> <span class="n">lockObject</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span> <span class="c1">// 锁对象</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">sharedValue</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Thread</span> <span class="n">thread1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">IncrementSharedValue</span><span class="p">);</span>
        <span class="n">Thread</span> <span class="n">thread2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">IncrementSharedValue</span><span class="p">);</span>

        <span class="n">thread1</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
        <span class="n">thread2</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>

        <span class="n">thread1</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
        <span class="n">thread2</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Final shared value: "</span> <span class="p">+</span> <span class="n">sharedValue</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">IncrementSharedValue</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="k">lock</span> <span class="p">(</span><span class="n">lockObject</span><span class="p">)</span> <span class="c1">// 使用锁</span>
            <span class="p">{</span>
                <span class="n">sharedValue</span><span class="p">++;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  两个线程分别对sharedValue进行了100000次的增加操作，但由于使用了锁机制，它们不会交叉并发地修改sharedValue，从而确保了数据一致性。thread1.Join()与thread2.Join()简单理解就是把thread1/2合并到主线程，主线程默认是前台线程需要等待thread1/2执行完成后才能继续执行。如果不调用Join那么直接打印了Final shared value结果会不准确。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 锁的开销提示 </div> </div> <div class="content"> <p>使用锁机制可能会引入性能开销，因为在一个线程访问锁定代码块时，其他线程会被阻塞。因此，在设计多线程应用时，应根据实际需求和性能要求合理地使用锁机制，避免锁的过度使用导致性能问题。</p>



 </div> </div>
<h4 id="死锁">死锁</h4>

<p>  死锁将导致程序停止工作是最常见的多线程错误，下面是一个死锁示例：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">object</span> <span class="n">locker1</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>
<span class="kt">object</span> <span class="n">locker2</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span> 
<span class="n">Thread</span> <span class="n">threadA</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span> <span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">lock</span> <span class="p">(</span><span class="n">locker1</span><span class="p">){</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">locker2</span><span class="p">);</span> <span class="c1">//Deadlock</span>
    <span class="p">}</span>
    
<span class="p">});</span>
<span class="n">threadA</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>

<span class="k">lock</span> <span class="p">(</span><span class="n">locker2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span> <span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="k">lock</span> <span class="p">(</span><span class="n">locker1</span><span class="p">);</span> <span class="c1">//Deadlock</span>
<span class="p">}</span>

<span class="c1">//使用三个或者更多的线程则可能形成更加复杂的死锁链。</span>
</code></pre></div></div>

<p>  死锁的形成过程如下：</p>

<p><strong>初始状态</strong>：</p>
<ol>
  <li>创建了两个锁对象：locker1和locker2</li>
  <li>有两个线程：线程A（新创建的线程）和主线程</li>
</ol>

<p><strong>步骤1</strong>：线程启动（t=0ms）</p>
<ol>
  <li>线程A 开始执行，进入第一个lock(locker1)</li>
  <li>线程A 成功获取lock(locker1)的锁</li>
  <li>同时，主线程 执行到lock(locker2)</li>
  <li>主线程 成功获取lock(locker2)的锁</li>
</ol>

<p><strong>步骤2</strong>：延时阶段（t=0-1000ms）</p>
<ol>
  <li>线程A 持有lock(locker1)，执行Thread.Sleep(1000)</li>
  <li>主线程 持有lock(locker2)，执行Thread.Sleep(1000)</li>
  <li>此时两个线程都在睡眠，各自持有一个锁</li>
</ol>

<p><strong>步骤3</strong>：死锁形成（t=1000ms后）</p>
<ol>
  <li>线程A 从睡眠中醒来，尝试获取lock(locker2)，但是locker2已经被主线程持有，线程A被阻塞，等待lock(locker2)释放</li>
  <li>主线程 从睡眠中醒来，尝试获取lock(locker1)，但是locker1 已经被线程A持有，主线程被阻塞，等待lock(locker1)释放</li>
</ol>

<pre><code class="language-mermaid2">graph LR
    A[线程A] --&gt; |持有| L1[locker1]
    A --&gt; |等待| L2[locker2]
    B[主线程] --&gt; |持有| L2
    B --&gt; |等待| L1
    
    L1 -.-&gt; |阻塞| B
    L2 -.-&gt; |阻塞| A
    
    style A fill:#ff9999
    style B fill:#99ccff
    style L1 fill:#ffcc99
    style L2 fill:#ffcc99
</code></pre>

<h4 id="monitor锁定资源">Monitor锁定资源</h4>

<p>  Monitor是C#中用于实现线程同步和互斥的另一种机制，同时lock关键字是Monitor类的一种语法糖。它提供了更高级的方法TryEenter()。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">acquiredLock</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> 
<span class="k">try</span><span class="p">{</span>
    <span class="n">Monitor</span><span class="p">.</span><span class="nf">Enter</span><span class="p">(</span><span class="n">lockObject</span><span class="p">,</span> <span class="k">ref</span> <span class="n">acquiredLock</span><span class="p">);</span>
    <span class="c1">// Code that accesses resources that are protected by the lock.</span>
<span class="p">}</span>
<span class="k">finally</span><span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">acquiredLock</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Monitor</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="n">lockObject</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  Monitor类的使用方式相对于lock锁机制更灵活。以下是使用Monitor类的一个示例，展示如何在多个线程之间控制访问顺序：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="kt">object</span> <span class="n">syncLock</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">currentThread</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="c1">// 1表示线程1，2表示线程2</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">thread1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">Worker</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">thread2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">Worker</span><span class="p">);</span>

        <span class="n">thread1</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
        <span class="n">thread2</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>

        <span class="n">thread1</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
        <span class="n">thread2</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Worker</span><span class="p">(</span><span class="kt">object</span> <span class="n">threadIdObj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">threadId</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">threadIdObj</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="k">lock</span> <span class="p">(</span><span class="n">syncLock</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">currentThread</span> <span class="p">!=</span> <span class="n">threadId</span><span class="p">)</span>
                    <span class="n">Monitor</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="n">syncLock</span><span class="p">);</span>

                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Thread </span><span class="p">{</span><span class="n">threadId</span><span class="p">}</span><span class="s">: </span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
                <span class="n">currentThread</span> <span class="p">=</span> <span class="n">threadId</span> <span class="p">==</span> <span class="m">1</span> <span class="p">?</span> <span class="m">2</span> <span class="p">:</span> <span class="m">1</span><span class="p">;</span>
                <span class="n">Monitor</span><span class="p">.</span><span class="nf">Pulse</span><span class="p">(</span><span class="n">syncLock</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  两个线程同时访问Worker时通过判定线程ID是否一致确定该线程是否继续执行，不一致就使用Monitor.Wait()方法会使当前线程等待，直到其它线程完成访问Worker通过Monitor.Pulse()方法通知其他等待的线程可以继续执行。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> Monitor也会有死锁 </div> </div> <div class="content"> <p>使用Monitor类可以在更复杂的情况下控制线程之间的访问顺序，但也需要小心避免死锁等问题。这种方法需要线程之间相互配合，以确保正确的执行顺序。</p>



 </div> </div>
<h4 id="mutex同步">Mutex同步</h4>

<p>  Mutex和lock类似，但是它可以支持多个进程。其只对一个线程授予对共享资源的独占访问。Mutex类的WaitOne方法将获得该锁，ReleaseMutex方法将释放该锁。Mutex只能在获得锁的线程释放锁。释放Mutex需要大约一微秒的时间，大概比1ock要慢20倍<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">string</span> <span class="n">MutexName</span> <span class="p">=</span> <span class="s">"CSharpThreadingCookbook"</span><span class="p">;</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">m</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Mutex</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="n">MutexName</span><span class="p">)){</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">m</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">5</span><span class="p">),</span> <span class="k">false</span><span class="p">)){</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Second instance is running!"</span><span class="p">);</span>    
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Running!"</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
        <span class="n">m</span><span class="p">.</span><span class="nf">ReleaseMutex</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="semaphore信号量">Semaphore信号量</h4>

<p>  信号量是一种计数器，用于限制同时访问某个资源的线程数量。信号量可用于限制并发性，防止太多的线程同时执行特定的代码。在C#4.0引入了轻量级Semaphoreslim信号量，Semaphore在调用WaitOne和Release方法时大概会消耗1微秒的时间，而Semaphoreslim的开销只有前者的十分之一<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">Semaphoreslim</span> <span class="n">semaphore</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Semaphoreslim</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="n">Thread</span> <span class="n">thread</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">DoWork</span><span class="p">);</span>
            <span class="n">thread</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">DoWork</span><span class="p">(</span><span class="kt">object</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">semaphore</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span> <span class="c1">// 等待获取信号量</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thread "</span> <span class="p">+</span> <span class="n">id</span> <span class="p">+</span> <span class="s">" is working..."</span><span class="p">);</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thread "</span> <span class="p">+</span> <span class="n">id</span> <span class="p">+</span> <span class="s">" finished."</span><span class="p">);</span>
        <span class="n">semaphore</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span> <span class="c1">// 释放信号量</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="线程池">线程池</h2>

<p>  每当启动一个线程时，都需要一定时间(上百毫秒)来创建新的局部变量栈。如果使用线程池预先创建可回收线程可大幅降低创建开销。但是<strong>线程池的线程都是后台线程，阻塞线程池将会影响性能</strong>。Thread.CurrentThread.IsThreadPoolThread属性可确认当前线程是否属于线程池。</p>

<h3 id="线程池简介">线程池简介</h3>

<p>  线程池线程是后台线程。 每个线程使用默认堆栈大小，以默认优先级运行，并且位于多线程单元中。 线程池中的线程完成其任务后，它将返回到等待线程的队列。 从此刻起，可以重复使用它。 这样，应用程序就可以避免为每个任务创建新线程的成本。</p>

<p>  <strong>每个进程只有一个线程池实例。</strong></p>

<h3 id="线程池的使用">线程池的使用</h3>

<p>  通过System.Threading.ThreadPool类可以获取线程池中的线程，通过QueueUserWorkItem静态方法将任务添加到线程池队列中，该方法接受一个委托表示一个自定义的异步操作。在调用QueueUserWorkItem方法时，如果线程池中没有空闲线程，则该方法会创建一个新的线程来执行委托任务。如果过快调用QueueUserWorkItem方法，则线程池会创建过多的线程，新的委托操作将在队列中等待直到线程池中线程空闲，所以过快的调用会导致性能下降。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 线程池警告 </div> </div> <div class="content"> <ol>
  <li>线程池适合短时任务，不适合长时间运行且计算密集型操作。</li>
  <li>线程是被CLR管理的作为系统级资源，如果应用大量占用线程池线程导致阻塞，会显著拖慢进程的响应速度。</li>
</ol>



 </div> </div>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">delegate</span> <span class="kt">string</span> <span class="nf">RunTestThreadPool</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">threadId</span><span class="p">);</span>

<span class="c1">//public delegate void AsyncCallback(IAsyncResult ar);</span>
<span class="c1">//只要跟AsyncCallback委托的签名一致即可</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">FinishCallback</span><span class="p">(</span><span class="n">IAsyncResult</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"callback called"</span><span class="p">);</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"线程状态=</span><span class="p">{</span><span class="n">result</span><span class="p">.</span><span class="n">AsyncState</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"线程Id</span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">Test</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">threadId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Thread starting"</span><span class="p">);</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"Thread id = </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="n">threadId</span> <span class="p">=</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="s">$"Thread id = </span><span class="p">{</span><span class="n">threadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//入口函数</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">ThreadPoolStart</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">threadId</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="c1">// 使用Thread创建线程</span>
    <span class="kt">var</span> <span class="n">thread1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">((()</span> <span class="p">=&gt;</span> <span class="nf">Test</span><span class="p">(</span><span class="k">out</span> <span class="n">threadId</span><span class="p">)));</span>
    <span class="n">thread1</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
    <span class="c1">//创建线程id确定不是来自线程池的线程id</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"new Thread id </span><span class="p">{</span><span class="n">thread1</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// 使用线程池运行委托</span>
    <span class="n">RunTestThreadPool</span> <span class="n">poolDelegate</span> <span class="p">=</span> <span class="n">Test</span><span class="p">;</span>
    <span class="c1">// 接受一个回调函数和自定义参数，并理解返回IAsyncResult对象</span>
    <span class="n">IAsyncResult</span> <span class="n">thread2</span> <span class="p">=</span> <span class="n">poolDelegate</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="k">out</span> <span class="n">threadId</span><span class="p">,</span> <span class="n">FinishCallback</span><span class="p">,</span> <span class="s">"delegate async callback"</span><span class="p">);</span>
    <span class="c1">// 等待线程池线程完成，后面的代码开始挂起，允许继续其他工作</span>
    <span class="n">thread2</span><span class="p">.</span><span class="n">AsyncWaitHandle</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
    <span class="c1">// 获取线程池线程返回值</span>
    <span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">poolDelegate</span><span class="p">.</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">thread2</span><span class="p">);</span>
    <span class="c1">// 打印线程池线程id</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"thread pool threaId </span><span class="p">{</span><span class="n">threadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// 打印线程池线程返回值</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="c1">// 等待1秒</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  BeginInvoke/EndInvoke的前x个参数与委托的签名参数是要一致的，然后后一个参数是完成回调，最后是自定义object参数是在EndInvoke的返回值。使用Begin/End方法和IAsyncResult对象可以实现异步调用被称为异步编程模型<a href="../CSharp/CSharp_Thread_Pattern.html#2">APM模型</a>。<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<div class="premonition error"> <div class="header"> <svg class="icon error" aria-hidden="true"> <use xlink:href="#icon-error"></use> </svg> <div class="title"> Thread已过时 </div> </div> <div class="content"> <p>现代C#不再推荐直接操作使用Thread、ThreadPool，C#在4.0以后推出了一套抽象程度更高的TPL的API将ThreadPool作为底层实现包装起来。</p>



 </div> </div>
<h4 id="线程池创建">线程池创建</h4>

<p>  观察创建线程需要的时间，线程池创建线程的效率比new Thread()创建线程的效率要高，因为线程池创建线程是可复用的，而new Thread()创建线程是每次都创建新的线程。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stopwatch</span> <span class="n">stopwatch</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Stopwatch</span><span class="p">();</span>
<span class="n">stopwatch</span><span class="p">.</span><span class="nf">Start</span><span class="p">();;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="c1">// new Thread(() =&gt; { }).Start();</span>
    <span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">((</span><span class="n">a</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">});</span>
<span class="p">}</span>
<span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"创建100个线程需要花费时间(毫秒)："</span> <span class="p">+</span> <span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>
</code></pre></div></div>
<p>  用我的Mac intel 6核CPU测试到直接New Thread创建消耗260ms，而线程池创建100个可复用的线程消耗只有3ms。</p>

<h4 id="线程池数量">线程池数量</h4>

<p>  线程池的线程数量是根据CPU核心数来决定的，默认情况下线程池的线程数量为CPU核心数，但是可以通过SetMinThreads()和 SetMaxThreads()设置线程池工作的最小和最大线程数。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">SetMinThreads</span> <span class="p">(</span><span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">SetMaxThreads</span> <span class="p">(</span><span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span>

<span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">GetMinThreads</span> <span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">GetMaxThreads</span> <span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span>
</code></pre></div></div>

<p>  <code class="language-plaintext highlighter-rouge">**workerThreads**</code>：工作线程数，这些线程用于处理一般的CPU密集型任务和普通的异步操作，默认值通常等于CPU核心数。</p>

<p>  <code class="language-plaintext highlighter-rouge">**completionPortThreads**</code>：I/O完成端口线程数，这些线程专门用于处理异步I/O操作的完成通知，处理文件读写、网络请求等I/O密集型操作的回调。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">workerThreads</span><span class="p">;</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">;</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">GetMaxThreads</span><span class="p">(</span><span class="k">out</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="k">out</span> <span class="n">completionPortThreads</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"线程池最大线程数=</span><span class="p">{</span><span class="n">workerThreads</span><span class="p">}</span><span class="s"> completeiong=</span><span class="p">{</span><span class="n">completionPortThreads</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">GetMinThreads</span><span class="p">(</span><span class="k">out</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="k">out</span> <span class="n">completionPortThreads</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"线程池最小线程数=</span><span class="p">{</span><span class="n">workerThreads</span><span class="p">}</span><span class="s"> completeiong=</span><span class="p">{</span><span class="n">completionPortThreads</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>
</code></pre></div></div>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>参考书籍：C#多线程编程实战。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>参考书籍：C#7.0本质论lock部分。 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>参考书籍：C#7.0本质论信号量。 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>参考<a href="https://learn.microsoft.com/zh-cn/dotnet/navigate/advanced-programming/">微软文档</a>。 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>编程散记</name></author><category term="CSharp" /><category term="多线程" /><summary type="html"><![CDATA[现代应用程序可能要同时处理数据计算、画面渲染、文件读写等操作，同时要求操作系统要满足运行多个应用程序，后来随着现代CPU的从单核进化到多核，从物理核心进化到逻辑核心。就逐渐有了多任务执行概念。]]></summary></entry><entry><title type="html">Unity Addressable System使用分析(三)</title><link href="https://www.damonc.top/unity3d/Unity_Addressable_Build.html" rel="alternate" type="text/html" title="Unity Addressable System使用分析(三)" /><published>2024-07-15T20:00:00+08:00</published><updated>2024-07-15T20:00:00+08:00</updated><id>https://www.damonc.top/unity3d/Unity_Addressable_Build</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Addressable_Build.html"><![CDATA[<h2 id="addressable初始化">Addressable初始化</h2>

<p>  AA初始化调用函数<code class="language-plaintext highlighter-rouge">Addressables.InitializeAsync(autoReleaseHandle)</code>，返回AsyncOperationHandle。参数autoReleaseHandle是控制Handle是否自动释放，默认是true会自动释放。虽然成功执行了初始化，但是想要拿到AsyncOperationHandle的结果就不能让它自动释放，如果访问会提示handle无效。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AsyncOperationHandle</span><span class="p">&lt;</span><span class="n">IResourceLocator</span><span class="p">&gt;</span> <span class="n">handle</span> <span class="p">=</span> <span class="n">Addressables</span><span class="p">.</span><span class="nf">InitializeAsync</span><span class="p">();</span>
<span class="k">yield</span> <span class="k">return</span> <span class="n">handle</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="p">.</span><span class="n">Status</span> <span class="p">!=</span> <span class="n">AsyncOperationStatus</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Initialization Error"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  AA初始化返回结果就是本地的Catalog.bundle对象，使用DefaultBuildScript打AssetBundle结果会保存在<code class="language-plaintext highlighter-rouge">Library/com.unity.addressables/aa/平台/</code>。Initial加载的就是本地最新的Catalog对象，如果是真机就会加载打包APK时最初打进包的Catalog对象。</p>

<h3 id="catalog结构">Catalog结构</h3>

<p>  Catalog加载后会构建成<code class="language-plaintext highlighter-rouge">ResourceLocationMap</code>对象，该数据对象就是记录了一个Bundle的所保存的地址信息(本地还是远程)。加载Catalog流程：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用户代码中调用</span>
<span class="n">Addressables</span><span class="p">.</span><span class="nf">InitializeAsync</span><span class="p">();</span>

<span class="c1">// 内部实际调用</span>
<span class="n">AddressablesImpl</span><span class="p">.</span><span class="nf">InitializeAsync</span><span class="p">()</span> <span class="err">→</span> <span class="n">ResourceManager</span><span class="p">.</span><span class="nf">StartOperation</span><span class="p">()</span>

<span class="c1">// 在 InitializeAsync 内部</span>
<span class="n">InitializationOperation</span> <span class="n">operation</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">InitializationOperation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="k">return</span> <span class="n">ResourceManager</span><span class="p">.</span><span class="nf">StartOperation</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="k">default</span><span class="p">);</span>

<span class="c1">// InitializationOperation 中</span>
<span class="c1">// 1. 首先加载主 Catalog 文件</span>
<span class="nf">LoadContentCatalogInternal</span><span class="p">(</span><span class="n">m_ResourceLocators</span><span class="p">,</span> <span class="n">s_Settings</span><span class="p">.</span><span class="n">catalogLocation</span><span class="p">,</span> <span class="p">...);</span>

<span class="c1">// 2. 然后加载额外的 Catalog 文件，包括远程的catalog(如果有配置)</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">catalogLocation</span> <span class="k">in</span> <span class="n">s_Settings</span><span class="p">.</span><span class="n">catalogLocations</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">LoadContentCatalogInternal</span><span class="p">(</span><span class="n">m_ResourceLocators</span><span class="p">,</span> <span class="n">catalogLocation</span><span class="p">,</span> <span class="p">...);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  当 Catalog 加载完成后，系统会解析其中的内容并构建 ResourceLocationMap：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在ContentCatalogProvider.cs 中</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ContentCatalogProvider</span> <span class="p">:</span> <span class="n">IResourceProvider</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnCatalogLoaded</span><span class="p">(</span><span class="n">ContentCatalogData</span> <span class="n">catalogData</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 创建 ResourceLocationMap</span>
        <span class="kt">var</span> <span class="n">locMap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ResourceLocationMap</span><span class="p">(</span><span class="n">catalogData</span><span class="p">);</span>
        
        <span class="c1">// 处理内部 ID 映射</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">kvp</span> <span class="k">in</span> <span class="n">catalogData</span><span class="p">.</span><span class="n">InternalIds</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 建立 key -&gt; location[]的映射</span>
            <span class="kt">string</span> <span class="n">key</span> <span class="p">=</span> <span class="n">kvp</span><span class="p">.</span><span class="n">Key</span><span class="p">;</span>
            <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">locations</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;();</span>
            
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">id</span> <span class="k">in</span> <span class="n">kvp</span><span class="p">.</span><span class="n">Value</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 为每个内部ID创建 ResourceLocation</span>
                <span class="kt">var</span> <span class="n">loc</span> <span class="p">=</span> <span class="nf">CreateLocationForCatalogEntry</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">catalogData</span><span class="p">);</span>
                <span class="n">locations</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">loc</span><span class="p">);</span>
            <span class="p">}</span>
            
            <span class="c1">// 将 locations 添加到 ResourceLocationMap 中</span>
            <span class="n">locMap</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">locations</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// 其他处理...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  <code class="language-plaintext highlighter-rouge">ResourceLocationMap</code>本质上是一个字典结构，它将用户可访问的键映射到对应的资源位置列表：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ResourceLocationMap 的简化结构</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ResourceLocationMap</span> <span class="p">:</span> <span class="n">IResourceLocator</span>
<span class="p">{</span>
    <span class="c1">// 核心数据结构：键 -&gt; 资源位置列表的映射</span>
    <span class="k">private</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;&gt;</span> <span class="n">m_Locations</span><span class="p">;</span>
    
    <span class="k">public</span> <span class="nf">ResourceLocationMap</span><span class="p">(</span><span class="n">ContentCatalogData</span> <span class="n">catalogData</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_Locations</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;&gt;();</span>
        <span class="c1">// 初始化其他元数据...</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">locations</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_Locations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="n">locations</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// IResourceLocator 接口实现</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Locate</span><span class="p">(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="n">Type</span> <span class="n">type</span><span class="p">,</span> <span class="k">out</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">locations</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_Locations</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="n">locations</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// 根据类型筛选位置...</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">locations</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  当所有 Catalog 都处理完成后，ResourceLocationMap 被注册到 Addressables 系统：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在初始化完成时</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">locator</span> <span class="k">in</span> <span class="n">m_ResourceLocators</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 将构建好的 ResourceLocationMap 注册到 ResourceManager</span>
    <span class="n">ResourceManager</span><span class="p">.</span><span class="nf">RegisterLocator</span><span class="p">(</span><span class="n">locator</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="加载远程catalog">加载远程Catalog</h2>

<p>  每次修改文件打包AssetBundle后Catalog是有差异的，为了得到最新AssetBundle就要先下载到最新的Catalog文件然后保存在本地Document目录。AA也提供加载指定地址的Catalog，可以是file:///，也可以是http(s)。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// remoteUrl -&gt; http://localhost:8000/</span>
<span class="n">AsyncOperationHandle</span><span class="p">&lt;</span><span class="n">IResourceLocator</span><span class="p">&gt;</span> <span class="n">remoteHandle</span> <span class="p">=</span> <span class="n">Addressables</span><span class="p">.</span><span class="nf">LoadContentCatalogAsync</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">remoteUrl</span><span class="p">}</span><span class="s">catalog.bundle"</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="k">yield</span> <span class="k">return</span> <span class="n">remoteHandle</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">remoteHandle</span><span class="p">.</span><span class="n">Status</span> <span class="p">!=</span> <span class="n">AsyncOperationStatus</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"InitRemoteLocation Error"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  本地模拟Server，把<code class="language-plaintext highlighter-rouge">Library/com.unity.addressables/aa/平台/</code>下面的Assetbundle和catalog复制到一个目录，在该目录打开cmd，输入python -m http.server 8000会模拟一个文件服务器。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/simulator_server.png" width="250" /><font size="2.5">
            <i>模拟文件服务器.</i>
        </font></center>
<p>  下载好之后就能获取到远程<code class="language-plaintext highlighter-rouge">ResourceLocationMap</code>。现在有了本地和远程Location信息，通过对比就能知道有哪些AssetBundle产生变化。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 缓存AssetBundle Location</span>
<span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_missingBundle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;();</span>
<span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_localBundle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;();</span>

<span class="k">private</span> <span class="n">IEnumerator</span> <span class="nf">CheckRemoteLocation</span><span class="p">(</span><span class="n">IResourceLocator</span> <span class="n">local</span><span class="p">,</span> <span class="n">IResourceLocator</span> <span class="n">remote</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="c1">// 检查本地资源在远程是否存在</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">key</span> <span class="k">in</span> <span class="n">remote</span><span class="p">.</span><span class="n">Keys</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 默认打包的AssetBundle文件后缀带了.bundle，如果修改AA代码就用自定义</span>
        <span class="c1">// 一定要增加一个标记，否则就不能区别bundle名和其他信息的描述名</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">key</span><span class="p">.</span><span class="nf">EndsWith</span><span class="p">(</span><span class="s">".bundle"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Type</span> <span class="n">iAbType</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IAssetBundleResource</span><span class="p">);</span>
        <span class="c1">// Locate定位remoteKey是否在local内，若有表示该AB文件没有差异不用更新</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">local</span><span class="p">.</span><span class="nf">Locate</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">iAbType</span><span class="p">,</span> <span class="k">out</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">localLocations</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// remoteKey不在local内，该AB有差异是最新的需要更新下载</span>
            <span class="n">remote</span><span class="p">.</span><span class="nf">Locate</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">iAbType</span><span class="p">,</span> <span class="k">out</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IResourceLocation</span><span class="p">&gt;</span> <span class="n">remoteLocations</span><span class="p">);</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">remoteLoc</span> <span class="k">in</span> <span class="n">remoteLocations</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_missingBundle</span><span class="p">[</span><span class="n">remoteLoc</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">IResourceLocation</span> <span class="n">location</span> <span class="k">in</span> <span class="n">localLocations</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_localBundle</span><span class="p">[</span><span class="n">location</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新assetbundle">更新AssetBundle</h3>

<p>  现在拿到了<code class="language-plaintext highlighter-rouge">_missingBundle</code>和<code class="language-plaintext highlighter-rouge">_localBundle</code>，现在就要更新AssetBundle。更新AssetBundle就要获取它的最新地址，那么AA也提供了一个回调接口<code class="language-plaintext highlighter-rouge">Addressables.InternalIdTransformFunc</code>，只要注册了该回调，任何加载动作都会进入到该回调，就可以在回调里面进行处理。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Addressables</span><span class="p">.</span><span class="n">InternalIdTransformFunc</span> <span class="p">=</span> <span class="n">InternalIdTransformFunc</span><span class="p">;</span>

<span class="kt">string</span> <span class="nf">InternalIdTransformFunc</span><span class="p">(</span><span class="n">IResourceLocation</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_missingBundle</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">$"</span><span class="p">{</span><span class="n">remoteUrl</span><span class="p">}{</span><span class="n">arg</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_localBundle</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">PrimaryKey</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">arg</span><span class="p">.</span><span class="n">InternalId</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">arg</span><span class="p">.</span><span class="n">InternalId</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">IResourceLocation</code>有三个关键信息：<code class="language-plaintext highlighter-rouge">PrimaryKey</code>、<code class="language-plaintext highlighter-rouge">InternalId</code>、<code class="language-plaintext highlighter-rouge">ResourceType</code></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 资源加载名的主要标识符</span>
<span class="k">public</span> <span class="kt">object</span> <span class="n">PrimaryKey</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 资源加载地址</span>
<span class="k">public</span> <span class="kt">string</span> <span class="n">InternalId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 资源加载类型，重点处理IAssetBundleResource、catalog类型</span>
<span class="k">public</span> <span class="n">Type</span> <span class="n">ResourceType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>先处理如何下载、加载最新的catalog
  不管是Initial本地Catalog还是Load远程Catalog，只要注册<code class="language-plaintext highlighter-rouge">InternalIdTransformFunc</code>就可以在函数内处理：
    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="nf">InternalIdTransformFunc</span><span class="p">(</span><span class="n">IResourceLocation</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
 <span class="c1">// 如果argResourceType是catalog类型</span>
     <span class="c1">// 判定本地缓存目录是否有Catalog.bundle，计算bundle的hash是否与catalog.hash一致</span>
         <span class="c1">// 如果一致就加载，直接返回$"{缓存目录}/Catalog.bundle"</span>
         <span class="c1">// 如果没有Catalog.bundle就用包体内的Catalog直接返回arg.InternalId</span>

 <span class="c1">// 如果argResourceType是IAssetBundleResource类型</span>
     <span class="c1">// 判定缓存目录有该文件</span>
     <span class="c1">// 有，直接返回$"{缓存目录}/xxx.bundle"</span>
     <span class="c1">// 没有，直接返回$"{remoteUrl}/xxx.bundle"去下载</span>
 <span class="c1">// 只要能确保Catalog是最新，下载的AssetBundle文件是一定是最新的</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="复杂的更新策略">复杂的更新策略</h2>
<p>  上面我是演示用了一种最简单的更新策略，肯定是不能满足复杂需求的。如果设定Group打包使用hash of file name，也就是确保构建时每个AssetBundle名不变，文件内容hash会发生了变化。那么就要维护一份bundle名映射hash表，一个本地一个远程，每次启动就要检查两张表是否一致、是否有变化，同时检查缓存的最新文件有没有丢失。当然也还有其他的策略就不讨论了。</p>

<h2 id="踩坑">踩坑</h2>
<p>  1. 不能同时存在多个Catalog对象，就是InstantiateAsync了本地Catalog后获取了Result后最好是立即释放掉</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">localLocator</span> <span class="p">=</span> <span class="n">localHandle</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
<span class="n">Addressables</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="n">localHandle</span><span class="p">);</span>
<span class="n">Addressables</span><span class="p">.</span><span class="nf">RemoveResourceLocator</span><span class="p">(</span><span class="n">localLocator</span><span class="p">);</span>
</code></pre></div></div>
<p>  2. <code class="language-plaintext highlighter-rouge">Addressables.ClearResourceLocators()</code>不能随便调用，会丢弃所有Catalog对象。</p>

<p>  3. 游戏重启，如果是在游戏内重启就不能再次初始化<code class="language-plaintext highlighter-rouge">InstantiateAsync</code>了，内部标记了<code class="language-plaintext highlighter-rouge">hasStartedInitialization</code>。</p>]]></content><author><name>编程散记</name></author><category term="Unity3d" /><category term="Addressable System" /><summary type="html"><![CDATA[使用Unity Addressable System进行热更、加载AB包，本文Addressable后续简称AA。]]></summary></entry><entry><title type="html">Unity Addressable System使用分析(二)</title><link href="https://www.damonc.top/unity3d/Unity_Addressabel_Group.html" rel="alternate" type="text/html" title="Unity Addressable System使用分析(二)" /><published>2024-07-12T20:00:00+08:00</published><updated>2024-07-12T20:00:00+08:00</updated><id>https://www.damonc.top/unity3d/Unity_Addressabel_Group</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Addressabel_Group.html"><![CDATA[<h2 id="构建前置准备">构建前置准备</h2>

<p>  AA打包提供了自带脚本<strong><em>BuildScriptPackedMode</em></strong>打包入口有两个：</p>
<ol>
  <li>不带打包结果返回：AddressableAssetSettings.BuildPlayerContent();</li>
  <li>带打包结果的接口：AddressableAssetSettings.BuildPlayerContent(<code class="language-plaintext highlighter-rouge">out AddressablesPlayerBuildResult rst</code>);</li>
</ol>

<h3 id="开始构建">开始构建</h3>

<p>  AddressablesPlayerBuildResult主要记录了打包成功后获取到bundle列表信息，每份bundle都有生成，类似于以前的AssetBundle Menifest结构。这个结果可以序列化保存在本地，方便查看调试各资源之间依赖情况。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> AddressablesPlayerBuildResult结构 </div> </div> <div class="content"> 
<pre><code class="language-CSHARP">//bundle构建后的信息
class BundleBuildResult{
 public string FilePath;
 public string InternalBundleName;
 public AddressableAssetGroup SourceAssetGroup;
 public uint Crc;
 public string Hash;
}
public List&lt;BundleBuildResult&gt; AssetBundleBuildResults =&gt; m_AssetBundleBuildResults;
//catalog hash的路径
public string RemoteCatalogHashFilePath { get; internal set; }
//catalog json的路径
public string RemoteCatalogJsonFilePath { get; internal set; }
//content state的路径
public string ContentStateFilePath { get; internal set; }
</code></pre>



 </div> </div>
<p>  进入到<strong><em>BuildPlayerContent</em></strong>函数，最主要工作之一是对所有Group内的所有Entry资源在打包之前把<code class="language-plaintext highlighter-rouge">BundleFileId</code>置空，这个字段在编辑器打包时有用到。该变量值在打包时多次使用，非常重要！
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/bundle_field_id.png" width="250" /><font size="2.5">
            <i>Debug模式查看到BundleFileId.</i>
        </font></center>
<p>  进入到<strong><em>BuildPlayerContentImpl</em></strong>函数，主要做了三块工作。</p>
<ol>
  <li>检查Addressables BuildPath目录，存在就清空该目录。<code class="language-plaintext highlighter-rouge">BuildPath</code>就是构建bundle的存放目录，这里有一个<code class="language-plaintext highlighter-rouge">清空该目录</code>的操作。</li>
  <li>实例化<code class="language-plaintext highlighter-rouge">AddressablesDataBuilderInput</code>对象，该对象内部初始化：指定构建平台、构建版本号、FileRegistry容器、PreviousContentState置空。</li>
  <li>使用指定的<code class="language-plaintext highlighter-rouge">ActivePlayerDataBuilder</code>构建对象开始构建bundle。</li>
</ol>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 清空目录如何做到增量打包？ </div> </div> <div class="content"> <p>  对于之前使用<strong><em>BuildPipeline.BuildAssetBundles</em></strong>接口打包，默认自带增量打包参数，除非使用ForceRebuildAssetBundle参数指定。</p>

<p>  以前的增量打包的所需条件：</p>

<p>  <strong>(1)</strong>资源没变化且生成目录下的bundle包和对应manifest存在，不会重新打包；</p>

<p>  <strong>(2)</strong>资源没变化即使生成目录下的bundle包被删除了，不会重新打包；</p>

<p>  <strong>(3)</strong>只要生成目录下的bundle包对应的manifase被删除了，会重新打包；</p>

<p>  而现在即使删除了Bundle存放目录，对于增量打包的使用addressables_content_state文件和BuildCache信息组合判断。</p>



 </div> </div>
<p>  <code class="language-plaintext highlighter-rouge">ActivePlayerDataBuilder</code>分析：该对象一定要继承自BuildScriptBase。一定要放在Data Builders列表。一定要给ActivePlayerDataBuilderIndex赋值，或者在Settings的Data Builders列表放在第一位，读取ActivePlayerDataBuilderIndex优先级是高于列表顺序。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/build_play_scripts.png" width="250" /><font size="2.5">
            <i>Data Builders列表就是这个Scripts列表.</i>
        </font></center>

<p>  <code class="language-plaintext highlighter-rouge">FileRegistry</code>分析：文件注册表的作用在构建Bundle期间保存创建Bundle时的存放路径(带hash信息)，然后在Bundle构建的后处理使用ReplaceBundleEntry，使用无hash的路径替换带hash路径。暂时不重要。</p>

<p>  <code class="language-plaintext highlighter-rouge">AddressablesContentState</code>结构与<code class="language-plaintext highlighter-rouge">BundleFileId</code>分析：AddressablesContentState保存了当次构建时所有的Asset缓存信息和Bundle信息，以便在下次构建bundle时读取这些缓存信息。BundleFileId就包含在这些缓存信息内。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AddressablesContentState</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">playerVersion</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">editorVersion</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">CachedAssetState</span><span class="p">[]</span> <span class="n">cachedInfos</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">remoteCatalogLoadPath</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">CachedBundleState</span><span class="p">[]</span> <span class="n">cachedBundles</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CachedAssetState</span> <span class="p">:</span> <span class="n">IEquatable</span><span class="p">&lt;</span><span class="n">CachedAssetState</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">AssetState</span> <span class="n">asset</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">AssetState</span><span class="p">[]</span> <span class="n">dependencies</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">groupGuid</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">bundleFileId</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">CachedAssetState</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CachedBundleState</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">bundleFileId</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="初始化icontextobject">初始化IContextObject</h3>

<p>  进入<strong><em>BuildDataImplementation</em></strong>内，会继续初始化一些数据：调用场景保存(使用SBP管线构建Bundle前一定要保存场景)、初始化AddressableAssetsBuildContext对象、处理所有Group对象。这里有两个重要的数据结构：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ResourceManagerRuntimeData</code>：用于初始化AA的运行时数据，包含许多AA设置时的参数，每次构建都会重新生成。</li>
  <li><code class="language-plaintext highlighter-rouge">AddressableAssetsBuildContext</code>：用于构建过程中数据传递，在后面的Task流的会多次用到IContextObject或IAddressableAssetsBuildContext接口数据。</li>
</ol>

<p><span id="jump1"></span></p>

<h3 id="处理group">处理Group</h3>

<p>  对每个Group的Schema进行预处理，对Group内所有AssetEntry生成一份<code class="language-plaintext highlighter-rouge">ContentCatalogDataEntry</code>运行时寻址数据信息。</p>

<p>  <strong>(1)PlayerDataGroupSchema</strong>分别有场景内的资源和Resource目录内的资源。把该Schema内所有的AssetEntry执行GatherAllAssets：收集该Schema内所有资源(包括subAsset、sprite精灵)装入AddressableAssetEntry收集列表。遍历收集列表执行CreateCatalogEntries创建<code class="language-plaintext highlighter-rouge">ContentCatalogDataEntry</code>数据(IResourceLocation寻址数据，在运行时初始化AA和加载Catalog这一数据非常重要)。</p>

<p>  <strong>(2)BundledAssetGroupSchema</strong>构建bundle配置和包含在Entries列表里的资源，根据BundlePackingMode生成预定义Bundle名，三者的区别是寻址路径参数不一样，<strong>Bundle命名格式</strong>：<code class="language-plaintext highlighter-rouge">groupGuid + _assets_ + address + .bundle</code>。重点说一下PackTogetherByLabel，根据AssetEntry对象内的标签生成Bundle名，选择这个模式命名Bundle，没有特殊需求一般每个Asset只需要一个标签即可，这样一个标签对应多个资源就可以打成一个Bundle。三种模式都会生成一份AssetBundleBuild[]打包数据，然后把该份数据每个BundleName执行ReHash替换(这一步可以定制bundle name)。</p>

<h2 id="开始打包">开始打包</h2>

<p>  实例化ExtractDataTask对象，实例化AddressableAssetsBundleBuildParameters对象，初始化buildTasks，调用SBP管线ContentPipeline.BuildAssetBundles接口开始打包。</p>

<h3 id="contentpipeline">ContentPipeline</h3>

<p>  ContentPipeline是SBP打包管线入口的静态类。在调用BuildAssetBundles后进行了一系列的安全检查；把IBuildTask需要的数据装入BuildContext对象的m_ContextObjects字典；在执行RunTask之前先通过Inject函数操作Task成员变量的FieldInfo，再从BuildContext的m_ContextObjects根据成员变量类型取出Value并写入Field；执行Task Running操作；然后再把Task执行后更新的成员变量数据取出装入BuildContext值。</p>

<h2 id="task管线">Task管线</h2>

<p>  每个Task内的成员变量用属性标记，ContextUsage.In是从BuildContext取出，ContextUsage.InOut是输入输出双向，ContextUsage.Out输出。</p>

<h3 id="switchtobuildplatform">SwitchToBuildPlatform</h3>

<p>  切换到指定的打包平台(如果当前平台不是目标平台触发切换基本要好几十分钟吧).</p>

<h3 id="rebuildspriteatlascache">RebuildSpriteAtlasCache</h3>

<p>  触发所有Sprite Atlas Packing操作，生成所有精灵图集的缓存数据。</p>

<h3 id="buildplayerscripts">BuildPlayerScripts</h3>

<p>  触发所有脚本编译。</p>

<h3 id="postscriptscallback">PostScriptsCallback</h3>

<p>  编译脚本时的回调，要用到这个回调需要给ContentPipeline.BuildCallbacks注册。</p>

<h3 id="calculatescenedependencydata">CalculateSceneDependencyData</h3>

<p>  收集Scene的依赖资源信息。</p>

<h3 id="calculateassetdependencydata">CalculateAssetDependencyData</h3>

<p>  收集资源的依赖信息，有三个最重要的输出数据收集<code class="language-plaintext highlighter-rouge">IBuildResults、IBuildSpriteData、IBuildExtendedAssetData</code>传递给下一个Task，这里有许多Unity内部代码现在看不到，用这三个结果数据倒推这个收集流程，先看看这三个数据结构。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IBuildResults</span> <span class="p">:</span> <span class="n">IContextObject</span>
<span class="p">{</span>
    <span class="n">ScriptCompilationResult</span> <span class="n">ScriptResults</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">WriteResult</span><span class="p">&gt;</span> <span class="n">WriteResults</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">SerializedFileMetaData</span><span class="p">&gt;</span> <span class="n">WriteResultsMetaData</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">GUID</span><span class="p">,</span> <span class="n">AssetResultData</span><span class="p">&gt;</span> <span class="n">AssetResults</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">WriteResult</span><span class="p">{...}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SerializedFileMetaData</span><span class="p">{...}</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">AssetResultData</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GUID</span> <span class="n">Guid</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Hash128</span> <span class="n">Hash</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectIdentifier</span><span class="p">&gt;</span> <span class="n">IncludedObjects</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectIdentifier</span><span class="p">&gt;</span> <span class="n">ReferencedObjects</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">ObjectIdentifier</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Type</span><span class="p">[</span><span class="k">]&gt;</span> <span class="n">ObjectTypes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IBuildSpriteData</span> <span class="p">:</span> <span class="n">IContextObject</span>
<span class="p">{</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">GUID</span><span class="p">,</span> <span class="n">SpriteImporterData</span><span class="p">&gt;</span> <span class="n">ImporterData</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IBuildExtendedAssetData</span> <span class="p">:</span> <span class="n">IContextObject</span>
<span class="p">{</span>
    <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">GUID</span><span class="p">,</span> <span class="n">ExtendedAssetData</span><span class="p">&gt;</span> <span class="n">ExtendedData</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>(1) 依赖数据新旧对比</strong>，先用TaskOutput的临时结构AssetOutput保存，AssetOutput包含有上述最重要三个数据。通过BuildCache接口根据Asset GUID获取资产信息，这里的缓存都是从Library下的BuildCache读取，若没有缓存会跳过后续的更新缓存数据操作，然后生成缓存保存；若有上次打包的缓存数据，则检查Sprite与Atlas的关联数据在这次打包前是否发生变化，把缓存中有过时的数据需要重新生成数据替换。</p>

<p><strong>(2) 依赖数据收集</strong>，(可跳过不阅读)，具体流程<strong>1)</strong>遍历每个Asset GUID获取Cache Info，如果Data[2]类型是Sprite就加入packedSprites表；<strong>2)</strong>获取该Asset CacheInfo Data[4]类型表并遍历，若是Spirte进入GetPlayerDependenciesForAsset检查其依赖；<strong>3)</strong>遍历所有includedObjects对象并使用ContentBuildInterface.GetPlayerDependenciesForObjects获取该对象的所有依赖，跳过input自身把其他依赖加入otherReferencedAssetObjectsHashSet表；<strong>4)</strong>使用objectLookingAt栈对收集到的依赖对象再次遍历查找，a.对于不是input自身且没有在explicitAssets表内就加入encounteredExplicitAssetDependencies，若是非打包精灵加入mainRepresentationNeeded，b.对于未处理过的隐式资源，更新或创建implicitOutput，查找缓存依赖，将新发现的依赖压入objectLookingAt栈中继续遍历；<strong>5)</strong>最后再执行合并collectedImmediateReferences表和mainRepresentationNeeded表返回最终的依赖信息。</p>

<p><strong>(3) 收集IBuildResults、IBuildSpriteData、IBuildExtendedAssetData</strong>，非Sprite资源走ProcessAsset处理，使用GetPlayerObjectIdentifiersInAsset获取includedObjects ID表，继续使用GetPlayerDependenciesForAsset收集依赖，然后收集资源的表示装入ExtendedAssetData，然后将依赖项扩展为显式资产。最后将assetOutput.asset装入各自的数据结构中。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">internal</span> <span class="k">struct</span> <span class="nc">AssetOutput</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GUID</span> <span class="n">asset</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Hash128</span> <span class="n">Hash</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">AssetLoadInfo</span> <span class="n">assetInfo</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectDependencyInfo</span><span class="p">&gt;</span> <span class="n">objectDependencyInfo</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">BuildUsageTagSet</span> <span class="n">usageTags</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">SpriteImporterData</span> <span class="n">spriteData</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">ExtendedAssetData</span> <span class="n">extendedData</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ObjectTypes</span><span class="p">&gt;</span> <span class="n">objectTypes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CachedInfo</span> <span class="p">:</span> <span class="n">ICachedData</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">CacheEntry</span> <span class="n">Asset</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">CacheEntry</span><span class="p">[]</span> <span class="n">Dependencies</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="cm">/*
    [0]AssetLoadInfo
    [1]BuildUsageTagSet
    [2]SpriteImporterData
    [3]ExtendedAssetData
    [4]List&lt;ObjectTypes&gt;
    [5]List&lt;ObjectDependencyInfo&gt;
    */</span>
    <span class="k">public</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">Data</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="addhashtobundlenametask">AddHashToBundleNameTask</h3>

<p>  如果使用了UniqueBundleIds定义Bundle唯一的标识符，</p>

<h3 id="stripunusedspritesources">StripUnusedSpriteSources</h3>

<p>  剥离未使用的Spirite，从依赖分析的Task获取的IBuildSpriteData数据进行遍历，在m_DependencyData没有用到的Sprite统统剥离，并从IBuildExtendedAssetData的ExtendedData内删除。</p>

<h3 id="generatebundlepacking">GenerateBundlePacking</h3>

<p>  处理资源包打包生成内部文件名、收集资源的对象标识符、过滤和处理资源引用、记录资源到文件的映射，过滤逻辑移除默认资源引用、处理资源间的循环引用、去除重复或不必要的引用</p>

<h3 id="updatebundleobjectlayout">UpdateBundleObjectLayout</h3>

<p>  更新bundle的组织结构，最开始的数据是从ContentPipeline.BuildAssetBundles打包接口参数BundleBuildContent(m_AllBundleInputDefs)对象生成，通过Bundle Packing更新依赖数据后，这块的bundle内部结构数据也要更新。</p>

<h3 id="generatebundlecommands">GenerateBundleCommands</h3>

<p>  为资源和场景生成打包命令，处理自定义资源、遍历资源包布局，根据资源类型创建不同的命令：</p>
<ol>
  <li>资源包命令 (CreateAssetBundleCommand)：创建写入命令、创建使用的列表集、创建引用映射、处理依赖哈希并排序、生成资源包写入操作。</li>
  <li>场景包命令 (CreateSceneBundleCommand)：获取场景文件对象、创建写入命令、处理预加载对象、生成场景加载信息、创建场景包写入操作。</li>
  <li>场景数据命令 (CreateSceneDataCommand)：类似场景包命令、专门处理额外的场景数据。</li>
</ol>

<h3 id="generatesubassetpathmaps">GenerateSubAssetPathMaps</h3>

<p>  创建子资源的加载信息，资源包写入操作集转为internalName与Value的字典映射，遍历ExtendedData的guid数据，通过AssetToFiles取出主资源，通过主资源获取当前guid的info，根据info和资源表示形式CreateSubAssetLoadInfo，然后插入到主资源info的BundleAssets。</p>

<h3 id="generatebundlemaps">GenerateBundleMaps</h3>

<p>  对AssetBundle生成依赖映射和使用集合，BuildReferenceMap详细说明源包中的对象所依赖的其他包中存在哪些对象（前向依赖项）；BuildUsageTagSet 详细说明了源包中的对象需要写入的条件数据，该数据由其他包中的对象使用（反向依赖）。</p>

<h3 id="writeserializedfiles">WriteSerializedFiles</h3>

<p>  把资源包数据分段写入AssetBundle。通过TaskCachingUtility.RunCachedOperation注册本地回调函数分布操作写入：获取缓存、处理未缓存文件hash写入SerializedFileMetaData、保存MetaData数据与WriteResult数据。</p>

<h3 id="archiveandcompressbundles">ArchiveAndCompressBundles</h3>

<p>  压缩写入资源包，创建ArchiveWorkItem集、执行压缩Item的ResourceFiles所有文件并返回crc。</p>

<h3 id="generatelocationliststask">GenerateLocationListsTask</h3>

<p>  创建寻址资产的位置列表，用于描述资源在最终构建包中的位置和加载方式。每个位置列表条目包含以下信息：资源类型、加载路径、提供程序、其他元数据。</p>

<h2 id="打包后处理">打包后处理</h2>

<p>  遍历ContentCatalogDataEntry集合生成主键映射、Bundle ReName、Catalog ReMap、创建Catalog File、保存ContentState。</p>

<h3 id="bundle后处理">Bundle后处理</h3>

<p>  这一步在Bundle压缩写入后。创建下载信息AssetBundleRequestOptions是提供给AssetBundleProvider下载时使用。根据BundleNaming模式重构AssetBundleName，重构命名这一步会影响bundle命名格式，尤其会破坏<a href="#jump1"><code class="language-plaintext highlighter-rouge">1.3处理Group</code></a>这一步的预命名。</p>]]></content><author><name>编程散记</name></author><category term="Unity3d" /><category term="Addressable System" /><summary type="html"><![CDATA[总结在使用Unity Addressable System过程中遇到的一部分问题，该篇主要记录Addressable打AB包、加载AB包，本文Addressable后续简称AA。]]></summary></entry><entry><title type="html">Unity Addressable System使用分析(一)</title><link href="https://www.damonc.top/unity3d/Unity_Addressable_Editor.html" rel="alternate" type="text/html" title="Unity Addressable System使用分析(一)" /><published>2024-07-10T00:00:00+08:00</published><updated>2024-07-10T00:00:00+08:00</updated><id>https://www.damonc.top/unity3d/Unity_Addressable_Editor</id><content type="html" xml:base="https://www.damonc.top/unity3d/Unity_Addressable_Editor.html"><![CDATA[<h2 id="addressable安装">Addressable安装</h2>
<p>  总结在使用Unity Addressable System过程中遇到的一部分问题，该篇主要记录Addressable在Unity编辑器的各种组织结构，本文Addressable后续简称AA，基于1.21.19版本。</p>

<h3 id="package安装">Package安装</h3>
<p>  打开Unity Window - Package Manger，找到Addressable安装找一个合适的版本：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_win_pkg_mgr.png" width="250" /><font size="2.5">
            <i>Addressable Version Seleclt.</i>
        </font></center>

<h3 id="手动安装">手动安装</h3>
<p>  在Package Manager选择一个合适的Addressable版本还要结合Addressable更新log，打开<a href="https：//docs.unity3d.com/Packages/com.unity.addressables@1.21/changelog/CHANGELOG.html"><code class="language-plaintext highlighter-rouge">Addressable更新日志</code></a>，版本列表展示了Address able对应的Unity版本：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_version.png" width="250" /><font size="2.5">
            <i>Addressable Version List.</i>
        </font></center>
<p>  Unity这里分了两个分支维护Addressable，其中一个分支是1.21版本对应的Unity版本是2019+，另一个分支是2.0版本对应的Unity版本是2023+：
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_1_21.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_2_0.png" width="250" /><font size="2.5">
            <i>Addressable Branch.</i>
        </font></center>

<p>  2.0以上版本也可以用在非2023版的引擎，主要还是针对2023+ Unity引擎支持新的API什么的。如果想把2.0版本合到1.21，开一Beyond Compare合并差异也行。打开<a href="https：//packages.unity.com/com.unity.addressables"><code class="language-plaintext highlighter-rouge">Addressable Package Json</code></a>，这里列明了每一个Addressable版本对应的Unity版本，结合<a href="https：//docs.unity3d.com/Packages/com.unity.addressables@1.21/changelog/CHANGELOG.html"><code class="language-plaintext highlighter-rouge">Addressable更新日志</code></a>找到一个Bug最少又符合对Unity版本要求的Addressable版本。找到合适的Addressable版本后，打开Packages/manifest.json，手动新增包”com.unity.addressables”:”1.21.19”。</p>

<h3 id="安装addressable依赖">安装Addressable依赖</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_deps.png" width="250" /><font size="2.5">
            <i>Addressable Dependencies.</i>
        </font></center>
<p>  Addressable最重要的依赖是ScriptableBuildPipeline，SBP这个包要更新到1.21.23或2.1.x以上，旧版SBP对SpriteAtlas图集打包会有冗余。打开Packages/manifest.json，强制指定SBP版本”com.unity.scriptablebuildpipeline”:”1.21.23”,
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/sbp_upgrade.png" width="250" /><font size="2.5">
            <i>SBP指定版本.</i>
        </font></center>

<h3 id="addressable结构预览">Addressable结构预览</h3>
<p>  安装好了AA之后，会在Assets生成以下目录：</p>

<table>
  <tbody>
    <tr>
      <td>目录</td>
      <td>说明</td>
    </tr>
    <tr>
      <td>AddressableAssetsData</td>
      <td>根目录也包含几个重要文件</td>
    </tr>
    <tr>
      <td>##Platform</td>
      <td>根据当前平台构建一次AB包后生成的目录</td>
    </tr>
    <tr>
      <td>AssetGroups</td>
      <td>给某资源设置寻址地址并指定Group后的Group描述文件</td>
    </tr>
    <tr>
      <td>Schemas</td>
      <td>Group组的配置包含逻辑结构和特性描述文件</td>
    </tr>
    <tr>
      <td>AssetGroupTemplates</td>
      <td>生成Group的模版描述文件</td>
    </tr>
    <tr>
      <td>DataBuilders</td>
      <td>自定义AssetBundle打包脚本目录</td>
    </tr>
  </tbody>
</table>

<h2 id="addressable各项配置">Addressable各项配置</h2>

<h3 id="addressableassetsettings">AddressableAssetSettings</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/addressable_assets_settings.png" width="250" /><font size="2.5">
            <i>AddressableAssetSettings预览.</i>
        </font></center>
<p>  AA的全局配置文件，涉及一些打包配置、热更配置、下载配置等等，下面是每项参数配置说明。</p>

<h3 id="profile">Profile</h3>

<p>  <strong>Profile</strong>主要作用是指定打包地址和加载地址，这里可以配置新增打包Ab的保存目录和HotUpdate热更资源目录的指定路径，建议自定义路径。</p>

<p>  这两个参数的使用地方在不同的AA版本有一点差别：1.20以前的版本在Content Update有用到，1.20以后的版本在Catalog有使用。见<a href="#jump1"><code class="language-plaintext highlighter-rouge">Catalog</code></a>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/profile_in_use.png" width="250" /><font size="2.5">
            <i>Profile预览.</i>
        </font></center>
<p>Profile In Use可以选择系统自带或自定义，其中自定义使用Manager按钮打开Profile Window，点击Create按钮新增变量等参数。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/profile_window.png" width="250" /><font size="2.5">
            <i>Profile Window.</i>
        </font></center>

<p><span id="jump1"></span></p>

<h3 id="catalog">Catalog</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/catalog_attribute.png" width="250" /><font size="2.5">
            <i>Catalog设置面板.</i>
        </font></center>
<p>  Catalog类似于根bundle，记录了当前构建bundle时的依赖和AA的各项设置。</p>
<ul>
  <li><strong>(1) Player Version Override</strong>： 这个参数会对构建好的catalog进行重命名，unity使用时间戳，我们自己可以用自己的构建版本号，格式可以是catalog_1.2.1720684396.json。</li>
  <li><strong>(2) Compress Local Catalog</strong>： 启用会将Catalog.json压缩成Catalog.bundle，显著减少文件size。</li>
  <li><strong>(3) Build Remote Catalog</strong>： 要热更Catalog就要启用。</li>
  <li><strong>(4) Build Path</strong>： 构建Assetbundle的保存地址。</li>
  <li><strong>(5) Load Path</strong>： 加载AssetBundle的地址，这里我是在Profiles设置成了相对地址，然后在加载脚本回调地址逻辑完成后组装完整的加载地址。</li>
  <li><strong>(6) Only Update catalogs manually</strong>： 手动控制更新Catalog时机和方式。</li>
</ul>

<h3 id="update-a-previous-build">Update a Previous Build</h3>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/update_download.png" width="250" /><font size="2.5">
            <i>Update Downloads设置.</i>
        </font></center>

<ul>
  <li><strong>(1) Check for Update Issues</strong>：官方推荐使用List Restricted Assets，在更新过程中对使用了限制更新的Group有限制。</li>
  <li><strong>(2) Content State Build Path</strong>：指定addressables_content_state.bin的保存地址。</li>
</ul>

<p>  该content_state文件只在本地构建时读取进行增量打包，可以看看<a href="https：//docs.unity3d.com/Packages/com.unity.addressables@2.2/manual/content-update-builds-overview.html"><code class="language-plaintext highlighter-rouge">官方workflow</code></a>。简化描述就是要构建更新的AssetBundle，请运行Update a Previous Build脚本。此工具还使用到<code class="language-plaintext highlighter-rouge">addressables_content_state.bin</code>文件，它会重新构建所有内容并会生成到一个修改过的目录，该目录可以访问原始AssetBundle中未更改的内容以及新AssetBundle中更改过的内容。通过打开Groups面板Tools选项Check Content Update Restrictions窗口，只要Group内某个资源有修改，就会出现在这个列表中。但是如果玩家本地用户目录的bundle不小心损坏了或者需要回退资源版本，直接使用Unity这个方案就不好办。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/modify_update_remote.png" width="250" /><font size="2.5">
            <i>修改过的group列表.</i>
        </font></center>

<p>  由于我开了手动更新Catalog，同时自己维护了一套完整的更新列表，就禁用了这条属性。</p>

<h3 id="downloads">Downloads</h3>
<p>  自定义证书、下载并发数量、超时等设置</p>
<ul>
  <li><strong>(1) Custom certificate handler</strong>：自定义证书类要实现CertificateHandler。</li>
  <li><strong>(2) Max Concurrent Web Requests</strong>：设置Web并发下载数量官方建议2-4个。</li>
  <li><strong>(3) Catalog Download Timeout</strong>：超时设置。</li>
</ul>

<h3 id="builds">Builds</h3>

<p>  构建AB包的一些设置
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/setting_build.png" width="250" /><font size="2.5">
            <i>Build设置.</i>
        </font></center>
<ul>
  <li><strong>(1) Build Addressables on Player Build</strong>： 打APK的时候一起先打Assetbundle在打APK，这里我关了不需要，一般是单独出Bundle资源的。</li>
  <li><strong>(2) Ignore Invalid/Unsupported Files in Build</strong>： 构建时排除无效文件，如果未启用可能导致中断构建。</li>
  <li><strong>(3) Unique Bundle IDs</strong>： 指定每个Assetbundle生成唯一标识符。</li>
  <li><strong>(4) Contiguous Bundles</strong>： 定义的Assetbundle内容布局。</li>
  <li><strong>(5) Non-Recursive Dependency Calculation</strong>： 循环依赖计算耗费时间，开启只计算直接依赖。(某些情况下所有设置都正确却无法加载Bundle，一般是Group内的资源依赖有问题。)</li>
  <li><strong>(6) Strip Unity Version From AssetBundles</strong>： 裁剪Assetbundle内的unity版本号，启用。</li>
  <li><strong>(7) Disable Visible Sub Asset Representations</strong>： 不直接拖拽引用某个sprite，开启该项可以加快构建时间。</li>
</ul>

<h3 id="build-and-play-mode-scripts">Build And Play Mode Scripts</h3>

<p>  构建AB的一些脚本配置，可以实现IDataBuilder接口自定义打包流程。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/build_play_scripts.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/play_mode.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/build_mode.png" width="250" /><font size="2.5">
            <i>Build Bundle设置.</i>
        </font></center>
<p>  Play mode指定在编辑器是怎么加载资源，本地测试用</p>
<ul>
  <li><strong>(1) Fast Mode</strong>： 不打包直接加载文件，速度快但在Profiler中提供的信息较少</li>
  <li><strong>(2) Virtual Mode</strong>： 虚拟环境模拟类似于AssetBundle的行为，无需打包</li>
  <li><strong>(3) Packed Mode</strong>： 从实际的AssetBundle中加载资源，真实环境</li>
</ul>

<h2 id="addressablegroups分析">AddressableGroups分析</h2>

<h3 id="group配置">Group配置</h3>

<p>  AssetGroups是Addressable组织bundle的一种容器，必须要把资源加入Group才能参与打包。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/group_view.png" width="250" /><font size="2.5">
            <i>Group设置.</i>
        </font></center>

<ul>
  <li><strong>(1) Buildin&amp;Load Path</strong>：选择Local或Remote，一般选RemotRemotee以支持热更，基本上所有资源都可能会热更。</li>
  <li><strong>(2) AB Compression</strong>：指定AB包用哪种压缩算法：不压缩、LZ4、LZMA。</li>
  <li><strong>(3) Include In Build</strong>： 启用才能构建该组内所包含的Asset Entry。</li>
  <li><strong>(4) Force Unique Provider</strong>：是否指定唯一的Group加载实例，如果Group有上百个就不要勾选了。</li>
  <li><strong>(5) Use AB Cache</strong>：从远程下载的AB是否使用AA的缓存机制。(这个缓存包括AB资源和当前更新时的AA版本信息)</li>
  <li><strong>(6) Use UnityWebRequest for Local Asset Bundles</strong>：对于本地的AB资源是否使用UnityWebRequestAssetBundle GetAssetBundle加载，还是使用AssetBundle LoadFromFileAsync加载。</li>
  <li><strong>(7) Request Timeout</strong>：设置下载超时。</li>
  <li><strong>(8) Use Http Chunked Transfer</strong>：开启分块传输。</li>
  <li><strong>(9) Http Redirect Limit</strong>：设置重定向次数。</li>
  <li><strong>(9) Retry Count</strong>：设置下载失败重试次数。</li>
  <li><strong>(10) Include Addresses in Catalog</strong>： 禁用后构建bundle时不会包含在catalog.json。</li>
  <li><strong>(11) Include GUIDs in Catalog</strong>： 使用AssetReference拖拽引用就得启用。</li>
  <li><strong>(12) Include Labels in Catalog</strong>： 不通过label标签加载资源，我这里不使用label去加载资源。</li>
  <li><strong>(13) Internal Asset Naming Mode</strong>：AB包内资源的ID标识方式，有三种：Full Path(资源全路径)、Filename(资源名)、GUID(unity导入时设置的ID)、Dynamic(官方推荐使用)。这个模式影响Ab的CRC和HASH，设置该模式中任意一种也不会影响我们从AB包内读取某个资源。</li>
  <li><strong>(14) Cache Clear Behavior</strong>：设置APK包内缓存AA下载的AB资源时长，到期自动清除。</li>
  <li><strong>(15) Bundle Mode</strong>：构建AB的模式，有三种：Group内所有资源打成一个AB、Group内资源分别单独打成AB、根据组内标签打包。</li>
  <li><strong>(16) Bundle Naming Mode</strong>：设置AB名，有三种：Group名、 Group名追加HASH、使用Bundle的HASH(推荐-但要做组名与HASH之间的映射，加载Bundle先拿到组名映射的HASH去找Bundle加载)、使用Group组名的字符HASH。</li>
  <li><strong>(17) Asset Load Mode</strong>：资源加载模式，有两种：从bundle请求加载的资源及其依赖一起加载、bundle内所有的资源全部加载。</li>
  <li><strong>(18) Asset Provider</strong>：从Bundle内加载Asset，官方推荐使用自带的Asset from Bundle Provider,也可以根据Group内文件类型选择Json、Sprites等provider。</li>
  <li><strong>(19) Asset Bundle Provider</strong>：加载AssetBundle接口，官方推荐AssetBundle Provider，或者自己实现一套Provider(可以实现加密解密)。</li>
</ul>

<h3 id="content-update">Content Update</h3>
<ul>
  <li><strong>(1) Prevent Updates</strong>：是否启用禁止更新移动Asset。当使用了AA自带的<strong>Check for Content Update Restrictions tool</strong>，不启用时如果组内有资源发生变更，这个工具会把变更的资源移动到需要生成的Remote Group内。(我没有使用这个工具也没有启用这个选项，组内的资源移动实现了一个脚本规则检查)。</li>
</ul>

<h3 id="group-schema配置">Group Schema配置</h3>

<p>  BundledAssetGroupSchema主要是Group面板配置，一个Group会生成两份Schema，<strong>#GroupName_BundledAssetGroupSchema</strong>、<strong>#GroupName_BundledAssetGroupSchema</strong>。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/group_serialize.png" width="250" /><font size="2.5">
            <i>Group Debug模式.</i>
        </font></center>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/schema_serialize1.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2024/month7/addressable_system/schema_serialize2.png" width="250" /><font size="2.5">
            <i>Schema Debug模式.</i>
        </font></center>

<p>  通过Debug模式可以看到Group主要是保存了<strong>SerializeEntries</strong>资源、<strong>Schema</strong>配置，所以配置实际上是由Schema保存的。在写代码创建Group时，要把资源加入到Group内、配置写到Schema内。</p>
<pre><code class="language-CSHARP">//...
group = settings.CreateGroup(key, i == 0, false, false, null);
AddressableBuildUtil.CheckSchemaValue(group, _keyIdArray);
AddressableBuildUtil.CheckUpdateSchema(group);
//...

SetSchemaBuildLoadPath(schema, keyIds);
schema.ChunkedTransfer = true;
//disable crc 使用md5代替
schema.UseAssetBundleCrc = false;
schema.UseAssetBundleCrcForCachedBundles = false;
//disable guid
schema.IncludeGUIDInCatalog = false;
schema.IncludeLabelsInCatalog = false;
schema.RedirectLimit = 2;
schema.RetryCount = 2;
schema.Timeout = 30;

SetBundleCache(schema);
//load asset by name
SetSchemaNameMode(schema, BundledAssetGroupSchema.AssetNamingMode.Filename);
//pack mode打包模式
SetSchemaPackMode(schema, BundledAssetGroupSchema.BundlePackingMode.PackTogetherByLabel);
//bundle name
SetSchemaNameStyle(schema, BundledAssetGroupSchema.BundleNamingStyle.FileNameHash);
//bundle id
SetSchemaBundleIdMode(schema, BundledAssetGroupSchema.BundleInternalIdMode.GroupGuid);
//bundle compression
SetSchemaBundleCompressionMode(schema, BundledAssetGroupSchema.BundleCompressionMode.LZ4);

//设置Schema Value会触发Group dirty通知，要判断值有没有变再设置
if (schema.BundleMode ~= packMode)
{
    schema.BundleMode = packMode;
}
</code></pre>

<h2 id="assetgrouptemplates">AssetGroupTemplates</h2>
<p>  Group模版配置,可以预先设置好Group的配置，使用该模版创建Group。</p>

<h2 id="databuilders">DataBuilders</h2>
<p>  存放打包脚本和Editor测试加载脚本的目录，AA提供了四个自带脚本。</p>
<ul>
  <li><strong>(1) BuildScriptFastMode</strong>：对应<strong>Use Asset Database (fastest)</strong>按钮，快速加载模式，类似AssetdataBase加载资源。</li>
  <li><strong>(2) BuildScriptPackedMode</strong>：对应<strong>Default Build Script</strong>打包按钮，默认的打AB包脚本，可以根据这个脚本修改自己的打包前后流程。</li>
  <li><strong>(3) BuildScriptPackedPlayMode</strong>：对应<strong>Use Existing Build(#Platform)</strong>，真实完整的AB加载场景模式，在Editor测试AB是否正确。</li>
  <li><strong>(4) BuildScriptVirtualMode</strong>：对应<strong>Simulate Groups (advanced)</strong>按钮，不用打AB包可模拟加载AB模式。</li>
</ul>]]></content><author><name>编程散记</name></author><category term="Unity3d" /><category term="Addressable System" /><summary type="html"><![CDATA[总结在使用Unity Addressable System过程中遇到的一部分问题，该篇主要记录Addressable在Unity编辑器的各种组织结构，本文Addressable后续简称AA。]]></summary></entry><entry><title type="html">视差和法线、高度图回顾(翻译二十)</title><link href="https://www.damonc.top/Unity_Parallax_Normals_Heightmap.html" rel="alternate" type="text/html" title="视差和法线、高度图回顾(翻译二十)" /><published>2018-01-25T20:00:00+08:00</published><updated>2018-01-25T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_Parallax_Normals_Heightmap</id><content type="html" xml:base="https://www.damonc.top/Unity_Parallax_Normals_Heightmap.html"><![CDATA[<p>由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外的景物，附近的物体看起来很大并且移动很快，而远处的背景看起来很小并且移动较慢。渲染时，相机使用透视模式时，也会出现视差。</p>

<h2 id="视差纹理">视差纹理</h2>

<p>之前翻译使用过法线贴图将表面不规则感添加到平滑表面。 它会影响照明，但不会影响表面的实际形状。 因此，该效果视差不明显，通过实现法线贴图基于视野深度的幻觉有许多限制。这一篇的目的就是解决该限制。</p>

<h3 id="法线贴图效果回顾">法线贴图效果回顾</h3>

<p>下面给出许多albedo map 和 normal map差异对比：</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200615181223145-1229624244.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200615181223966-473200226.png" width="250" /><font size="2.5">
            <i>albedo map 和 normal map.</i>
        </font></center>

<p>如果没有法线贴图，表面看起来很平坦。 添加法线贴图会使它看起来好像具有不规则的表面。 但是，高度海拔差异看起来不明显。 当从入射视角与表面的夹角越趋于0，高度差越不明显。如果高程差异较大，则表面特征的相对视觉位置应由于视差而发生很大变化，但不会发生变化。 我们看到的视差是平坦的表面。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200616191420845-1957506928.png" width="250" /><font size="2.5">
            <i>平坦的视角.</i>
        </font></center>

<p>虽然可以增加法线贴图的强度，但这不会改变视差。同样，当法线贴图变得太强时，它会看起来很奇怪。它影响了平坦表面的光线的明暗变换，而视差效果它们确实是平的。所以法线贴图只适用于小的变化，但不会表现出明显的视差。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200616191421654-712293996.png" width="250" /><font size="2.5">
            <i>法线贴图的光线变化.</i>
        </font></center>

<p>要获得真正的深度视差感，<strong>首先</strong>需要确定深度应该是多少。法线贴图不包含这些信息。所以我们需要一个高度图。这样，我们就可以创建一个基于高度信息的假视差效果，就像法线贴图创建一个假斜率一样。下面的贴图也称它是灰度图，黑色代表最低点，白色代表最高点。因为我们将使用这个贴图来创建一个视差效果，也称为视差图。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200616191422519-1710373191.png" width="250" /><font size="2.5">
            <i>高度图.</i>
        </font></center>

<p>确保在导入时禁用sRGB(颜色纹理)，这样在使用线性空间渲染时数据就不会被弄乱</p>

<h3 id="shader参数">Shader参数</h3>

<p>为了能够使用视差贴图，我们必须为它添加一个属性到着色器。也会给它一个强度参数来缩放效果。因为视差效果相当强，我们将其范围设置为(0 , 0.1)。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_ParallaxMap</span> <span class="p">(</span><span class="s">"Parallax"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"black"</span> <span class="p">{}</span>
<span class="n">_ParallaxStrength</span> <span class="p">(</span><span class="s">"Parallax Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>

<span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_OcclusionMap</span> <span class="p">(</span><span class="s">"Occlusion"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
<span class="n">_OcclusionStrength</span> <span class="p">(</span><span class="s">"Occlusion Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>视差贴图是一个着色器特性，我们将启用__PARALLAX_MAP_关键字。将必需的编译器指令添加到base pass、additive pass和deferred pass。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma shader_feature _NORMAL_MAP
#pragma shader_feature _PARALLAX_MAP
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>为什么不在ShadowCaster增加视差贴图？
当使用albedo贴图的alpha通道的透明度时，视差贴图只会影响阴影。即使是这样，在阴影贴图中的视差效果也很难被注意到。所以它通常不值得额外的计算时间。但是如果愿意，也可以将它添加到阴影施法者通道中。
</code></pre></div></div>

<p>为了访问新的属性，给我的照明添加相应的变量</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_ParallaxMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>

<span class="n">sampler2D</span> <span class="n">_OcclusionMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_OcclusionStrength</span><span class="p">;</span>
</code></pre></div></div>

<p>为了能够自定义配置材质，在Extend ShaderGUI扩展中增加相应Enable与Disanble key的方法。</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">DoParallax</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialProperty</span> <span class="n">map</span> <span class="p">=</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_ParallaxMap"</span><span class="p">);</span>
    <span class="n">Texture</span> <span class="n">tex</span> <span class="p">=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">;</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="nf">BeginChangeCheck</span><span class="p">();</span>
    <span class="n">editor</span><span class="p">.</span><span class="nf">TexturePropertySingleLine</span>
    <span class="p">(</span>
        <span class="nf">MakeLabel</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">"Parallax (G)"</span><span class="p">),</span> <span class="n">map</span><span class="p">,</span>
        <span class="n">tex</span> <span class="p">?</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_ParallaxStrength"</span><span class="p">)</span> <span class="p">:</span> <span class="k">null</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="nf">EndChangeCheck</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">tex</span> <span class="p">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">SetKeyword</span><span class="p">(</span><span class="s">"_PARALLAX_MAP"</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200616191423089-347056836.png" width="250" /></center>

<h3 id="坐标匹配">坐标匹配</h3>

<p>通过在fragment程序中调整纹理坐标，让平坦表面的某些部分看起来高低交错。创建一个应用视差函数，给它一个inout插值器参数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在fragment程序使用插入的数据之前调用视差函数。_会有点异常是LOD衰落，_因为这取决于屏幕位置。先不调整这些坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="n">ApplyParallax</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">GetAlpha</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#if defined(_RENDERING_CUTOUT)
</span>        <span class="nb">clip</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">_Cutoff</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>通过简单地向U坐标添加视差强度来调整纹理坐标。做一次偏移计算</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>改变视差强度会导致纹理偏移。增加U坐标会使纹理向负的U方向移动，V坐标同理。这看起来不是视差效果，因为这是一个与视角无关的均匀位移。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012938981-982216259.gif" width="250" /><font size="2.5">
            <i>u坐标移动.</i>
        </font></center>

<h3 id="随视角方向移动">随视角方向移动</h3>

<p>视差是由相对于观察者的透视投影，所以必须改变纹理坐标。这意味着必须基于视图的方向来移动坐标，而视图的方向对于表面上每个片段都是不同的。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192759952-594530144.png" width="250" /><font size="2.5">
            <i>varies across a surface.</i>
        </font></center>

<p>纹理坐标存在于切线空间中。为了调整这些坐标，需要知道视图在切线空间中的方向。这需要矩阵乘法对空间进行转换。在fragment-程序已经有了一个切线空间矩阵，但是它是用于从切线空间到世界空间的转换。在本例中，需要从对象空间转到切线空间。</p>

<p>视图方向向量定义为从表面到摄像机，需要归一化。我们可以在vertex程序中确定这个向量，转换它并将它传递给fragment程序。但是为了最终得到正确的方向，需要推迟归一化，直到插值完成后。添加切线空间视图方向作为一个新的插值成员变量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="kt">float3</span> <span class="n">tangentViewDir</span> <span class="o">:</span> <span class="n">TEXCOORD8</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="kt">float3</span> <span class="n">tangentViewDir</span> <span class="o">:</span> <span class="n">TEXCOORD8</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>寄存器数量限制是多少?
model 1与model 2都只支持8个Texture Coordinate Register -&gt;Texcoord[0-7]。当使用model 3时，可以使用TEXCOORD8。若硬件不支持model 3其机能也就不是很强大，所以不要使用视差映射。
</code></pre></div></div>

<p><strong>首先</strong>, 使用mesh网格数据中的原始顶点切向量和法向量，在顶点程序中创建一个从对象空间到切线空间的转换矩阵。因为我们只用它来变换一个向量而不是一个位置我们用一个3×3矩阵就足够了。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ComputeVertexLightColor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="cp">#if defined (_PARALLAX_MAP)
</span>        <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span><span class="p">(</span>
            <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
            <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
            <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
        <span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>然后</strong>，可以使用<code class="language-plaintext highlighter-rouge">ObjSpaceViewDir</code>函数得到对象空间中顶点位置的视图方向，再用矩阵变换它我们就得到了我们需要的切线空间下视图方向。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined (_PARALLAX_MAP)
</span>    <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span>
    <span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
        <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
    <span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">objectToTangent</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ObjSpaceViewDir内部实现?</span>
<span class="c1">//ObjSpaceViewDir函数是在UnityCG中定义的。它先将摄像机位置转换到对象空间，然后减去对象空间下顶点位置得到一个从顶点指向摄像机的向量，注意它还没有标准化.</span>

<span class="k">inline</span> <span class="kt">float3</span> <span class="nf">ObjSpaceViewDir</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float3</span> <span class="n">objSpaceCameraPos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_WorldToObject</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">objSpaceCameraPos</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>最后</strong>，我们可以在ApplyParallax函数使用切线空间视图方向了。首先，对它进行规格化normalize，把它变成一个合适的方向向量。然后，添加它的XY组件到纹理坐标，再由视差强度缩放。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>这能有效地将视图方向投影到纹理表面上。当以90度角直视表面时，在切空间中的视图方向等于表面法线(0,0,1)，这不会导致位移。视角越浅，投影越大，位移效果也越大。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192800432-1757806048.png" width="250" /><font size="2.5">
            <i>影视图方向用作UV偏移.</i>
        </font></center>

<p>所有这一切的影响是表面似乎被拉向上的切线空间，看起来比它实际上更高，基于视差强度。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012940748-384205609.gif" width="250" /><font size="2.5">
            <i>随投影视角方向移动UV.</i>
        </font></center>

<h3 id="基于高度滑动">基于高度滑动</h3>

<p>在基于高度这一点上，我们可以让表面看起来更高，但它仍然是一个均匀位移。下一步是使用视差贴图来缩放位移。采样贴图，使用它的G通道作为高度，应用视差强度，并使用它来调节位移。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
<span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012942351-290008046.gif" width="250" /><font size="2.5">
            <i>由高度调整的移动.</i>
        </font></center>

<p>低的区域现在保持不变，而高的区域被向上拉。standard shader抵消了这种效果，所以低的区域也向下移动，而在中间的区域保持他们原来的位置。这是通过从原始高度数据中减去差值来实现的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012944095-1997194416.gif" width="250" /><font size="2.5">
            <i>视差贴图效果 由合理到过量.</i>
        </font></center>

<p>这就产生了我们想要的视差效果，但它只在低强度下有效。不足的是位移位移变换的很快，会撕裂表面。</p>

<h3 id="偏移视差映射算法">偏移视差映射算法</h3>

<p>我们目前使用的视差映射技术被称为带偏移限制的视差映射。我们只是使用了视图方向的XY部分，它的最大长度是1。因此，纹理偏移量是有限的。这种效果不错，但不能代表正确的透视投影。</p>

<p>一个更精确的计算偏移量的物理方法是将高度场视为几何图形表面下的体积，并通过它拍摄一个视图射线。光线从相机发射到表面，从上面进入高度场体积，并持续发射直到它到达由场定义的表面。</p>

<p>如果高度场均匀为零，那么射线就会一直持续到体积的底部。它与物体的距离取决于光线进入物体时的角度。它没有限制。角度越浅，越远。最极端的情况是当视角趋于0时，光线射向无穷大。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192800958-1980748310.png" width="250" /><font size="2.5">
            <i>光线投射到底部，有限且正确.</i>
        </font></center>

<p>为了找到合适的偏移量，我们必须缩放视图方向向量，通过除以它自己的Z分量来使它的Z分量变成1。因为我们以后不需要用Z，我们只需要用X和Y除以Z。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
<span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</code></pre></div></div>

<p>虽然这样可以得到一个更正确的投影，但它确实会使浅视角的视差效果恶化。standard着色器通过增加0.42偏差到Z减轻浅视角的视差效果恶化，所以它永远不会接近零。这扭曲了透视图，但使工件更易于管理。我们再加上这个偏差.</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">42</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192802151-218582125.png" width="250" /><font size="2.5">
            <i>视差贴图像标准着色器.</i>
        </font></center>

<p>通过上述多个步骤修正后, 现在我们的着色器与标准着色器支持同样的视差效果。视差映射可以应用于任何表面，投影假设切线空间是均匀的。曲面具有弯曲的切线空间，因此会产生物理上不正确的结果。只要视差强度和曲率很小，你就可以摆脱它。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192802555-2049613835.png" width="250" /><font size="2.5">
            <i>球面视差贴图.</i>
        </font></center>

<p>同样，阴影坐标不会受到这个效果的影响。因此，阴影在强烈的视差的组合下看起来很奇怪，好像漂浮在表面上。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192803371-1931947503.png" width="250" /><font size="2.5">
            <i>阴影不受视差影响.</i>
        </font></center>

<h3 id="parallax-configuration">Parallax Configuration</h3>

<p>你不同意Unity使用0.42的偏移值吗?或者你想使用一个不同的值，还是让它保持在0?或者你想用偏移限制代替吗?它是可以配置!</p>

<p>当你想使用偏移限制，定义<code class="language-plaintext highlighter-rouge">PARALLAX_OFFSET_LIMITING</code>在着色器。或者，通过定义PARALLAX_BIAS来设置要使用的偏差。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>            <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>当没有定义时，假设偏差是0.42。在<code class="language-plaintext highlighter-rouge">ApplyParallax</code> 中定义它。注意，宏定义不关心函数作用域，它们总是全局的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>    <span class="cp">#if !defined(PARALLAX_BIAS)
</span>        <span class="cp">#define PARALLAX_BIAS 0.42
</span>    <span class="cp">#endif
</span>    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>现在我们可以通过着色器的CGINCLUDE块来微调我们的视差效果。添加无偏差和限制偏移的选项，但将它们转换为注释，以坚持默认选项。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGINCLUDE</span>
    <span class="cp">#define BINORMAL_PER_FRAGMENT
</span>    <span class="cp">#define FOG_DISTANCE
</span>
<span class="c1">//	#define PARALLAX_BIAS 0</span>
<span class="c1">//	#define PARALLAX_OFFSET_LIMITING</span>

<span class="n">ENDCG</span>
</code></pre></div></div>

<h3 id="detail-uv">Detail UV</h3>

<p>视差贴图可以在主贴图上工作，但是我们还没有注意到副贴图。我们必须应用纹理坐标偏移到细节UV上。</p>

<p>首先，下面是一个包含网格模式的详细地图。它可以很容易地验证效果是否正确地应用于细节。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192803893-1797850325.png" width="250" /><font size="2.5">
            <i>细节网格纹理.</i>
        </font></center>

<p>使用这个纹理作为材质的细节albedo贴图。设置二级贴图的平铺为10×10。这表明，细节紫外线确实仍然不受影响。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192804491-290326603.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192805295-1360127209.png" width="250" /><font size="2.5">
            <i>细节UV不受影响.</i>
        </font></center>

<p>Standard也简单地添加了UV偏移到细节UV，这是存储在UV插值器的ZW组件。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
<span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
</code></pre></div></div>

<p>细节可能有所变化，但是它们肯定还不匹配视差效果。 那是因为我们平铺了二级纹理。 这样会将细节UV缩放10倍，使视差偏移量变弱十倍。 我们还必须将细节拼贴应用到偏移量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
</code></pre></div></div>

<p>实际上，缩放应该相对于主UV平铺，以防它被设置为1×1以外的一些东西。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192806533-2106069113.png" width="250" /><font size="2.5">
            <i>正确的UV.</i>
        </font></center>

<h2 id="ray-marching-光线步进">Ray Marching-光线步进</h2>

<p>然而，除了上述的偏移视差映射还有另外的视差算法：发射射线与高度场体积相交，确定其交点在表面上的位置，然后对该位置采样。 它通过在射线进入体积时的交点，对高度图进行一次采样。 但是，当看向任意一个角度时，这并不能准确告诉射线实际上与高度场相交的高度。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192807160-2024700857.png" width="250" /><font size="2.5">
            <i>实际与预测的高度对比.</i>
        </font></center>

<p>先假设入口点的高度与交点的高度相同，但这实际上只有在入口点和交点具有相同的高度时才是正确的。当偏移量不大且高度场变化不大时，它的效果仍然很好。但是，当偏移量太大或高度变化太快时，该算法就会出现问题，而这很可能是错误的。这就会造成表面撕裂。</p>

<p>如果我们能算出射线实际到达的高度场的位置，那么总能找到真正的可见表面点。这不能通过单个纹理样本来实现，我们必须沿着视图射线逐步移动，并每次都采样高度场，直到射线到达表面。该技术是RayMarching。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200617192807679-1545265192.png" width="250" /><font size="2.5">
            <i>随视图射线前进.</i>
        </font></center>

<p>有各种不同的视差贴图使用raymarching。常见的是陡视差映射_Steep Parallax Mapping_、地形映射_Relief Mapping_和视差遮挡映射_Parallax Occlusion Mapping_。与使用单一纹理样本相比，它们能通过高度场来创建更好的视差效果。除此之外，它们还可以应用额外的阴影和技术来改进该算法。当我们做的匹配这些方法时，我会调用它。</p>

<h3 id="自定义视差函数">自定义视差函数</h3>

<p>标准着色器仅支持简单的偏移视差映射。 现在，我们要在自己的着色器中添加对视差光线Ray marching的支持。 但是，我们还要继续支持这种简单方法。 两者都需要采样height字段，因此将采样代码行放在单独的GetParallaxHeight函数中。 而且，两种方法的投影视图方向和偏移量的最终应用都相同。 因此，将偏移量计算也单独为一个函数。 它仅需要原始UV坐标和已处理的视图方向作为参数，结果返回要应用的UV偏移。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">GetParallaxHeight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="nf">ParallaxOffset</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">height</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">height</span> <span class="o">-=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">height</span> <span class="o">*=</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">);</span>
        <span class="cp">#if !defined(PARALLAX_OFFSET_LIMITING)
</span>            <span class="cp">#if !defined(PARALLAX_BIAS)
</span>                <span class="cp">#define PARALLAX_BIAS 0.42
</span>            <span class="cp">#endif
</span>            <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">PARALLAX_BIAS</span><span class="p">);</span>
        <span class="cp">#endif
</span>
        <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">ParallaxOffset</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>现在，我们将应用视差函数宏替换对视差偏移的硬编码调用，从而使视差方法更加灵活。如果没有定义它，我们将它设置为使用偏移量方法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplyParallax</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(_PARALLAX_MAP)
</span>        <span class="c1">//...</span>
        <span class="cp">#if !defined(PARALLAX_FUNCTION)
</span>            <span class="cp">#define PARALLAX_FUNCTION ParallaxOffset
</span>        <span class="cp">#endif
</span>        <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">PARALLAX_FUNCTION</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+=</span> <span class="n">uvOffset</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">+=</span> <span class="n">uvOffset</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DetailTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>为RayMarching方法创建一个新函数。与ParallaxOffset函数类似的参数和返回类型。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxOffset</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在可以通过定义_PARALLAX_FUNCTION_来改变着色器中的视差方法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<h3 id="相交计算">相交计算</h3>

<p>为了找到视图射线到达高度场的点，我们需要对射线上的多个点进行采样并计算出在表面下方的位置。第一个采样点在顶部，我们在这里输入高度量，就像使用偏移方法一样。最后一个采样点就是射线到达体积底部的地方。我们会在这些端点之间均匀地添加额外的采样点。</p>

<p>假设每条射线进行10次采样。这意味着我们将对高度图采样10次而不是一次，所以这不是一个便宜计算方法。因为我们用了10个样本，所以步长是0.1。这是我们沿着视图射线移动的因子，也就是UV偏移增量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了应用视差强度，我们可以调整每一步采样的高度。但是缩放UV delta也有同样的效果，只需要计算一次。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>
</code></pre></div></div>

<p>通过这种方式，无论视差强度如何，我们都可以继续使用0–1作为高度场的范围。 因此，射线的第一步高度始终为1。低于或高于该高度的表面点的高度由高度场定义。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span><span class="c1">//步长</span>
<span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>
<span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//步高</span>
<span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
</code></pre></div></div>

<p>现在我们要沿着射线迭代。<strong>首先</strong>，每一步我们都会增加UV偏移量。视图向量指向摄像机，但我们是在向表面移动，所以我们需要减去UV delta。<strong>然后</strong>我们用步高来减小步长。<strong>然后</strong>我们再次对高度图采样。使用while循环重复上述步骤，直到采样完毕。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当编译时，会得到一个编译器警告和错误。这个警告告诉我们在循环中使用了梯度指令。这指的是循环中的纹理采样。GPU必须弄清楚使用哪个mipmap级别，它需要比较相邻片段使用的UV坐标。只有当所有片段执行相同的代码时，它才能对比。对于循环来说，这是不可能的，因为它可以提前终止，每个片段都可能不同。因此编译器将展开循环，这意味着它将一直执行所有9个步骤，而不管逻辑是否可以提前停止。相反，它随后使用确定性逻辑选择最终结果。</p>

<p>编译失败是因为编译器无法确定循环的最大迭代次数。它不知道这个最多是9。通过将while循环转换为执行限制的for循环来明确这一点。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012945572-448280189.png" width="250" /><font size="2.5">
            <i>Raymarching 步进10次 无偏差, 无限制.</i>
        </font></center>

<p>与简单的视差偏移方法相比，视差效果更加明显。较高的区域现在也正确地阻挡了我们后面较低区域的视野。我们还得到了明显的图层，总共10层。</p>

<h3 id="更多步进">更多步进</h3>

<p>这个基本的光线行进方法最适合陡峭的视差贴图。效果的质量是由我们的样本分辨率决定的。一些方法根据视角使用可变的步骤。较浅的角度需要更多的步长，因为光线较长。但我们的样本量是固定的，所以我们不会这样做。</p>

<p>提高质量的明显方法是增加采样的次数，因此让其可配置。使用_PARALLAX_RAYMARCHING_STEPS_，默认值为10，而不是固定的步长和迭代次数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="nf">ParallaxRaymarching</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if !defined(PARALLAX_RAYMARCHING_STEPS)
</span>        <span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
</span>    <span class="cp">#endif
</span>    <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="n">PARALLAX_RAYMARCHING_STEPS</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uvDelta</span> <span class="o">=</span> <span class="n">viewDir</span> <span class="o">*</span> <span class="p">(</span><span class="n">stepSize</span> <span class="o">*</span> <span class="n">_ParallaxStrength</span><span class="p">);</span>

    <span class="n">float</span> <span class="n">stepHeight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span>
        <span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_STEPS</span> <span class="o">&amp;&amp;</span> <span class="n">stepHeight</span> <span class="o">&gt;</span> <span class="n">surfaceHeight</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
        <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
        <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在我们可以在着色器中控制步数。对于真正的高质量，将PARALLAX_RAYMARCHING_STEPS定义为100。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 100
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012948054-536464296.png" width="250" /><font size="2.5">
            <i>Raymarching 100次采样.</i>
        </font></center>

<p>这让我们知道了它的效果能有多好，但它计算量太大了，一般不适合手机。所以把样本数设为10后，我们仍然可以看到视差效果看起来连续和平滑。然而，由视差遮挡引起的轮廓总是锯齿状的，MSAA并不能消除这一点，因为它只适用于几何图形的边缘，而不是纹理效果。只要不依赖深度缓冲区，后处理抗锯齿技术能解决。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>不能按片段写入深度缓冲区吗?
这在足够先进的硬件上确实是可能的，使它能够正确地与高度场相交并应用阴影。不过，它计算量太大。
</code></pre></div></div>

<p>我们当前的方法是沿着射线步进，直到到达表面以下的点，或者到达射线末端可能的最低点。然后我们用UV偏移处理那个点。但隐藏在表面之下的这个点，很可能会出现错误。这就是导致表面撕裂的原因。</p>

<p>增加步长数只会减少最大误差。使用足够的步骤，错误会变得更小，以至于我们无法再看到它。所以当一个表面总是从远处看，你可以用更少的步骤。距离越近，视角越小，需要的样本就越多。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012948690-1598196626.png" width="250" /><font size="2.5">
            <i>Raymarching 100次采样.</i>
        </font></center>

<h3 id="步长之间插值">步长之间插值</h3>

<p>提高质量的一种方法是根据经验预测光线真正到达表面的位置。比如第一步在表面之上，下一步在表面之下。在这两步之间的某个点射线一定到达了表面。</p>

<p>两个射线点、和两个射线点到表面最近的点，能定义两条线段。因为光线和表面碰撞，这两条线段会相交。所以如果我们跟踪前面的步骤，我们可以在循环之后执行直线交叉。我们可以用这个信息来近似出真正的交点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012949277-977122761.png" width="250" /><font size="2.5">
            <i>执行直线交叉.</i>
        </font></center>

<p>在for循环内，我们必须跟踪之前的UV偏移量、步长高度和表面高度。一般来说，这些等于循环之前的第一个样本。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float2</span> <span class="n">prevUVOffset</span> <span class="o">=</span> <span class="n">uvOffset</span><span class="p">;</span>
<span class="n">float</span> <span class="n">prevStepHeight</span> <span class="o">=</span> <span class="n">stepHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">prevSurfaceHeight</span> <span class="o">=</span> <span class="n">surfaceHeight</span><span class="p">;</span>
</code></pre></div></div>

<p>在循环之后，我们计算这些线的交点。我们可以使用这个插值之间的前点和后点的UV偏移。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
<span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
<span class="n">uvOffset</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">prevUVOffset</span><span class="p">,</span> <span class="n">uvOffset</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

<span class="k">return</span> <span class="n">uvOffset</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>数学原理：
这两个线段定义在两个样本步骤之间的空间内。我们将这个空间的宽度设置为1。从前一步到最后一步的直线由点(0，a)和点(1，b)定义，其中a是前一步的高度，b是后一步的高度。因此，可以用线性函数'v(t) = a + (b - a)t'来定义视图线。同样地，面线由点(0，c)和(1，d)定义，函数's(t) = hlsl + (d - hlsl)t'。

交点存在于s(t) = v(t)'处。那么t的值是多少?
c + (d - c)t = a + (b - a)t
(d - c)t - (b - a)t = a - c
(a - c + d - b)t = a - c
t = (a - c) / (a - c + d - b)
注意:a - c是在t = 0处直线高度的绝对差。d - b是t = 1处的绝对高度差。
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012950193-51635460.png" width="250" /><font size="2.5">
            <i>线段交点.</i>
        </font></center>

<p>实际上，在这种情况下，我们可以使用插值器来缩放我们要添加到上一点上的UV偏移量。它可以归结为相同的东西，只是用了更少的数学。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">-</span> <span class="n">difference</span><span class="p">);</span>
<span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012951620-360864955.png" width="250" /></center>

<p>效果看起来好多了。我们现在假设表面在样本点之间是线性的，这可以防止最明显的分层假象。然而，它不能帮助我们检测我们是否错过了步骤之间的交集。我们仍然需要很多的样本来处理小的特征，轮廓和浅角度。</p>

<p>有了这个技巧，我们的方法类似于视差遮挡映射。虽然这是一个相对便宜的改进，但通过定义_PARALLAX_RAYMARCHING_INTERPOLATE_，我们让它成为可选的。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(PARALLAX_RAYMARCHING_INTERPOLATE)
</span>    <span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
    <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>在shader内定义PARALLAX_RAYMARCHING_INTERPOLATE。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<h3 id="步长搜索">步长搜索</h3>

<p>通过在两个步长之间进行线性插值，我们假定表面在两个步长之间是笔直的。 但是，通常情况并非如此。 为了更好地处理不规则的高度场，我们必须在两个步长之间搜索实际的交点。 或至少接近它。</p>

<p>完成循环后，不要使用最后的偏移量，而是将偏移量调整到最后两个步长的中间位置。对该点的高度进行采样。如果我们结束在表面以下，向表面之上方向移动四分之一，并再次采样。如果我们在表面上结束，向表面之下方向移动四分之，并再次采样。不断重复这个过程。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012952340-10743193.png" width="250" /><font size="2.5">
            <i>越来越接近交点.</i>
        </font></center>

<p>上述方法是二分查找的一个应用。它与地形测绘方法最匹配。每走一步，路程减半，直到到达目的地。在我们的例子中，我们将简单地做固定次数，以达到预期的解决方案。一步，得到0.5。两步，得到0.25、0.75。三步，是0.125、0.375、0.625、0.875。注意，从第二步开始，每次采样提升分的辨率将翻倍。</p>

<p>为了控制是否使用此方法，我们定义_PARALLAX_RAYMARCHING_SEARCH_STEPS_。默认情况下将其设置为零，这意味着我们根本不进行搜索。如果它被定义为大于0，我们将不得不使用另一个循环。注意，这种方法与_PARALLAX_RAYMARCHING_INTERPOLATE_是<strong>不兼容</strong>的，因为我们不能再保证表面是交叉的最后两个步骤。当我们搜索的时候，禁用插值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(PARALLAX_RAYMARCHING_SEARCH_STEPS)
</span>    <span class="cp">#define PARALLAX_RAYMARCHING_SEARCH_STEPS 0
#endif
#if PARALLAX_RAYMARCHING_SEARCH_STEPS &gt; 0
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="cp">#elif defined(PARALLAX_RAYMARCHING_INTERPOLATE)
</span>    <span class="n">float</span> <span class="n">prevDifference</span> <span class="o">=</span> <span class="n">prevStepHeight</span> <span class="o">-</span> <span class="n">prevSurfaceHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">surfaceHeight</span> <span class="o">-</span> <span class="n">stepHeight</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prevDifference</span> <span class="o">/</span> <span class="p">(</span><span class="n">prevDifference</span> <span class="o">+</span> <span class="n">difference</span><span class="p">);</span>
    <span class="n">uvOffset</span> <span class="o">=</span> <span class="n">prevUVOffset</span> <span class="o">-</span> <span class="n">uvDelta</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>此循环也执行与原始循环相同的基本工作。调整偏移量和步高，然后采样高度字段。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但每次迭代，UV增量和步长减半。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uvDelta</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">stepSize</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
    <span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>同样，如果点在表面之下，我们必须朝相反的方向移动。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uvDelta</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">stepSize</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">stepHeight</span> <span class="o">&lt;</span> <span class="n">surfaceHeight</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">+=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">+=</span> <span class="n">stepSize</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">uvOffset</span> <span class="o">-=</span> <span class="n">uvDelta</span><span class="p">;</span>
    <span class="n">stepHeight</span> <span class="o">-=</span> <span class="n">stepSize</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">surfaceHeight</span> <span class="o">=</span> <span class="n">GetParallaxHeight</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">);</span>
</code></pre></div></div>

<p>调整着色器，所以它使用三个搜索步骤</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3
#define PARALLAX_FUNCTION ParallaxRaymarching
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012953271-1061541462.png" width="250" /><font size="2.5">
            <i>10步长加上3个二分查找的最终效果.</i>
        </font></center>

<p>结果看起来相当不错，但仍不完美。二分法搜索可以比简单的插值处理较浅的角度，但仍然需要相当多的搜索步骤，以摆脱分层。所以这是一个试验的问题，找出哪种方法在特定情况下最有效，需要多少步骤。</p>

<h3 id="缩放对象和动态批处理">缩放对象和动态批处理</h3>

<p>尽管我们的视差映射方法似乎可行，但存在一个隐藏的错误。 而且还把错误显示出来了。它显示了何时使用动态批处理来组合已缩放的对象。 例如，给我们的四边形一个像\((10,10,10)\)的比例，然后复制它，将副本移到它下面一点。 假设在播放器设置中启用了此选项，这将触发Unity动态批处理四边形。</p>

<p>批处理开始时，视差效果将扭曲。 旋转相机时，这一点非常明显。 但是，这仅发生在游戏视图和构建中，而不发生在场景视图中。 请注意，standard着色器也存在此问题，但是当使用弱偏移视差效果时，您可能不会立即注意到它。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/1692664-20200618012954391-1540920343.png" width="250" /><font size="2.5">
            <i>动态批处理会产生奇怪的结果.</i>
        </font></center>

<p>在批处理将它们合并到一个单一的网格中之后，Unity不能标准化处理后的几何法向量和切向量。因此顶点数据正确的假设不再成立。</p>

<p>顶点法向量和切向量没有规范化不是什么大的问题，因为我们在顶点程序中将视图向量转换到切线空间。对于其他所有内容，数据在使用之前都要标准化。</p>

<p>解决方法是在构造对象转换到切线矩阵之前对向量进行归一化。 因为只有动态批处理的缩放几何才需要此选项，所以根据是否定义了PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING，将其设为可选。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined (_PARALLAX_MAP)
</span>    <span class="cp">#if defined(PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING)
</span>        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="kt">float3x3</span> <span class="n">objectToTangent</span> <span class="o">=</span> <span class="kt">float3x3</span><span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
        <span class="nb">cross</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span>
    <span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">tangentViewDir</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">objectToTangent</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PARALLAX_BIAS 0
</span><span class="c1">//#define PARALLAX_OFFSET_LIMITING</span>
<span class="cp">#define PARALLAX_RAYMARCHING_STEPS 10
#define PARALLAX_RAYMARCHING_INTERPOLATE
#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3
#define PARALLAX_FUNCTION ParallaxRaymarching
#define PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING
</span></code></pre></div></div>
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender20/batched-correct.png" width="250" /><font size="2.5">
            <i>动态批量与正确的结果.</i>
        </font></center>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外的景物，附近的物体看起来很大并且移动很快，而远处的背景看起来很小并且移动较慢。渲染时，相机使用透视模式时，也会出现视差。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender20/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender20/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity GPU Instance(翻译十九)</title><link href="https://www.damonc.top/Unity_GPU_Instance.html" rel="alternate" type="text/html" title="Unity GPU Instance(翻译十九)" /><published>2018-01-24T20:00:00+08:00</published><updated>2018-01-24T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_GPU_Instance</id><content type="html" xml:base="https://www.damonc.top/Unity_GPU_Instance.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>渲染大量球体-优化DrawCall</li>
  <li>支持GPU-Instance</li>
  <li>使用材质属性块</li>
  <li>LOD-Groups支持GPU-Instance</li>
</ul>

<h2 id="batching-instance-批处理">Batching Instance-批处理</h2>

<p>指示GPU绘制需要花时间；向其传递mesh和material属性也要花时间。现在已知两种节省Draw Call的方式：static和<a href="https://docs.unity3d.com/Manual/DrawCallBatching.html"><strong>dynamic batching</strong></a></p>

<p>Unity可以将多个静态物体的网格合并为一个更大的静态网格，从而减少draw call。 <strong>注意：</strong> 只有使用相同材质的对象才能以这种方式组合。 这是以必须存储更多网格数据为代价的。 启用动态批处理后，Unity在运行时会对视图中的动态对象执行相同的操作。 这仅适用于小型网格物体，否则开销将变得太大。</p>

<p>还有另一种组合draw call的方法：GPU instance或Geometry instance。与动态批处理一样，此操作在运行时针对可见对象。 它的目标是让GPU一次性渲染同一网格的多个副本。 因此，它不能组合不同的网格或材质。</p>

<h3 id="创建大量球体">创建大量球体</h3>

<div class="language-plaintext tip-info highlighter-rouge"><div class="highlight"><pre class="highlight"><code>im title?
test test test.
test test test.
test test test!!dfS:FDFH&amp;*YER#.
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">using</span> <span class="n">UnityEngine</span><span class="p">;</span>

<span class="kr">public</span> <span class="k">class</span> <span class="n">GPUInstancingTest</span> <span class="o">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="n">Transform</span> <span class="n">prefab</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">int</span> <span class="n">instances</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">50</span><span class="n">f</span><span class="p">;</span>
    <span class="c1">//单位圆内随机一点并放大坐标50倍，生成5000个球体</span>
    <span class="c1">//然后查看statistics统计的draw Call信息</span>
    <span class="kt">void</span> <span class="n">Start</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
            <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用forward render path统计到的draw call，去掉背景和camera Effect两个draw call：</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010902826-821880737.png" width="250" /><font size="2.5">
            <i>5000 draw call.</i>
        </font></center>

<p>但是当使用cube代替球体</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010904552-338192039.png" width="250" /><font size="2.5">
            <i>6 draw call.</i>
        </font></center>

<h3 id="支持instance">支持Instance</h3>

<p>默认情况下，GPU Instance不会开启，必须设计shader以支持它。 即使这样，也必须为每种材料显式启用实例化。 Unity的standard着色器有一个开关。像标准着色器的GUI一样，我们将为shader扩展面板创建“高级选项”部分。 可以通过调用MaterialEditor.EnableInstancingField方法来添加切换。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoAdvanced</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">GUILayout</span><span class="p">.</span><span class="n">Label</span><span class="p">(</span><span class="s">"Advanced Options"</span><span class="p">,</span> <span class="n">EditorStyles</span><span class="p">.</span><span class="n">boldLabel</span><span class="p">);</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">EnableInstancingField</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>仅当shader实际支持instance时，才会显示该切换。 我们可以通过将#pragma multi_compile_instancing指令添加到着色器base-pass启用此支持。 这将为一些关键字启用着色器变体，自定义关键字_INSTANCING_ON_，其他关键字也可以。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_fwdbase
#pragma multi_compile_fog
#pragma multi_compile_instancing
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010905493-1524350499.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010906722-1492830859.png" width="250" /><font size="2.5">
            <i>合并了，但是显示有错误.</i>
        </font></center>

<p>批处理数量已减少到42，这意味着现在仅用40个批处理即可渲染所有5000个球体。帧速率也高达80 fps，但是只有几个球体可见。<strong>错误原因</strong>：虽然5000个球体仍在渲染，但是在合批中同一批次的所有球体的顶点转换时都使用了同一个位置：它们都使用同一批次中第一个球的转换矩阵。 发生这种情况是因为现在同一批中所有球体的矩阵都作为数组发送到GPU。 在不告知着色器要使用哪个数组索引的情况下，它始终使用第一个索引。</p>

<h3 id="instance-ids">Instance IDs</h3>

<p>上述错误解决办法：每个Instance相对应的数组索引称为其Instance ID，GPU通过顶点数据将其传递到着色器的vertex程序。在大多数平台上，它是一个无符号整数，名为instanceID，具有SV_InstanceID语义。 我们可以简单地使用_UNITY_VERTEX_INPUT_INSTANCE_ID_宏将其包含在我们的VertexData结构中。 它在UnityCG中包含的_UnityInstancing.cginc_文件中定义。 它为我们提供了实例ID的正确定义，或者在未启用实例化时不提供任何内容。将其添加到VertexData结构。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>启用instance后，我们现在可以在顶点程序中访问instanceID。 有了它，我们可以在变换顶点位置时使用正确的矩阵。 但是，UnityObjectToClipPos函数没有矩阵参数，它函数内部始终使用unity_ObjectToWorld矩阵。要解决此问题，UnityInstancing包含文件会使用矩阵数组的宏覆盖unity_ObjectToWorld。 <em>这可以被认为是肮脏的宏技巧，但无需更改现有着色器代码即可工作，从而确保了向后兼容性</em>。</p>

<p>要使它工作，instance的数组索引必须对所有着色器代码全局可用。必须通过_UNITY_SETUP_INSTANCE_ID_宏进行手动设置，该宏必须在vertex程序最先计算，然后再执行其他的代码。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010908398-221325174.png" width="250" /><font size="2.5">
            <i>矩阵替换内部实现？.</i>
        </font></center>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//UnityInstancing中的实际代码要复杂得多。 它要处理平台差异，其他使用实例化的方法以及用于立</span>
<span class="c1">//体声渲染的特殊代码，从而导致间接定义的多个步骤。 它还必须重新定义UnityObjectToClipPos，因</span>
<span class="c1">//为UnityCG首先包含UnityShaderUtilities。</span>
<span class="c1">//缓冲区宏将在后面说明。</span>
<span class="k">static</span> <span class="n">uint</span> <span class="n">unity_InstanceID</span><span class="p">;</span>

<span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityDrawCallInfo</span><span class="p">)</span>
    <span class="c1">// Where the current batch starts within the instanced arrays.</span>
    <span class="n">int</span> <span class="n">unity_BaseInstanceID</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>

<span class="cp">#define UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;
</span>
<span class="cp">#define UNITY_SETUP_INSTANCE_ID(input) \
    unity_InstanceID = input.instanceID + unity_BaseInstanceID;
</span>
<span class="c1">// Redefine some of the built-in variables</span>
<span class="c1">// macros to make them work with instancing.</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">PerDraw0</span><span class="p">)</span>
    <span class="kt">float4x4</span> <span class="n">unity_ObjectToWorldArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
    <span class="kt">float4x4</span> <span class="n">unity_WorldToObjectArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
<span class="cp">#define unity_ObjectToWorld     unity_ObjectToWorldArray[unity_InstanceID]
#define unity_WorldToObject     unity_WorldToObjectArray[unity_InstanceID]
</span></code></pre></div></div>

<h3 id="批处理大小">批处理大小</h3>

<p>每台设备不一样，最终得到的批次数量可能与当前实验得到的数量不同。现在这情况下，以40批渲染5000个球体实例，这意味着每批125个球体。</p>

<p>每个批次都需要自己的矩阵数组。 此数据发送到GPU并存储在内存缓冲区中，在Direct3D中称为常量缓冲区，在OpenGL中称为统一缓冲区。 这些<strong>缓冲区具有最大大小</strong>，这限制了一批中可以容纳多少个实例。 假设台式机GPU每个缓冲区的限制为64KB。</p>

<p>一个矩阵由16个浮点数组成，每个浮点数均为4个字节。 因此，每个矩阵64个字节。 每个实例都需要一个对象到世界的转换矩阵。 但是，我们还需要一个世界到对象的矩阵来转换法线向量。 因此，最终每个实例有128个字节。 这导致最大批处理大小为“ 64000/128 = 500”，这只能在10个批处理中渲染5000个球体。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>内存单位是2进制，所以1KB表示1024字节，而不是1000。因此，'(64 * 1024)/ 128 = 512 '。UNITY_INSTANCED_ARRAY_SIZE默认定义为500，但您可以使用编译器指令覆盖它。例如，#pragma instancing_options maxcount:512将最大值设置为512。但是，这将导致断言失败错误，因此实际限制为511。到目前为止，500和512之间没有太大的差别。
</code></pre></div></div>

<p>即使假设台式机的最大容量为64KB成立，但是大多数移动设备的最大容量远远达不到64，可能仅为16KB。 Unity通过在针对OpenGL ES 3，OpenGL Core或Metal时将最大值除以四来解决此问题。 因为我在编辑器中使用的是OpenGL Core，所以最终的最大批处理大小为“ 500/4 = 125”。</p>

<p>可以通过添加编译器指令#pragma instancing_options force_same_maxcount_for_gl来禁用此自动减少功能。 多个instance选项组合在同一指令中。 但是，这可能会导致在部署到移动设备上时发生故障，因此请小心使用。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>那假设均等缩放选项呢？

可以使用#pragma instancing_options指示所有instance对象具有统一的缩放比例。 这消除了将世界到对象矩阵用于法线转换的需要(少存储一个矩阵)。 设置此选项后，虽然UnityObjectToWorldNormal函数确实会更改其行为，但它不会消除第二个矩阵数组。 因此，至少在Unity 2017.1.0中，此选项实际上没有任何作用。
</code></pre></div></div>

<h3 id="instance-shadows">Instance Shadows</h3>

<p>到目前为止，一直没有阴影。 重新打开主阴影的Soft shadow，并确保阴影距离足以包含所有球体</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010909964-776430193.png" width="250" /><font size="2.5">
            <i>批处理爆炸.</i>
        </font></center>

<p>为大量物体渲染阴影会增加GPU耗能。但是我们也可以在渲染球体阴影时使用GPU instance。在shadow caster-pass中添加instance指令；同时也增加<code class="language-plaintext highlighter-rouge">UNITY_VERTEX_INPUT_INSTANCE_ID</code> and <code class="language-plaintext highlighter-rouge">UNITY_SETUP_INSTANCE_ID</code></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_shadowcaster
#pragma multi_compile_instancing
</span><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
	<span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010911627-1161944067.png" width="250" /><font size="2.5">
            <i>instanced 阴影.</i>
        </font></center>

<h3 id="多光源">多光源</h3>

<p>我们仅在base-pass和shadow caster-pass中添加了instance支持。 因此，批处理不适用于其他光源。 要验证这一点，停用主光源并添加一些会影响多个球体的聚光灯或点光源。 不要为它们打开阴影，因为那样会降低帧速率。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010913312-1389275661.png" width="250" /><font size="2.5">
            <i>批处理爆炸.</i>
        </font></center>

<p>上图，完全不支持多光源批处理。 要将instance与多个光源结合使用，只能切换到延迟渲染路径。 为此，请将所需的编译器指令添加到着色器的延迟传递中。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_prepassfinal
#pragma multi_compile_instancing
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010914967-1310775534.png" width="250" /><font size="2.5">
            <i>多光源instance.</i>
        </font></center>

<h2 id="mixing-material-properties">Mixing Material Properties</h2>

<p>所有批处理都有一个限制：它们仅限于具有相同材料的对象。 当我们希望渲染的对象具有多样性时，此限制就会成为问题。</p>

<h3 id="随机着色">随机着色</h3>

<p>随机改变球体的颜色</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">MeshRenderer</span><span class="o">&gt;</span><span class="p">().</span><span class="n">material</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span>    <span class="kr">new</span> <span class="n">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010916576-490651101.png" width="250" /><font size="2.5">
            <i>球体与随机的颜色，没有批量和阴影.</i>
        </font></center>

<p>即使我们为物料启用了批处理，它也不再起作用。由于每个球体现在都有自己的材质，因此每个球体的着色器状态也必被更改。 这显示在统计面板中为SetPass call的数量。在这修改之前只有少量几个批次渲染，但是现在是5000加批次。</p>

<h3 id="材质属性块-material-property-blocks">材质属性块-Material Property Blocks</h3>

<p>除了为每个球体创建新的材质实例外，我们还可以使用材质属性块。 这些是小的修改，设置属性块的颜色并将其传递给球体的渲染器，而不是直接分配材质的颜色。<a href="http://docs.unity3d.com/Documentation/ScriptReference/MaterialPropertyBlock.html">MaterialPropertyBlock</a>官网介绍;</p>

<h3 id="property-buffers-属性缓冲区">Property Buffers-属性缓冲区</h3>

<p>渲染instance对象时，Unity通过数组形式将颜色数据传递到GPU内存并转换矩阵，Unity对存储在材料属性块中的属性执行相同的操作，但要使其起作用的话，我们必须在shader中定义一个instance的缓冲区。</p>

<p>声明instance缓冲区的工作类似于创建诸如插值器之类的结构，但是确切的语法因平台而异。 我们可以使用UNITY_INSTANCING_CBUFFER_START和UNITY_INSTANCING_CBUFFER_END宏来解决差异。 启用实例化后，它们将不执行任何操作。</p>

<p>将_Color变量的定义放在instance缓冲区中。 UNITY_INSTANCING_CBUFFER_START宏需要一个名称参数，实际名称无关紧要但要注意避免重名冲突。 宏以UNITY_INSTANCING_为其前缀。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="kt">float4</span> <span class="n">_Color</span><span class="p">;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div>

<p>像变换矩阵一样，启用instance后，颜色数据作为数组上传到GPU。UNITY_DEFINE_INSTANCED_PROP宏会为我们处理正确的声明语法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="c1">//float4 _Color;</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div>

<p>最后要访问fragment程序中的数组，我们还需要在其中知道instanceID。 因此，将其添加到插值器结构中。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在vertex顶点程序中，将ID从顶点数据复制到插值器。 启用实例化时，UNITY_TRANSFER_INSTANCE_ID宏定义此简单操作，否则不执行任何操作。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在片段程序的开头，使ID全局可用，就像在顶点程序中一样。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，我们必须在不使用instance时以_Color的形式访问颜色，而在启用实例化时以_Color [unity_InstanceID]的形式访问颜色。 使用UNITY_ACCESS_INSTANCED_PROP宏可同时支持上述两种访问。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="nf">GetAlbedo</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">albedo</span> <span class="o">=</span>
        <span class="nb">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>新版本如果编译有错误：
从2017.3及以上版本, UNITY_ACCESS_INSTANCED_PROP macro改了它需要的两个参数：buffer名，颜色名使用UNITY_ACCESS_INSTANCED_PROP(InstanceProperties, _Color).
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010918398-38688989.png" width="250" /></center>

<p>现在，我们的颜色随机的球再次被批处理。 我们<strong>可以用相同的方式使其他属性可变。 对于颜色，浮点数，矩阵和四分量浮点向量，这是可能的</strong>。 <strong>如果要改变纹理，可以使用单独的纹理数组</strong>，并将索引添加到实例化缓冲区。其他属性修改类似。</p>

<p>可以在同一个缓冲区中组合多个属性，但要牢记大小限制。 还应注意，缓冲区被划分为32位块，因此单个浮点数需要与向量相同的空间。 您也可以使用多个缓冲区，但是也有一个限制，它们不是免费提供的。 启用instance后，每个要缓冲的属性都将成为一个数组，因此仅对需要根据instance变化的属性执行此操作。</p>

<h3 id="阴影">阴影</h3>

<p>我们的阴影也取决于颜色。 调整shader阴影以便每个实例也可以支持唯一的颜色。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//float4 _Color;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>

<span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">float4</span> <span class="nf">MyShadowFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="lod-instance">LOD Instance</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialPropertyBlock</span> <span class="n">properties</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="p">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="nf">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="c1">//MaterialPropertyBlock properties = new MaterialPropertyBlock();</span>
        <span class="n">properties</span><span class="p">.</span><span class="nf">SetColor</span>
        <span class="p">(</span>
            <span class="s">"_Color"</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="c1">//t.GetComponent&lt;MeshRenderer&gt;().SetPropertyBlock(properties);</span>
        <span class="n">MeshRenderer</span> <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> 
        <span class="p">{</span>
            <span class="c1">//对LOD子对象设置颜色</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ci</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">ci</span> <span class="p">&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">childCount</span><span class="p">;</span> <span class="n">ci</span><span class="p">++)</span> <span class="p">{</span>
                <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">GetChild</span><span class="p">(</span><span class="n">ci</span><span class="p">).</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010919954-2006515171.png" width="250" /></center>

<p>不幸的是没有有效的批处理。Unity能够对以相同的LOD颜色球体进行批处理，但是如果可以像往常一样进行批处理会更好。 我们可以通过用缓冲数组替换unity_LODFade来实现。可以通过为支持实例化的每个过程添加lodfade实例化选项来指示Unity的着色器代码执行此操作。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_instancing
#pragma instancing_options lodfade
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010921540-656727216.png" width="250" /><font size="2.5">
            <i>instance LOD fading.</i>
        </font></center>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[还有另一种组合draw call的方法：GPU instance或Geometry instance。与动态批处理一样，此操作在运行时针对可见对象。 它的目标是让GPU一次性渲染同一网格的多个副本。 因此，它不能组合不同的网格或材质，但不仅限于小网格。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender19/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender19/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity 实时 GI &amp;amp; LPPV &amp;amp; LOD(翻译十八)</title><link href="https://www.damonc.top/Unity_RealTime_GI_LOD.html" rel="alternate" type="text/html" title="Unity 实时 GI &amp;amp; LPPV &amp;amp; LOD(翻译十八)" /><published>2018-01-23T20:00:00+08:00</published><updated>2018-01-23T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_RealTime_GI_LOD</id><content type="html" xml:base="https://www.damonc.top/Unity_RealTime_GI_LOD.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>支持实时全局光照</li>
  <li>用动画控制发光对GI的贡献</li>
  <li>使用光照探针代理体LPPV</li>
  <li>LOD组与GI结合</li>
  <li>LOD之间的淡入淡出</li>
</ul>

<p>从这篇开始，这个系列教程将由Unity 2017.1.0f3来完成。后续的Shader新特性Unity的旧版本没有，因为我们要使用一个新的着色器函数。</p>

<h2 id="实时全局光照">实时全局光照</h2>

<p>　　烘焙光照在静态物体上工作的非常好，对于动态几何体，由于有光照探针的缘故，烘焙光照这种方法也能工作的非常好。<strong>但是</strong>，烘焙光照不能处理动态光源。混合模式的光源可以通过一些实时的调节来消除，但调节的太多使得烘焙出来的间接光照不会改变。所以当你有一个户外场景的话，使用烘焙光照这种方法太阳的光照就不能有变化。太阳不能像在现实生活中一样在天空中移动，因为如果需要太阳在天空中移动的话，就需要逐渐变化的全局光照。所以场景必须一直不变。</p>

<p>　　为了使间接光照能够在移动的太阳这样的情况发挥作用，Unity使用Enlighten系统来计算实时全局光照。除了在运行时计算光照和光照探针以外，它还采用烘焙间接光照一样的方式来工作。</p>

<p>　　了解间接光需要知道光在静态表面之间如何反射。重点在于哪些表面可能会受到其他表面的影响，以及程度如何。弄清这些关系需要做很多的工作，不能实时完成。所以这个数据由编辑器处理并存储在运行时使用。然后 Enlighten系统会使用这个数据来计算实时光照贴图和探针数据。即使如此，只有低分辨率的光照贴图才可以在实时情况下运行。</p>

<h3 id="启用全局光照">启用全局光照</h3>

<p>实时全局光照、烘焙全局光照都可以独立启用。你可以同时启用两个，或者启用其中的一个，或者两个都不启用。这两个选项都是通过“光照”窗口的“实时照光照”部分中的复选框启用。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605003217232-1241081746.png" width="250" /><font size="2.5">
            <i>实时全局光照和烘焙光照同时启用的状态.</i>
        </font></center>

<p>要实际查看实时全局光照，请将测试场景中的主光源的模式设置为实时模式。 由于我们没有其他光源，即使启用了烘焙光照也能有效地关闭。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605003333043-1240937953.png" width="250" /><font size="2.5">
            <i>主光源设置为实时模式.</i>
        </font></center>

<p>确保场景中的所有对象都使用我们的白色材质。 像上次一样，球体都是动态的，而其他的都是静态几何体。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605003421685-903339628.png" width="250" /><font size="2.5">
            <i>只有动态对象能接收实时的全局光照.</i>
        </font></center>

<p>事实证明，只有动态对象会受益于实时全局光照。静态物体会变的暗一点。这是因为光照探针自动并入实时全局光照。而静态对象必须对实时的光照贴图进行采样，而这些光照贴图与烘焙的光照贴图不同。我们的着色器还不支持。</p>

<h3 id="烘焙的全局光照">烘焙的全局光照</h3>

<p>Unity在编辑模式下已经生成了实时的光照贴图，所以你可以随时查看实时的全局光照贴图。在编辑模式和播放模式之间进行切换的时候，这些贴图不会被保留，但是它们最终会得到相同的结果。你可以通过“光照”窗口的“对象贴图”选项来选择一个光照贴图静态对象对实时光照贴图进行检查。 选择“实时强度“可以可视化的查看实时光照贴图的数据。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605003617860-357493611.png" width="250" /><font size="2.5">
            <i>实时光照贴图，屋顶被选中时候的状态.</i>
        </font></center>

<p>虽然实时光照贴图已经被烘焙出来，并且它们还可能显示正确，但我们的meta渲染通道实际上使用的是错误的坐标。实时全局光照具有自己的光照贴图坐标，最终可能与静态光照贴图的坐标不同。Unity会根据光照贴图和对象的设置来自动生成这些坐标。这些数据存储在第三套UV中。所以将这些数据添加到My Lightmapping中的VertexData里面。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv2</span> <span class="o">:</span> <span class="nb">TEXCOORD2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>现在，MyLightmappingVertexProgram必须使用第二个或是第三个UV坐标，以及静态或动态光照贴图的大小和偏移量。 我们可以依靠UnityMetaVertexPosition函数来使用正确的数据。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyLightmappingVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
<span class="c1">//    v.vertex.xy = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;</span>
<span class="c1">//    v.vertex.z = v.vertex.z &gt; 0 ? 0.0001 : 0;</span>
<span class="c1">//    i.pos = UnityObjectToClipPos(v.vertex);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityMetaVertexPosition</span><span class="p">(</span>
        <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv2</span><span class="p">,</span> <span class="n">unity_LightmapST</span><span class="p">,</span> <span class="n">unity_DynamicLightmapST</span>
    <span class="p">);</span>

    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityMetaVertexPosition</span><span class="err">是什么样子的？</span>

<span class="err">它除了通过</span><span class="n">unity_MetaVertexControl</span><span class="err">提供的标志来决定使用哪些坐标集和光照贴图之外，它还做了我们以前做的工作。</span>
<span class="kt">float4</span> <span class="nf">UnityMetaVertexPosition</span> <span class="p">(</span>
    <span class="kt">float4</span> <span class="n">vertex</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uv1</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uv2</span><span class="p">,</span>
    <span class="kt">float4</span> <span class="n">lightmapST</span><span class="p">,</span> <span class="kt">float4</span> <span class="n">dynlightmapST</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaVertexControl</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">uv1</span> <span class="o">*</span> <span class="n">lightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">lightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
        <span class="c1">// OpenGL right now needs to actually use incoming vertex position,</span>
        <span class="c1">// so use it in a very dummy way</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">1.0e-4</span><span class="n">f</span> <span class="o">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaVertexControl</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">uv2</span> <span class="o">*</span> <span class="n">dynlightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">dynlightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
        <span class="c1">// OpenGL right now needs to actually use incoming vertex position,</span>
        <span class="c1">// so use it in a very dummy way</span>
        <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">1.0e-4</span><span class="n">f</span> <span class="o">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>请注意，<strong>meta渲染通道既用于烘焙光照贴图，也用于实时光照贴图</strong>。所以当使用实时全局光照的时候，meta渲染通道也将被包含在构建中。</p>

<h3 id="对实时光照贴图进行采样">对实时光照贴图进行采样</h3>

<p>为了对实时光照贴图进行采样，我们还必须将第三个UV坐标添加到My Lightmapping中的VertexData里面。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="nb">NORMAL</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">tangent</span> <span class="o">:</span> <span class="nb">TANGENT</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv2</span> <span class="o">:</span> <span class="nb">TEXCOORD2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>当一张实时光照贴图被使用的时候，我们必须将这个光照贴图的坐标添加到我们的插值器中去。标准着色器在单个插值器中将两个光照贴图的坐标集合组合起来 - 与其他数据复用 - 但是我们可以为两者准备单独的插值器。当_DYNAMICLIGHTMAP_ON_关键字被定义的时候，我们知道有动态光照数据。它是multi_compile_fwdbase编译器指令的关键字列表的一部分。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> 
<span class="p">{</span>
    <span class="cp">#if defined(DYNAMICLIGHTMAP_ON)
</span>        <span class="kt">float2</span> <span class="n">dynamicLightmapUV</span> <span class="o">:</span> <span class="n">TEXCOORD7</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>填充坐标就像对静态光照贴图的坐标所做的事情一样，除了动态光照图的缩放比例和偏移量的设置以外，这些可以通过unity_DynamicLightmapST变得可用。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined(DYNAMICLIGHTMAP_ON)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">dynamicLightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv2</span> <span class="o">*</span> <span class="n">unity_DynamicLightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_DynamicLightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>对实时光照贴图的采样是在我们的CreateIndirectLight函数中完成的。复制 #if defined(LIGHTMAP_ON) 代码块并进行一些更改。 <strong>首先</strong>，新的部分是基于DYNAMICLIGHTMAP_ON关键字的。 <strong>此外</strong>，它应该使用DecodeRealtimeLightmap而不是DecodeLightmap，这是因为实时光照贴图使用不同的颜色格式。而且因为这些数据可能被添加到烘焙光照中，不要立即分配给indirectLight.diffuse，而是使用最后添加的中间变量。 <strong>最后</strong>，当不使用烘焙光照贴图和实时光照贴图的时候，我们只应该对球面谐波进行采样。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(LIGHTMAP_ON)
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span>    <span class="n">DecodeLightmap</span><span class="p">(</span><span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">));</span>
    <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>        <span class="kt">float4</span> <span class="n">lightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
            <span class="n">unity_LightmapInd</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span>
        <span class="p">);</span>
        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeDirectionalLightmap</span><span class="p">(</span>
            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">lightmapDirection</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span>
        <span class="p">);</span>
    <span class="cp">#endif
</span>
    <span class="n">ApplySubtractiveLighting</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">);</span>
   <span class="c1">// #else</span>
   <span class="c1">// indirectLight.diffuse += max(0, ShadeSH9(float4(i.normal, 1)));</span>
<span class="cp">#endif
</span>
<span class="cp">#if defined(DYNAMICLIGHTMAP_ON)
</span>    <span class="kt">float3</span> <span class="n">dynamicLightDiffuse</span> <span class="o">=</span> <span class="n">DecodeRealtimeLightmap</span><span class="p">(</span>
        <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_DynamicLightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">dynamicLightmapUV</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>        <span class="kt">float4</span> <span class="n">dynamicLightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
            <span class="n">unity_DynamicDirectionality</span><span class="p">,</span> <span class="n">unity_DynamicLightmap</span><span class="p">,</span>
            <span class="n">i</span><span class="p">.</span><span class="n">dynamicLightmapUV</span>
        <span class="p">);</span>
                <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="n">DecodeDirectionalLightmap</span><span class="p">(</span>
                    <span class="n">dynamicLightDiffuse</span><span class="p">,</span> <span class="n">dynamicLightmapDirection</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span>
                <span class="p">);</span>
    <span class="cp">#else
</span>        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="n">dynamicLightDiffuse</span><span class="p">;</span>
    <span class="cp">#endif
#endif
</span>
<span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013216623-414124444.png" width="250" /><font size="2.5">
            <i>把实时全局光照应用于一切物体之上.</i>
        </font></center>

<p>现在我们的着色器使用的是实时光照贴图。最初，当使用Distance Shadowmask模式的时候，它的效果可能看起来与使用混合光源的烘焙光照的效果相同。当在播放模式下关闭光源的时候，差异就变得非常明显。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013217805-1029939389.png" width="250" /><font size="2.5">
            <i>禁用混合光源以后，间接光照仍然被保留.</i>
        </font></center>

<p>禁用混合光源以后，其间接光照将保持不变。相比之下，实时光照的间接贡献就会消失，并重新出现 - 这是应该出现的情况。 不过，新情况的完全烘焙好可能需要一段时间。 Enlighten系统会逐步调整光照贴图和光照探针。 这种情况发生的速度取决于场景的复杂性和实时全局光照CPU质量设置。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013219337-640958770.gif" width="250" /><font size="2.5">
            <i>切换实时光与实时GI.</i>
        </font></center>

<p>所有实时光源都对实时全局光照有贡献。 然而，它的典型用途是那些仅在主要方向上存在光线的光源，比如可以代表太阳，因为它在天空中移动。它适用于方向光源。点光源和聚光光源也能工作，但只是没有阴影。所以<strong>当使用带有阴影的点光源或聚光光源的时候，你可能会遇到不正确的间接光照结果</strong>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013220298-1170450196.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013221104-52400640.png" width="250" /><font size="2.5">
            <i>没有影响的间接光源和实时的聚光光源.</i>
        </font></center>

<p>如果要从实时全局光照里面去掉一个实时光源，可以通过设置它的Indirect Multiplier将它的光强度设置为零。</p>

<h3 id="自发光光源">自发光光源</h3>

<p>实时全局光照也可以用于自发光的静态物体。这使得可以匹配实时间接光照来改变物体的自发光变得可能。让我们来试试看吧。向场景中添加一个静态球体，并赋予它一个使用我们着色器的材质，这个材质具有黑色的反照率和白色的自发光颜色。最初，我们只能看到通过静态光照贴图实现的自发光的间接效果。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013222060-1153434303.png" width="250" /><font size="2.5">
            <i>用自发光球来烘焙全局光照.</i>
        </font></center>

<p>要将自发光光源烘焙到静态光照贴图中，我们必须在我们的着色器的GUI中设置材质的全局光照标志。因为我们总是将标志设置为BakedEmissive，光源最终将以烘焙好的光照贴图的形式出现。如果自发光光源是恒定的这个效果是很不错的，但这样就不允许我们做动画控制。</p>

<p>为了同时对自发光光源支持烘焙和实时光照，我们必须使其可配置化。我们可以通过向MyLightingShaderGUI中添加一个选项来做到这一点，使用的是MaterialEditor.LightmapEmissionProperty方法。这个方法的单个参数是属性的缩进级别。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoEmission</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialProperty</span> <span class="n">map</span> <span class="o">=</span> <span class="n">FindProperty</span><span class="p">(</span><span class="s">"_EmissionMap"</span><span class="p">);</span>
    <span class="n">Texture</span> <span class="n">tex</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">;</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="n">BeginChangeCheck</span><span class="p">();</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">TexturePropertyWithHDRColor</span><span class="p">(</span>
        <span class="n">MakeLabel</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="s">"Emission (RGB)"</span><span class="p">),</span> <span class="n">map</span><span class="p">,</span> <span class="n">FindProperty</span><span class="p">(</span><span class="s">"_Emission"</span><span class="p">),</span>
        <span class="n">emissionConfig</span><span class="p">,</span> <span class="nb">false</span>
    <span class="p">);</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">LightmapEmissionProperty</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="n">EndChangeCheck</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tex</span> <span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">SetKeyword</span><span class="p">(</span><span class="s">"_EMISSION_MAP"</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">editor</span><span class="p">.</span><span class="n">targets</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">globalIlluminationFlags</span> <span class="o">=</span>
                <span class="n">MaterialGlobalIlluminationFlags</span><span class="p">.</span><span class="n">BakedEmissive</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>每次当自发光属性发生改变的时候，我们也必须停止覆盖这个标志位。其实真正要做的事情比这更复杂一点。其中一个标志选项是EmissiveIsBlack，这个表示表示的是自发光计算可以跳过。这个标志总是会针对新材质进行设置。要让间接自发光能够工作，我们必须保证这个标志不被设置，无论我们选择实时光照还是烘焙。我们可以通过总是屏蔽标志值的EmissiveIsBlack位来做到这一点。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">editor</span><span class="p">.</span><span class="n">targets</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">.</span><span class="n">globalIlluminationFlags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MaterialGlobalIlluminationFlags</span><span class="p">.</span><span class="n">EmissiveIsBlack</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013222795-276798177.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013223641-2073252267.png" width="250" /><font size="2.5">
            <i>带有自发光球的实时全局光照效果.</i>
        </font></center>

<p>烘焙全局光照和实时全局光照之间的视觉差异主要是因为实时光照贴图通常具有比烘焙全局光照更低的分辨率。所以当自发光不发生不变化的时候，你也可以使用烘焙全局光照，确保能够利用其更高的分辨率。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EmissiveIsBlack的目的是什么？

这是一个优化，使得计算可以跳过全局光照烘焙过程。然而，只有当自发光颜色确实是黑色的时候，它才依赖于标志。由于这个标志位由着色器的GUI进行设置，这是当材质在检视器里面进行编辑的时候确定的。或者至少，这是Unity的标准着色器的做法。因此，如果自发光颜色稍后被脚本或动画系统更改，则该标志位不会做相应的调整。这是许多人不理解为什么对自发光做动画不会影响到实时全局光照的原因。结果就是如果你想在运行时更改自发光颜色，那么就不要将自发光颜色设置为纯黑色。

我们没有使用这种方法，我们使用的是LightmapEmissionProperty，它还提供了对自发光完全关闭全局光照的选项。 所以这个选择对于用户来说是非常明确的，没有任何隐藏的行为。如果用户不要使用自发光？ 那么只要确保它的全局光照被设置为None就可以了。
</code></pre></div></div>

<h3 id="对自发光进行动画控制">对自发光进行动画控制</h3>

<p>用于自发光的实时全局光照只能用于静态对象。虽然物体是静态的，但其材质的自发光属性还是可以被动画化，并且<strong>将被全局光照系统所捕获到</strong>。让我们用一个在自发光颜色为白色和自发光颜色为黑色之间振荡的简单组件来尝试下这个事情。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">EmissiveOscillator</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="n">Material</span> <span class="n">emissiveMaterial</span><span class="p">;</span>
    <span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">emissiveMaterial</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;().</span><span class="n">material</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">Color</span> <span class="n">c</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span>
            <span class="n">Color</span><span class="p">.</span><span class="n">white</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">black</span><span class="p">,</span>
            <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">Time</span><span class="p">.</span><span class="n">time</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">PI</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5f</span> <span class="p">+</span> <span class="m">0.5f</span>
        <span class="p">);</span>
        <span class="n">emissiveMaterial</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="s">"_Emission"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>将这个组件添加到我们的自发光球体。在播放模式下，自发光将会动画化，但间接光照不受影响。我们必须通知实时光照系统，它有工作要做。这可以通过调用适当网格渲染器的Renderer.UpdateGIMaterials方法来完成。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MeshRenderer</span> <span class="n">emissiveRenderer</span><span class="p">;</span>
<span class="n">Material</span> <span class="n">emissiveMaterial</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">emissiveRenderer</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
    <span class="n">emissiveMaterial</span> <span class="p">=</span> <span class="n">emissiveRenderer</span><span class="p">.</span><span class="n">material</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">emissiveMaterial</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="s">"_Emission"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="n">emissiveRenderer</span><span class="p">.</span><span class="nf">UpdateGIMaterials</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013226755-1065411582.gif" width="250" /><font size="2.5">
            <i>动画控制实时GI.</i>
        </font></center>

<p>调用UpdateGIMaterials方法会触发物体自发光的完整更新，并<strong>使用其meta渲染通道进行渲染</strong>。当自发光比纯色更复杂的时候，这是必要的，举个简单的例子来说，比如说我们使用纹理。如果一个<strong>纯色</strong>就足够了，那么我们可以通过使用渲染器和自发光颜色<strong>调用DynamicGI.SetEmissive方法</strong>来得到一个比较快捷的计算方式。这<strong>比使用meta渲染通道来渲染物体更快</strong>，所以在能够使用的时候可以利用这种方法。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//emissiveRenderer.UpdateGIMaterials();</span>
<span class="n">DynamicGI</span><span class="p">.</span><span class="nf">SetEmissive</span><span class="p">(</span><span class="n">emissiveRenderer</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="光照探针">光照探针</h2>

<p>烘焙全局光照和实时全局光照都通过光照探针应用于动态对象。物体的位置用于对光探针数据进行插值，然后将其用于全局光照。这对于相当小的物体来说下效果很好，但对于较大的物体来说就太粗糙了。</p>

<p>举个简单的例子来是说，将做了比较大拉伸的立方体添加到测试场景，以便它可以受到不同的光照条件的影响。它应该使用我们的白色材质。由于它是一个动态立方体，所以最终使用一个点来确定它的全局光照贡献。让我们移动这个点的位置，使得这一点最终处于一个被遮蔽的位置，那么整个立方体就会变黑，这显然是错误的。为了使这一点非常明显，让我们使用一个烘焙主光源，所以所有光照都来自烘焙全局光照和实时全局光照的数据。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013229006-1893115114.png" width="250" /><font size="2.5">
            <i>对于大型动态物体来说，光照效果不好.</i>
        </font></center>

<p>为了使光照探针器适用于这样的情况，我们可以使用光照探针代理体，或者简称为LPPV。这可以通过向着色器发送插值后的探针器数据网格而不是单个插值后的探针器数据来做到。这需要具有线性滤波的浮点数3D纹理，这就将这个方法限制到只能在现代显卡上使用。此外，还要确保在图形层设置中启用LPPV（光照探针代理体）支持。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013229758-553683463.png" width="250" /><font size="2.5">
            <i>启用了LPPV（光照探针代理体）支持.</i>
        </font></center>

<h3 id="向物体中添加一个光照探针代理体">向物体中添加一个光照探针代理体</h3>

<p>光照探针代理体可以以各种方式设置，最直接的方法是在作为使用光照探针代理体的物体的一个组件。你可以通过Component / Rendering / Light Probe Proxy Volume来添加它。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013230509-1112003195.png" width="250" /><font size="2.5">
            <i>光照探针代理体组件.</i>
        </font></center>

<p>LPPV（光照探针代理体）通过在运行时在光照探针之间进行插值来工作，就好像它们是常规动态对象的网格一样。插值后得到的结果被缓存，刷新模式（Refresh Mode）控制在何时进行更新。默认值为“自动（Automatic）”，这意味着当动态全局光照更改和探针器组发生移动的时候会触发更新。包围盒模式（Bounding Box Mode）控制着代理体的定位。自动本地化（AutomaticLocal ）意味着它会去匹配其附着的对象的包围盒。这些默认设置适用于我们的立方体，因此我们将保留这些设置。</p>

<p>要使我们的立方体实际使用LPPV（光照探针代理体），我们必须将其网格渲染器的光照探针(Light Probes)模式设置为使用光照探针代理体（Use ProxyVolume）。默认行为是使用对象本身的LPPV（光照探针代理体）组件，但也可以强制使用另一个代理体。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013231203-999964017.png" width="250" /><font size="2.5">
            <i>使用一个光照探针代理体而不是常规的探针器.</i>
        </font></center>

<p>自动分辨率模式（automaticresolution mode）对于我们的拉伸立方体不起作用。 因此，将“分辨率模式（Resolution Mode ）”设置为“自定义（Custom ）”，并确保立方体的角上有采样点，并沿着其长边有多个样本点。当你选中这个对象的时候，可以看到这些采样点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013231870-1652713364.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013232779-1496013065.png" width="250" /><font size="2.5">
            <i>自定义探针器分辨率以适应拉伸的立方体.</i>
        </font></center>

<h3 id="对光照探针代理体进行采样">对光照探针代理体进行采样</h3>

<p>立方体已变黑，因为我们的着色器现在还不支持LPPV（光照探针代理体）采样。为了使其工作，我们必须在CreateIndirectLight函数内调整球面谐波代码。当使用LPPV（光照探针代理体）的时候，_UNITY_LIGHT_PROBE_PROXY_VOLUME_被定义为1。我们在这种情况下什么都不做，看看会发生什么。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
</span>    <span class="cp">#if UNITY_LIGHT_PROBE_PROXY_VOLUME
</span>    <span class="c1">//...</span>
    <span class="cp">#else
</span>        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013233601-1847365803.png" width="250" /><font size="2.5">
            <i>没有更多球面谐波的效果.</i>
        </font></center>

<p>得到的结果是所有的球面谐波被禁用，对于不使用LPPV（光照探针代理体）的动态对象也是如此。这是因为_UNITY_LIGHT_PROBE_PROXY_VOLUME_在项目范围内定义，而不是对每个对象实例进行定义。单个对象是否使用LPPV由UnityShaderVariables中定义的unity_ProbeVolumeParams的X分量指定。如果unity_ProbeVolumeParams的X分量设置为1，那么我们有一个LPPV（光照探针代理体），否则我们应该使用常规的球面谐波。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if UNITY_LIGHT_PROBE_PROXY_VOLUME
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="p">}</span>
<span class="cp">#else
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>要对光照探针代理体进行采样，我们可以使用SHEvalLinearL0L1_SampleProbeVolume函数而不是ShadeSH9。这个函数在UnityCG中进行定义，并且需要世界空间中的位置作为额外的参数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SHEvalLinearL0L1_SampleProbeVolume</span>
    <span class="p">(</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span>
    <span class="p">);</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SHEvalLinearL0L1_SampleProbeVolume如何工作？

_顾名思义，该函数仅包括前两个球面谐波带L0和L1。 Unity不使用LPPV（光照探针代理体）的第三个波带。所以我们得到较低质量的光照近似值，但是我们在多个世界空间中的样本之间进行插值，而不是使用单个点。下面是这个函数的代码。_
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">half3</span> <span class="nf">SHEvalLinearL0L1_SampleProbeVolume</span> <span class="p">(</span><span class="kt">half4</span> <span class="n">normal</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">float</span> <span class="n">transformToLocal</span> <span class="o">=</span> <span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">float</span> <span class="n">texelSizeX</span> <span class="o">=</span> <span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>

    <span class="c1">//The SH coefficients textures and probe occlusion</span>
    <span class="c1">// are packed into 1 atlas.</span>
    <span class="c1">//-------------------------</span>
    <span class="c1">//| ShR | ShG | ShB | Occ |</span>
    <span class="c1">//-------------------------</span>

    <span class="kt">float3</span> <span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="n">transformToLocal</span> <span class="o">==</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)</span> <span class="o">?</span>
        <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ProbeVolumeWorldToObject</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span> <span class="o">:</span>
        <span class="n">worldPos</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">texCoord</span> <span class="o">=</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">unity_ProbeVolumeMin</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">unity_ProbeVolumeSizeInv</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span><span class="p">;</span>

    <span class="c1">// We need to compute proper X coordinate to sample. Clamp the</span>
    <span class="c1">// coordinate otherwize we'll have leaking between RGB coefficients</span>
    <span class="n">float</span> <span class="n">texCoordX</span> <span class="o">=</span>
        <span class="nb">clamp</span><span class="p">(</span><span class="n">texCoord</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span> <span class="o">*</span> <span class="n">texelSizeX</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span> <span class="o">*</span> <span class="n">texelSizeX</span><span class="p">);</span>

    <span class="c1">// sampler state comes from SHr (all SH textures share the same sampler)</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoordX</span><span class="p">;</span>
    <span class="kt">half4</span> <span class="n">SHAr</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX3D_SAMPLER</span><span class="p">(</span>
        <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">texCoord</span>
    <span class="p">);</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoordX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">half4</span> <span class="n">SHAg</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX3D_SAMPLER</span><span class="p">(</span>
        <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">texCoord</span>
    <span class="p">);</span>
    <span class="n">texCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">texCoordX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">half4</span> <span class="n">SHAb</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX3D_SAMPLER</span><span class="p">(</span>
        <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">texCoord</span>
    <span class="p">);</span>
    <span class="c1">// Linear + constant polynomial terms</span>
    <span class="kt">half3</span> <span class="n">x1</span><span class="p">;</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">SHAr</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">SHAg</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">SHAb</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">x1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013235369-787618137.png" width="250" /><font size="2.5">
            <i>采样后的LPPV（光照探针代理体）的效果，在伽马空间中的效果太暗.</i>
        </font></center>

<p>我们的着色器现在在需要的时候对LPPV（光照探针代理体）进行采样，但结果太暗了。至少在伽马颜色空间中工作就是这样的结果。这是因为球面谐波数据存储在线性空间中。因此，可能需要进行颜色的转换。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SHEvalLinearL0L1_SampleProbeVolume</span><span class="p">(</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span>
    <span class="p">);</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
    <span class="cp">#if defined(UNITY_COLORSPACE_GAMMA)
</span>               <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">LinearToGammaSpace</span><span class="p">(</span><span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
        <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013236310-749557848.png" width="250" /><font size="2.5">
            <i>采样后的LPPV（光照探针代理体）的效果，带有正确的颜色.</i>
        </font></center>

<h2 id="lod-groups">LOD Groups</h2>

<p>当一个对象最终只覆盖应用程序窗口的一小部分的时候，你不需要高度详细的网格来渲染它。你可以根据对象在视图中的大小使用不同的网格。这被称为细节层次，或简称LOD。Unity允许我们通过组件LOD组来实现这样的功能。</p>

<h3 id="创建一个lod层次结构">创建一个LOD层次结构</h3>

<p>这个想法是你在各种不同的LOD等级使用同一网格的多个版本。最高级 - LOD 0 - 具有最多的顶点、子对象、动画、复杂的材质等。随后的级别逐渐变得更简单，更容易计算。在理想情况下，相邻的LOD等级被设计为使得当Unity从一个LOD等级切换到另一个LOD等级的时候，你不能轻易地辨别出它们之间的区别。否则突然有LOD等级变化的时候就会让人很晕。但是在研究这种技术的时候，我们会使用明显的不同的网格。</p>

<p>创建一个空的游戏对象并给它两个子对象。第一个子对象是标准球体，第二个子对象是标准立方体，其大小设置为0.75。 预期的结果看起来像是一个重叠的球体和立方体。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013237093-2016130218.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013237695-361227834.png" width="250" /><font size="2.5">
            <i>球体和立方体作为一个对象.</i>
        </font></center>

<p>通过Component /Rendering / LOD Group将一个LOD组组件添加到父对象。你会得到一个具有默认设置的LOD组，它有三个LOD等级。 百分比是指由对象的包围盒覆盖的窗口的垂直部分。因此，当垂直尺寸下降到窗口高度的60％的时候，默认设置为切换到LOD 1，当垂直尺寸下降到窗口高度的30％的时候，默认设置为切换到LOD 2。当垂直尺寸下降到窗口高度的10％的时候，它根本不渲染。 你可以通过拖动LOD框的边来更改这些阈值。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013238446-1711254101.png" width="250" /><font size="2.5">
            <i>组件LOD组.</i>
        </font></center>

<p>这些阈值由LOD偏移（LOD Bias）进行修改，LOD偏移（LOD Bias）可以在组件检视器里面查看并修改。目前使用的是质量设置为2的默认值，这意味着阈值被减半。也可以设置为最大LOD等级，这将导致跳过最高级别。</p>

<p>为了使其工作，你必须告诉组件每个LOD等级都会使用哪些对象。这是通过选择一个LOD块并将对象添加到其“渲染器”列表中完成的。你可以在场景中添加任何对象，但一定要确保添加其子对象到LOD块的“渲染器”列表。让LOD 0的“渲染器”使用球体，让LOD 1的“渲染器”使用立方体。我们将LOD 2的“渲染器”留空，所以我们只有两个LOD等级。如果需要的话，你可以通过右键单击上下文菜单删除并插入LOD等级。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013239110-167141319.png" width="250" /><font size="2.5">
            <i>让球这个子物体使用LOD 0等级.</i>
        </font></center>

<p>一旦配置了LOD等级，你可以通过移动相机来查看它们的效果。如果物体足够大的话，它将使用球体，否则的话它将使用立方体，或根本不会渲染。</p>

<center>
    <video controls="" width="" loop="true" autoplay="true" preload="auto">
        <source src="https://thumbs.gfycat.com/ShyAffectionateFairyfly-mobile.mp4" type="video/mp4" />
    </video>
</center>
<font size="2.5">
        <center><i><b>LOD切换.</b></i></center>    
    </font>

<h3 id="烘焙全局光照和lod组">烘焙全局光照和LOD组</h3>

<p>因为LOD组是如何渲染的取决于它的<strong>视图大小</strong>，所以它们自然是动态的。但是，你仍然可以使其成为静态。对整个对象层次结构执行此操作，因此也包括了根节点和它的两个子节点。然后设置主光源为烘焙光源，看看会发生什么。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013240110-283978428.png" width="250" /><font size="2.5">
            <i>让球这个子物体使用LOD 0等级.</i>
        </font></center>

<p><em>使用烘焙光源得到的效果</em></p>

<p>看起来在烘焙静态光照贴图的时候使用的是LOD 0。 我们最终总是能够看到球体的阴影和间接光照的贡献，即使LOD组切换到一个立方体或是对自身做了剔除。但请注意，立方体也是使用了静态光照贴图。 所以它不使用光照探针，对吧？ 转动光照探针组就能发现这一点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013241019-1435398902.png" width="250" /><font size="2.5">
            <i>没有光照探针时候的烘焙光照.</i>
        </font></center>

<p>禁用光探针组会使得立方体变得更暗。这意味着他们不再接受间接光照。 这是因为在烘焙过程中确定间接光照的时候使用的是LOD 0。为了找到其他LOD等级下的间接光照， Unity可以做到的最好程度是依靠烘焙光照探针。 因此，即使在运行时我们不需要光照探针，我们也需要光照探针来为我们的立方体计算间接光照。</p>

<h3 id="实时全局光照和lod组">实时全局光照和LOD组</h3>

<p>当只使用实时全局光照的时候，方法是类似的，除了我们的立方体现在在运行时使用的是光照探针。你可以通过选择球体或立方体来验证这一点。选择立方体后，你可以看到小工具显示了哪些光照探针被使用。 球体不显示它们，因为它使用的是动态光照贴图。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013242971-183808454.png" width="250" /><font size="2.5">
            <i>LOD 1使用光照探针来计算实时全局光照.</i>
        </font></center>

<p>当烘焙全局光照和实时全局光照同时使用的时候，它会变得更加复杂。 在这种情况下，立方体应该对烘焙全局光照使用光照贴图，对实时全局光照使用光照探针。不幸的是，这是不可能的，这是因为光照贴图和和球面谐波不能同时使用。这是一个非此即彼的问题。因为光照贴图数据对于立方体来说是可用的，所以Unity最终会使用它。因此，立方体不受实时全局光照的影响。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013243831-1402316420.png" width="250" /><font size="2.5">
            <i>仅对LOD 1等级使用烘焙光照，使用的是低强度的主光源.</i>
        </font></center>

<p>一个重要的细节是，烘焙的LOD等级和渲染的LOD等级是完全独立的。 他们不需要使用相同的设置。如果实时全局光照最终比烘焙全局光照更重要，你可以强制立方体使用光照探针，确保它对于光照贴图来说不是静态的，同时保持球体静止。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013244794-1245713384.png" width="250" /><font size="2.5">
            <i>LOD 1强制使用光照探针.</i>
        </font></center>

<h3 id="lod淡入淡出功能">LOD淡入淡出功能</h3>

<p>LOD组这种方法的缺点是，当LOD等级发生变化的时候，它可以在视觉上很明显的表现出来。几何体会在视图中突然弹出、消失或改变形状。 这可以通过相邻LOD等级之间的淡入淡出来缓解，这通过将LOD组的渐变模式设置为淡入淡出来完成。还有另一种渐变模式，由Unity用于SpeedTree对象，我们不会使用这种模式。</p>

<p>当启用淡入淡出的时候，每个LOD等级都会显示一个淡入变换宽度（Fade Transition Width ）字段，用于控制其块的哪个部分用于衰落。举个简单的例子来说，当设置为0.5的时候，一半LOD范围将用于淡出到下一级。或者，淡入淡出过程可以是有动画的，在这种情况下，在LOD等级之间的切换需要大约半秒钟。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013245526-1175118666.png" width="250" /><font size="2.5">
            <i>带有0.5变换宽度的淡入淡出.</i>
        </font></center>

<p>当启用淡入淡出的时候，在LOD组之间进行转换的时候会同时渲染两个LOD等级。</p>

<h3 id="支持淡入淡出">支持淡入淡出</h3>

<p>Unity的标准着色器在默认情况下是不支持淡入淡出的。如果想要支持支持淡入淡出的话，你必须复制标准着色器并为LOD_FADE_CROSSFADE关键字添加一个多编译指令。添加这条指令还有一个原因是为了在My First Lighting着色器里面支持淡入淡出功能。让我们将这条指令添加到除了meta渲染通道以外的所有渲染通道。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ LOD_FADE_CROSSFADE
</span></code></pre></div></div>

<p>我们将使用抖动来在LOD等级之间进行转换。这种方法适用于前向渲染和延迟渲染，也适用于有阴影的情况。</p>

<p>在创建半透明阴影的时候，我们已经使用了抖动这种方法。它需要片段的屏幕空间坐标，这迫使我们为顶点程序和片段程序使用不同的插值器结构。所以让我们复制My Lighting 中的Interpolators结构，将其重命名为InterpolatorsVertex。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>

<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>

<span class="p">};</span>

<span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当我们必须进行淡入淡出处理的时候，片段程序的插值器里面必须包含vpos，否则我们可以使用同样的位置信息。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UNITY_VPOS_TYPE</span> <span class="n">vpos</span> <span class="o">:</span> <span class="nb">VPOS</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>我们可以在我们片段程序中开始的位置使用UnityApplyDitherCrossFade函数来执行淡入淡出操作。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnityApplyDitherCrossFade是如何工作的？

这个函数在UnityCG中进行定义。它的方法类似于我们在《渲染12:半透明阴影》中使用的抖动方法，区别只是整个对象的抖动级别是均匀的。 因此，不需要混合抖动级别。 它使用存储在4×64大小的二维纹理中的16个抖动级别，而不是4×4×16大小的三维纹理。
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>unity_LODFade变量在UnityShaderVariables中进行定义。它的Y分量包含的是对象的渐变量，共有十六步。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013246331-642394563.png" width="250" /><font size="2.5">
            <i>通过抖动方法得到的淡入淡出几何体.</i>
        </font></center>

<p>淡入淡出现在可以在几何体上正常工作了。为了使其适用于阴影，我们必须调整My Shadows着色器。 首先，当我们进行淡入淡出处理的时候，必须使用vpos。其次，我们还必须在片段程序开始的位置使用UnityApplyDitherCrossFade函数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="cp">#if SHADOWS_SEMITRANSPARENT || defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UNITY_VPOS_TYPE</span> <span class="n">vpos</span> <span class="o">:</span> <span class="nb">VPOS</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">positions</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="kt">float4</span> <span class="nf">MyShadowFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">UnityApplyDitherCrossFade</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">vpos</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013247225-2138491287.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender18/1692664-20200605013249358-581600268.gif" width="250" /><font size="2.5">
            <i>对几何体和阴影都做了淡入淡出处理.</i>
        </font></center>

<p>因为立方体和球体相互交叉，所以我们在对它们做淡入淡出处理的时候，得到一些奇怪的自阴影效果。这对于看到淡入淡出处理能在阴影上起作用是很方便的，但是当你为实际游戏创建LOD几何体的时候，需要注意这些瑕疵。</p>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><category term="Unity3d API" /><summary type="html"><![CDATA[了解间接光需要知道光在静态表面之间如何反射。重点在于哪些表面可能会受到其他表面的影响，以及程度如何。弄清这些关系需要做很多的工作，不能实时完成。所以这个数据由编辑器处理并存储在运行时使用。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender18/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender18/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity 混合光照(翻译十七)</title><link href="https://www.damonc.top/Unity_Mix_Lighting.html" rel="alternate" type="text/html" title="Unity 混合光照(翻译十七)" /><published>2018-01-21T20:00:00+08:00</published><updated>2018-01-21T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_Mix_Lighting</id><content type="html" xml:base="https://www.damonc.top/Unity_Mix_Lighting.html"><![CDATA[<p>本篇摘要：</p>
<ul>
  <li>只烘焙间接光</li>
  <li>混合烘焙阴影和实时阴影</li>
  <li>处理代码的变化和问题</li>
  <li>支持消减光照（subtractivelighting）</li>
</ul>

<h2 id="烘焙间接光">烘焙间接光</h2>

<p>光照贴图可以提供预计算光照：以纹理内存为代价减少了GPU在实时中的工作量；还加入了间接光。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>烘焙光的限制
    1.高光不能被烘焙
    2.烘焙光只通过光照探头影响动态物体
    3.烘焙光不产生实时阴影
</code></pre></div></div>

<p>你可以在下面的截图中看到完全实时光照和完全烘焙光照之间的区别。<a href="https://www.damonc.top/2018/01/19/Unity_Static_Lightting/">前一篇</a>教程中的一个场景，唯一的不同是我将所有的球体都设置为动态并重新改变了一些球体的位置。其它一切都是静态的。这是使用前向渲染的方法。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002309942-1932595350.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002311276-1707091650.png" width="250" /><font size="2.5">
            <i>完全实时和完全烘焙光照.</i>
        </font></center>

<h3 id="混合模式">混合模式</h3>

<p>烘焙光照有间接光而没有实时光照，因为间接光需要光照贴图。由于间接光可以为场景加入很大的真实感，如果我们可以将它和实时光照融合在一起就再好不过了。这是可以的，但也意味着着色的开销会增加。我们需要将混合光（Mixed Lighting）的光照模式（Lighting Mode）设置为烘焙间接（Baked Indirect）。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002312394-324532807.png" width="250" /><font size="2.5">
            <i>混合光照，烘焙间接.</i>
        </font></center>

<p>我们已经在<a href="https://www.damonc.top/2018/01/19/Unity_Static_Lightting/">前一篇</a>教程中切换到这个模式了，但是之前我们只使用了完全烘焙光照。虽然表现结果与完全烘焙光照相同，混合光照模式没有任何区别。为了使用混合光照，光源的模式必须要设置为混合。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002313374-471117722.png" width="250" /><font size="2.5">
            <i>混合模式的主光源.</i>
        </font></center>

<p>在将主定向光改为混合光后，两件事会发生：</p>

<p>第一，Unity会再次烘焙光照贴图。这一次光照贴图只会存储间接光，所以它会比之前的暗很多。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002314496-2053721233.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002315595-1655913714.png" width="250" /><font size="2.5">
            <i>完全烘焙的光照贴图 vs 只有间接光的光照贴图.</i>
        </font></center>

<p>第二，所有物体都会像主光源被设置为实时那样被照亮。只有一点不同：光照贴图被用来为静态物体添加间接光，而不是球谐光或探头。动态物体的间接光仍要使用光照探头。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002316908-68636833.png" width="250" /><font size="2.5">
            <i>混合光照，实时直接光照烘焙间接光.</i>
        </font></center>

<p>我们不需要改变我们的着色器来支持这点，因为前向基础通道（forward base pass）已经融合了光照贴图数据和主定向光源。和往常一样，额外的光照会得到附加通道（additive pass）。当使用延迟渲染通道时，主光源也会得到一个通道。</p>

<p><strong>混合光可以在运行时调整吗？</strong><br />
是的，因为它们被用于实时光照。但是，它们的烘焙数据时静态的。所以在运行时你只能稍微调整光照，比如稍微调整它的强度。更大的变化会使人明显看出烘焙光照和实时光照之间的不同步。_</p>

<h3 id="更新着色器">更新着色器</h3>

<p>刚开始一切似乎正常运行。但是，定向光的阴影衰减发生了错误。我们通过极大降低阴影距离观察到阴影被剪掉了。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002318408-928334072.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002319957-145579115.png" width="250" /><font size="2.5">
            <i>阴影衰减，标准着色器vs我们的着色器.</i>
        </font></center>

<p>虽然Unity很长一段时间都有混合光照模式，但实际上它在Unity5中就不起作用了。Unity5.6中新加入了一个混合光照模式，即我们现在使用的这个。当该新模式被加入时，_UNITY_LIGHT_ATTENUATION_宏下面的代码发生了变化。我们在使用完全烘焙光照或者实时光照时没有注意到这一点，但是我们必须更新我们的代码以适应混合光照的新方法。由于这是最近的一个巨大的变化，我们必须要注意它所带来的问题。</p>

<p>我们要改变的第一点是不再使用_SHADOW_COORDS_宏来定义阴影坐标的插值（interpolater）。我们必须使用新的_UNITY_SHADOW_COORDS_宏来代替它。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span>
<span class="p">{</span>
    <span class="c1">//SHADOW_COORDS(5)</span>
    <span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div></div>

<p>同样，<em>TRANSFER_SHADOW_应该替换为_UNITY_TRANSFER_SHADOW</em></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//TRANSFER_SHADOW(i);</span>
    <span class="n">UNITY_TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   
<span class="p">}</span>
</code></pre></div></div>

<p>然而，这会产生一个编译错误，因为该宏需要一个额外的参数。从Unity 5.6开始，只有定向阴影的屏幕空间坐标中被放入一个插值。点光源和聚光源的阴影坐标现在在片段程序（fragment program）中进行计算。有个新变化：在一些情况中光照贴图的坐标被用在阴影蒙版（shadow mask）中，我们会在后面讲解这一点。为了该宏能正常工作，我们必须为它提供第二个UV通道中的数据，其中包含光照贴图的坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">);</span>

</code></pre></div></div>

<p>这样会再次产生一个编译错误。这是因为在一些情况下_UNITY_SHADOW_COORDS_错误地创建了一个插值，尽管实际上并不需要。在这种情况下，_TRANSFER_SHADOW_不会初始化它，因而导致错误。这个问题出现在5.6.0中，一直到5.6.2和2017.1.0beta版本中都有。</p>

<p>人们通常不会注意到这个问题，因为Unity的标准着色器使用_UNITY_INITIALIZE_OUTPUT_宏来完全地初始化它的插值结构体。因为我们不使用这个宏，所以出现了问题。为了解决它，我们使用_UNITY_INITIALIZE_OUTPUT_宏来初始化我们的插值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>  
<span class="p">}</span>
</code></pre></div></div>

<p>_UNITY_INITIALIZE_OUTPUT_有什么作用？</p>

<p>它只是为变量分配数值0，将其转换为正确的类型。至少是当程序支持该宏时会这样，否则它不会做任何事。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Initialize arbitrary structure with zero values.</span>
<span class="c1">// Not supported on some backends</span>
<span class="c1">// (e.g. Cg-based particularly with nested structs).</span>
<span class="c1">// hlsl2glsl would almost support it, except with structs that have</span>
<span class="n">arrays</span>
<span class="c1">// -- so treat as not supported there either :(</span>
<span class="cp">#if defined(UNITY_COMPILER_HLSL) || defined(SHADER_API_PSSL) || \\
</span><span class="n">defined</span><span class="p">(</span><span class="n">UNITY_COMPILER_HLSLCC</span><span class="p">)</span>
    <span class="cp">#define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
#else
</span>    <span class="cp">#define UNITY_INITIALIZE_OUTPUT(type,name)
#endif
</span></code></pre></div></div>

<p><strong>通常我们倾向于只使用显式赋值，很少使用这个初始化插值宏。</strong></p>

<h3 id="手动衰减阴影">手动衰减阴影</h3>

<p>现在我们正确地使用了新的宏定义，但是主光源的阴影仍然没有按照它们应该的那样衰减。结果我们发现当同时使用定向阴影和光照贴图时，<em>UNITY_LIGHT_ATTENUATION</em> 不会对光源进行衰减。使用混合模式的主定向光源就会产生这个问题。所以我们必须手动设置。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>为什么在这个例子中阴影没有衰减？

1、UNITY_LIGHT_ATTENUATION宏之前是独立使用的，但是自从Unity5. 6它开始和Unity的标准全局光照函数一同使用。我们没有采用同样的方法，因此它不能正常工作。  
2、至于为什么要做这个改动，唯一的线索就是AutoLight中的一段注释：“为了性能的原因以GI函数的深度处理阴影”。由于着色器编译器会随意地移动代码。
</code></pre></div></div>

<p>对于我们的延迟光照着色器，我们已经有了进行阴影衰减的代码。将相关代码片段从MyDeferredShading中复制到My Lighting中的一个新函数中。唯一实际的区别在于我们必须使用视图向量和视图矩阵构建viewZ。我们只需要Z分量，所以无需进行一次完整的矩阵乘法。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">viewZ</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">UNITY_MATRIX_V</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该手动衰减必须在使用了_UNITY_LIGHT_ATTENUATION初始化完成_之后。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>只有当 <em>HANDLE_SHADOW_BLENDING_IN_GI</em> 在UnityShadowLibrary.cginc文件中有定义时，FadeShadows才会开始计算。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI
</span>        <span class="c1">// UNITY_LIGHT_ATTENUATION doesn't fade shadows for us.</span>
        <span class="n">float</span> <span class="n">viewZ</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">UNITY_MATRIX_V</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后，我们的阴影如它们应该的那样正常衰减了。</p>

<h2 id="使用阴影蒙版">使用阴影蒙版</h2>

<p>烘焙间接光的混合模式成本很高。它们需要实时光照外加间接光的光照贴图那么大的工作量。它和完全烘焙光照相比最重要的是加入了实时阴影。幸运的是，有一个方法仍可以将阴影烘焙到光照贴图中，将其和实时阴影综合起来。为了开启这个功能，我们将混合光照模式改为Shadowmask。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002321275-2134383138.png" width="250" /><font size="2.5">
            <i>Shadowmask模式.</i>
        </font></center>

<p>在这个模式中，混合光照的间接光和阴影衰减都存储在了光照贴图中。阴影被存储在一张额外的贴图（即阴影蒙版）。当只有主定向光源时，红色的阴影蒙版决定是否过滤被照亮的物体。红色是因为阴影信息被存储在纹理的R通道中。事实上，贴图中至多可以储存四个光照的阴影，因为它只有四个通道。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002322323-849349388.png" width="250" /><font size="2.5">
            <i>烘焙的强度以及阴影蒙版.</i>
        </font></center>

<p>在Unity创建了阴影蒙版后，静态物体的阴影投射会消失。只有光照探头仍会处理它们。动态物体的阴影不受影响。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002323536-1775535799.png" width="250" /><font size="2.5">
            <i>没有烘焙阴影.</i>
        </font></center>

<h3 id="对阴影蒙版采样">对阴影蒙版采样</h3>

<p>为了重新得到烘焙阴影，我们必须对阴影蒙版采样样。Unity的宏已经对点光源和聚光源进行了取样，不过我们必须也要将它包含在我们的FadeShadows函数中。为此我们可以使用UnityShadowLibrary中的UnitySampleBakedOcclusions函数。它需要光照贴图的UV坐标和世界位置作为输入参数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI
</span>        
        <span class="n">float</span> <span class="n">bakedAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleBakedOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnitySampleBakedOcclusion是什么样子的？

它使用光照贴图坐标对阴影蒙版取样，然后选择适当的通道。unity_OcclusionMaskSelector变量是一个含有一个分量的向量，该分量被设置为1以匹配当前正在被着色的光源。
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed</span> <span class="nf">UnitySampleBakedOcclusion</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightmapUV</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">fixed4</span> <span class="n">rawOcclusionMask</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
                <span class="n">unity_ShadowMask</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">lightmapUV</span><span class="p">.</span><span class="n">xy</span>
            <span class="p">);</span>
        <span class="cp">#else
</span>            <span class="n">fixed4</span> <span class="n">rawOcclusionMask</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_ShadowMask</span><span class="p">,</span> <span class="n">lightmapUV</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="cp">#endif
</span>        <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">rawOcclusionMask</span><span class="p">,</span> <span class="n">unity_OcclusionMaskSelector</span><span class="p">));</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p><em>该函数还处理了光照探头代理体积的衰减，但是我们还没有支持这点所以我去掉了那部分的代码。这就是为什么该函数有一个世界位置的参数。</em></p>

<p>当使用阴影蒙版时，_UnitySampleBakedOcclusions_提供给我们烘焙阴影衰减，在其他情况下它的值都为1。现在我们必须将它和我们已经有的衰减综合起来然后对阴影进行衰减。UnityMixRealtimeAndBakedShadows函数为我们实现了这些。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">bakedAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleBakedOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
<span class="c1">//attenuation = saturate(attenuation shadowFade);</span>
<span class="n">attenuation</span> <span class="o">=</span> <span class="n">UnityMixRealtimeAndBakedShadows</span>
<span class="p">(</span>
    <span class="n">attenuation</span><span class="p">,</span> <span class="n">bakedAttenuation</span><span class="p">,</span> <span class="n">shadowFade</span>
<span class="p">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnityMixRealtimeAndBakedShadows是如何工作的？

它也是UnityShadowLibrary中的一个函数。它还处理光照探头代理体积以及一些其他极端情况。那些情况和我们无关，所以我删除了一些内容。
</code></pre></div></div>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inline</span> <span class="n">half</span> <span class="nf">UnityMixRealtimeAndBakedShadows</span> <span class="p">(</span>
    <span class="n">half</span> <span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">half</span> <span class="n">bakedShadowAttenuation</span><span class="p">,</span> <span class="n">half</span> <span class="n">fade</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if !defined(SHADOWS_DEPTH) &amp;&amp; !defined(SHADOWS_SCREEN) &amp;&amp; \\
</span>        <span class="o">!</span><span class="n">defined</span><span class="p">(</span><span class="n">SHADOWS_CUBE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bakedShadowAttenuation</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="cp">#if defined (LIGHTMAP_SHADOW_MIXING)
</span>            <span class="n">realtimeShadowAttenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span> <span class="o">+</span> <span class="n">fade</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">bakedShadowAttenuation</span><span class="p">);</span>
        <span class="cp">#else
</span>            <span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span>
                <span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">bakedShadowAttenuation</span><span class="p">,</span> <span class="n">fade</span>
            <span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#else //no shadowmask
</span>        <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span> <span class="o">+</span> <span class="n">fade</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p><strong>如果没有动态阴影，那么结果将得到烘焙的衰减。这意味着动态物体没有阴影，以及被映射到光照贴图上的物体没有烘焙阴影。</strong></p>

<p>当没有使用阴影蒙版时，它会进行原来的衰减。否则，它会根据我们是否做了阴影混合进行表现，我们后面再讲。现在，它只是在实时衰减和烘焙衰减之间进行一个插值。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002325094-888038969.png" width="250" /><font size="2.5">
            <i>实时阴影和阴影蒙版阴影.</i>
        </font></center>

<p>现在静态物体有了实时阴影和烘焙阴影，且它们正确地混合。实时阴影的衰减仍然超过了阴影距离，但是烘焙阴影没有。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002326606-1972314102.png" width="250" /><font size="2.5">
            <i>只有实时阴影衰减了.</i>
        </font></center>

<h3 id="添加一个阴影蒙版g-buffer">添加一个阴影蒙版G-Buffer</h3>

<p>现在阴影蒙版可用于前向渲染路径，但是我们需要使它也可用于延迟渲染：添加阴影蒙版信息作为一个额外的G-缓存。所以当_SHADOWS_SHADOWMASK_被定义时，在_FragmentOutput_结构体中添加一个缓存。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">FragmentOutput</span> <span class="p">{</span>
    <span class="cp">#if defined(DEFERRED_PASS)
</span>        <span class="kt">float4</span> <span class="n">gBuffer0</span> <span class="o">:</span> <span class="n">SV_Target0</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer1</span> <span class="o">:</span> <span class="n">SV_Target1</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer2</span> <span class="o">:</span> <span class="n">SV_Target2</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer3</span> <span class="o">:</span> <span class="n">SV_Target3</span><span class="p">;</span>

        <span class="cp">#if defined(SHADOWS_SHADOWMASK)
</span>            <span class="kt">float4</span> <span class="n">gBuffer4</span> <span class="o">:</span> <span class="n">SV_Target4</span><span class="p">;</span>
        <span class="cp">#endif
</span>    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">SV_Target</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>添加的第五个G-缓存，会使显存增大，并不是所有的平台(mobile)都支持它。Unity只在有足够多的渲染目标可用时才支持阴影蒙版，因此我们也应该这样做。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>    <span class="kt">float4</span> <span class="n">gBuffer4</span> <span class="o">:</span> <span class="n">SV_Target4</span><span class="p">;</span>
<span class="cp">#endif
</span>
</code></pre></div></div>

<p>我们只需在G-缓存中存储采样得到的阴影蒙版数据，而且没有一个确切的光照，为此我们可以使用_UnityGetRawBakedOcclusions_函数，它与_UnitySampleBakedOcclusion_相似，唯一不同在于它没有选择某个纹理通道。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="n">output</span><span class="p">;</span>
<span class="cp">#if defined(DEFERRED_PASS)
</span>    <span class="cp">#if !defined(UNITY_HDR_ON)
</span>        <span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">exp2</span><span class="p">(</span><span class="o">-</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer0</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">albedo</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer0</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">GetOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer1</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">specularTint</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer1</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">GetSmoothness</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer2</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer3</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>        <span class="n">output</span><span class="p">.</span><span class="n">gBuffer4</span> <span class="o">=</span> <span class="n">UnityGetRawBakedOcclusions</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="cp">#endif
#else
</span>    <span class="n">output</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">ApplyFog</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>为了可以在没有光照贴图的时候也能成功编译，当光照贴图坐标不可用时我们使用0代替它。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>    <span class="kt">float2</span> <span class="n">shadowUV</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="n">shadowUV</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer4</span> <span class="o">=</span> <span class="n">UnityGetRawBakedOcclusions</span><span class="p">(</span><span class="n">shadowUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="cp">#endif
</span>
</code></pre></div></div>

<h3 id="使用阴影蒙版g-缓存">使用阴影蒙版G-缓存</h3>

<p>调整MyDeferredShading延迟渲染着色器。</p>

<p>第一步先添加额外的一个G-buffer变量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture0</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture1</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture2</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture4</span><span class="p">;</span>
</code></pre></div></div>

<p>第二步，创建一个函数来得到适当的阴影衰减。如果有了阴影蒙版，可通过对纹理采样然后和_unity_OcclusionMaskSelector_进行一次颜色饱和点乘。这个变量是在_UnityShaderVariables.cginc_中定义的，包含了一个用于选择当前正在被渲染的光照通道的向量。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">GetShadowMaskAttenuation</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="kt">float4</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_CameraGBufferTexture4</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">unity_OcclusionMaskSelector</span><span class="p">));</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在CreateLight中，即使当前光照没有实时阴影，我们在有阴影蒙版时也要衰减阴影。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">,</span> <span class="n">float</span> <span class="n">viewZ</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(SHADOWS_SHADOWMASK)
</span>        <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> 
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了正确地包含烘焙阴影，再次使用UnityMixRealtimeAndBakedShadows代替之前的衰减计算。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
<span class="c1">//  shadowAttenuation = saturate(shadowAttenuation + shadowFade);</span>
    <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="n">UnityMixRealtimeAndBakedShadows</span><span class="p">(</span>
        <span class="n">shadowAttenuation</span><span class="p">,</span> <span class="n">GetShadowMaskAttenuation</span><span class="p">(</span><span class="n">uv</span><span class="p">),</span> <span class="n">shadowFade</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在也可以使用自定义的延迟光照着色器得到正确的烘焙阴影了。例外，即当我们的优化分支被使用时会跳过阴影混合。该捷径在阴影蒙版被使用时不可用。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="cp">#if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT)
</span>        <span class="cp">#if !defined(SHADOWS_SHADOWMASK)
</span>            <span class="n">UNITY_BRANCH</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">shadowFade</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="阴影蒙版-距离模式-distance-shadowmask">阴影蒙版-距离模式 DIstance Shadowmask</h3>

<p>虽然使用阴影蒙版模式我们可以得到不错的静态物体的烘焙阴影，动态物体却不能从中获利。动态物体只能接收到实时阴影以及光照探头数据。如果我们希望得到动态物体的阴影，那么静态物体必须也要投射实时阴影。这里的混合光照模式我们要用到距离阴影蒙版（Distance Shadowmask）了。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002327719-433885054.png" width="250" /><font size="2.5">
            <i>距离阴影蒙版模式.</i>
        </font></center>

<p><em>在2017及以上，使用哪个阴影蒙版模式是通过质量设置进行控制。</em></p>

<p>当使用DistanceShadowmask模式时，所有物体都使用实时阴影。第一眼看去，好像和Baked Indirect模式完全一样。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002329008-1483902900.png" width="250" /><font size="2.5">
            <i>所有物体都有实时阴影.</i>
        </font></center>

<p>不过这里仍有一个阴影蒙版。在这个模式中，烘焙阴影和光照探头的使用超出了阴影距离。因此该模式是成本最高的模式，在阴影距离范围内等价于烘焙间接模式，超出该范围则等价于阴影蒙版模式。</p>

<p>前面已经支持这个模式了，因为我们正在使用UnityMixRealtimeAndBakedShadows。为了正确地混合完全实时阴影和烘焙阴影，它像往常那样衰减实时阴影，然后取其和烘焙阴影的最小值。</p>

<h3 id="多重光照">多重光照</h3>

<p>因为阴影蒙版有四个通道，它可以最多同时支持4个光照体积重叠在一起</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002330331-1413395037.png" width="250" /><font size="2.5">
            <i>四个光源，都是混合光.</i>
        </font></center>

<p><strong>主方向光源的阴影仍存储在R通道中</strong>。你还能够看到存储在G通道和B通道中的聚光源的阴影，最后一个聚光源的阴影存储在A通道中。</p>

<p>当光照体积不重叠时，它们使用相同的通道来存储它们的阴影数据。所以你可以有任意多个混合光照。但是你必须<strong>确保至多四个光照体积彼此重叠</strong>。如果有太多个混合光影响同一篇区域，那么一些就会改回到完全烘焙模式。为了说明这一点，下面这张截图显示的是在多加入一个聚光源以后的光照贴图。你可以在强度贴图中清楚地看到其中一个已经变成了烘焙光。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002332758-586177298.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002333778-925731185.png" width="250" /><font size="2.5">
            <i>5个重叠的光照，其中一个为完全烘焙光.</i>
        </font></center>

<h3 id="支持多个有蒙版的定向光">支持多个有蒙版的定向光</h3>

<p>不幸的是，阴影蒙版只有当包含至多一个混合模式的方向光源存在时才能正常工作。对于额外的方向光，阴影衰减会发生错误，至少是在使用前向渲染通道时。延迟渲染倒没有问题。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002335110-966052747.png" width="250" /><font size="2.5">
            <i>两个方向光源产生错误的衰减.</i>
        </font></center>

<p>这是使用UNITY_LIGHT_ATTENUATION的新方法中的一个漏洞：Unity使用通过UNITY_SHADOW_COORDS定义的阴影插值来存储方向阴影的屏幕空间坐标，或者其它拥有阴影蒙版的光源的光照贴图坐标。</p>

<p>使用阴影蒙版的方向光还需要光照贴图坐标。在forward-render中，这些坐标会被包含，因为LIGHTMAP_ON会在需要的时候被定义。然而，LIGHTMAP_ON在additional-pass中永远不会被定义。这意味着多余的方向光没有可用的光照贴图坐标。结果UNITY_LIGHT_ATTENUATION在这种情况下只会使用0，导致错误的光照贴图采样</p>

<p>所以我们不能依靠UNITY_LIGHT_ATTENUATION额外获得使用阴影蒙版的方向光源。用屏幕空间的方向阴影</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2)
</span>    
<span class="cp">#endif
#if !defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; !defined(UNITY_NO_SCREENSPACE_SHADOWS)
</span>        <span class="cp">#define ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS 1
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>接下来，对那些额外有蒙版的定向阴影，我们也要包含光照贴图坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="kt">float2</span> <span class="n">lightmapUV</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span>    
<span class="p">}</span>
</code></pre></div></div>

<p>当光照贴图坐标可用时，我们可以再次使用FadeShadows函数进行我们自己控制的衰减。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是，这仍然不正确，因为我们为其输入了错误的衰减数据。我们必须绕开UNITY_LIGHT_ATTENUATION，只得到烘焙后的衰减，在这个情况中我们可以使用SHADOW_ATTENUATION宏。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="c1">//UNITY_LIGHT_ATTENUATION doesn't fade shadows for us.</span>
        <span class="cp">#if ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>            <span class="n">attenuation</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="cp">#endif
</span>        
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002336571-896877423.png" width="250" /><font size="2.5">
            <i>两个定向光源正确的衰减.</i>
        </font></center>

<h2 id="消减阴影-subtractive-shadows">消减阴影-Subtractive Shadows</h2>

<p>混合光照很好，但是它不像完全烘焙光照那样成本低廉。如果以低性能硬件为目标，那么混合光照不太可行。烘焙光照会管用，但是事实上你<strong>也许需要动态物体对静态物体投射阴影。那样的话，你可以使用消减混合光照模式</strong>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002337701-173459592.png" width="250" /><font size="2.5">
            <i>消减模式.</i>
        </font></center>

<p>在切换到消减模式后，场景会亮很多。这是由于静态物体现在同时使用完全烘焙的光照贴图和方向光源。这是因为动态物体仍然会同时使用光照探头和方向光源。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002338965-1025220581.png" width="250" /><font size="2.5">
            <i>静态物体受到两次光照.</i>
        </font></center>

<p><strong>消减模式只可用于前向渲染</strong>。当使用延迟渲染路径时，相关的物体会回到前向渲染路径，就像透明物体那样。</p>

<h3 id="消减光照">消减光照</h3>

<p>在消减模式中，静态物体通过光照贴图被照亮，同时还将动态阴影考虑在内。这是通过降低光照贴图在阴影区域的强度来实现的。为此，着色器需要使用光照贴图和实时阴影。它还需要使用实时光照来计算出要将光照贴图调暗多少。这就是为什么我们在切换到这个模式后得到了双重光照。</p>

<p><strong>消减光照是一个近似，只在一个单一定向光下起作用，因此它只支持主方向光的阴影</strong>。另外，我们必须以某种方式了解在动态着色区域内间接光的环境是什么。由于我们使用的是一个完全烘焙的光照贴图，我们没有这个信息。Unity没有包含一个额外的只有间接光的光照贴图，而是使用了一个统一的颜色对环境光取近似值。即实时阴影颜色（Realtime Shadow Color），你可以在混合光照选项中调整它。</p>

<p>在着色器中，我们知道_当LIGHTMAP_ON_，<em>SHADOWS_SCREEN</em>，和_LIGHTMAP_SHADOW_MIXING_关键词被定义而_SHADOWS_SHADOWMASK_没有被定义时我们应该使用消减光照。如果这样的话我们定义_SUBTRACTIVE_LIGHTING_，以便更容易使用它。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; !defined(UNITY_NO_SCREENSPACE_SHADOWS)
</span>        <span class="cp">#define ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS 1
</span>    <span class="cp">#endif
#endif
</span>
<span class="cp">#if defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK)
</span>        <span class="cp">#define SUBTRACTIVE_LIGHTING 1
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>在做其他事情之前，我们必须去除掉双重阴影。为此我们可以关闭动态光照，就像我们对延迟通道所做的那样。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>

    <span class="cp">#if defined(DEFERRED_PASS) || SUBTRACTIVE_LIGHTING
</span>        <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="kt">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cp">#else
</span>        
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002340399-1575340233.png" width="250" /><font size="2.5">
            <i>静态物体只有烘焙光.</i>
        </font></center>

<h3 id="为烘焙光打阴影">为烘焙光打阴影</h3>

<p>为了应用消减阴影，我们创建一个函数以在需要的时候调整间接光。通常它不会做任何事。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplySubtractiveLighting</span> <span class="p">(</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">UnityIndirect</span> <span class="n">indirectLight</span>
<span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<p>我们在获取光照贴图数据后要调用该函数。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityIndirect</span> <span class="nf">CreateIndirectLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeLightmap</span><span class="p">(</span><span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">));</span>

            <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>                
            <span class="cp">#endif
</span>
            <span class="n">ApplySubtractiveLighting</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">);</span>
        <span class="cp">#else
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="cp">#endif
</span>        
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">indirectLight</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果有消减光照，那么我们必须获取阴影衰减。我们可以简单地从CreateLight中将代码复制过来。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplySubtractiveLighting</span> <span class="p">(</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">UnityIndirect</span> <span class="n">indirectLight</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if SUBTRACTIVE_LIGHTING
</span>        <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>下一步，我们要计算出如果使用实时光照的话我们可以接收到多少光。我们假设该信息和烘焙在光照贴图中的信息相吻合。由于光照贴图只包含漫射光，我们只需计算定向光的Lambert。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if SUBTRACTIVE_LIGHTING
</span>    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">ndotl</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>为了达到阴影光照的强度，我们必须将兰伯特项乘以衰减。但是我们已经有了完全不含阴影的烘焙光照。因此我们估算一下有多少光被阴影挡住了。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">ndotl</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
<span class="kt">float3</span> <span class="n">shadowedLightEstimate</span> <span class="o">=</span> <span class="n">ndotl</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">attenuation</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</code></pre></div></div>

<p>通过从烘焙光中减去该估值，我们最终得到了调整好的光照。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">shadowedLightEstimate</span> <span class="o">=</span> <span class="n">ndotl</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">attenuation</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">subtractedLight</span> <span class="o">=</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="err">–</span> <span class="n">shadowedLightEstimate</span><span class="p">;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002341952-1577870051.png" width="250" /><font size="2.5">
            <i>减去后得到的光照.</i>
        </font></center>

<p>无论在什么环境光场景中，这总会产生纯黑色阴影。为了更好地符合场景的需要，我们可以使用我们的消减阴影颜色，可以通过unity_ShadowColor实现。阴影区域不应比这个颜色更暗，不过它们可以更亮些。所以我们取计算出的光照和阴影颜色的最大值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">subtractedLight</span> <span class="o">=</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">-</span> <span class="n">shadowedLightEstimate</span><span class="p">;</span>
<span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">unity_ShadowColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</code></pre></div></div>

<p>我们还要考虑到阴影强度被设置为小于1这个情况。为了应用阴影强度，在有阴影和无阴影光照之间基于_LightShadowData的X分量做插值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">unity_ShadowColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
<span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002343602-223725225.png" width="250" /><font size="2.5">
            <i>有颜色的阴影.</i>
        </font></center>

<p>因为我们的场景的环境强度（ambient intensity）被设置为0，所以默认的阴影颜色和场景不太搭配。但是可以很轻松地发现消减阴影，因此我没有调整它。还有一点非常明显，即阴影颜色现在覆盖了所有的烘焙阴影，而实际不应该这样。它应该只影响那些接收动态阴影的区域，不应该使烘焙阴影变亮。为此，使用消减光照和烘焙光照的最小值。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//indirectLight.diffuse = subtractedLight;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002345136-2052798411.png" width="250" /><font size="2.5">
            <i>正确的消减阴影.</i>
        </font></center>

<p>现在只要我们使用适当的阴影颜色，我们就会得到正确的消减阴影。但是记住这只是一个近似，而且它不太适用于多重光照。例如，其它的烘焙光会产生错误的阴影。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002346714-785287043.png" width="250" /><font size="2.5">
            <i>多重光照错误的消减.</i>
        </font></center>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[烘焙光照有间接光而没有实时光照，因为间接光需要光照贴图。由于间接光可以为场景加入很大的真实感，如果我们可以将它和实时光照融合在一起就再好不过了。这是可以的，但也意味着着色的开销会增加。我们需要将混合光（Mixed Lighting）的光照模式（Lighting Mode）设置为烘焙间接（Baked Indirect）。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender17/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender17/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Unity 光照烘焙(翻译十六)</title><link href="https://www.damonc.top/Unity_Static_Lightting.html" rel="alternate" type="text/html" title="Unity 光照烘焙(翻译十六)" /><published>2018-01-19T20:00:00+08:00</published><updated>2018-01-19T20:00:00+08:00</updated><id>https://www.damonc.top/Unity_Static_Lightting</id><content type="html" xml:base="https://www.damonc.top/Unity_Static_Lightting.html"><![CDATA[<p>实时光照计算的开销非常昂贵。根据翻译13，延迟渲染允许程序员使用的光源可以多于Forward渲染，但阴影的开销仍然对性能有一个限制。如果我们的场景是动态的，那么没有办法来避免执行这些计算。但是如果光源和几何物体位置都是不变的，那么我们可以只计算一次光照并重复使用。这使得我们可以在场景中放置许多光源，而不必在运行的时候再渲染它们。这种方法也可以使用那些不能用作实时光源的区域光源(area lighting)。</p>

<h2 id="光照贴图-lightingmapping">光照贴图-Lightingmapping</h2>

<p>为了尝试光照贴图，我创建了一个简单的测试场景，它具有一个简单的结构，可以提供阴影，还有一些放置在其内部的球体。一切物体都使用默认的Unity材质。
<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
--></p>
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224543545-885823133.png" width="250" /><font size="2.5">
            <i>针对光照贴图的一个测试场景.</i>
        </font></center>

<h3 id="烘焙光源-baked-lights">烘焙光源-Baked Lights</h3>

<p>要开始使用光照贴图，将唯一的光源对象的模式改为“Baked（烘焙）”而不是“Realtime（实时）”。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224544162-1495985851.png" width="250" /><font size="2.5">
            <i>使用烘焙模式的主方向光源.</i>
        </font></center>

<p><strong>将主方向光源变成烘培光源后，就不被纳入动态光照计算。从动态对象的角度来看，光源是不存在的。 唯一仍然不变的是环境光照，它仍然是基于主方向光源的。</strong></p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224544847-451474149.png" width="250" /><font size="2.5">
            <i>没有直接光照的效果.</i>
        </font></center>

<p>要实际启用光照贴图，请在lighting窗口的“混合光照（<em>Mixed Lighting</em>）”中打开“烘培全局光照(<em>BakedGlobal Illumination</em>)”。 然后<strong>将光照模式设置为“烘培间接光照（<em>BakedIndirect</em>）”。 尽管它的名字说的是烘培间接光照，但是它也包括了直接光照</strong>。 它通常用于向场景添加间接光照。另外，确保实时全局光照（<em>Realtime Global Illumination</em>）被禁用，因为我们还没有支持到这一点。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224545646-2048168292.png" width="250" /><font size="2.5">
            <i>烘培间接光照模式.</i>
        </font></center>

<h3 id="静态几何体">静态几何体</h3>

<p>场景的对象都应该是固定的：它们位置永远不会移动。要将这一个信息传达给Unity，请将这些对象标记为静态。你可以通过启用检视器窗口右上角的“静态”切换键来做到这一点。</p>

<p><strong>光源也必须被标记为静态吗？</strong></p>
<ul>
  <li>不需要。光源只需要设置为适当的模式。</li>
</ul>

<p>有各种子系统关心物体是否是静态的。“静态（static）”还有一个下拉菜单，你可以使用它来微调哪些系统会将这个对象视为静态的。现在我们只关心光照贴图，但最简单的做法是使一切都完全是静态的。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224546220-2118005287.png" width="250" /><font size="2.5">
            <i>静态标签设定.</i>
        </font></center>

<p>一个物体对于光照贴图来说是否是静态的，也可以通过其网格渲染器的检视器来进行查看和编辑。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224546912-1870383195.png" width="250" /><font size="2.5">
            <i>对于光照贴图来说是静态的物体.</i>
        </font></center>

<p>现在，所有的物体都是静态的，它们将被包含在光照贴图的处理过程中。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224547954-1770311194.png" width="250" /><font size="2.5">
            <i>使用烘焙光照的场景.</i>
        </font></center>

<p><strong>必须注意</strong>，使用光照贴图得到的结果不如使用实时照明得到的结果亮度那么高。这是因为缺失了镜面高光，只剩下了漫反射光照。镜面高光取决于视角，因此取决于相机的角度。正是由于相机是移动的，因此它不能包含在光照贴图中。(使用场景推荐)这种限制意味着光照贴图可以用于微弱的光线和暗淡的表面，但不能用于强直射光或有光泽的表面。如果你想要镜面高光，你将不得不使用实时光源。所以你经常会使用烘烤光源和实时光源的混合。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>为什么没有立即得到烘焙光源？
为了确保在需要的时候光照贴图可以实际生成和更新，请在光照窗口的底部启用“自动生成（Auto Generate）”。 否则，你必须手动生成新的光照贴图。
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224548501-1138122298.png" width="250" /><font size="2.5">
            <i>自动烘焙.</i>
        </font></center>

<h3 id="光照贴图设置-lightingmapping-setting">光照贴图设置-Lightingmapping Setting</h3>

<p>光照烘焙窗口包含专门用于光照贴图设置的部分。在这里，你可以在<strong>质量</strong>、<strong>尺寸</strong>和<strong>烘烤时间</strong>之间取得平衡。你还可以在光照贴图烘焙算法引擎：Enlighten和Progressive lightmapper之间进行切换。后者会增量地生成光照贴图，优先考虑场景视图中可见的内容，这在编辑的时候很方便。本教程中使用的是Enlighten光照贴图引擎。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224549324-867042323.png" width="250" /><font size="2.5">
            <i>默认的光照贴图设置.</i>
        </font></center>

<p>在做任何事情之前，请将“DirectionalMode“设置为”Non-Direction“。 稍后我们会处理其他模式。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224549936-119016943.png" width="250" /><font size="2.5">
            <i>使用“Non-directional”模式的光照贴图.</i>
        </font></center>

<p>烘烤的光照存储在纹理中。 你可以通过将光照窗口从“场景（Scene）“切换到”全局地图（<em>Global Maps</em>）“模式来进行查看。 使用默认设置，我的测试场景很容易与一张1024×1024贴图相匹配。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224550735-1332475026.png" width="250" /><font size="2.5">
            <i>得到光照贴图.</i>
        </font></center>

<p>Unity自带的Objects物体都有用于光照贴图的UV坐标。对于手动导入的模型，可以自己提供UV坐标，也可以让Unity生成。烘烤后可以在光照贴图中看到展开的纹理。它们需要多少空间取决于场景中物体的大小和光照贴图的分辨率设置。 如果质量要求高分辨率太大，一张贴图涨不下，Unity会创建额外的贴图存储，直至完成。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224551453-953456979.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224552186-1643111793.png" width="250" /><font size="2.5">
            <i>光照贴图的分辨率的不同会带来很大的差异.</i>
        </font></center>

<p>对于每个项目来说，最佳设置都是不同。 你必须不断的调整烘焙参数，直到达成很好的效果及平衡。需要注意的是，视觉质量也很大程度上取决于用于光照贴图的纹理展开的质量。不存在纹理接缝可能会产生明显的瑕疵。Unity的默认球体就是一个很好的例子。它不适用于光照贴图。</p>

<h3 id="间接光源">间接光源</h3>

<p>烘焙光照会失去镜面高光，只能获得的是间接光照，它是在到达人眼之前会在多个表面反射的光。烘焙光会在拐角周围区域反射，那些本来会被遮挡的区域仍然会被照亮。我们不能实时计算镜面高光这个信息(本节1.2有说明)，但是我们可以在烘焙的时候包括反射光。</p>

<p>要清楚地看到实时光照和烘培光照之间的差异：将环境光照的强度设置为零，去掉天空盒的影响，所有的光都只是来自方向光。比对</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224552903-1416086887.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224553660-737254829.png" width="250" /><font size="2.5">
            <i>没有环境光照，realtime vs. lightmapped.</i>
        </font></center>

<p>每次光子反射的时候，它都会失去一些能量，它会被一些需要的材质采样着色。Unity在烘焙间接光照的时候，物体会根据附近的颜色进行着色。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224554555-1690717767.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224555273-1136371525.png" width="250" /><font size="2.5">
            <i>绿色的地面，realtime vs. lightmapped.</i>
        </font></center>

<p>自发光表面也会影响烘焙光照。它们会成为间接光源。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224556002-270644308.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224556791-2131078685.png" width="250" /><font size="2.5">
            <i>自发光的地面，realtime vs. lightmapped.</i>
        </font></center>

<p>间接光照的一个特殊设置是AO环境遮挡：这是指在角落和转折中发生的间接光照造成的阴影。这是一种人为的提升，可以增强深度方面的视觉。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224557440-355583450.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224558173-2138402443.png" width="250" /><font size="2.5">
            <i>使用环境遮挡的效果.</i>
        </font></center>

<p>环境遮挡效果完全基于物体表面。它不考虑光线实际来自哪里。烘焙时并不总是正确，举个简单的例子：当与自发光表面组合的时候就会产生一些错误的结果。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224558930-1992313410.png" width="250" /><font size="2.5">
            <i>显然是错误的环境遮挡效果.</i>
        </font></center>

<h3 id="透明度-transparency">透明度-Transparency</h3>

<p>光照贴图在一定程度上可以处理半透明表面。 光将通过它们，尽管光的颜色不会被它们所过滤。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224559715-1180880317.png" width="250" /><font size="2.5">
            <i>半透明的屋顶.</i>
        </font></center>

<p>镂空材质也可以在光照贴图中正常工作。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224600513-791335188.png" width="250" /><font size="2.5">
            <i>镂空的屋顶.</i>
        </font></center>

<p>但 这仅在使用封闭曲面的时候有效。当使用像是quad这样的单面几何，光线将在不存在的一面损坏。<em>当另外一面没有任何东西的时候，这是很好的，但是当使用单面透明表面的时候会导致问题</em>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224601275-358793307.png" width="250" /><font size="2.5">
            <i>四边形上有一个错误.</i>
        </font></center>

<p>为了处理这个问题，必须告诉光照贴图系统将这些表面视为透明的。 这可以通过自定义光照贴图设置完成</p>

<ol>
  <li>通过Asset / Create / Lightmap参数来创建这些数据。这些资源允许你自定义每个对象的光照贴图计算。在这种情况下，我们只想表明我们正在处理一个透明的对象。所以启用“它是透明的（<em>Is Transparent</em>）“。 下面它是一个全局作用预计算实时全局光照（<em>Precomputed Realtime GI</em>）部分中的一部分，它会影响所有烘烤光照。</li>
</ol>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224602678-564328235.png" width="250" /><font size="2.5">
            <i>指示这是透明的.</i>
        </font></center>

<ol>
  <li>单独设置：通过物体的网格渲染器检视器来选择它们。你的资源名字将显示在Lightmap参数的下拉列表中。</li>
</ol>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224603354-539689204.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224604232-1056111478.png" width="250" /><font size="2.5">
            <i>为透明四边形使用自定义参数.</i>
        </font></center>

<p>将物体标记为透明也会改变它对间接光照的贡献。透明物体让间接光通过，而不透明物体则会阻挡间接光。</p>

<h2 id="使用光照贴图">使用光照贴图</h2>

<p>现在我们知道光照贴图是如何工作的，我们可以为Shader着色器添加对光照贴图的支持。第一步是对光照贴图进行采样。调整场景中的球体，以便我们的着色器使用白色材质。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224605139-922193658.png" width="250" /><font size="2.5">
            <i>使用我们的白色材质的球体.</i>
        </font></center>

<h3 id="光照贴图的着色器变体">光照贴图的着色器变体</h3>

<p>当一个着色器被认为应该使用光照贴图的时候，Unity会寻找与LIGHTMAP_ON关键字关联的变体。 所以我们必须为这个关键字添加一个多编译指令。 当使用forward-render-path的时候，仅在base-pass中采样光照贴图。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ SHADOWS_SCREEN
#pragma multi_compile _ VERTEXLIGHT_ON
#pragma multi_compile _ LIGHTMAP_ON
#pragma multi_compile_fog
</span></code></pre></div></div>

<p>当使用光照贴图的时候，Unity不会包含顶点光源。他们的关键字是_相互排斥_的。所以我们不需要一个会同时使用_VERTEXLIGHT_ON_和_LIGHTMAP_ON_的变体。（互斥）</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ SHADOWS_SCREEN
</span><span class="c1">//#pragma multi_compile _ VERTEXLIGHT_ON</span>
<span class="c1">//#pragma multi_compile _ LIGHTMAP_ON</span>
<span class="cp">#pragma multi_compile _ LIGHTMAP_ON VERTEXLIGHT_ON
#pragma multi_compile_fog
</span></code></pre></div></div>

<p>延迟渲染路径中也支持光照贴图，因此也可以将这个关键字添加到延迟渲染通道中。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ UNITY_HDR_ON
#pragma multi_compile _ LIGHTMAP_ON
</span></code></pre></div></div>

<h3 id="光照贴图的坐标">光照贴图的坐标</h3>

<p>用于采样光照贴图的坐标存储在TEXCOORD1。 所以将此通道添加到shader中的VertexData结构体中。Unity给出了uv使用说明表：Shader中是uv0、uv1、uv2、uv3；C#中是UV、UV2、UV3、UV4</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span>
<span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="nb">NORMAL</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">tangent</span> <span class="o">:</span> <span class="nb">TANGENT</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>光照贴图坐标也必须进行插值。因为它们与顶点光源互斥，所以都可以使用TEXCOORD6。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span>
<span class="p">{</span>
    <span class="err">…</span>
    <span class="cp">#if defined(VERTEXLIGHT_ON)
</span>        <span class="kt">float3</span> <span class="n">vertexLightColor</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="kt">float2</span> <span class="n">lightmapUV</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>来自模型顶点数据的坐标定义了用于光照贴图的纹理展开(第二套uv)。但是它并没有告诉我们这个展开位置在哪里，展开尺寸大小。我们必须缩放和偏移坐标才能得到最终的光照贴图坐标。这种方法类似于常规纹理坐标的转换，除了转换是特定于对象的，而这里的方法是特定于材质的。在_UnityShaderVariables_中将光照贴图的纹理定义为_unity_Lightmap_。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">);</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>不幸的是，我们不能使用方便的_TRANSFORM_TEX_宏，因为它假定光照贴图的变换被被定义为_unity_Lightmap_ST_，而实际上是被定义为_unity_LightmapST_。由于这种不一致，我们必须手动进行这个变换。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span><span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="对光照贴图进行采样-sampling-lightmap">对光照贴图进行采样-Sampling Lightmap</h3>

<p>因为光照贴图的数据被认为是间接光照，我们将在CreateIndirectLight函数中进行采样。当光照贴图可用的时候，必须将它们用作间接光而不是球面谐波。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityIndirect</span> <span class="nf">CreateIndirectLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(VERTEXLIGHT_ON)
</span>        <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">vertexLightColor</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cp">#else
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="cp">#endif
</span>        <span class="kt">float3</span> <span class="n">reflectionDir</span> <span class="o">=</span> <span class="nb">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>

    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">indirectLight</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>为什么indirectLight.diffuse的值被赋值而不是加起来？光照贴图从来没有与顶点光源组合起来。</em></p>

<p>unity_Lightmap的确切形式取决于目标平台。 它被定义为UNITY_DECLARE_TEX2D（unity_Lightmap）。要对它进行采样，我们将使用UNITY_SAMPLE_TEX2D宏而不是tex2D。这是根据不同平台决定。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224605941-2016281613.png" width="250" /><font size="2.5">
            <i>使用原始光照图数据的效果.</i>
        </font></center>

<p>我们现在得到了烘焙的间接光照，但效果看起来不对。这是因为光照贴图数据已被编码。颜色以RGBM格式或是半强度格式进行存储，以支持高强度的光。UnityCG的DecodeLightmap函数负责为我们解码。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeLightmap</span>
<span class="p">(</span>
    <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224606764-748268587.png" width="250" /><font size="2.5">
            <i>使用解码后光照图数据的效果.</i>
        </font></center>

<h2 id="创建光照贴图">创建光照贴图</h2>

<p><em>目前，光照贴图会将场景对象总是视为不透明和纯白色的物体。我们必须对我们的着色器进行一些调整，添加一个渲染通道来完全支持光照贴图。</em></p>

<p><em>从现在开始，对场景中的所有对象使用我们自己的着色器。也不再使用默认的材质。</em></p>

<h3 id="半透明的阴影-semitransparent-shadow">半透明的阴影-Semitransparent Shadow</h3>

<p>光照贴图不使用实时渲染管道，因此现有自写的shader不能支持。 当尝试使用半透明阴影的时候，这是最明显的。通过设置屋顶立方体材质的色调alpha分量小于1来赋予屋顶立方体半透明度。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224607620-2057696906.png" width="250" /><font size="2.5">
            <i>半透明的屋顶，效果不正确.</i>
        </font></center>

<p><strong>光照贴图</strong>仍然把屋顶看成是实心物体，这是不正确的。它<strong>使用材质的渲染类型来确定如何处理表面</strong>，这应该告诉光照贴图我们的对象是半透明的。事实上，它确实知道屋顶是半透明的，它只是把它看作是完全不透明的而已。这是因为<strong>它</strong>采用Unity的命名约定<strong>_Color材质属性的alpha组件以及主纹理来设置不透明度</strong>。</p>

<p>用_Color替换_Tint。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Properties</span>
<span class="p">{</span>
    <span class="c1">// _Tint ("Tint", Color) = (1, 1, 1, 1)</span>
    <span class="n">_Color</span> <span class="p">(</span><span class="s">"Tint"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后，为了保证我们的着色器的功能，我们还必须在shader文件、cg文件替换，而且我们还要调整GUI拓展。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224608540-1659292184.png" width="250" /><font size="2.5">
            <i>半透明的屋顶，正确的效果.</i>
        </font></center>

<h3 id="镂空部分的阴影-cutout-shadow">镂空部分的阴影-Cutout Shadow</h3>

<p>镂空部分的阴影也有类似的问题。光照贴图程序期望透明度的阈值存储在_Cutoff属性中，但是我们使用的是_AlphaCutoff。 因此，它使用默认阈值1。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224609483-570537720.png" width="250" /><font size="2.5">
            <i>镂空的屋顶，效果不正确.</i>
        </font></center>

<p>解决方案是再次<strong>采用Unity的命名约定_Cutoff材质属性</strong>。所以替换shader、cg文件、GUI拓展。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224611382-1243752544.png" width="250" /><font size="2.5">
            <i>镂空的屋顶，正确的效果.</i>
        </font></center>

<h3 id="添加一个meta渲染通道-add-meta-pass">添加一个Meta渲染通道-Add Meta Pass</h3>

<p><strong>渲染光照贴图正确的表面反照率和自发光</strong>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224612151-595484578.png" width="250" /><font size="2.5">
            <i>绿色的地板，效果不正确.</i>
        </font></center>

<p>要采样物体的表面颜色，光照贴图程序会将它的光照模式设置为Meta来寻找一个着色器渲染通道。这个渲染通道仅由光照贴图程序使用，不使用剔除。所以让我们在我们的着色器上添加一个渲染通道。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Tags</span> <span class="p">{</span>
        <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"Meta"</span>
    <span class="p">}</span>
    <span class="n">Cull</span> <span class="n">Off</span>

    <span class="n">CGPROGRAM</span>

    <span class="cp">#pragma vertex MyLightmappingVertexProgram
</span>    <span class="cp">#pragma fragment MyLightmappingFragmentProgram
</span>    <span class="cp">#include</span> <span class="cpf">"My Lightmapping.cginc"</span><span class="cp">
</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在我们<strong>需要确定反照率、镜面高光颜色、平滑度、自发光</strong>。只需要顶点的位置和uv坐标，以及需要vertexProgram中的光照贴图坐标。不使用法线和切线。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(MY_LIGHTMAPPING_INCLUDED)
#define MY_LIGHTMAPPING_INCLUDED
</span>
<span class="cp">#include</span> <span class="cpf">"UnityPBSLighting.cginc"</span><span class="cp">
</span>
<span class="kt">float4</span> <span class="n">_Color</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">,</span> <span class="n">_DetailMask</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">_MainTex_ST</span><span class="p">,</span> <span class="n">_DetailTex_ST</span><span class="p">;</span>

<span class="n">sampler2D</span> <span class="n">_MetallicMap</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_Metallic</span><span class="p">;</span>
<span class="n">float</span> <span class="n">_Smoothness</span><span class="p">;</span>

<span class="n">sampler2D</span> <span class="n">_EmissionMap</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">_Emission</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">uv</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">float</span> <span class="nf">GetDetailMask</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="kt">float3</span> <span class="nf">GetAlbedo</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetMetallic</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetSmoothness</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="kt">float3</span> <span class="nf">GetEmission</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>GetEmission函数去除_FORWARD_BASE_PASS_和_DEFERRED_PASS_限制。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="nf">GetEmission</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//    #if defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)</span>
    <span class="cp">#if defined(_EMISSION_MAP)
</span>        <span class="k">return</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_EmissionMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">)</span> <span class="o">*</span><span class="n">_Emission</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="n">_Emission</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="c1">//    #else</span>
<span class="c1">//        return 0;</span>
<span class="c1">//    #endif</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这些函数只有在定义了适当的关键字时才会起作用，因此可以在渲染通道中为其添加着色功能。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma vertex MyLightmappingVertexProgram
#pragma fragment MyLightmappingFragmentProgram
</span>
<span class="cp">#pragma shader_feature _METALLIC_MAP
#pragma shader_feature _ _SMOOTHNESS_ALBEDO _SMOOTHNESS_METALLIC
#pragma shader_feature _EMISSION_MAP
#pragma shader_feature _DETAIL_MASK
#pragma shader_feature _DETAIL_ALBEDO_MAP
</span>
<span class="cp">#include</span> <span class="cpf">"My Lightmapping.cginc"</span><span class="cp">
</span></code></pre></div></div>

<h3 id="顶点程序-vertex-program">顶点程序-Vertex Program</h3>

<p>这个pass的vertex 程序很简单。只是转换位置、转换纹理坐标。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyLightmappingVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>

    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>计算2.2提到的映射偏移，我们必须使用光照贴图uv坐标而不是顶点位置，然后进行适当的转换把纹理uv坐标作为模型顶点的屏幕位置，模型的UV映射必须要正确：纹理上的每个点必须映射为模型上的唯一点。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span><span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
</code></pre></div></div>

<p>v.vertex.z = 0，不是所有机器上都能支持，顶点位置的Z坐标必须以某种方式使用，即使我们不使用它也是如此。Unity的着色器为此使用虚拟值，所以我们将简单地做同样的事情。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span><span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span><span class="p">.</span><span class="mo">0001</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="片段程序-fragment-program">片段程序-Fragment Program</h3>

<p>在<strong>片段程序中</strong>，计算<strong>输出反照率和自发光颜色</strong>。光照贴图程序将通过<strong>执行两次渲染</strong>来做到这一点，<strong>每次</strong>执行<strong>有一个输出</strong>。为了使这个过程更容易，我们可以使用_UnityMetaPass.cginc文_件中定义的_UnityMetaFragment_函数。它使用_<strong>UnityMetaInput</strong>_结构<strong>作为参数</strong>，其中<strong>包含反照率和自发光颜色</strong>。 该函数将决定要输出反照率和自发光颜色中的哪一个以及如何编码输出结果。</p>

<p>UnityMetaInput也包含镜面高光颜色，即使它不存储在光照贴图中。它用于一些编辑器可视化，我们先忽略它。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"UnityPBSLighting.cginc"</span><span class="cp">
#include</span> <span class="cpf">"UnityMetaPass.cginc"</span><span class="cp">
</span><span class="err">…</span>
<span class="kt">float4</span> <span class="nf">MyLightmappingFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">UnityMetaInput</span> <span class="n">surfaceData</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">Emission</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">SpecularColor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">UnityMetaFragment</span><span class="p">(</span><span class="n">surfaceData</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>UnityMetaFragment是什么样子的？</em></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//unity_MetaFragmentControl变量包含一个标记，这个标记会告诉函数是否输出反照率或是自发光颜色。还有一段有关</span>
<span class="c1">//编辑器可视化变体的代码，但是我把它删掉了，因为与这里的内容不相关。</span>
<span class="kt">half4</span> <span class="nf">UnityMetaFragment</span> <span class="p">(</span><span class="n">UnityMetaInput</span> <span class="n">IN</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">half4</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaFragmentControl</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="kt">half4</span><span class="p">(</span><span class="n">IN</span><span class="p">.</span><span class="n">Albedo</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

        <span class="c1">// d3d9 shader compiler doesn't like NaNs and infinity.</span>
        <span class="n">unity_OneOverOutputBoost</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">unity_OneOverOutputBoost</span><span class="p">);</span>

        <span class="c1">// Apply Albedo Boost from LightmapSettings.</span>
        <span class="n">res</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">clamp</span><span class="p">(</span>
            <span class="nb">pow</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">unity_OneOverOutputBoost</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unity_MaxOutputValue</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaFragmentControl</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">half3</span> <span class="n">emission</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unity_UseLinearSpace</span><span class="p">)</span>
            <span class="n">emission</span> <span class="o">=</span> <span class="n">IN</span><span class="p">.</span><span class="n">Emission</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">emission</span> <span class="o">=</span> <span class="n">GammaToLinearSpace</span> <span class="p">(</span><span class="n">IN</span><span class="p">.</span><span class="n">Emission</span><span class="p">);</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">UnityEncodeRGBM</span><span class="p">(</span><span class="n">emission</span><span class="p">,</span> <span class="n">EMISSIVE_RGBM_SCALE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224612936-832867814.png" width="250" /><font size="2.5">
            <i>间接光照设置为0的效果.</i>
        </font></center>

<p>要<strong>获得自发光颜色</strong>，我们可以简单的<strong>使用GetEmission函数</strong>。要<strong>获得反照率</strong>，我们必须再次<strong>使用_DiffuseAndSpecularFromMetallic_函数</strong>。 该函数具有镜面高光颜色和反射率作为输出参数，即使我们现在不使用它们，我们也必须提供这些参数。我们可以使用<strong>surfaceData.SpecularColor来捕获镜面高光颜色</strong>。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="nf">MyLightmappingFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span>
<span class="p">{</span>
    <span class="n">UnityMetaInput</span> <span class="n">surfaceData</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">Emission</span> <span class="o">=</span> <span class="n">GetEmission</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">oneMinusReflectivity</span><span class="p">;</span>
    <span class="n">surfaceData</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">=</span> <span class="n">DiffuseAndSpecularFromMetallic</span>
    <span class="p">(</span>
        <span class="n">GetAlbedo</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">GetMetallic</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
        <span class="n">surfaceData</span><span class="p">.</span><span class="n">SpecularColor</span><span class="p">,</span> <span class="n">oneMinusReflectivity</span>
    <span class="p">);</span>
    <span class="c1">//surfaceData.SpecularColor = 0;</span>
    <span class="k">return</span> <span class="n">UnityMetaFragment</span><span class="p">(</span><span class="n">surfaceData</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224613700-1556141393.png" width="250" /><font size="2.5">
            <i>间接光照着色的效果.</i>
        </font></center>

<p>但自发光光照可能还没有出现在光照贴图中。这是因为光照贴图程序并不总是包含一个自发光光照的渲染通道。<strong>材质必须表明它们具有自发光光照属性，</strong>以对烘焙过程做出贡献。这是<strong>通过Material.globalIlluminationFlags属性</strong>完成的。扩展GUI设置：当自发光光照编辑的时候，它应该被烘焙进光照贴图。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoEmission</span> <span class="p">()</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="n">EndChangeCheck</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tex</span> <span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">SetKeyword</span><span class="p">(</span><span class="s">"_EMISSION_MAP"</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">textureValue</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">editor</span><span class="p">.</span><span class="n">targets</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">globalIlluminationFlags</span> <span class="o">=</span> <span class="n">MaterialGlobalIlluminationFlags</span><span class="p">.</span><span class="n">BakedEmissive</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="粗糙的金属-rough-metals">粗糙的金属-Rough Metals</h3>

<p>我们的shader现在看起来可以正常工作了，但它与标准着色器的结果不完全匹配。 <strong>当使用平滑度非常低的有色金属的时候，物体表面不太明亮</strong>。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224614488-83217782.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224615215-1831739305.png" width="250" /><font size="2.5">
            <i>粗糙的绿色金属，standard vs. our.</i>
        </font></center>

<p>标准着色器通过<strong>将反射率的一部分加到镜面高光颜色</strong>进行补偿（高亮）。它使用_UnityStandardBRDF.cginc_的_SmoothnessToRoughness函数_来确定基于平滑度的粗糙度值，将其缩小一半，并使用它来缩放镜面高光颜色。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">roughness</span> <span class="o">=</span> <span class="n">SmoothnessToRoughness</span><span class="p">(</span><span class="n">GetSmoothness</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">surfaceData</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">+=</span> <span class="n">surfaceData</span><span class="p">.</span><span class="n">SpecularColor</span> <span class="o">*</span><span class="n">roughness</span><span class="p">;</span>

<span class="k">return</span> <span class="nf">UnityMetaFragment</span><span class="p">(</span><span class="n">surfaceData</span><span class="p">);</span>
</code></pre></div></div>

<p><em>SmoothnessToRoughness计算了什么东西？</em></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//转换：减去平滑度值，然后平方。 从平滑度到粗糙度的平方映射最终会产生比仅仅做线性转换更好的结果。</span>
<span class="c1">// Smoothness is the user facing name</span>
<span class="c1">// it should be perceptualSmoothness</span>
<span class="c1">// but we don't want the user to have to deal with this name</span>
<span class="n">half</span> <span class="nf">SmoothnessToRoughness</span><span class="p">(</span><span class="n">half</span> <span class="n">smoothness</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">smoothness</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">smoothness</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224616025-563552905.png" width="250" /><font size="2.5">
            <i>调整反照率后的效果.</i>
        </font></center>

<h2 id="方向光照贴图-directinal-lightmap">方向光照贴图-Directinal Lightmap</h2>

<p>光照贴图程序只使用物体的顶点数据，不考虑物体的法线贴图。光照贴图的分辨率太低，无法捕获由典型法线贴图提供的细节。这意味着静态光照将是平坦的。当使用具有法线贴图的材质的时候，这变得非常明显。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224616867-1000562908.png" width="250" /><body></body>
        <img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224617705-756171309.png" width="250" /><font size="2.5">
            <i>使用了法线贴图，standard vs. our.</i>
        </font></center>

<p>当从实时光照切换到烘焙光时，法线贴图的影响几乎完全消失。这是因为它要求环境反射才能看到它们。</p>

<h3 id="方向性-directionality">方向性-Directionality</h3>

<p>通过将“<em>DirectionalMode</em>”改回“<em>Directional</em>”，可以让法线贴图与烘焙光照一起工作。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224618490-889208576.png" width="250" /><font size="2.5">
            <i>再次启用定向光照贴图.</i>
        </font></center>

<p>当使用方向光照贴图的时候，Unity将创建两个贴图。第一张贴图包含通常的光照信息，称为强度图。 第二张贴图被称为方向图。 它包含大部分烘烤光来自的方向。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224619243-972818284.png" width="250" /><font size="2.5">
            <i>强度图和方向图.</i>
        </font></center>

<p>当方向图可用的时候，用它来对烘焙光进行简单的<strong>漫反射阴影计算</strong>。这使得它可用于法线贴图之上。注意，只有一个光方向是已知的，所以阴影将是一个近似。至少有一个主方向光照的时候，结果就会很好。</p>

<h3 id="对方向进行采样">对方向进行采样</h3>

<p>当方向光照贴图可用的时候，Unity将使用_LIGHTMAP_ON_和_DIRLIGHTMAP_COMBINED_关键字查找着色器变体。我们可以在forward-base-pass通道中使用#pragma multi_compile_fwdbase，而不是为手动添加多编译指令。它会负责解决所有的光照贴图关键字，以及VERTEXLIGHT_ON关键字。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//#pragma multi_compile _ SHADOWS_SCREEN</span>
<span class="c1">//#pragma multi_compile _ LIGHTMAP_ON VERTEXLIGHT_ON</span>

<span class="cp">#pragma multi_compile_fwdbase
#pragma multi_compile_fog
</span></code></pre></div></div>

<p>我们可以为deferred-pass必须使用#pragma multi_compile_prepassfinal指令。 它解决了光照贴图和高动态光照渲染的关键字。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//#pragma multi_compile _ UNITY_HDR_ON</span>
<span class="c1">//#pragma multi_compile _ LIGHTMAP_ON</span>
<span class="cp">#pragma multi_compile_prepassfinal
</span></code></pre></div></div>

<p><em>prepassfinal是什么东西?</em><br />
Unity 4使用了一种与以后的版本不同的延迟渲染管线。 在Unity 5中，它被称为传统延迟光照。 这种方法有更多的渲染通道。Prepass决定是当时的术语。不需要引入新的指令，#pragma multi_compile_prepassfinal也用于当前的延迟渲染通道。</p>

<p>在CreateIndirectLight函数中，在检索烘焙光源本身后，需要直接获得烘焙光的方向。方向贴图可以通过unity_LightmapInd获得。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(LIGHTMAP_ON)
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeLightmap</span><span class="p">(</span><span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">));</span>
    <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>        <span class="kt">float4</span> <span class="n">lightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D</span>
        <span class="p">(</span>
            <span class="n">unity_LightmapInd</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span>
        <span class="p">);</span>
    <span class="cp">#endif
#else
</span>    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>但是，这将导致编译错误。这是因为一个纹理变量实际上由两部分组成。 有纹理资源，还有采样器状态。采样器状态决定纹理的采样方式，包括滤波器和截取模式。 通常，每个纹理都定义了这两个部分，但这并不是所有平台都需要的。 也可以将这两个部分分开，这允许我们为多个纹理定义单个采样器状态。</p>

<p>因为强度和方向贴图总是以相同的方式进行采样，所以在可能的情况下，Unity使用单个采样器状态。 这就是为什么我们在采样强度贴图的时候必须使用UNITY_SAMPLE_TEX2D宏。方向贴图已经定义，没有采样器。 要对其进行采样，我们必须使用UNITY_SAMPLE_TEX2D_SAMPLER宏来明确地告诉它要使用哪个采样器。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="n">lightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span>
<span class="p">(</span>
    <span class="n">unity_LightmapInd</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="使用方向贴图">使用方向贴图</h3>

<p>要使用方向：1、解码 2、对法向量执行点积，找到漫反射因子并将其应用于颜色。</p>

<p>但是方向贴图并没有包含单位长度的方向，而是比单位长度的方向会大一些。 幸运的是可以使用UnityCG的DecodeDirectionLightmap函数来解码方向数据。</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="n">lightmapDirection</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span>
<span class="p">(</span>
    <span class="n">unity_LightmapInd</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span>
<span class="p">);</span>

<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeDirectionalLightmap</span>
<span class="p">(</span>
    <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">lightmapDirection</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span>
<span class="p">);</span>

</code></pre></div></div>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224620025-25891459.png" width="250" /><font size="2.5">
            <i>使用带有方向的光照贴图的效果.</i>
        </font></center>

<p><em>DecodeDirectionLightmap内部做了什么？</em></p>

<p><code class="language-plaintext highlighter-rouge">DecodeDirectionLightmap实际上并不计算正确的漫射照明因子。 相反，它使用的是半Lambert。 这种方法可以有效地将光照射在表面周围，照亮阴影的区域会更多。这么做是有必要的，这是因为烘烤的光照不是来自于单个方向.</code></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inline</span> <span class="kt">half3</span> <span class="nf">DecodeDirectionalLightmap</span> <span class="p">(</span>
    <span class="kt">half3</span> <span class="n">color</span><span class="p">,</span> <span class="n">fixed4</span> <span class="n">dirTex</span><span class="p">,</span> <span class="kt">half3</span> <span class="n">normalWorld</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="c1">// In directional (non-specular) mode Enlighten bakes dominant light</span>
    <span class="c1">// direction in a way, that using it for half Lambert and then dividing</span>
    <span class="c1">// by a "rebalancing coefficient" gives a result close to plain diffuse</span>
    <span class="c1">// response lightmaps, but normalmapped.</span>

    <span class="c1">// Note that dir is not unit length on purpose. Its length is</span>
    <span class="c1">// "directionality", like for the directional specular lightmaps.</span>

    <span class="n">half</span> <span class="n">halfLambert</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">normalWorld</span><span class="p">,</span> <span class="n">dirTex</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">color</span> <span class="o">*</span><span class="n">halfLambert</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1e-4</span><span class="n">h</span><span class="p">,</span> <span class="n">dirTex</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>代码的注释中提到镜面高光。 这些是支持镜面高光的光照贴图，但需要更多的纹理，使用起来也更昂贵，并且在大多数情况下没有产生良好的效果。自Unity 5.6起，它们已被删除了。</em></p>

<h2 id="光照探针-light-probes">光照探针-Light Probes</h2>

<p>光照贴图仅适用于静态对象，而不适用于动态对象。 因此，动态对象不适合带有烘烤光照的场景。当没有实时光源的时候，这是非常明显的。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224620869-2011940708.png" width="250" /></center>

<p>为了更好地混合静态和动态对象，我们必须以某种方式将烘焙的光照应用于动态对象。为了解决这个问题，Unity有光照探针。 光照探针是对空间中的一个点包含该位置的光照信息。 它是用球面谐波来存储这些信息而不是用纹理。 如果可用的话，这些光照探针将用于动态对象，而不是全局环境数据。所以我们要做的就是创建一些探针，等到烘焙的时候，我们的着色器就会自动使用它们。</p>

<h3 id="创建光照探针组">创建光照探针组</h3>

<p>通过GameObject / Light /Light Probe Group将一组光探测器添加到场景中。 这将创建一个新的游戏对象，在立方体的形状中共有八个光探测器。 它们将在渲染动态对象的时候立即使用。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224621611-72687147.png" width="250" /><font size="2.5">
            <i>一个新的光探测器组.</i>
        </font></center>

<p>通过检视器，可以在启用“编辑探针”模式后编辑光探测器组。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224622328-105716559.png" width="250" /></center>

<h3 id="放置光照探针">放置光照探针</h3>

<p>光照探针组将其包围的体积分成四个区域。四个探测器定义了四面体的角。 这些探测器被进行插值以确定用于动态物体的最终球谐函数，这取决于其在四面体内的位置。这意味着动态对象被视为一个单一的点，因此这种方法只对相当小的对象有效。在编辑探测器的时候，会自动生成四面体。 你不需要知道他们的配置，但它们的可视化信息可以帮助你查看探测器的相对位置。放置光照探针需要你去调整他们的位置，直到你得到一个你可以接受的结果，就像光照贴图的设置一样。首先封装将要包含动态对象的区域。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224623082-2091379510.png" width="250" /><font size="2.5">
            <i>封装区域.</i>
        </font></center>

<p>然后根据光照条件如何变化来添加更多的探针。你不必将它们放置在静态几何中。 也不要把它们放在不透明的单面几何体错误的那一面。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224623843-1380403562.png" width="250" /><font size="2.5">
            <i>放置更多的探测器.</i>
        </font></center>

<p>继续添加和移动探测器，直到你在所有区域都有了合理的光照条件，并且在它们之间发生的转换是可以接受的。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224624739-928043347.png" width="250" /><font size="2.5">
            <i>调整探测器的位置.</i>
        </font></center>

<p>可以通过移动动态对象来测试探针。当选择一个动态对象的时候，也会显示当前正在发挥作用的探针。探针将显示其光照，而不仅仅是黄色球体。你还可以看到用于动态对象的内插数据。</p>

<!--url1 url2 url3 url4 url5
    代表一次加载多少张图
-->
<center class="half"><img loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender16/1692664-20200601224702732-797999005.gif" width="250" /><font size="2.5">
            <i>移动动态对象.</i>
        </font></center>

<p>通过不同的光照探头，物体的明暗变化明显。</p>]]></content><author><name>catlikecoding</name></author><category term="Shader" /><summary type="html"><![CDATA[为什么没有立即得到烘焙光源？为了确保在需要的时候光照贴图可以实际生成和更新，请在光照窗口的底部启用“自动生成（Auto Generate）”。 否则，你必须手动生成新的光照贴图。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender16/tutorial-image.png" /><media:content medium="image" url="https://www.damonc.top/web-assets/posts/2018/month1/catRender16/tutorial-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>