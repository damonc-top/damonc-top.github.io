<!DOCTYPE html><html lang="zh-Hans"> <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>多线程编程模型篇-Task(二) - 编程散记</title><meta name="author" content="编程散记"><meta name="description" content="多线程编程模型篇-Task(二)"><meta name="keywords" content="Task"><meta property="og:previous_url" content="/csharp/CSharp_Thread_Pattern.html"><meta property="og:next_url" content="/csharp/CSharp_Thread_Base.html"><meta property="post-date-format" content="0"><meta property="post-date" content="2025-06-06 10:00:00 +0000" /><meta property="calendar-scale" content="year" /><meta property="calendar-scheme" content="null" /><meta property="calendar-color" content="null" /><meta property="og:title" content="多线程编程模型篇-Task(二) - 编程散记"><meta property="og:type" content="website"><meta property="og:url" content="https://www.damonc.top/csharp/Csharp_Task_Base.html"><meta property="og:baseurl" content=""><meta property="og:description" content="个人的一个技术博客站点，记录生活、工作、学习中的一些小事，以及一些比较有趣的事情，留点什么东西也挺不错的，偶尔会在这里停留。"><meta property="og:site_name" content="编程散记"><meta property="og:gray" content="false"><meta property="og:lang" content="zh-Hans"><meta name="alivestart" content="12/23/2020"><meta name="theme-color" content="#81BBFF" /><meta name="algolia-site-verification" content="5E91324370E1262B" /><title>Algolia Verification</title><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="manifest" href="/manifest.json" async><link rel="apple-touch-icon" href="/assets/img/touch/apple-touch-icon.png" /><link rel="Shortcut Icon" href="/favicon.ico"><link rel="icon" href="/favicon.ico" type="image/x-icon" /><link rel="bookmark" href="/favicon.ico" type="image/x-icon" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.min.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.2.0/github-markdown-light.min.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-light.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://unpkg.com/@waline/client@3.3.2/dist/waline.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3" async><link rel="stylesheet" href="/assets/css/app.min.css" async><body class="line-numbers" ontouchstart=""><div id="all" class="post" data-theme="default"><div class="alert-tip" id="no-previous">已经是最新一篇文章了！</div><div class="alert-tip" id="no-next">已经是最后一篇文章了！</div><input id="nm-switch" type="hidden" value="false"><header class="g-header" data-theme="default"><div class="g-logo"> <a href="/" aria-label="logo"></a></div><div id="search-toggle"></div><div id="travelling-toggle"> <a href="https://www.travellings.cn/go.html" aria-label="Travelings" target="_blank"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-train-subway"></use> </svg> </a></div><div id="mode-toggle"> <svg class="icon icon-day" aria-hidden="true"> <use xlink:href="#icon-day"></use> </svg> <svg class="icon icon-night" aria-hidden="true"> <use xlink:href="#icon-night"></use> </svg></div><svg id="menu-toggle" class="icon-menu" aria-hidden="true"> <use xlink:href="#icon-menu"></use> </svg><nav class="g-nav"><ul><li> <a href="/" aria-label="home"> home </a><li> <a href="/blog/index.html" aria-label="blog"> blog </a><li> <a href="/archives.html" aria-label="archives"> archives </a><li> <a href="/tags.html" aria-label="tags"> tags </a><li class="dropdown"> <a class="dropdown-toggle" href="#"> about </a><ul class="dropdown-menu"><li> <a href="/feed.xml" aria-label="RSS"> RSS </a></ul><li class="travelling"> <a href="https://www.travellings.cn/go.html" aria-label="Travelings" target="_blank"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-train-subway"></use> </svg> </a><li class="mode"> <svg class="icon day" aria-hidden="true"> <use xlink:href="#icon-day"></use> </svg> <svg class="icon night" aria-hidden="true"> <use xlink:href="#icon-night"></use> </svg><li id="search"></ul></nav></header><div class="g-banner post-header post-pattern-circuitBoard bgcolor-default post-no-cover" data-theme="default"><div class="post-wrapper"><div class="post-tags"> <a href="/%20/tags.html#Task" class="post-tag">Task</a></div><h1>多线程编程模型篇-Task(二)</h1><div class="post-meta"> <span class="post-meta-item"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-user"></use> </svg> 编程散记 </span> <time class="post-meta-item" datetime=" 25-06-06"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-calendar"></use> </svg> <span class="create-at"></span> </time> <time class="post-meta-item" datetime=" 25-06-06"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-update"></use> </svg> <span class="update-at"></span> </time> <span class="post-meta-item"> <svg class="icon words" aria-hidden="true"> <use xlink:href="#icon-words"></use> </svg> 本文总共 24.5k 字 </span> <span class="post-meta-item"> <svg class="icon time" aria-hidden="true"> <use xlink:href="#icon-time"></use> </svg> 阅读全文大约需要 71 分钟 </span> <span class="post-meta-item"> <svg class="icon pv" aria-hidden="true"> <use xlink:href="#icon-pv"></use> </svg> 本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次 </span></div></div></div><main class="post-content visible"><h2 class="post-subtitle">多线程编程在Unity3d中的应用，Task的基础知识与基本概念。</h2><div class="container"><div class="submenu hidden"></div><div class="contents"><article class="markdown-body post"><h2 id="什么是task">什么是Task</h2><p>  任务是对象，其中封装了以异步方式执行的工作。这听起来有点儿耳熟，委托不也是封装了代码的对象吗？区别在于委托是同步的而任务是异步的。如果执行一个委托(例如一个Action)，当前线程的控制点会立即转移到委托的代码；除非委托结束，否则控制不会返回调用者。简单地说，<strong>任务是将委托从同步执行模式转变成异步执行</strong>。</p><p>  任务是.NET4.0引入的，是.NET4.0中新增的异步编程模型。用以取代复杂、老旧的、代价高昂的Thread编程模型。</p><h3 id="task-vs-线程">Task vs 线程</h3><p>  <code class="language-plaintext highlighter-rouge">Thread</code>是.NET中最基础的线程模型，它提供了最底层的线程管理。但是Thread的创建和销毁成本很高，而且编码过程不能很好地管理线程。</p><p>  <code class="language-plaintext highlighter-rouge">ThreadPool</code>是.NET中基础组件，为所有异步编程模型提供底层支持并在不断改进中。它提供了线程的复用，可以很好地管理线程的创建和销毁。但是ThreadPool的线程只适合短时轻量化任务，像操作I/O这样的活动或者长时间占用线程池中的线程的方法极可能拖慢线程队列中的其他任务，反而性能降低。</p><p>  <code class="language-plaintext highlighter-rouge">Task</code>是.NET4.0中提供的异步编程模型，是基于ThreadPool实现的，可以更方便地编写异步代码。Task的引入使得异步编程变得更加简单、直观。</p><h3 id="task的生命周期">Task的生命周期</h3><p>  Task的生命周期包含创建（Created）、等待运行（WaitingToRun）、运行（Running）、完成（RanToCompletion/Completed）、失败（Faulted）或已取消（Canceled）等阶段。</p><pre><code class="language-mermaid2">graph LR
    A[Task Created&lt;br/&gt;Created] --&gt; B{Task Started?}
    
    B --&gt;|No| C[WaitingToRun]
    B --&gt;|Yes| D[Running]
    
    C --&gt; E[Task Started]
    E --&gt; D
    
    D --&gt; F{Task Completed?}
    D --&gt; G{Task Cancelled?}
    D --&gt; H{Task Faulted?}
    
    F --&gt;|Yes| I[RanToCompletion]
    G --&gt;|Yes| J[Cancelled]
    H --&gt;|Yes| K[Faulted]
    
    I --&gt; L[Task Completed&lt;br/&gt;Final State]
    J --&gt; L
    K --&gt; L
    
    style A fill:#e1f5fe
    style L fill:#c8e6c9
    style D fill:#fff3e0
    style I fill:#e8f5e8
    style J fill:#ffebee
    style K fill:#fff3e0
</code></pre><h2 id="task的api">Task的API</h2><p>  从Task构造函数创建Task实例开始。System.Threading.Tasks命名空间下提供了Task类。</p><h3 id="task构造函数">Task构造函数</h3><p>  Task的构造函数有多个重载，主要用于创建Task对象。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 内部构造函数签名</span>
<span class="k">internal</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Delegate</span><span class="p">,</span><span class="kt">object</span><span class="p">,</span><span class="n">Task</span><span class="p">,</span><span class="n">CancellationToken</span><span class="p">,</span>
    <span class="n">TaskCreationOptions</span><span class="p">,</span><span class="n">InternalTaskOptions</span><span class="p">,</span><span class="n">TaskScheduler</span><span class="p">)</span>

<span class="c1">// 创建一个Task对象，参数为要执行的委托</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数为取消令牌</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数为TaskCreationOptions枚举的值</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数为取消令牌，参数为TaskCreationOptions枚举的值</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数是传递给委托的</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;,</span> <span class="n">Object</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数是传递给委托的，参数为取消令牌</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数是传递给委托的，参数为TaskCreationOptions枚举的值</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">)</span>
<span class="c1">// 创建一个Task对象，参数为要执行的委托，参数是传递给委托的，参数为取消令牌，参数为TaskCreationOptions枚举的值</span>
<span class="k">public</span> <span class="nf">Task</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">)</span>
</code></pre></div></div><p>  虽然Task的构造函数有多个重载，但是<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.-ctor?view=net-9.0#system-threading-tasks-task-ctor(system-action)" rel="nofollow" target="_blank" class="extlinks">官方示例</a>推荐常见做法还是使用Task.Run或TaskFactory.StartNew方法来创建Task对象。</p><div class="premonition info"><div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg><div class="title"> 推荐使用方式</div></div><div class="content"><p>每一个Task构造函数，都提供了对应版本的Task.Run或者TaskFactory.StartNew方法。官方示例中的所有构造函数都多次推荐使用上述方法来创建Task对象。除了要实现一套更高级别的分离任务创建和启动的高级方案。</p></div></div><h3 id="使用taskrun">使用Task.Run</h3><p>  对在 ThreadPool 上运行的指定工作进行排队，并为该工作返回任务或Task<tresult>句柄。它是StartNew重载的轻型替代方法。</tresult></p><table><thead><tr><th>方法<th>描述<tbody><tr><td>Run(Func<task>, CancellationToken)</task><td>在线程池上排队运行任务，返回任务代理。可取消。<tr><td>Run(Action, CancellationToken)<td>在线程池上排队运行工作，返回Task对象。可取消。<tr><td>Run(Func<task>)</task><td>在线程池上排队运行任务，返回任务代理。<tr><td>Run(Action)<td>在线程池上排队运行工作，返回Task对象。<tr><td>Run<tresult>(Func&lt;Task<tresult>&gt;)</tresult></tresult><td>在线程池上排队运行任务，返回Task(TResult)代理。<tr><td>Run<tresult>(Func<tresult>)</tresult></tresult><td>在线程池上排队运行工作，返回Task<tresult>对象。</tresult><tr><td>Run<tresult>(Func&lt;Task<tresult>&gt;, CancellationToken)</tresult></tresult><td>在线程池上排队运行任务，返回Task(TResult)代理。<tr><td>Run<tresult>(Func<tresult>, CancellationToken)</tresult></tresult><td>在线程池上排队运行工作，返回Task<tresult>对象。</tresult></table><p>  新线程要运行的代码由传给Task.Run()方法的委托(本例是Action类型)来定义。这个委托(以Lambda表达式的形式)在控制台不断打印。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"-"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Task</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="n">task</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
</code></pre></div></div><div class="premonition warning"><div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg><div class="title"> 任务的冷与热</div></div><div class="content"><p>调用Task.Run()之后，作为参数传递的 Action几乎立即开始执行。这称为“热”任务，即已触发并开始执行(或已开始排队等待执行)。</p><p>new Task()则是“冷”任务，它需要在显式触发start之后才开始进入线程池排队去执行任务。在start之前不能调用wait、getRuselt等。</p></div></div><h3 id="使用taskfactory">使用Task.Factory</h3><p>  启动Task对象并将任务调度到TaskScheduler，它与Run方法基本相同，但返回Task对象而不是Task<tresult>代理。可以调用TaskFactory类的构造函数来配置 TaskFactory类创建所需要的模版任务。</tresult></p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>

<span class="k">static</span> <span class="n">TaskFactory</span> <span class="n">factory</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TaskFactory</span><span class="p">(</span>
    <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">,</span>
    <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">PreferFairness</span><span class="p">,</span>
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">ExecuteSynchronously</span><span class="p">,</span>
    <span class="k">new</span> <span class="nf">CustomScheduler</span><span class="p">());</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">t2</span> <span class="p">=</span> <span class="n">factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoWork</span><span class="p">());</span>
    <span class="n">cts</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">DoWork</span><span class="p">()</span> <span class="p">{</span><span class="cm">/*...*/</span> <span class="p">}</span>
</code></pre></div></div><h2 id="task的核心属性">Task的核心属性</h2><table><thead><tr><th>属性<th>描述<tbody><tr><td>Status<td>获取任务的当前状态。<tr><td>IsCompleted<td>该值指示Task是否已通过运行其方法完成执行。<tr><td>IsFaulted<td>该值指示Task是否由于未处理异常而完成执行。<tr><td>IsCanceled<td>该值指示Task是否由于被取消而完成执行。<tr><td>Exception<td>获取一个异常，该异常是Task因未处理异常而完成时引发的。<tr><td>Result<td>获取Task的结果值。<tr><td>Id<td>获取任务的唯一标识符。</table><h2 id="task的等待和同步">Task的等待和同步</h2><table><thead><tr><th>方法<th>返回类型<th>说明<tbody><tr><td>WaitAny<td>int<td>返回已完成Task在数组中的索引<tr><td>WaitAll<td>void<td>无返回值，阻塞直到所有完成<tr><td>WhenAny<td>Task<task></task><td>返回一个Task，其Result是第一个完成的Task<tr><td>WhenAll<td>Task 或 Task&lt;TResult[]&gt;<td>返回一个Task，当所有输入Task完成后完成</table><p>  <code class="language-plaintext highlighter-rouge">Wait接口是阻塞方法</code>。是不管是哪一种Wait、WaitAny、WaitAll他们都阻塞当前线程，直到条件满足。异常会直接抛出，需要立即处理。</p><p>  <code class="language-plaintext highlighter-rouge">When接口是非阻塞方法</code>。都是非阻塞方法，它们不会阻塞当前线程，而是返回一个Task，当条件满足时，该Task会完成。异常被包装在返回的Task中。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 传统方式 - 阻塞</span>
<span class="n">Task</span><span class="p">[]</span> <span class="n">tasks</span> <span class="p">=</span> <span class="p">{</span> <span class="nf">Task1</span><span class="p">(),</span> <span class="nf">Task2</span><span class="p">(),</span> <span class="nf">Task3</span><span class="p">()</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">index</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WaitAny</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>  <span class="c1">// 阻塞等待</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Task </span><span class="p">{</span><span class="n">index</span><span class="p">}</span><span class="s"> completed first"</span><span class="p">);</span>

<span class="c1">// 异步方式 - 非阻塞</span>
<span class="n">Task</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">whenAnyResult</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAny</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
<span class="n">Task</span> <span class="n">completedTask</span> <span class="p">=</span> <span class="k">await</span> <span class="n">whenAnyResult</span><span class="p">;</span>  <span class="c1">// 不阻塞线程</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"First task completed"</span><span class="p">);</span>
</code></pre></div></div><h3 id="task接口一致性">Task接口一致性</h3><p>  FromResult、FromException、FromCanceled是Task的静态方法，用于创建已完成的Task对象。这些方法的主要价值在于保持异步接口的一致性，尤其是在无法使用async/await关键字的情况下，符合Task<t>的契约。</t></p><table><thead><tr><th>方法<th>描述<tbody><tr><td>FromResult<td>创建一个已完成的Task对象，参数为结果<tr><td>FromException<td>创建一个已完成的Task对象，参数为异常<tr><td>FromCanceled<td>创建一个已完成的Task对象，参数为取消令牌</table><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IMathService</span>
<span class="p">{</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="nf">DivideAsync</span><span class="p">(</span><span class="kt">double</span> <span class="n">numerator</span><span class="p">,</span> <span class="kt">double</span> <span class="n">denominator</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MathService</span> <span class="p">:</span> <span class="n">IMathService</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="nf">DivideAsync</span><span class="p">(</span><span class="kt">double</span> <span class="n">numerator</span><span class="p">,</span> <span class="kt">double</span> <span class="n">denominator</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 同步的参数验证</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">denominator</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 发现错误，立即返回一个失败的任务，而不是抛出阻塞性异常</span>
            <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromException</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;(</span><span class="k">new</span> <span class="nf">DivideByZeroException</span><span class="p">(</span><span class="s">"Denominator cannot be zero."</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// 如果验证通过，进行同步计算并返回成功结果</span>
        <span class="kt">double</span> <span class="n">result</span> <span class="p">=</span> <span class="n">numerator</span> <span class="p">/</span> <span class="n">denominator</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="task的延续操作">Task的延续操作</h2><p>  延续任务（Continuation Tasks）是Task并行库中最重要的特性之一，它允许您在某个任务完成后自动执行后续操作，形成任务链。延续任务的核心方法是ContinueWith。</p><h3 id="taskcontinuewith">Task.ContinueWith</h3><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Task</span> <span class="nf">ContinueWith</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">continuationAction</span><span class="p">);</span>
<span class="k">public</span> <span class="n">Task</span> <span class="nf">ContinueWith</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">continuationAction</span><span class="p">,</span> <span class="n">TaskContinuationOptions</span> <span class="n">continuationOptions</span><span class="p">);</span>
<span class="k">public</span> <span class="n">Task</span> <span class="nf">ContinueWith</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">continuationAction</span><span class="p">,</span> <span class="n">TaskScheduler</span> <span class="n">scheduler</span><span class="p">);</span>
<span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;</span> <span class="n">ContinueWith</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">continuationFunction</span><span class="p">);</span>
</code></pre></div></div><p>关键特性：</p><ol><li>非阻塞性：延续任务不会阻塞前置任务的完成<li>自动调度：当任务完成时，延续任务会自动被调度执行<li>状态感知：延续任务可以通过Task参数访问前置任务的状态、结果和异常</ol><p>  延续任务的执行依赖于前置任务的状态：</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">antecedent</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">ComputeData</span><span class="p">());</span>

<span class="n">Task</span> <span class="n">continuation</span> <span class="p">=</span> <span class="n">antecedent</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">IsCompleted</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 任务成功完成</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">IsFaulted</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 任务出现异常</span>
        <span class="kt">var</span> <span class="n">exception</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Exception</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">IsCanceled</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 任务被取消</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"任务被取消"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div><h3 id="延续任务的选项">延续任务的选项</h3><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 无条件执行 - 无论前置任务什么状态都执行</span>
<span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">None</span>

<span class="c1">// 2. 条件执行选项</span>
<span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span>    <span class="c1">// 仅在前置任务成功完成时执行</span>
<span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnFaulted</span>           <span class="c1">// 仅在前置任务失败时执行  </span>
<span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnCanceled</span>          <span class="c1">// 仅在前置任务取消时执行</span>

<span class="c1">// 3. 支持组合条件</span>
<span class="n">OnlyOnRanToCompletion</span> <span class="p">|</span> <span class="n">OnlyOnFaulted</span>
</code></pre></div></div><h3 id="链式延续任务">链式延续任务</h3><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DownloadData</span><span class="p">())</span>
<span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">ProcessData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">)</span>
<span class="p">.</span><span class="nf">Uwarp</span><span class="p">()</span>
<span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">processedData</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">SaveResults</span><span class="p">(</span><span class="n">processedData</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">);</span>

<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
</code></pre></div></div><p>  Unwrap是Task的扩展方法，用于将Task&lt;Task<t>&gt;解包为Task<t>。可以将链式任务解包，避免嵌套的Task。</t></t></p><h2 id="task的异常处理">Task的异常处理</h2><p>  不能用try块包装start()调用来捕捉异常，因为控制会立即从调用返回，然后控制会离开try块，而这时距离工作者线程发生异常可能还有好久呢 一个解决方案是将任务的委托主体包装到try/catch块中。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"Something went wrong"</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 异常此时还没有抛出</span>
<span class="c1">// 只有在以下操作时才会抛出：</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="n">task</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>  <span class="c1">// 直接抛出异常</span>
    <span class="c1">// 或</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>  <span class="c1">// 通过Result抛出</span>
    <span class="c1">// 或在async方法中</span>
    <span class="k">await</span> <span class="n">task</span><span class="p">;</span>  <span class="c1">// await时抛出</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">InvalidOperationException</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="异常传播机制">异常传播机制</h3><p>  当一个Task抛出异常时，异常会被捕获并存储在Task对象中，只有在访问Result属性、调用Wait()或await时才会抛出异常，异常可以在任何线程上被观察到。</p><h3 id="aggregateexception详解">AggregateException详解</h3><p>  多个Task的异常会被包装成AggregateException，可以嵌套其他AggregateException。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">task1</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{});</span>
<span class="n">Task</span> <span class="n">task2</span> <span class="p">=</span> <span class="n">task1</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"exception"</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">try</span> <span class="p">{</span>
    <span class="n">Task</span><span class="p">.</span><span class="nf">WaitAll</span><span class="p">(</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ae</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 处理聚合异常</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">innerEx</span> <span class="k">in</span> <span class="n">ae</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Inner exception: </span><span class="p">{</span><span class="n">innerEx</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 或者展开所有异常</span>
    <span class="n">ae</span><span class="p">.</span><span class="nf">Flatten</span><span class="p">().</span><span class="nf">Handle</span><span class="p">(</span><span class="n">ex</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Flattened exception: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span> <span class="c1">// 表示已处理</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="异常处理最佳实践">异常处理最佳实践</h3><p>  ①使用await进行自然异常处理。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 推荐：异常自然传播</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ProcessDataAsync</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">DownloadDataAsync</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">ProcessDataAsync</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 调用方自然处理异常</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">ProcessDataAsync</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">InvalidOperationException</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 直接处理具体异常类型</span>
<span class="p">}</span>
</code></pre></div></div><p>  ②聚合异常的处理模式</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 模式1：展开并逐个处理</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ae</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ae</span><span class="p">.</span><span class="nf">Flatten</span><span class="p">().</span><span class="nf">Handle</span><span class="p">(</span><span class="n">ex</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="k">is</span> <span class="n">IOException</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 处理IO异常</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="k">is</span> <span class="n">ValidationException</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 处理验证异常</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span> <span class="c1">// 未处理的异常会重新抛出</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// 模式2：重新抛出第一个异常</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ae</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">ae</span><span class="p">.</span><span class="n">InnerException</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>  ③避免混用同步和异步等待</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 避免：混用.Wait()和await</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ProcessAsync</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="nf">DoWorkAsync</span><span class="p">();</span>
    
    <span class="c1">// 不要这样做 - 可能导致死锁</span>
    <span class="n">task</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>  <span class="c1">// 阻塞当前线程</span>
    
    <span class="c1">// 而应该：</span>
    <span class="k">await</span> <span class="n">task</span><span class="p">;</span>  <span class="c1">// 正确的方式</span>
<span class="p">}</span>
</code></pre></div></div><p>  ④延续任务的异常处理</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoWork</span><span class="p">());</span>
<span class="n">Task</span> <span class="n">continuation</span> <span class="p">=</span> <span class="n">task</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">IsFaulted</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 处理前置任务的异常</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Previous task failed: </span><span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">Exception</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 处理成功结果</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">);</span>
</code></pre></div></div><h3 id="未观察异常的处理">未观察异常的处理</h3><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 危险：创建Task但不观察其结果</span>
<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"This will be unobserved!"</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// 危险：创建Task但不观察其结果</span>
<span class="n">New</span> <span class="nf">Task</span><span class="p">(()=&gt;{}).</span><span class="nf">Start</span><span class="p">();</span>
<span class="c1">// Task被垃圾回收时才会触发UnobservedTaskException</span>
</code></pre></div></div><p>  Unity中未观察异常的处理。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Unity中处理未观察异常</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">TaskExceptionHandler</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">UnobservedTaskException</span> <span class="p">+=</span> <span class="n">HandleUnobservedException</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">void</span> <span class="nf">OnDestroy</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">UnobservedTaskException</span> <span class="p">-=</span> <span class="n">HandleUnobservedException</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">void</span> <span class="nf">HandleUnobservedException</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">UnobservedTaskExceptionEventArgs</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 在主线程处理异常，避免Unity崩溃</span>
        <span class="n">UnityEngine</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"Unobserved Task Exception: </span><span class="p">{</span><span class="n">e</span><span class="p">.</span><span class="n">Exception</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="n">e</span><span class="p">.</span><span class="nf">SetObserved</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="task的取消机制">Task的取消机制</h2><h3 id="cancellationtokensource">CancellationTokenSource</h3><p>  CancellationTokenSource是Task取消机制的核心类，负责创建和管理CancellationToken实例。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建CancellationTokenSource</span>
<span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
<span class="c1">// 获取令牌</span>
<span class="n">CancellationToken</span> <span class="n">token</span> <span class="p">=</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">;</span>
<span class="c1">// 启动任务</span>
<span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 执行工作</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="n">token</span><span class="p">);</span>
<span class="c1">// 请求取消</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">Cancel</span><span class="p">();</span>
<span class="c1">// 清理资源</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
</code></pre></div></div><h4 id="超时cancellationtokensource">超时CancellationTokenSource</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建带超时的令牌源</span>
<span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">5</span><span class="p">));</span>
<span class="c1">// 或者手动设置超时</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">CancelAfter</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">10</span><span class="p">));</span>
<span class="c1">// 使用</span>
<span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">LongRunningOperation</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">),</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
</code></pre></div></div><h4 id="链接cancellationtokensource">链接CancellationTokenSource</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CancellationTokenSource</span> <span class="n">cts1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
<span class="n">CancellationTokenSource</span> <span class="n">cts2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
<span class="c1">// 创建链接的令牌源</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">linkedCts</span> <span class="p">=</span> <span class="n">CancellationTokenSource</span><span class="p">.</span><span class="nf">CreateLinkedTokenSource</span><span class="p">(</span><span class="n">cts1</span><span class="p">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">cts2</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
<span class="c1">// 任何一个令牌取消都会导致链接令牌取消</span>
<span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoWork</span><span class="p">(</span><span class="n">linkedCts</span><span class="p">.</span><span class="n">Token</span><span class="p">),</span> <span class="n">linkedCts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
</code></pre></div></div><h3 id="cancellationtoken">CancellationToken</h3><p>  CancellationToken是不可变的值类型，用于传递取消请求。</p><h4 id="核心属性和方法">核心属性和方法</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">struct</span> <span class="nc">CancellationToken</span> <span class="p">{</span>
    <span class="c1">// 属性</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsCancellationRequested</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 是否请求了取消</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">CanBeCanceled</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>            <span class="c1">// 是否可以被取消</span>
    <span class="k">public</span> <span class="n">WaitHandle</span> <span class="n">WaitHandle</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>         <span class="c1">// 用于同步等待</span>
    
    <span class="c1">// 方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">ThrowIfCancellationRequested</span><span class="p">()</span>    <span class="c1">// 抛出取消异常</span>
    <span class="k">public</span> <span class="n">CancellationTokenRegistration</span> <span class="nf">Register</span><span class="p">(</span><span class="n">Action</span> <span class="n">callback</span><span class="p">)</span>  <span class="c1">// 注册取消回调</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="基本取消检查模式">基本取消检查模式</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoWorkAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 方式1：轮询检查</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>  <span class="c1">// 自动处理取消</span>
    <span class="p">}</span>
    
    <span class="c1">// 方式2：定期检查</span>
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">DoStep1Async</span><span class="p">();</span>
    
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">DoStep2Async</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="注册取消回调">注册取消回调</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CancellationToken</span> <span class="n">token</span> <span class="p">=</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">;</span>

<span class="c1">// 注册取消时的回调</span>
<span class="n">CancellationTokenRegistration</span> <span class="n">registration</span> <span class="p">=</span> <span class="n">token</span><span class="p">.</span><span class="nf">Register</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"任务被取消，执行清理工作"</span><span class="p">);</span>
    <span class="c1">// 清理资源</span>
<span class="p">});</span>

<span class="c1">// 取消注册（可选）</span>
<span class="n">registration</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
</code></pre></div></div><h3 id="取消操作的模式">取消操作的模式</h3><h4 id="协作式取消模式">协作式取消模式</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ProcessDataAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 阶段1：数据验证</span>
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">ValidateDataAsync</span><span class="p">();</span>
    
    <span class="c1">// 阶段2：数据处理</span>
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">ProcessDataAsync</span><span class="p">();</span>
    
    <span class="c1">// 阶段3：结果保存</span>
    <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">SaveResultAsync</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="基于回调的取消模式">基于回调的取消模式</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">using</span> <span class="nn">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>
        
        <span class="c1">// 注册取消回调</span>
        <span class="k">using</span> <span class="nn">var</span> <span class="n">registration</span> <span class="p">=</span> <span class="n">token</span><span class="p">.</span><span class="nf">Register</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="n">client</span><span class="p">.</span><span class="nf">CancelPendingRequests</span><span class="p">();</span>
        <span class="p">});</span>
        
        <span class="c1">// 执行下载</span>
        <span class="k">return</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span>
    <span class="p">},</span> <span class="n">token</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="超时取消模式">超时取消模式</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ExecuteWithTimeoutAsync</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span>
    <span class="n">Func</span><span class="p">&lt;</span><span class="n">CancellationToken</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">operation</span><span class="p">,</span> 
    <span class="n">TimeSpan</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="k">using</span> <span class="nn">var</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
    
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">await</span> <span class="nf">operation</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="nf">when</span> <span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">TimeoutException</span><span class="p">(</span><span class="s">$"操作在</span><span class="p">{</span><span class="n">timeout</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">}</span><span class="s">秒内未完成"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="复合取消模式用户取消--超时">复合取消模式（用户取消 + 超时）</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ExecuteWithUserCancellationAsync</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span>
    <span class="n">Func</span><span class="p">&lt;</span><span class="n">CancellationToken</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">operation</span><span class="p">,</span>
    <span class="n">CancellationToken</span> <span class="n">userToken</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="k">using</span> <span class="nn">var</span> <span class="n">timeoutCts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMinutes</span><span class="p">(</span><span class="m">5</span><span class="p">));</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">linkedCts</span> <span class="p">=</span> <span class="n">CancellationTokenSource</span><span class="p">.</span><span class="nf">CreateLinkedTokenSource</span><span class="p">(</span>
        <span class="n">userToken</span><span class="p">,</span> <span class="n">timeoutCts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="k">await</span> <span class="nf">operation</span><span class="p">(</span><span class="n">linkedCts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="取消操作的传播">取消操作的传播</h3><h4 id="父子任务的取消传播">父子任务的取消传播</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ProcessMultipleFilesAsync</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">files</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">files</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">file</span> <span class="p">=&gt;</span> 
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">ProcessFileAsync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">token</span><span class="p">),</span> <span class="n">token</span><span class="p">)</span>
    <span class="p">);</span>
    
    <span class="c1">// 当任何一个任务失败或取消时，取消所有任务</span>
    <span class="kt">var</span> <span class="n">allTasks</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
    
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">await</span> <span class="n">allTasks</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 取消传播到所有子任务</span>
        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="延续任务的取消处理">延续任务的取消处理</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">initialTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoInitialWork</span><span class="p">(),</span> <span class="n">token</span><span class="p">);</span>

<span class="c1">// 只有当初始任务成功完成时才执行延续</span>
<span class="n">Task</span> <span class="n">continuation1</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 处理成功结果</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">);</span>

<span class="c1">// 无论初始任务什么状态都执行延续（用于清理）</span>
<span class="n">Task</span> <span class="n">continuation2</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 执行清理工作</span>
    <span class="nf">CleanupResources</span><span class="p">();</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
</code></pre></div></div><h4 id="取消状态的传播">取消状态的传播</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">OperationResult</span><span class="p">&gt;</span> <span class="nf">ExecuteOperationAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">DoWorkAsync</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">OperationResult</span> <span class="p">{</span> <span class="n">Success</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span> <span class="n">Data</span> <span class="p">=</span> <span class="n">result</span> <span class="p">};</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 取消状态传播</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">OperationResult</span> <span class="p">{</span> <span class="n">Success</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span> <span class="n">WasCancelled</span> <span class="p">=</span> <span class="k">true</span> <span class="p">};</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 其他异常</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">OperationResult</span> <span class="p">{</span> <span class="n">Success</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span> <span class="n">Error</span> <span class="p">=</span> <span class="n">ex</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="资源清理的取消传播">资源清理的取消传播</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ProcessWithCleanupAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IDisposable</span> <span class="n">resource</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
    
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">resource</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">AcquireResourceAsync</span><span class="p">();</span>
        
        <span class="c1">// 检查取消状态</span>
        <span class="n">token</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
        
        <span class="k">await</span> <span class="nf">ProcessResourceAsync</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 即使取消也要清理资源</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">resource</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">resource</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
        <span class="c1">// 确保资源被清理</span>
        <span class="n">resource</span><span class="p">?.</span><span class="nf">Dispose</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="取消请求的级联传播">取消请求的级联传播</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">CancellationTokenSource</span> <span class="n">_cts</span><span class="p">;</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">StartOperation</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
    <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">ExecuteOperationAsync</span><span class="p">(</span><span class="n">_cts</span><span class="p">.</span><span class="n">Token</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ExecuteOperationAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 子操作也会收到取消请求</span>
        <span class="k">await</span> <span class="nf">Step1Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">Step2Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">Step3Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 取消被正确处理</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"操作被取消"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="task的调度和配置">Task的调度和配置</h2><p>  TaskScheduler是Task调度系统的核心抽象类，负责控制Task的执行方式和位置。</p><h3 id="taskscheduler详解">TaskScheduler详解</h3><p>  TaskScheduler调度器维护了一个等待执行的任务队列，并决定任务执行的优先级和处理任务的依赖关系。TaskScheduler可以决定任务在哪个线程执行，控制并发执行的任务数量，处理任务的异常。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 线程池调度器（默认）</span>
<span class="n">TaskScheduler</span> <span class="n">threadPoolScheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Default</span><span class="p">;</span>

<span class="c1">// 2. 当前同步上下文调度器</span>
<span class="n">TaskScheduler</span> <span class="n">currentScheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>

<span class="c1">// 3. 从同步上下文中捕获的调度器</span>
<span class="n">TaskScheduler</span> <span class="n">capturedScheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="nf">FromCurrentSynchronizationContext</span><span class="p">();</span>

<span class="c1">// 默认调度器 - 使用线程池</span>
<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"执行线程: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="m">42</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 显式指定调度器</span>
<span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">DoWork</span><span class="p">();</span>
<span class="p">},</span> <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>



<span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 在后台线程执行</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">DoWork</span><span class="p">());</span>
    
    <span class="c1">// 自动切换回UI线程更新界面</span>
    <span class="n">textBox</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 显式使用调度器</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">UpdateUI</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TaskScheduler</span> <span class="n">uiScheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="nf">FromCurrentSynchronizationContext</span><span class="p">();</span>
    
    <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="nf">LoadData</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}).</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">// 在UI线程执行</span>
        <span class="nf">UpdateUI</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
    <span class="p">},</span> <span class="n">uiScheduler</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="taskcreationoptions">TaskCreationOptions</h3><p>  TaskCreationOptions枚举用于配置Task的创建行为。</p><table><thead><tr><th>选项<th>说明<th>使用场景<tbody><tr><td>None<td>默认行为<td>标准任务创建<tr><td>PreferFairness<td>公平调度<td>确保任务按顺序执行<tr><td>LongRunning<td>长运行任务<td>CPU密集型或长时间运行任务<tr><td>AttachedToParent<td>附加到父任务<td>创建子任务层次结构<tr><td>DenyChildAttach<td>拒绝子任务附加<td>独立任务执行<tr><td>HideScheduler<td>隐藏调度器<td>内部使用<tr><td>RunContinuationsAsynchronously<td>异步延续<td>避免死锁</table><p>  LongRunning选项用于将任务分配给专用线程，适用于CPU密集型或长时间运行的任务。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 长运行任务 - 为其分配专用线程</span>
<span class="n">Task</span> <span class="n">longRunningTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// CPU密集型计算</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="c1">// 复杂计算</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">LongRunning</span><span class="p">);</span>
</code></pre></div></div><p>  AttachedToParent选项用于将子任务自动附加到父任务，适用于创建子任务层次结构。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">parentTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"父任务开始"</span><span class="p">);</span>
    
    <span class="c1">// 子任务自动附加到父任务</span>
    <span class="n">Task</span> <span class="n">childTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"子任务执行"</span><span class="p">);</span>
        <span class="k">return</span> <span class="m">42</span><span class="p">;</span>
    <span class="p">},</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">AttachedToParent</span><span class="p">);</span>
    
    <span class="c1">// 父任务等待所有子任务完成</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"父任务结束"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div><p>  PreferFairness选项用于确保任务按提交顺序执行。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 确保任务按提交顺序执行</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"任务 </span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="s"> 执行"</span><span class="p">);</span>
    <span class="p">},</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">PreferFairness</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="taskcontinuationoptions">TaskContinuationOptions</h3><p>  TaskContinuationOptions控制延续任务的执行条件和行为。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">initialTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 可能成功、失败或取消</span>
    <span class="k">return</span> <span class="nf">ComputeResult</span><span class="p">();</span>
<span class="p">});</span>

<span class="c1">// 1. 只有成功时执行</span>
<span class="n">Task</span> <span class="n">successContinuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"结果: </span><span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">);</span>

<span class="c1">// 2. 只有失败时执行</span>
<span class="n">Task</span> <span class="n">failureContinuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"错误: </span><span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">Exception</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnFaulted</span><span class="p">);</span>

<span class="c1">// 3. 只有取消时执行</span>
<span class="n">Task</span> <span class="n">cancellationContinuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"任务被取消"</span><span class="p">);</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnCanceled</span><span class="p">);</span>

<span class="c1">// 4. 无论什么情况都执行（用于清理）</span>
<span class="n">Task</span> <span class="n">cleanupContinuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nf">CleanupResources</span><span class="p">();</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>

<span class="c1">// 组合多个选项</span>
<span class="n">TaskContinuationOptions</span> <span class="n">options</span> <span class="p">=</span> 
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span> <span class="p">|</span> 
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">RunContinuationsAsynchronously</span> <span class="p">|</span> 
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">AttachedToParent</span><span class="p">;</span>

<span class="n">Task</span> <span class="n">continuation</span> <span class="p">=</span> <span class="n">initialTask</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">ProcessResult</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
<span class="p">},</span> <span class="n">options</span><span class="p">);</span>
</code></pre></div></div><h3 id="自定义taskscheduler">自定义TaskScheduler</h3><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">UnityTaskScheduler</span> <span class="p">:</span> <span class="n">TaskScheduler</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="n">_tasks</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">object</span> <span class="n">_lock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">QueueTask</span><span class="p">(</span><span class="n">Task</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lock</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_tasks</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">TryExecuteTaskInline</span><span class="p">(</span><span class="n">Task</span> <span class="n">task</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">taskWasPreviouslyQueued</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">TryExecuteTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span> <span class="nf">GetScheduledTasks</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_tasks</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 在Unity主线程调用此方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">ExecutePendingTasks</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">_tasks</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="n">task</span><span class="p">))</span> <span class="p">{</span>
            <span class="nf">TryExecuteTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 在MonoBehaviour中使用</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">TaskManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">private</span> <span class="n">UnityTaskScheduler</span> <span class="n">_scheduler</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">_scheduler</span><span class="p">.</span><span class="nf">ExecutePendingTasks</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">RunOnMainThread</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">action</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">tcs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskCompletionSource</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
        
        <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">action</span><span class="p">();</span>
            <span class="n">tcs</span><span class="p">.</span><span class="nf">SetResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="p">},</span> <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">_scheduler</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">tcs</span><span class="p">.</span><span class="n">Task</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="task的高级用法">Task的高级用法</h2><h3 id="taskcompletionsource">TaskCompletionSource</h3><p>  TaskCompletionSource是Task并行库中最强大的工具之一，允许创建”冷”任务，用于手动控制Task的生命周期和完成状态。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">TaskCompletionSource</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Task</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 获取关联的Task对象</span>
    
    <span class="c1">// 完成控制方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetResult</span><span class="p">(</span><span class="n">T</span> <span class="n">result</span><span class="p">);</span>           <span class="c1">// 设置成功结果</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetException</span><span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">);</span>    <span class="c1">// 设置异常</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetException</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Exception</span><span class="p">&gt;</span> <span class="n">exs</span><span class="p">);</span>  <span class="c1">// 设置多个异常</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetCanceled</span><span class="p">();</span>                <span class="c1">// 设置为已取消</span>
    
    <span class="c1">// 尝试版本（如果任务已完成则返回false）</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">TrySetResult</span><span class="p">(</span><span class="n">T</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">TrySetException</span><span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">);</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">TrySetCanceled</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div><p>  包装异步回调操作</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">DownloadFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">tcs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskCompletionSource</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
    
    <span class="k">using</span> <span class="nn">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WebClient</span><span class="p">();</span>
    <span class="n">client</span><span class="p">.</span><span class="n">DownloadStringCompleted</span> <span class="p">+=</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Error</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tcs</span><span class="p">.</span><span class="nf">SetException</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Error</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tcs</span><span class="p">.</span><span class="nf">SetCanceled</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tcs</span><span class="p">.</span><span class="nf">SetResult</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
    
    <span class="n">client</span><span class="p">.</span><span class="nf">DownloadAssestAsync</span><span class="p">(</span><span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="n">url</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">tcs</span><span class="p">.</span><span class="n">Task</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="task在unity3d中的应用">Task在Unity3D中的应用</h2><h3 id="unity主线程限制">Unity主线程限制</h3><p>  Unity3D有严格的主线程限制，这是使用Task时必须了解的核心概念：</p><p>  <strong>Unity API的线程安全性限制</strong></p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ 错误：在后台线程调用Unity API会抛出异常</span>
<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 这会导致异常："UnityEngine.Transform can only be called from the main thread"</span>
    <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
    <span class="n">GameObject</span><span class="p">.</span><span class="nf">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// ✅ 正确：在主线程执行Unity API调用</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">UnityTaskManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Action</span><span class="p">&gt;</span> <span class="n">_mainThreadActions</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
    
    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 在主线程执行队列中的操作</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">_mainThreadActions</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="n">action</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">action</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">RunOnMainThread</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">action</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">tcs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskCompletionSource</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
        
        <span class="n">_mainThreadActions</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">action</span><span class="p">();</span>
                <span class="n">tcs</span><span class="p">.</span><span class="nf">SetResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tcs</span><span class="p">.</span><span class="nf">SetException</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
        
        <span class="k">return</span> <span class="n">tcs</span><span class="p">.</span><span class="n">Task</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="异步操作的最佳实践">异步操作的最佳实践</h3><p>  <strong>网络请求的异步处理</strong></p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">NetworkManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">HttpClient</span> <span class="n">_httpClient</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>
    
    <span class="c1">// 异步下载并更新UI</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">Sprite</span><span class="p">&gt;</span> <span class="nf">LoadSpriteAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">,</span> <span class="n">Image</span> <span class="n">targetImage</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="c1">// 后台线程下载</span>
            <span class="kt">var</span> <span class="n">imageData</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_httpClient</span><span class="p">.</span><span class="nf">GetByteArrayAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
            
            <span class="c1">// 主线程创建Sprite并更新UI</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">UnityTaskScheduler</span><span class="p">.</span><span class="nf">RunOnMainThread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="kt">var</span> <span class="n">texture</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Texture2D</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>
                <span class="n">texture</span><span class="p">.</span><span class="nf">LoadImage</span><span class="p">(</span><span class="n">imageData</span><span class="p">);</span>
                
                <span class="kt">var</span> <span class="n">sprite</span> <span class="p">=</span> <span class="n">Sprite</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span> 
                    <span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">texture</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">texture</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> 
                    <span class="n">Vector2</span><span class="p">.</span><span class="n">one</span> <span class="p">*</span> <span class="m">0.5f</span><span class="p">);</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">targetImage</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">targetImage</span><span class="p">.</span><span class="n">sprite</span> <span class="p">=</span> <span class="n">sprite</span><span class="p">;</span>
                <span class="p">}</span>
                
                <span class="k">return</span> <span class="n">sprite</span><span class="p">;</span>
            <span class="p">});</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"加载图片失败: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>  <strong>文件I/O的异步处理</strong></p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">SaveSystem</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="nf">SaveGameDataAsync</span><span class="p">(</span><span class="n">GameData</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="c1">// 后台线程序列化和写入文件</span>
            <span class="kt">var</span> <span class="n">json</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">JsonUtility</span><span class="p">.</span><span class="nf">ToJson</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">true</span><span class="p">));</span>
            <span class="kt">var</span> <span class="n">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">Combine</span><span class="p">(</span><span class="n">Application</span><span class="p">.</span><span class="n">persistentDataPath</span><span class="p">,</span> <span class="s">"save.json"</span><span class="p">);</span>
            
            <span class="k">await</span> <span class="n">File</span><span class="p">.</span><span class="nf">WriteAllTextAsync</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">json</span><span class="p">);</span>
            
            <span class="c1">// 主线程显示保存成功提示</span>
            <span class="k">await</span> <span class="n">UnityTaskScheduler</span><span class="p">.</span><span class="nf">RunOnMainThread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="nf">ShowSaveSuccessMessage</span><span class="p">();</span>
            <span class="p">});</span>
            
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"保存失败: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">GameData</span><span class="p">&gt;</span> <span class="nf">LoadGameDataAsync</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="kt">var</span> <span class="n">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">Combine</span><span class="p">(</span><span class="n">Application</span><span class="p">.</span><span class="n">persistentDataPath</span><span class="p">,</span> <span class="s">"save.json"</span><span class="p">);</span>
            
            <span class="k">if</span> <span class="p">(!</span><span class="n">File</span><span class="p">.</span><span class="nf">Exists</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">GameData</span><span class="p">();</span> <span class="c1">// 返回默认数据</span>
            <span class="p">}</span>
            
            <span class="c1">// 后台线程读取和反序列化</span>
            <span class="kt">var</span> <span class="n">json</span> <span class="p">=</span> <span class="k">await</span> <span class="n">File</span><span class="p">.</span><span class="nf">ReadAllTextAsync</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">JsonUtility</span><span class="p">.</span><span class="n">FromJson</span><span class="p">&lt;</span><span class="n">GameData</span><span class="p">&gt;(</span><span class="n">json</span><span class="p">));</span>
            
            <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"加载失败: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">GameData</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>  <strong>批量操作的进度报告</strong></p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AssetLoader</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">LoadAssetsWithProgressAsync</span><span class="p">(</span>
        <span class="kt">string</span><span class="p">[]</span> <span class="n">assetPaths</span><span class="p">,</span> 
        <span class="n">IProgress</span><span class="p">&lt;</span><span class="kt">float</span><span class="p">&gt;</span> <span class="n">progress</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span>
        <span class="n">CancellationToken</span> <span class="n">cancellationToken</span> <span class="p">=</span> <span class="k">default</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="kt">var</span> <span class="n">loadedCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">totalCount</span> <span class="p">=</span> <span class="n">assetPaths</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
        
        <span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">assetPaths</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="k">async</span> <span class="n">path</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="c1">// 后台加载资源数据</span>
                <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">LoadAssetDataAsync</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">cancellationToken</span><span class="p">);</span>
                
                <span class="c1">// 主线程创建Unity对象</span>
                <span class="k">await</span> <span class="n">UnityTaskScheduler</span><span class="p">.</span><span class="nf">RunOnMainThread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                    <span class="nf">CreateUnityAsset</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
                <span class="p">});</span>
                
                <span class="c1">// 更新进度</span>
                <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="n">loadedCount</span><span class="p">);</span>
                <span class="kt">var</span> <span class="n">currentProgress</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">loadedCount</span> <span class="p">/</span> <span class="n">totalCount</span><span class="p">;</span>
                
                <span class="c1">// 主线程更新UI进度</span>
                <span class="k">await</span> <span class="n">UnityTaskScheduler</span><span class="p">.</span><span class="nf">RunOnMainThread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                    <span class="n">progress</span><span class="p">?.</span><span class="nf">Report</span><span class="p">(</span><span class="n">currentProgress</span><span class="p">);</span>
                <span class="p">});</span>
                
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"加载 </span><span class="p">{</span><span class="n">path</span><span class="p">}</span><span class="s"> 被取消"</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"加载 </span><span class="p">{</span><span class="n">path</span><span class="p">}</span><span class="s"> 失败: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
        
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="协程-vs-task">协程 vs Task</h3><p>  <strong>功能对比分析</strong></p><table><thead><tr><th>特性<th>协程(Coroutine)<th>Task<tbody><tr><td><strong>执行线程</strong><td>仅主线程<td>可多线程<tr><td><strong>Unity集成</strong><td>原生支持<td>需要适配器<tr><td><strong>取消机制</strong><td>手动实现<td>内置CancellationToken<tr><td><strong>异常处理</strong><td>复杂<td>标准try-catch<tr><td><strong>组合性</strong><td>有限<td>强大(WhenAll/WhenAny)<tr><td><strong>性能开销</strong><td>低<td>中等<tr><td><strong>调试支持</strong><td>一般<td>优秀</table><p>  <strong>协程的优势场景</strong></p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">CoroutineExamples</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="c1">// 简单的时间延迟和帧等待</span>
    <span class="n">IEnumerator</span> <span class="nf">SimpleAnimation</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="m">0.1f</span><span class="p">;</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// 等待一帧</span>
        <span class="p">}</span>
        
        <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitForSeconds</span><span class="p">(</span><span class="m">1f</span><span class="p">);</span> <span class="c1">// 等待1秒</span>
        
        <span class="c1">// 等待特定条件</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitUntil</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">Space</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="c1">// Unity特定的等待条件</span>
    <span class="n">IEnumerator</span> <span class="nf">WaitForAnimation</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">animator</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Animator</span><span class="p">&gt;();</span>
        <span class="n">animator</span><span class="p">.</span><span class="nf">SetTrigger</span><span class="p">(</span><span class="s">"Play"</span><span class="p">);</span>
        
        <span class="c1">// 等待动画完成</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitForAnimatorState</span><span class="p">(</span><span class="n">animator</span><span class="p">,</span> <span class="s">"IdleState"</span><span class="p">);</span>
        
        <span class="c1">// 等待物理更新</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitForFixedUpdate</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>  <strong>Task的优势场景</strong></p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">TaskExamples</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="c1">// 复杂的异步操作组合</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">ComplexAsyncOperation</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="c1">// 并行执行多个网络请求</span>
            <span class="kt">var</span> <span class="n">task1</span> <span class="p">=</span> <span class="nf">DownloadUserDataAsync</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">task2</span> <span class="p">=</span> <span class="nf">DownloadConfigAsync</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">task3</span> <span class="p">=</span> <span class="nf">DownloadAssetsAsync</span><span class="p">();</span>
            
            <span class="c1">// 等待所有请求完成</span>
            <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">,</span> <span class="n">task3</span><span class="p">);</span>
            
            <span class="c1">// 处理结果</span>
            <span class="nf">ProcessResults</span><span class="p">(</span><span class="n">results</span><span class="p">);</span>
            
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">HttpRequestException</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">HandleNetworkError</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">HandleCancellation</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 带超时的操作</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="nf">TryConnectWithTimeoutAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">using</span> <span class="nn">var</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">5</span><span class="p">));</span>
        
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">await</span> <span class="nf">ConnectToServerAsync</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span> <span class="nf">when</span> <span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"连接超时"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>  <strong>混合使用模式</strong></p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">HybridAsyncManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="c1">// 将Task转换为协程</span>
    <span class="k">public</span> <span class="n">Coroutine</span> <span class="n">StartTaskAsCoroutine</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">onComplete</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">TaskToCoroutine</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">onComplete</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="k">private</span> <span class="n">IEnumerator</span> <span class="n">TaskToCoroutine</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">onComplete</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 等待Task完成</span>
        <span class="k">while</span> <span class="p">(!</span><span class="n">task</span><span class="p">.</span><span class="n">IsCompleted</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">IsFaulted</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">$"Task失败: </span><span class="p">{</span><span class="n">task</span><span class="p">.</span><span class="n">Exception</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">IsCanceled</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Task被取消"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">onComplete</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 将协程转换为Task</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CoroutineToTask</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">IEnumerator</span> <span class="n">coroutine</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">getResult</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">tcs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskCompletionSource</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
        
        <span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">CoroutineWrapper</span><span class="p">());</span>
        
        <span class="n">IEnumerator</span> <span class="nf">CoroutineWrapper</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="nf">StartCoroutine</span><span class="p">(</span><span class="n">coroutine</span><span class="p">);</span>
            
            <span class="k">try</span> <span class="p">{</span>
                <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">getResult</span><span class="p">();</span>
                <span class="n">tcs</span><span class="p">.</span><span class="nf">SetResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tcs</span><span class="p">.</span><span class="nf">SetException</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">tcs</span><span class="p">.</span><span class="n">Task</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="性能考虑">性能考虑</h3><p>  <strong>Task分配优化</strong></p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PerformanceOptimizedTaskManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="c1">// 缓存常用的已完成Task</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_trueTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">_falseTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Task</span> <span class="n">_completedTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
    
    <span class="c1">// 避免不必要的Task分配</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="nf">ValidateAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 同步验证，直接返回缓存的Task</span>
        <span class="k">if</span> <span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="nf">IsNullOrEmpty</span><span class="p">(</span><span class="n">input</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_falseTask</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">Length</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_falseTask</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">// 只有需要异步操作时才创建新Task</span>
        <span class="k">return</span> <span class="nf">ValidateAsyncInternal</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="nf">ValidateAsyncInternal</span><span class="p">(</span><span class="kt">string</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 实际的异步验证逻辑</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">input</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="s">"valid"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 使用ValueTask减少分配</span>
    <span class="k">public</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">GetCachedValueAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_cache</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">cachedValue</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// 同步路径，不分配Task对象</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">cachedValue</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// 异步路径，需要分配Task</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="nf">LoadValueAsync</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><div class="post-copyright"><p> <span>版权声明：</span> 如无特别声明，本文版权归 <a href="https://www.damonc.top" class="cplink">编程散记</a> 所有，转载请注明本文链接。</p><p> （采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" class="extlinks">CC BY-NC-SA 4.0</a> 许可协议进行授权）</p><p><span>本文标题：</span>《 多线程编程模型篇-Task(二) 》</p><p><span>本文链接：</span><a href="https://www.damonc.top/csharp/Csharp_Task_Base.html" class="cplink">https://www.damonc.top/csharp/Csharp_Task_Base.html</a></p><p class="tips">本文最后一次更新为 <span></span> 天前，文章中的某些内容可能已过时！</p></div></article></div><div class="table-of-contents"><div class="toc-header"><h2>目录</h2></div><div class="toc-body"><ul><li><a onclick="scrollToAdjust('什么是task')">1. 什么是Task</a><ul><li><a onclick="scrollToAdjust('task-vs-线程')">1.1 Task vs 线程</a><li><a onclick="scrollToAdjust('task的生命周期')">1.2 Task的生命周期</a></ul><li><a onclick="scrollToAdjust('task的api')">2. Task的API</a><ul><li><a onclick="scrollToAdjust('task构造函数')">2.1 Task构造函数</a><li><a onclick="scrollToAdjust('使用task.run')">2.2 使用Task.Run</a><li><a onclick="scrollToAdjust('使用task.factory')">2.3 使用Task.Factory</a></ul><li><a onclick="scrollToAdjust('task的核心属性')">3. Task的核心属性</a><li><a onclick="scrollToAdjust('task的等待和同步')">4. Task的等待和同步</a><ul><li><a onclick="scrollToAdjust('task接口一致性')">4.1 Task接口一致性</a></ul><li><a onclick="scrollToAdjust('task的延续操作')">5. Task的延续操作</a><ul><li><a onclick="scrollToAdjust('task.continuewith')">5.1 Task.ContinueWith</a><li><a onclick="scrollToAdjust('延续任务的选项')">5.2 延续任务的选项</a><li><a onclick="scrollToAdjust('链式延续任务')">5.3 链式延续任务</a></ul><li><a onclick="scrollToAdjust('task的异常处理')">6. Task的异常处理</a><ul><li><a onclick="scrollToAdjust('异常传播机制')">6.1 异常传播机制</a><li><a onclick="scrollToAdjust('aggregateexception详解')">6.2 AggregateException详解</a><li><a onclick="scrollToAdjust('异常处理最佳实践')">6.3 异常处理最佳实践</a><li><a onclick="scrollToAdjust('未观察异常的处理')">6.4 未观察异常的处理</a></ul><li><a onclick="scrollToAdjust('task的取消机制')">7. Task的取消机制</a><ul><li><a onclick="scrollToAdjust('cancellationtokensource')">7.1 CancellationTokenSource</a><ul><li><a onclick="scrollToAdjust('超时cancellationtokensource')">7.1.1 超时CancellationTokenSource</a><li><a onclick="scrollToAdjust('链接cancellationtokensource')">7.1.2 链接CancellationTokenSource</a></ul><li><a onclick="scrollToAdjust('cancellationtoken')">7.2 CancellationToken</a><ul><li><a onclick="scrollToAdjust('核心属性和方法')">7.2.1 核心属性和方法</a><li><a onclick="scrollToAdjust('基本取消检查模式')">7.2.2 基本取消检查模式</a><li><a onclick="scrollToAdjust('注册取消回调')">7.2.3 注册取消回调</a></ul><li><a onclick="scrollToAdjust('取消操作的模式')">7.3 取消操作的模式</a><ul><li><a onclick="scrollToAdjust('协作式取消模式')">7.3.1 协作式取消模式</a><li><a onclick="scrollToAdjust('基于回调的取消模式')">7.3.2 基于回调的取消模式</a><li><a onclick="scrollToAdjust('超时取消模式')">7.3.3 超时取消模式</a><li><a onclick="scrollToAdjust('复合取消模式（用户取消-+-超时）')">7.3.4 复合取消模式（用户取消 + 超时）</a></ul><li><a onclick="scrollToAdjust('取消操作的传播')">7.4 取消操作的传播</a><ul><li><a onclick="scrollToAdjust('父子任务的取消传播')">7.4.1 父子任务的取消传播</a><li><a onclick="scrollToAdjust('延续任务的取消处理')">7.4.2 延续任务的取消处理</a><li><a onclick="scrollToAdjust('取消状态的传播')">7.4.3 取消状态的传播</a><li><a onclick="scrollToAdjust('资源清理的取消传播')">7.4.4 资源清理的取消传播</a><li><a onclick="scrollToAdjust('取消请求的级联传播')">7.4.5 取消请求的级联传播</a></ul></ul><li><a onclick="scrollToAdjust('task的调度和配置')">8. Task的调度和配置</a><ul><li><a onclick="scrollToAdjust('taskscheduler详解')">8.1 TaskScheduler详解</a><li><a onclick="scrollToAdjust('taskcreationoptions')">8.2 TaskCreationOptions</a><li><a onclick="scrollToAdjust('taskcontinuationoptions')">8.3 TaskContinuationOptions</a><li><a onclick="scrollToAdjust('自定义taskscheduler')">8.4 自定义TaskScheduler</a></ul><li><a onclick="scrollToAdjust('task的高级用法')">9. Task的高级用法</a><ul><li><a onclick="scrollToAdjust('taskcompletionsource')">9.1 TaskCompletionSource</a></ul><li><a onclick="scrollToAdjust('task在unity3d中的应用')">10. Task在Unity3D中的应用</a><ul><li><a onclick="scrollToAdjust('unity主线程限制')">10.1 Unity主线程限制</a><li><a onclick="scrollToAdjust('异步操作的最佳实践')">10.2 异步操作的最佳实践</a><li><a onclick="scrollToAdjust('协程-vs-task')">10.3 协程 vs Task</a><li><a onclick="scrollToAdjust('性能考虑')">10.4 性能考虑</a></ul></ul></div></div></div></div><div class="social-share-wrapper"><div class="social-share"></div></div></main><section class="author-detail"><section class="post-footer-item author-card"><div class="avatar"> <img src="https://img.damonc.top/commons/avatar.png" alt=""></div><div class="author-name" rel="author">编程散记</div><div class="bio"><p>Developer & Maintainer</p></div><ul class="sns-links"><li> <a href="https://github.com/damonc-top" target="_blank" aria-label="github"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-github"></use> </svg> </a><li> <a href="https://segmentfault.com/u/junyidebocai" target="_blank" aria-label="segmentfault"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-segmentfault"></use> </svg> </a></ul></section><section class="post-footer-item read-next"><div class="read-next-item"> <a href="/csharp/CSharp_Thread_Pattern.html" class="read-next-link" aria-label="多线程编程模型篇(三)"></a><section> <span>多线程编程模型篇(三)</span><p>多线程的演进</p></section></div><div class="read-next-item"> <a href="/csharp/CSharp_Thread_Base.html" class="read-next-link" aria-label="多线程编程基础篇-Thread(一)"></a><section> <span>多线程编程基础篇-Thread(一)</span><p>多线程概念</p></section></div></section><script src="https://unpkg.com/@waline/client@3.3.2/dist/waline.umd.js" async onload="initWaline()"></script> <script> function initWaline() { $(document).ready(function () { Waline.init({ el: '#waline', serverURL: "https://comments.damonc.top", reaction: "true", comment: true, locale: "{reaction0: '赞一个', reaction1: '踩一下', reaction2: '有点酷', reaction3: '看不懂', reaction4: '啥玩意', reaction5: '想睡觉'}", }); }); } </script> <script> $(document).ready(function () { if ($("#comments-switch").length > 0) { var comment_status = $("#cmn-toggle-4")[0].checked; if (comment_status) { $("#waline").addClass("active"); } else { $("#disqus_thread").addClass("active"); } $("#cmn-toggle-4").click(function () { $("#disqus_thread").toggleClass("active"); $("#waline").toggleClass("active"); }) } else { if ($("#disqus_thread").length > 0) { $("#disqus_thread").addClass("active"); } else if ($("#waline").length > 0) { $("#waline").addClass("active"); } } }) </script><section class="post-footer-item comment"><div class="comments-headline"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-comment"></use> </svg> <span>评论</span></div></section><section class="post-footer-item comment"><div id="waline"></div></section></section><footer class="g-footer"><div class="g-container"><div class="g-left"><section class="links"> 本站由 <a href="//jekyllrb.com" target="_blank" class="extlinks">Jekyll</a> 和 基于 <a href="https://github.com/kaeyleo/jekyll-theme-H2O" target="_blank" class="extlinks">H2O主题模版</a> 强力驱动</section><section class="links">编程散记 © 2016 - 2025 <a href="https://icp.gov.moe/?keyword=20240160" target="_blank" class="extlinks">萌ICP备20240160号</a> <a href="/rss.xml" target="_blank" aria-label="Terms of Service" class="others"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-rss"></use> </svg> RSS </a> <a href="/tos" target="_blank" aria-label="Terms of Service" class="others"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-tos"></use> </svg> 使用条款 </a></section><section class="links"> <span id="busuanzi_container_site_pv"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-pv"></use> </svg> 总浏览量 <span id="busuanzi_value_site_pv"></span> <b>·</b> </span> <span id="busuanzi_container_site_uv"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-user"></use> </svg> 总访问量 <span id="busuanzi_value_site_uv"></span> </span></section><section> 本站已运行 <span class="alivetime_days"></span> 天 <span class="alivetime_hours"></span> 小时 <span class="alivetime_minutes"></span> 分 <span class="alivetime_seconds"></span> 秒</section></div><div class="g-right"><section class="badges"> <a href="https://www.foreverblog.cn/" target="_blank" class="foreverblog" aria-label="foreverblog"> <img loading="lazy" src="https://img.foreverblog.cn/logo_en_default.png" alt=""> </a> <a href="https://www.foreverblog.cn/go.html" target="_blank" class="wormhole" aria-label="wormhole"> <img loading="lazy" src="https://img.foreverblog.cn/wormhole_3.gif" alt="" title="穿梭虫洞-随机访问十年之约友链博客"> </a> <a href="https://www.travellings.cn/go.html" target="_blank" class="travelling-badge" aria-label="Travelling" rel="noopener" title="开往-友链接力"> <img loading="lazy" src="https://cdn.jsdelivr.net/gh/travellings-link/travellings/assets/logo.gif" alt="开往-友链接力"> </a> <a href="https://notbyai.fyi/" target="_blank" class="notbyAI" aria-label="notbyAI"> <img loading="lazy" src="/assets/icons/notbyAI-white.png" alt="Written by Human, Not by AI"> </a></section></div></div></footer><div class="cookie-tip"> 为了提升本站的使用体验和必要功能的正常使用，本站会使用本地 Cookie。详细请查看「 <a href="/tos.html">本站使用条款</a> 」了解更多。 <button id="accept-tos">同意</button></div><section id="tools"><div class="tool toc"> <svg class="icon b1 active" aria-hidden="true"> <use xlink:href="#icon-toc"></use> </svg> <svg class="icon b2" aria-hidden="true"> <use xlink:href="#icon-exit"></use> </svg></div></section><section id="bttb" aria-label="Scroll back to top" class="bttb"><div class="tool"> <svg class="icon top" aria-hidden="true"> <use xlink:href="#icon-top"></use> </svg></div></section></div><div class="modal"><div class="modal-content"><header> <span class="close">&times;</span></header><div class="container"></div></div></div><script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" async></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/dayjs.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/plugin/customParseFormat.js"></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/plugin/relativeTime.js"></script> <script> $(document).ready(function () { var time_formats = ['YYYY-MM-DD HH:mm:ss ZZ', 'YYYY DD MMM HH:mm:ss ZZ', 'YYYY年MM月DD日 HH:mm:ss ZZ']; function dateFormat(date, format) { var date_org = dayjs(date, time_formats[format]); var date = date_org.format(time_formats[format]); return { "date_org": date_org, "date": date } } dayjs.extend(window.dayjs_plugin_customParseFormat); dayjs.extend(window.dayjs_plugin_relativeTime); var post_date = $("meta[property='post-date']").attr('content'); var post_date_format = $("meta[property='post-date-format']").attr('content'); var local_post_date = dateFormat(post_date, post_date_format); $(".post time span.create-at").html(local_post_date["date"]); var path = "post_project/_posts/2025/downloader/2025-06-01-Csharp_Task_Base.md"; var workerUrl = "https://winter-meadow-170b.damoncbl.workers.dev?" + new URLSearchParams({ path: path }); fetch(workerUrl).then(function (res) { if (!res.ok) throw new Error("worker non-200: " + res.status); return res.json(); }).then(function (commits) { if (commits && commits.length) { var update_at = dayjs(commits[0]['commit']['committer']['date']); } else { var update_at = post_date; } var local_update_at = dateFormat(update_at, post_date_format); $('.post time span.update-at').html(local_update_at["date"]); var relative_time = dayjs().diff(local_update_at["date_org"], 'day'); $(".post-copyright .tips span").append(relative_time); if (relative_time > 365) { $(".post-copyright .tips").addClass("active"); } }).catch(function () { var local_update_at = dateFormat(post_date, post_date_format); $('.post time span.update-at').html(local_update_at["date"]); }); }); </script> <script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script> <script> socialShare('.social-share', { sites: [ 'wechat', 'weibo', 'douban', 'twitter' ], wechatQrcodeTitle: "分享到微信朋友圈", wechatQrcodeHelper: '<p>扫码后点击右上角</p><p>将本文分享至朋友圈</p>' }); $("a.social-share-icon").each(function () { $(this).attr("aria-label", $(this).attr("class").split(' ')[1]) }); </script> <script src="https://cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script> <script> function scrollToAdjust(id){ var element = document.getElementById(id); var headerOffset = 90; var elementPosition = element.getBoundingClientRect().top; var offsetPosition = elementPosition + window.scrollY - headerOffset; window.scrollTo({ top: offsetPosition, behavior: "smooth" }); } </script> <script src="/assets/js/app.min.js"></script> <script src="https://at.alicdn.com/t/c/font_3046306_ujr2yq34hw.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-WN45VXRK"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'GTM-WN45VXRK'); </script> <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> <script async src="https://cdn.jsdelivr.net/npm/promise-polyfill@8.3.0/dist/polyfill.min.js"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax-full@3.2.2/es5/tex-mml-svg.min.js"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ jax: ["input/TeX", "output/HTML-CSS"], tex2jax: { inlineMath: [['$', '$'], ["\\(", "\\)"]], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }, "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] } }); </script> <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.min.js"></script> <script> $(document).ready(function () { var baseurl = $("meta[property='og:baseurl']").attr('content'); $("center img").each(function () { $(this).attr('data-src', $(this).attr('src')).removeAttr('src').addClass("lazyload").attr('src', baseurl + '/assets/img/loading.gif'); var strA = "<a data-fancybox='gallery' ref='gallery' href='" + $(this).attr('data-src') + "' data-caption='" + $(this).attr('alt') + "'></a>"; $(this).wrapAll(strA); var caption = $(this)[0].alt; $(this).parent().after('<span class="caption">' + caption + '</span>'); }); Fancybox.bind('[data-fancybox]', { on: { load: function(fancybox, slide) { var gray = $("meta[property='og:gray']").attr('content'); if (gray == "true") { $(".fancybox__content img").addClass("gray"); $(".carousel__track .fancybox__thumb").addClass("gray"); } } } }); }); </script> <script src="https://cdn.jsdelivr.net/npm/hotkeys-js/dist/hotkeys.min.js"></script> <script> $(document).ready(function () { var previous_url = $("meta[property='og:previous_url']").attr('content'); var next_url = $("meta[property='og:next_url']").attr('content'); hotkeys('left', function (event, handler) { event.preventDefault(); if (previous_url) { console.log('you pressed left!'); window.location.href = previous_url; } else { $("#no-previous").addClass("active"); setTimeout(function () { $("#no-previous").removeClass("active"); }, 1500); } }); hotkeys('right', function (event, handler) { event.preventDefault(); if (next_url) { console.log('you pressed right!'); window.location.href = next_url; } else { $("#no-next").addClass("active"); setTimeout(function () { $("#no-next").removeClass("active"); }, 1500); } }); }); </script> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.6/dist/mermaid.min.js"></script> <script> $(document).ready(function () { mermaid.initialize({ startOnLoad: true, theme: "default", }); mermaid.init(undefined, $('.mermaid2')); }); </script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script> <script> if (window.Prism) { Prism.languages.mermaid2 = Prism.languages.none || {}; } </script> <script> if ("serviceWorker" in navigator) { var env = 'development'; var isDev = env === 'development'; navigator.serviceWorker .register('/sw.js', { scope: '/' }) .then(function (reg) { if (isDev) console.log("Service worker registered for scope:", reg.scope); }) .catch(function (err) { if (isDev) console.warn("Service worker registration failed:", err); }); } </script> <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script> <script type="text/javascript"> docsearch({ appId: "NCUJ5WJECO", apiKey: "b625a4b91a45af033cbdb526694e9e65", indexName: "damonc", lang: "zh", insights: true, debug: false, container: 'li#search', }); </script>
