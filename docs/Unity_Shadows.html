<!DOCTYPE html><html lang="zh-Hans"> <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Unity Shadow 阴影(翻译七) - 编程散记</title><meta name="author" content="编程散记"><meta name="description" content="Unity Shadow 阴影(翻译七)"><meta name="keywords" content="Shader"><meta property="og:previous_url" content="/Unity_Reflection.html"><meta property="og:next_url" content="/Unity_Advance_Texture.html"><meta property="post-date-format" content="0"><meta property="post-date" content="2018-01-05 20:00:00 +0800" /><meta property="calendar-scale" content="year" /><meta property="calendar-scheme" content="null" /><meta property="calendar-color" content="null" /><meta property="og:title" content="Unity Shadow 阴影(翻译七) - 编程散记"><meta property="og:type" content="website"><meta property="og:url" content="https://www.damonc.top/Unity_Shadows.html"><meta property="og:baseurl" content=""><meta property="og:description" content="个人的一个技术博客站点，记录生活、工作、学习中的一些小事，以及一些比较有趣的事情，留点什么东西也挺不错的，偶尔会在这里停留。"><meta property="og:site_name" content="编程散记"><meta property="og:gray" content="false"><meta property="og:lang" content="zh-Hans"><meta name="alivestart" content="12/23/2020"><meta name="theme-color" content="#81BBFF" /><meta name="algolia-site-verification" content="5E91324370E1262B" /><title>Algolia Verification</title><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="manifest" href="/manifest.json" async><link rel="apple-touch-icon" href="/assets/img/touch/apple-touch-icon.png" /><link rel="Shortcut Icon" href="/favicon.ico"><link rel="icon" href="/favicon.ico" type="image/x-icon" /><link rel="bookmark" href="/favicon.ico" type="image/x-icon" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.min.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.2.0/github-markdown-light.min.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-light.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://unpkg.com/@waline/client@3.3.2/dist/waline.css" async><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3" async><link rel="stylesheet" href="/assets/css/app.min.css" async><body class="line-numbers" ontouchstart=""><div id="all" class="post" data-theme="default"><div class="alert-tip" id="no-previous">已经是最新一篇文章了！</div><div class="alert-tip" id="no-next">已经是最后一篇文章了！</div><input id="nm-switch" type="hidden" value="false"><header class="g-header" data-theme="default"><div class="g-logo"> <a href="/" aria-label="logo"></a></div><div id="search-toggle"></div><div id="travelling-toggle"> <a href="https://www.travellings.cn/go.html" aria-label="Travelings" target="_blank"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-train-subway"></use> </svg> </a></div><div id="mode-toggle"> <svg class="icon icon-day" aria-hidden="true"> <use xlink:href="#icon-day"></use> </svg> <svg class="icon icon-night" aria-hidden="true"> <use xlink:href="#icon-night"></use> </svg></div><svg id="menu-toggle" class="icon-menu" aria-hidden="true"> <use xlink:href="#icon-menu"></use> </svg><nav class="g-nav"><ul><li> <a href="/" aria-label="home"> home </a><li> <a href="/blog/index.html" aria-label="blog"> blog </a><li> <a href="/archives.html" aria-label="archives"> archives </a><li> <a href="/tags.html" aria-label="tags"> tags </a><li class="dropdown"> <a class="dropdown-toggle" href="#"> about </a><ul class="dropdown-menu"><li> <a href="/feed.xml" aria-label="RSS"> RSS </a></ul><li class="travelling"> <a href="https://www.travellings.cn/go.html" aria-label="Travelings" target="_blank"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-train-subway"></use> </svg> </a><li class="mode"> <svg class="icon day" aria-hidden="true"> <use xlink:href="#icon-day"></use> </svg> <svg class="icon night" aria-hidden="true"> <use xlink:href="#icon-night"></use> </svg><li id="search"></ul></nav></header><div class="g-banner post-header post-pattern-circuitBoard bgcolor-default post-no-cover" data-theme="default"><div class="post-wrapper"><div class="post-tags"> <a href="/%20/tags.html#Shader" class="post-tag">Shader</a></div><h1>Unity Shadow 阴影(翻译七)</h1><div class="post-meta"> <span class="post-meta-item"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-user"></use> </svg> catlikecoding </span> <time class="post-meta-item" datetime=" 18-01-05"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-calendar"></use> </svg> <span class="create-at"></span> </time> <time class="post-meta-item" datetime=" 18-01-05"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-update"></use> </svg> <span class="update-at"></span> </time> <span class="post-meta-item"> <svg class="icon words" aria-hidden="true"> <use xlink:href="#icon-words"></use> </svg> 本文总共 17.1k 字 </span> <span class="post-meta-item"> <svg class="icon time" aria-hidden="true"> <use xlink:href="#icon-time"></use> </svg> 阅读全文大约需要 49 分钟 </span> <span class="post-meta-item"> <svg class="icon pv" aria-hidden="true"> <use xlink:href="#icon-pv"></use> </svg> 本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次 </span></div></div></div><main class="post-content visible"><div class="container"><div class="submenu hidden"></div><div class="contents"><article class="markdown-body post"><p>本篇摘要:</p><ul><li>探索Unity中的阴影渲染<li>投射一个方向光阴影<li>接收一个方向光阴影<li>支持对聚光源和点光源阴影</ul><h2 id="方向光阴影-direction">方向光阴影-Direction</h2><p>前面写的光照shader产生了相当真实的效果，可它假设着来自每个光源的光线最终都会击中它的片元，但是这只有在那些光线没有被遮挡才成立。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20191218085818298-1814779079.png" width="250"><font size="2.5"> <i>方向光投射阴影的草图.</i> </font> </center><p>当一个物体位于光源和另一个物体之间时，它可能会阻止部分或全部光线到达另一个物体。这些光线照亮了第一个物体就不再可能照亮第二个物体。因此，第二个物体有一部不发光，而不发光的区域位于第一个物体的阴影下。我们通常是这样描述：第一个物体投射了一个阴影到第二个物体。</p><p>实际上，在全光照和全阴影的存在过渡区，被称为半阴影。这是因为所有光源都有一个体积，因此，这些区域只有部分光源是可见的，意味着它是部分阴影。光源远大，表面距离阴影投射器越远，半影区域也就越大。</p><p>但是Unity不支持半影，只支持软阴影soft shadow，但它是阴影过滤算法。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004113666-17566508.png" width="250"><font size="2.5"> <i>半阴影或是soft shadow.</i> </font> </center><h3 id="启用阴影-enable-shadow">启用阴影-Enable Shadow</h3><p>先关闭环境光，这样会更容易看见阴影。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004114401-1156490901.png" width="250"><font size="2.5"> <i>没有投射阴影.</i> </font> </center><p>没有阴影，物体间的空间视觉感不太强。在QualitySetting可以打开或关闭阴影。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004114977-1581119995.png" width="250"><font size="2.5"> <i>阴影参数.</i> </font> </center><p>同时确保光源开启投射阴影，分辨率依赖于上面的quality设置</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004115441-758263297.png" width="250"><font size="2.5"> <i>阴影类型.</i> </font> </center> <center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004116185-479542116.png" width="250"><font size="2.5"> <i>阴影投射.</i> </font> </center><h3 id="阴影贴图-shadow-map">阴影贴图-Shadow map</h3><p>Unity是如何把阴影添加到屏幕？上面所有物体使用的standard着色器，有一些方法确定光线是否被阻挡。</p><p>要搞清楚一个点是否在阴影中，可以通过在场景中从光线到表面片元投射光线，如果光线在到达表面之前击中某些东西，说明它就被阻挡了。这些事是物理引擎做的，但是要计算每个片元与每个光是不实际的，而且还要把结果传递给GPU。</p><p>现在有许多支持实时阴影的技术，它们各有优劣。而<strong>Unity采用了最常用的技术：Shadow Mapping</strong>。这意味着unity把阴影数据存储至纹理中。现在来看看它是如何工作的。</p><p>打开frame Debugger，Window/Frame Debugger。点击Enable，按顺序查看面板信息。注意看看每帧在gameScene视图中的不同，以及阴影的开启。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004116813-251352475.png" width="250"><font size="2.5"> <i>frame debugger调试.</i> </font> </center><p>当启用阴影绘制时，这个绘制过程变得非常复杂：有更多的渲染阶段，和更多的draw call。阴影绘制非常昂贵！</p><h3 id="渲染深度纹理-rendering-to-the-depth-texture">渲染深度纹理-Rendering to the Depth Texture</h3><p>当方向阴影激活后，Unity在渲染过程开启一个<strong>depth pass</strong>通道计算。结果存储在与屏幕分辨率相匹配的纹理，这个pass通道会渲染整个屏幕，但是<strong>只收集每个片元的深度信息</strong>。这些信息与GPU用于确定一个片段渲染结束时在先前渲染的片段之上(前)还是之下(后)的信息<strong>相同</strong>。</p><p>这个数据对应在裁剪空间(clip space)坐标的z分量值。而裁剪空间是定义摄像机能看见的区域，<strong>深度信息最终存储为0-1范围内的值</strong>。在debugger查看该纹理时，近裁切面附近的纹理显示趋近为(白)浅色，远裁切面附近的纹素texel，颜色趋近黑(暗)色。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004117380-1866548771.png" width="250"><font size="2.5"> <i>depth texture, 摄像机近裁切面为5.</i> </font> </center> <center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004117917-92987945.png" width="250"><font size="2.5"> <i>与屏幕分辨率一致.</i> </font> </center><p>这些信息实际上与阴影没有太多直接关系，但Unity在后面的pass通道使用了它。</p><h3 id="渲染阴影贴图-rendering-to-shadow-maps">渲染阴影贴图-Rendering to Shadow Maps</h3><p>这步主要工作：先渲染第一个光源的阴影贴图，然后就会渲染第二个光源的阴影贴图。</p><p>再一次渲染整个屏幕，并再次把深度信息存储在纹理中。但是，这此的屏幕渲染是从光源位置角度进行的，<strong>实际上是把光源作为摄像机</strong>。这意味着用深度值告诉了我们<strong>光线击中物体之前走了多远距离</strong>，<strong>这可以用来确定什么东西被遮蔽了!</strong></p><blockquote class="prompt-tip"><p>阴影贴图记录了实际的几何图形的深度信息。而法线贴图是为了添加粗糙表面的一种错觉， 阴影贴图会忽略它们。因此，阴影不受法线贴图的影响。</p></blockquote><p>由于我们使用方向光，这些光模拟的摄像机是正交投影，没有透视投影。因此它们模拟的相机的位置精确性就不那么重要。Unity将定位常规相机使其能够看见视野内所有物体。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004118495-150954892.png" width="250"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004119056-187327811.png" width="250"><font size="2.5"> <i>左第一个光源，右第二个光源.</i> </font> </center><blockquote class="prompt-tip"><p>事实上，原来Unity渲染整个场景不是每个光只渲染一次，而是每个光要渲染四次！</p><p>这个阴影纹理被分成四个象限，每个象限从不同的角度呈现。这是因为我们选择使用 <em>Four Cascades</em>(QualitySetting)。如果我们设置为Two Cascades，就是每个光渲染两次； 如果设置没有，只会渲染一次。我们接下来要探查阴影质量与该项设置的关系。Unity为什么渲染这么 多次。</p></blockquote><h3 id="收集阴影-collecting-shadows">收集阴影-Collecting Shadows</h3><p>我们已经从摄像机的角度得到场景的深度信息，也有了从每个光模拟的相机视角得到的深度信息，这些数据存在不同的裁剪空间。但是我们知道这些空间的相对位置和方向，因此能从一个空间转换到另一个空间。这允许我们从两个视角比较深度测量。理论上讲，我们有两个向量应该在同一点交会结束，这样相机和光源都能看见该点，说明它被点亮了。如果光的向量在到达该点之前结束，则光被挡住，这意味着该点被阴影化。</p><blockquote class="prompt-tip"><p>当摄像机看不到一个点时？ 看不到的这些点被隐藏在距离相机更近的其他点后面。 场景深度纹理仅包含最接近的点。 因此没有时间浪费在评估隐藏点。</p></blockquote><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004119634-36088154.png" width="250"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004120273-1411206867.png" width="250"><font size="2.5"> <i>每个光的屏幕空间阴影.</i> </font> </center><p>Unity通过渲染一个单独的覆盖整个视野的面片来创建这些纹理，它使用了Hidden/Internal-ScreenSpaceShadows shader的通道，每个片元从场景和光源的深度纹理采样，进行比较，渲染最终阴影值到屏幕空间的阴影纹理。亮的纹素值设为1，阴影纹素值设为0。此时Unity能执行过滤，创建柔和的阴影。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004120767-1471511920.png" width="250"><font size="2.5"> <i>shader 通道0.</i> </font> </center><blockquote class="prompt-tip"><p>为什么Unity在渲染和收集间交替？</p><p>每个光需要它自己的屏幕空间阴影贴图，然而从光源位置视野渲染的阴影贴图能被重复使用。</p></blockquote><h3 id="采样阴影贴图-sampling-the-shadow-maps">采样阴影贴图-Sampling the Shadow Maps</h3><p>最后，Unity完成了阴影渲染。现在屏幕是常规渲染，只有一个更改：光照颜色与它的阴影贴图的值相乘。这就消除了被遮挡的光线。渲染的每个片元都要采样阴影贴图，每个最终隐藏在其他对象之后的片元会最后绘制。因此这些片元最后能接收到最终能遮挡它们的对象的阴影。当在frame debugger步进调试观察时，您还可以看到阴影在实际投射它的对象之前出现。当然这些错误只在渲染帧时很明显，一旦完成渲染就是正确的了</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004121539-766772112.png" width="250"><font size="2.5"> <i>部分渲染帧.</i> </font> </center><h3 id="阴影质量-shadow-quality">阴影质量-Shadow Quality</h3><p>虽然场景是从光源的方向进行渲染，但是该方向与场景内摄像机视野方向不匹配。因此阴影贴图的纹素与最终呈现图像的纹素是没有对齐的，会出现锯齿。阴影贴图的分辨率也会不同，最终图像的分辨率是由显示设置决定的，而阴影贴图的分辨率由阴影质量设置决定。</p><p>当阴影贴图的纹素最后渲染的比最终图像大时，将很明显：阴影的边缘出现叠加，在使用硬阴影时非常明显。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104536520-1647041130.png" width="250"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104537010-710024064.png" width="250"><font size="2.5"> <i>硬阴影 vs 软阴影.</i> </font> </center><p>在质量设置面板修改使用hard shadow、lowest resolution、no cascades。就会看见满屏的锯齿。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104537807-1725277269.png" width="250"><font size="2.5"> <i>低质量阴影.</i> </font> </center><blockquote class="prompt-danger"><p>“阴影是一张纹理”</p><p>现在就非常明显了。但是上图有些阴影出现在了不该出现的地方。</p></blockquote><p>距离摄像机越近的阴影，它们的纹素变得越大。这是由于阴影贴图当前覆盖了场景相机的整个可视区域。在QualitySetting面板通过降低阴影覆盖的区域，来提升靠近相机区域的阴影质量。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104538524-1008907954.png" width="250"><font size="2.5"> <i>Shadow Distance降至25，其他参数一致.</i> </font> </center><p>通过限制靠近屏幕相机的阴影区域，我们能使用相同的阴影纹理去覆盖更多小区域。结果是能得到更好的阴影。但是会丢失更远区域的阴影细节，因为当阴影接近最大距离时会逐渐消失。</p><p>理想情况是，既要获得近距离高质量阴影，同时也要保留远处的阴影。因为远处的阴影最后渲染在较小的屏幕区域，就可以用作低分辨率阴影纹理。这就是<strong>Shadow Cascades的工作</strong>。当启用该选项，多个阴影贴图渲染进同一张纹理，每张贴图对应某些距离来使用。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104539269-790456352.png" width="250"><font size="2.5"> <i>fourCascades,100Distance,hardShodw,LowResolution.</i> </font> </center><p>当使用FourCascades，上图结果看起来比之前的要好，尽管我们使用了同一张纹理分辨率，我们更有效的使用了纹理。不过缺点就是我们现在至少要渲染场景3次以上。当渲染屏幕空间阴影纹理时，Unity关注从正确Cascade采样，如下图CascadeSplits：一个cascade结束是下一个的开始。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104539767-1296197985.png" width="250"><font size="2.5"> <i>Cascade Splits.</i> </font> </center><p>可以控制cascade的范围，作为阴影距离的一部分。也能通过改变_Shading Mode/Miscellaneous/Shadow Cascades_观察scene视图的变化。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104540599-1094570005.png" width="250"><font size="2.5"> <i>Cascade范围：StableFit.</i> </font> </center><p>上图显示的cascade形状(覆盖区域)是可以通过_Shadow Projection_调整，默认是_Stable Fit_：这个模式cascade条带选择的区域基于距离摄像机位置的远近。其他模式是_Close Fit_：使用相机的深度信息替代，在相机可视方向产生一条规则的条带。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104541528-964824910.png" width="250"><font size="2.5"> <i>Close Fit.</i> </font> </center><p>Close Fit模式可以更高效的利用阴影纹理，绘制更高质量的阴影。然而，该阴影投射模式(ShadowProjection)取决于阴影产生后位置和方向以及相机参数。结果是，当移动或旋转相机，阴影贴图也会跟着移动。这就是著名的<strong>阴影抖动</strong>。所以Stale Fit是引擎默认的选项。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011549767-631714908.gif" width="250"><font size="2.5"> <i>Close Fit: swimming.</i> </font> </center><p>Stable Fit模式下，在相机位置改变时Unity能够对齐纹理，纹素看起来好像没动。实际上cascade移动了，只是在cascade相互过渡时阴影会发生改变。如果没有注意到cascade改变，就不容易察觉到。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011551635-334469142.gif" width="250"><font size="2.5"> <i>Stable Fit: edge transition.</i> </font> </center><h3 id="阴影痤疮0什么鬼">阴影“痤疮”(0!什么鬼)</h3><p>当我们使用低质量的硬阴影时，我们看见一些阴影出现在不正确的地方。不幸的是，不管如何设置_Quality Setting_都会发生。</p><blockquote class="prompt-warning"><p>Shadow Acne</p><p>阴影贴图中每个纹素表示光线击中表面的点。然而，这些纹素不是单独点。它们最后要覆盖很大的区域并且与光的方向对 齐，而不是与表面一致。结果时，它们会像黑色瓦片最终黏在、穿过、伸出表面；当阴影纹理的一部分从投射出阴影的表面 伸出时，表面看起来也会产生阴影。</p></blockquote><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011552772-162435124.png" width="250"><font size="2.5"> <i>凸起.</i> </font> </center><p>阴影凸起的另一个来源是数字精度的限制，当使用非常小的距离时这些限制会导致不正确的结果。默认是0.05.</p><center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011553241-1223925943.png" width="500"></center> <center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011554194-2082319886.png" width="500"><font size="2.5"> <i>light组件中设置没有biases.</i> </font> </center><p>避免该问题的一个方法是：当渲染阴影纹理时增加深度偏移。这个_偏差系数_目的是增加‘光投射到表面距离’，把阴影‘推进’表面内。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011554763-238944472.png" width="250"><font size="2.5"> <i>Biases系数控制粉刺.</i> </font> </center><p>较低的Bias系数会产生粉刺，而较高的偏差系数就会有另一个问题：当投射阴影的对象逐渐远离光源时，阴影也会逐渐飘离原对象。使用较小的值问题还可接受，但太大的值会导致物体与该物体的阴影不再相连接了，好像飞起来了。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011555603-1490654705.png" width="500"><font size="2.5"> <i>太大的Bias导致阴影飘移.</i> </font> </center><p>除了距离bias偏差，还有法线偏差。该系数辅助调整阴影投射：沿着法线，将投射的阴影顶点向内‘推’。该值也会改善“阴影粉刺”，但是越大的值越会使阴影变得更小并且有可能使阴影中间出现洞。</p><p><strong>best bias settings</strong>？没有最优的默认值，必须不停的实验调整 。</p><h3 id="抗锯齿">抗锯齿</h3><p>Anti-Aliasing:图形边缘锯齿缓和。在Unity开启了4倍抗锯齿，感觉并没有达到想要的抗锯齿效果。</p><center class="half"><img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011555867-728275342.png" width="250"></center><p><strong>Unity采用的多重采样抗锯齿方案：MSAA，通过沿三角形边缘执行超级采样以消除边缘锯齿，更重要的是Unity渲染屏幕空间阴影时，它使用了一个单独四方面片覆盖整个可视区域。结果是，这就没有了三角形边缘，因此MSAA对屏幕空间阴影纹理采样就没有效果了。MSAA对最终图像有效，但阴影值是取之屏幕空间阴影纹理，当亮表面紧挨着暗表面被阴影覆盖时就非常明显。明暗之间的边缘是反锯齿的，而阴影边缘则不是</strong>。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011556603-1672887107.png" width="500"><font size="2.5"> <i>no AA.</i> </font> </center> <center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011557407-1382894965.png" width="500"><font size="2.5"> <i>4倍MSAA.</i> </font> </center><p>当然也有FXAA，是<strong>屏幕后处理抗锯齿</strong>，效果挺好！</p><h2 id="投射阴影">投射阴影</h2><p>通过上面我们知道了Unity如何创建方向光阴影，是时候写自己的Shader来支持阴影了。当前光照shader既不支持投射阴影也不支持接收阴影。</p><p>首先来处理投射阴影：我们知道对于方向光阴影Unity会渲染多次屏幕。对每个阴影纹理一次是深度pass渲染，一次是每个光源渲染。而屏幕空间阴影纹理是屏幕效果暂时与我们无关。阴影渲染Pass标签是_ShadowCaster。_因为我们只对深度值感兴趣，它与别的Pass相比应该会简单。增加一个pass</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Pass</span><span class="p">{</span>
    <span class="n">Tags</span><span class="p">{</span><span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ShadowCaster"</span><span class="p">}</span>
    <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma target 3.0
</span>        <span class="cp">#pragma vertex MyVertexProgram
</span>        <span class="cp">#pragma fragment MyFragmentProgram
</span>        <span class="cp">#include</span> <span class="cpf">"MyShadow.cginc"</span><span class="cp">
</span>    <span class="n">ENDCG</span>
<span class="p">}</span>
</code></pre></div></div><p>创建一个_MyShadow.cginc_文件</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(MY_SHADOW_INCLUDE)
#define MY_SHADOW_INCLUDE
#include “UnityCG.cginc”
</span><span class="k">struct</span> <span class="n">InputData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">float4</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">half4</span> <span class="nf">MyFragmentProgram</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif
</span></code></pre></div></div><p>上面写完就嫩产生方向光阴影了。下面开始用代码调优阴影质量。</p><h3 id="偏差-bias">偏差-Bias</h3><p>我们要支持阴影的偏移。在渲染深度Pass时该值是0，但当渲染阴影纹理时，偏差值取光照组件设置。我们要做的就是：<strong>在顶点函数中在裁切空间下，对顶点坐标应用深度偏差</strong>。UnityCG函数_UnityApplyLinerShadowBias：_</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">{</span>
    <span class="kt">float4</span> <span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
    <span class="k">return</span>	<span class="n">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p><em>在裁剪空间增加Z分量，复杂的是在其次坐标空间下，必须补偿透视投影，这样偏移不会随着与相机距离改变而改变，也必须确保结果不会越界。</em></p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="nf">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="kt">float4</span> <span class="n">clipPos</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(UNITY_REVERSED_Z)
</span>    <span class="c1">// We use max/min instead of clamp to ensure proper handling of the rare case</span>
    <span class="c1">// where both numerator and denominator are zero and the fraction becomes NaN.</span>
    <span class="n">clipPos</span><span class="p">.</span><span class="n">z</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">clipPos</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">float</span> <span class="n">clamped</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">clipPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">clipPos</span><span class="p">.</span><span class="n">w</span><span class="o">*</span><span class="n">UNITY_NEAR_CLIP_VALUE</span><span class="p">);</span>
<span class="cp">#else
</span>    <span class="n">clipPos</span><span class="p">.</span><span class="n">z</span> <span class="o">+=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">clipPos</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">clamped</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">clipPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">clipPos</span><span class="p">.</span><span class="n">w</span><span class="o">*</span><span class="n">UNITY_NEAR_CLIP_VALUE</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="n">clipPos</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">clipPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">clamped</span><span class="p">,</span> <span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">clipPos</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>同时支持Normal Bias，必须根据法向量移动顶点坐标。因此，添加一个normal变量。然后可以使用UnityCG定义的UnityClipSpaceShadowCasterPos函数</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">{</span>
    <span class="c1">//float4 position = UnityObjectToClipPos(i.position);</span>
    <span class="kt">float4</span> <span class="n">position</span> <span class="o">=</span> <span class="n">UnityClipSpaceShadowCasterPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="k">return</span>    <span class="n">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p><em>先将顶点坐标转换到世界空间，然后转换到裁剪空间。计算光的方向，计算法线和光的角度，取正弦值，最后转与观察投影矩阵相乘转到裁剪空间。</em></p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float4</span> <span class="nf">UnityClipSpaceShadowCasterPos</span><span class="p">(</span><span class="kt">float4</span> <span class="n">vertex</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">normal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float4</span> <span class="n">wPos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">vertex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float3</span> <span class="n">wNormal</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">normal</span><span class="p">);</span>
        <span class="kt">float3</span> <span class="n">wLight</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">UnityWorldSpaceLightDir</span><span class="p">(</span><span class="n">wPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>

        <span class="c1">// apply normal offset bias (inset position along the normal)</span>
        <span class="c1">// bias needs to be scaled by sine between normal and light direction</span>
        <span class="c1">// (http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/)</span>
        <span class="c1">//</span>
        <span class="c1">// unity_LightShadowBias.z contains user-specified normal offset amount</span>
        <span class="c1">// scaled by world space texel size.</span>

        <span class="n">float</span> <span class="n">shadowCos</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">wNormal</span><span class="p">,</span> <span class="n">wLight</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowSine</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">shadowCos</span><span class="o">*</span><span class="n">shadowCos</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">normalBias</span> <span class="o">=</span> <span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">shadowSine</span><span class="p">;</span>

        <span class="n">wPos</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-=</span> <span class="n">wNormal</span> <span class="o">*</span> <span class="n">normalBias</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_VP</span><span class="p">,</span> <span class="n">wPos</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>写完就具备了完全的阴影投射</p><h2 id="接收阴影">接收阴影</h2><p>First,我们先关注主方向光的阴影，因为该光源属于BasePass，必须要先适配。<strong>当主方向光投射阴影，Unity会找一个启用了SHADOWS_SCREEN关键字的shader变体</strong>。所以我们要在Base Pass创建两个变体，同之前使用顶点光关键字类似：一个无，一个是该关键字。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile _ VERTEXLIGHT_ON
#pragma multi_compile _ SHADOWS_SCREEN
</span></code></pre></div></div><p>该basePass有两个multi_compile指令，每个都是单关键字。因此编译后这里会有4个变体：</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Total snippets: 3</span>
<span class="c1">// --</span>
<span class="c1">// Snippet #0 platforms ffffffff:</span>
<span class="n">SHADOWS_SCREEN</span> <span class="n">VERTEXLIGHT_ON</span>

<span class="mi">4</span> <span class="n">keyword</span> <span class="n">variants</span> <span class="n">used</span> <span class="k">in</span> <span class="n">scene</span><span class="o">:</span>

<span class="o">&lt;</span><span class="n">no</span> <span class="n">keywords</span> <span class="n">defined</span><span class="o">&gt;</span>
<span class="n">SHADOWS_SCREEN</span>
<span class="n">VERTEXLIGHT_ON</span>
<span class="n">SHADOWS_SCREEN</span> <span class="n">VERTEXLIGHT_ON</span>
</code></pre></div></div><p>(老版本Unity有可能出现)当增加了multi_compile指令后，shader编译器会提示关于__ShadowCoord_不存在。这是因为_UNITY_LIGHT_ATTENUATION_宏在使用阴影时的行为不同导致。在MyLighting_shadow.cginc顶点函数快速修复</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(UNITY_SCREEN) float attenuation = 1;
#else
</span>    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div><h3 id="采样阴影">采样阴影</h3><p>Secend,采样屏幕空间阴影纹理。<br> Third,需要获取屏幕空间纹理坐标，从顶点函数传递给片元函数。在插值器Interpolator添加一个float4 变量以支持传递阴影纹理坐标。从裁剪空间开始(裁剪空间顶点坐标)。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolator</span><span class="p">{</span>
    <span class="cp">#if defined(SHADOWS_SCREEN)
</span>        <span class="kt">float4</span> <span class="n">shadowCoordinate</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
<span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//。。。</span>
    <span class="cp">#if defined(SHADOWS_SCREE)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="c1">//。。。</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015552159-153113228.png" width="250"><font size="2.5"> <i>错误的纹理坐标映射.</i> </font> </center><p>AutoLignt.cginc定义了Sampler2D _ShadowMapTexture，可以通过它访问屏幕阴影纹理。但是要覆盖整个屏幕，就需要屏幕空间坐标。在裁剪空间，XY坐标范围是[-1, 1]，而屏幕空间下是[0,1]；然后偏移坐标与屏幕左小脚等于0对齐。因为我们处理的使透视变换，偏移坐标值取决于距离，这里的偏移值等于加上齐次坐标的w分量之后的一半。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SHADOWS_SCREEN)
</span>    <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015552728-1203950638.png" width="250"><font size="2.5"> <i>错误的左下角映射.</i> </font> </center><p>上图的投影错误，还需要通过x和y除以齐次坐标进一步转换</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015553704-577419973.png" width="250"><font size="2.5"> <i>错误投影.</i> </font> </center><p>上图结果仍然是错误的，影子被拉伸了。这是由于在顶点函数计算导致，不应该在传递给片元函数时提前修改原始数据，需要保持它们的独立性。在片元函数再次除以w.</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015555540-1368845680.png" width="250"><font size="2.5"> <i>颠倒的投影.</i> </font> </center><p>此时，影子是上下颠倒的。如果它们被翻转，这意味着你的图形Direct3D屏幕空间Y坐标从0向下到1，而不是向上。要与此同步，翻转顶点的Y坐标。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SHADOWS_SCREEN)
</span>    <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float2</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">w</span><span class="p">);</span><span class="c1">// (i.pos.xy + i.pos.w) * 0.5;</span>
    <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015556220-1277984238.png" width="250"><font size="2.5"> <i>继续错误.</i> </font> </center><h3 id="内置函数使用">内置函数使用</h3><p>SHADOW_COORDS宏定义纹理坐标</p><p>TRANSFRE_SHADOW宏获取阴影纹理坐标(转换)</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TRANSFER_SHADOW(a) a._ShadowCoord = ComputeScreenPos(a.pos);
</span></code></pre></div></div><p>SHADOW_ATTENUATION宏阴影纹理明暗衰减</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SHADOW_COORDS
</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span> <span class="n">unityShadowCoord4</span> <span class="n">_ShadowCoord</span> <span class="o">:</span> <span class="n">TEXCOORD</span><span class="err">##</span><span class="n">idx1</span><span class="p">;</span>
    <span class="cp">#define SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)
</span></code></pre></div></div><p>UNITY_LIGHT_ATTENUATION宏包含了SHADOW_ATTENUATION宏使用，可替换之</p><p>当启用SHADOWS_SCREEN指令时，会自动计算，不启用不计算，没有任何损失。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="c1">// #if defined(SHADOWS_SCREEN)</span>
    <span class="c1">//    float4 shadowCoordinates : TEXCOORD5;</span>
    <span class="c1">// #endif</span>
    <span class="n">SHADOW_COORDS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="c1">//...</span>
<span class="p">};</span>

<span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="c1">// #if defined(SHADOWS_SCREEN)</span>
    <span class="c1">//   i.shadowCoordinates = i.position;</span>
    <span class="c1">// #endif</span>
    <span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
<span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="cp">#if defined(SHADOWS_SCREEN)
</span>        <span class="n">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#else
</span>        <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015557055-486911408.png" width="250"><font size="2.5"> <i>正确了.</i> </font> </center><p>ComputeScreenPos函数</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inline</span> <span class="kt">float4</span> <span class="nf">ComputeNonStereoScreenPos</span><span class="p">(</span><span class="kt">float4</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">o</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="kt">float2</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">inline</span> <span class="kt">float4</span> <span class="nf">ComputeScreenPos</span><span class="p">(</span><span class="kt">float4</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">o</span> <span class="o">=</span> <span class="n">ComputeNonStereoScreenPos</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="cp">#if defined(UNITY_SINGLE_PASS_STEREO)
</span>    <span class="n">o</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TransformStereoScreenSpaceTex</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">pos</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="聚光灯阴影">聚光灯阴影</h2><p>关闭方向光，增加聚光灯后，竟然直接有阴影了。这是Unity宏带来的便利。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151429610-436331942.png" width="250"><font size="2.5"> <i>点光源阴影.</i> </font> </center><p>再看帧调试器</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151430321-98573745.png" width="250"><font size="2.5"> <i>SpotLight Debugger.</i> </font> </center><p>上图对于聚光灯源阴影的渲染工作量很少</p><p><strong>不同之处</strong>：</p><ol><li>没有方向光独立的深度pass和屏幕空间阴影pass，而是直接渲染阴影纹理；<li>与方向光渲染阴影还有很大的差别之处：聚光灯光线不是平行的，因此用光的位置模拟相机视角会得到一个透视视角，结果就是不支持阴影分段渲染(cascades)；<li>normal bias(法线偏差)<strong>只</strong>支持方向光阴影，对于<strong>其他</strong>光源类型简单的置为0；<li>采样代码不同。</ol><p><strong>相同之处</strong>：</p><ol><li>投射阴影的这段代码通用。</ol><h3 id="采样阴影纹理">采样阴影纹理</h3><p>由于聚光灯不使用屏幕空间的阴影，这段采样纹理代码就有点不一样。因此，如果我们想要使用软阴影，我们必须在fragment程序中进行<strong>过滤</strong>。而Unity宏已经做了过滤计算UnitySampleShadowmap。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//阴影坐标把顶点坐标从模型空间转到世界空间再转到光的阴影空间得到。</span>

<span class="c1">// - Spot light shadows</span>
<span class="cp">#if defined (SHADOWS_DEPTH) &amp;&amp; defined (SPOT)
</span>
<span class="cp">#define SHADOW_COORDS(idx1) unityShadowCoord4 _ShadowCoord : TEXCOORD##idx1;
#define TRANSFER_SHADOW(a) a._ShadowCoord = mul(unity_WorldToShadow[0], mul(unity_ObjectToWorld,v.vertex));
#define SHADOW_ATTENUATION(a) UnitySampleShadowmap(a._ShadowCoord)
#endif
</span></code></pre></div></div><p>然后<code class="language-plaintext highlighter-rouge">SHADOW_ATTENUATION</code>宏使用<code class="language-plaintext highlighter-rouge">UnitySampleShadowmap</code>函数采样阴影映射。这个函数定义在_UnityShadowLibrary_，_AutoLight_文件引用了它。当使用硬阴影时，该函数对阴影纹理采样一次。当使用软阴影时，它对纹理采样四次并对结果取平均值。这个结果没有用于屏幕空间阴影的过滤效果好，但是速度快得多。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151431024-1101864231.png" width="250"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151431654-1775286822.png" width="250"><font size="2.5"> <i>hard vs. soft SpotLight Shadow.</i> </font> </center><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Spot light shadows</span>
<span class="k">inline</span> <span class="n">fixed</span> 

<span class="nf">UnitySampleShadowmap</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">shadowCoord</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// DX11 feature level 9.x shader compiler (d3dcompiler_47 at least)</span>
    <span class="c1">// has a bug where trying to do more than one shadowmap sample fails compilation</span>
    <span class="c1">// with "inconsistent sampler usage". Until that is fixed, just never compile</span>
    <span class="c1">// multi-tap shadow variant on d3d11_9x.</span>
    <span class="cp">#if defined (SHADOWS_SOFT) &amp;&amp; !defined (SHADER_API_D3D11_9X)
</span>        <span class="c1">// 4-tap shadows</span>
        <span class="cp">#if defined (SHADOWS_NATIVE)
</span>            <span class="cp">#if defined (SHADER_API_D3D9)
</span>                <span class="c1">// HLSL for D3D9, when modifying the shadow UV coordinate, really wants to do</span>
                <span class="c1">// some funky swizzles, assuming that Z coordinate is unused in texture sampling.</span>
                <span class="c1">// So force it to do projective texture reads here, with .w being one.</span>
                <span class="kt">float4</span> <span class="n">coord</span> <span class="o">=</span> <span class="n">shadowCoord</span> <span class="o">/</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
                <span class="kt">half4</span> <span class="n">shadows</span><span class="p">;</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
                <span class="n">shadows</span> <span class="o">=</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span> <span class="o">+</span> <span class="n">shadows</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span><span class="p">);</span>
            <span class="cp">#else
</span>                <span class="c1">// On other platforms, no need to do projective texture reads.</span>
                <span class="kt">float3</span> <span class="n">coord</span> <span class="o">=</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
                <span class="kt">half4</span> <span class="n">shadows</span><span class="p">;</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
                <span class="n">shadows</span> <span class="o">=</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span> <span class="o">+</span> <span class="n">shadows</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span><span class="p">);</span>
            <span class="cp">#endif
</span>        <span class="cp">#else
</span>            <span class="kt">float3</span> <span class="n">coord</span> <span class="o">=</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
            <span class="kt">float4</span> <span class="n">shadowVals</span><span class="p">;</span>
            <span class="n">shadowVals</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span> <span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xy</span><span class="p">);</span>
            <span class="n">shadowVals</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span> <span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">xy</span><span class="p">);</span>
            <span class="n">shadowVals</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span> <span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xy</span><span class="p">);</span>
            <span class="n">shadowVals</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span> <span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">xy</span><span class="p">);</span>
            <span class="kt">half4</span> <span class="n">shadows</span> <span class="o">=</span> <span class="p">(</span><span class="n">shadowVals</span> <span class="o">&lt;</span> <span class="n">coord</span><span class="p">.</span><span class="n">zzzz</span><span class="p">)</span> <span class="o">?</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
        <span class="cp">#endif
</span>        <span class="c1">// average-4 PCF</span>
        <span class="n">half</span> <span class="n">shadow</span> <span class="o">=</span> <span class="nb">dot</span> <span class="p">(</span><span class="n">shadows</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span><span class="p">);</span>
    <span class="cp">#else
</span>        <span class="c1">// 1-tap shadows</span>
        <span class="cp">#if defined (SHADOWS_NATIVE)
</span>        <span class="n">half</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">shadowCoord</span><span class="p">);</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">r</span> <span class="o">+</span> <span class="n">shadow</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">_LightShadowData</span><span class="p">.</span><span class="n">r</span><span class="p">);</span>
        <span class="cp">#else
</span>        <span class="n">half</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">UNITY_PROJ_COORD</span><span class="p">(</span><span class="n">shadowCoord</span><span class="p">))</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">shadowCoord</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">?</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">r</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div><h2 id="点光源阴影">点光源阴影</h2><p>如果直接使用点光源，会有编译报错：undeclared identifier ‘UnityDecodeCubeShadowDepth’。该函数在_UnityCG.cginc_文件。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151432459-1922680396.png" width="250"><font size="2.5"> <i>UnityPBSLighting文件引用；AutoLight文件引用.</i> </font> </center><p>所以根据引用结构，需要把UnityPBSLighing文件放在第一位引用。就不会报错了。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151433321-1428961084.png" width="250"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151434107-2064323872.png" width="250"><font size="2.5"> <i>左：render six times per light.</i> </font> </center><h3 id="投射阴影-1">投射阴影</h3><p>从帧调试器查看，左边一个光要渲染6次，两盏光就是12次了。有很多个RenderJobPoint渲染了。结果是，点光源的阴影纹理是一个立方体贴图，而立方体贴图是通过相机在6个不同方向观察场景，每个方向渲染一面组成六面体，前面1.4讲过把光源模拟相机对屏幕渲染。所以点光源阴影计算很费，尤其是实时点光源阴影。</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151434750-920356967.png" width="250"><font size="2.5"> <i>错误的阴影纹理.</i> </font> </center><p>当渲染点光源阴影纹理时，Unity引擎会找shader变体关键字<code class="language-plaintext highlighter-rouge">SHADOWS_CUBE，而SHADOWS_DEPTH关键字只适用于方向光和聚光灯。为了支持点光源阴影，Unity提供了一个特殊编译指令</code></p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_shadowcaster
</span>
<span class="c1">// --</span>
<span class="c1">// Snippet #2 platforms ffffffff:</span>
<span class="n">SHADOWS_CUBE</span> <span class="n">SHADOWS_DEPTH</span>

<span class="mi">2</span> <span class="n">keyword</span> <span class="n">variants</span> <span class="n">used</span> <span class="k">in</span> <span class="n">scene</span><span class="o">:</span>
<span class="n">SHADOWS_DEPTH</span>
<span class="n">SHADOWS_CUBE</span>
</code></pre></div></div><p>所以，需要创建一个独立的处理程序。这里首先要计算光到表面的距离，但得知道光到表面的方向。在顶点函数先转换顶点坐标所在世界空间，再计算光的方向。然后在片元函数计算该方向向量长度再与bias偏差相加。然后再除以点光源的范围映射到[0.1]再与长度相乘，最后解码。而_LightPositionRange.w = 1/range已经计算好了隐射范围，直接用。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SHADOWS_CUBE)
</span>    <span class="k">struct</span> <span class="n">Interplotars</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
        <span class="kt">float3</span> <span class="n">lightVec</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">Interplotars</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">v</span><span class="p">){</span>
        <span class="n">Interplotars</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">lightVec</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">position</span><span class="p">).</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">_LightPositionRange</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
        <span class="c1">//float4 position = UnityClipSpaceShadowCasterPos(i.position, i.normal);//方向光源：简单的裁剪空间顶点坐标</span>
        <span class="k">return</span>	<span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">half4</span> <span class="nf">MyFragmentProgram</span><span class="p">(</span><span class="n">Interplotars</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
        <span class="n">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightVec</span><span class="p">)</span> <span class="o">+</span> <span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
        <span class="n">depth</span> <span class="o">*=</span> <span class="n">_LightPositionRange</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">UnityEncodeCubeShadowDepth</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#else
</span>    <span class="kt">float4</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">{</span>
        <span class="c1">//float4 position = UnityObjectToClipPos(i.position);</span>
        <span class="kt">float4</span> <span class="n">position</span> <span class="o">=</span> <span class="n">UnityClipSpaceShadowCasterPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="k">return</span>	<span class="n">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">half4</span> <span class="nf">MyFragmentProgram</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151435367-1088891603.png" width="250"><font size="2.5"> <i>正确的阴影纹理.</i> </font> </center><p>UnityEncodeCubeShadowDepth函数：</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Shadow caster pass helpers</span>
<span class="kt">float4</span> <span class="nf">UnityEncodeCubeShadowDepth</span> <span class="p">(</span><span class="n">float</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp">#ifdef UNITY_USE_RGBA_FOR_POINT_SHADOWS
</span>    <span class="k">return</span> <span class="n">EncodeFloatRGBA</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">999</span><span class="p">));</span>
    <span class="cp">#else
</span>    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用浮点类型cube——map,存储再8位RGBA纹理</span>
<span class="k">inline</span> <span class="kt">float4</span> <span class="nf">EncodeFloatRGBA</span><span class="p">(</span> <span class="n">float</span> <span class="n">v</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float4</span> <span class="n">kEncodeMul</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">65025</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16581375</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">kEncodeBit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">enc</span> <span class="o">=</span> <span class="n">kEncodeMul</span> <span class="o">*</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">enc</span> <span class="o">=</span> <span class="nb">frac</span> <span class="p">(</span><span class="n">enc</span><span class="p">);</span><span class="c1">//返回小数部分</span>
    <span class="n">enc</span> <span class="o">-=</span> <span class="n">enc</span><span class="p">.</span><span class="n">yzww</span> <span class="o">*</span> <span class="n">kEncodeBit</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">enc</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="采样阴影纹理-1">采样阴影纹理</h3><p>在additional pass的编译指令，Unity宏已经做了。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//同样计算光的方向，然后采样cubeMap。区别是float3类型而不是float4，不需要齐次坐标。</span>
<span class="c1">// - Point light shadows</span>
<span class="cp">#if defined (SHADOWS_CUBE)
#define SHADOW_COORDS(idx1) unityShadowCoord3 _ShadowCoord : TEXCOORD##idx1;
#define TRANSFER_SHADOW(a) a._ShadowCoord = mul(unity_ObjectToWorld, v.vertex).xyz - _LightPositionRange.xyz;
#define SHADOW_ATTENUATION(a) UnitySampleShadowmap(a._ShadowCoord)
#endif
</span>
<span class="c1">// </span>
<span class="c1">// Point light shadows</span>
<span class="c1">//在这种情况下，UnitySampleShadowmap采样一个立方体地图，而不是2D纹理。</span>
<span class="cp">#if defined (SHADOWS_CUBE)
</span>
<span class="n">samplerCUBE_float</span> <span class="n">_ShadowMapTexture</span><span class="p">;</span>
<span class="k">inline</span> <span class="n">float</span> <span class="nf">SampleCubeDistance</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp">#ifdef UNITY_FAST_COHERENT_DYNAMIC_BRANCHING
</span>        <span class="k">return</span> <span class="n">UnityDecodeCubeShadowDepth</span><span class="p">(</span><span class="nb">texCUBElod</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="n">UnityDecodeCubeShadowDepth</span><span class="p">(</span><span class="nb">texCUBE</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">vec</span><span class="p">));</span>
    <span class="cp">#endif
</span><span class="p">}</span>
<span class="k">inline</span> <span class="n">half</span> <span class="nf">UnitySampleShadowmap</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float</span> <span class="n">mydist</span> <span class="o">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightPositionRange</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">mydist</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">97</span><span class="p">;</span> <span class="c1">// bias</span>

    <span class="cp">#if defined (SHADOWS_SOFT)
</span>        <span class="n">float</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">128</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">shadowVals</span><span class="p">;</span>
        <span class="n">shadowVals</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="o">+</span><span class="kt">float3</span><span class="p">(</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">));</span>
        <span class="n">shadowVals</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="o">+</span><span class="kt">float3</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">));</span>
        <span class="n">shadowVals</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="o">+</span><span class="kt">float3</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">));</span>
        <span class="n">shadowVals</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="o">+</span><span class="kt">float3</span><span class="p">(</span> <span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">));</span>
        <span class="kt">half4</span> <span class="n">shadows</span> <span class="o">=</span> <span class="p">(</span><span class="n">shadowVals</span> <span class="o">&lt;</span> <span class="n">mydist</span><span class="p">.</span><span class="n">xxxx</span><span class="p">)</span> <span class="o">?</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">dot</span><span class="p">(</span><span class="n">shadows</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="p">);</span>
    <span class="cp">#else
</span>        <span class="n">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">mydist</span> <span class="o">?</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">r</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>

<span class="cp">#endif // #if defined (SHADOWS_CUBE)
</span></code></pre></div></div><p>同样，如果使用软阴影会采样四次并取平均值，硬阴影采样一次。同时没有进行过滤计算，计算昂贵且效果很粗糙！</p><center class="half"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151435824-1969485390.png" width="250"> <img loading="lazy" src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151436465-1258622662.png" width="250"><font size="2.5"> <i>hard vs soft pointLight Shadows.</i> </font> </center><p>对于点光源阴影实在不能用于手机平台，替代方式就是用无阴影点光+cookie投射，模拟阴影。或者用较少的聚光灯阴影代替。</p><div class="post-copyright"><p> <span>版权声明：</span> 如无特别声明，本文版权归 <a href="https://www.damonc.top" class="cplink">编程散记</a> 所有，转载请注明本文链接。</p><p> （采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" class="extlinks">CC BY-NC-SA 4.0</a> 许可协议进行授权）</p><p><span>本文标题：</span>《 Unity Shadow 阴影(翻译七) 》</p><p><span>本文链接：</span><a href="https://www.damonc.top/Unity_Shadows.html" class="cplink">https://www.damonc.top/Unity_Shadows.html</a></p><p class="tips">本文最后一次更新为 <span></span> 天前，文章中的某些内容可能已过时！</p></div><div class="post-social-share"><div class="share-section"><div class="social-share-wrapper"><div class="social-share"></div></div></div></div></article></div><div class="table-of-contents"><div class="toc-header"><h2>目录</h2></div><div class="toc-body"><ul><li><a onclick="scrollToAdjust('方向光阴影-direction')">1. 方向光阴影-Direction</a><ul><li><a onclick="scrollToAdjust('启用阴影-enable-shadow')">1.1 启用阴影-Enable Shadow</a><li><a onclick="scrollToAdjust('阴影贴图-shadow-map')">1.2 阴影贴图-Shadow map</a><li><a onclick="scrollToAdjust('渲染深度纹理-rendering-to-the-depth-texture')">1.3 渲染深度纹理-Rendering to the Depth Texture</a><li><a onclick="scrollToAdjust('渲染阴影贴图-rendering-to-shadow-maps')">1.4 渲染阴影贴图-Rendering to Shadow Maps</a><li><a onclick="scrollToAdjust('收集阴影-collecting-shadows')">1.5 收集阴影-Collecting Shadows</a><li><a onclick="scrollToAdjust('采样阴影贴图-sampling-the-shadow-maps')">1.6 采样阴影贴图-Sampling the Shadow Maps</a><li><a onclick="scrollToAdjust('阴影质量-shadow-quality')">1.7 阴影质量-Shadow Quality</a><li><a onclick="scrollToAdjust('阴影“痤疮”(0!什么鬼)')">1.8 阴影“痤疮”(0!什么鬼)</a><li><a onclick="scrollToAdjust('抗锯齿')">1.9 抗锯齿</a></ul><li><a onclick="scrollToAdjust('投射阴影')">2. 投射阴影</a><ul><li><a onclick="scrollToAdjust('偏差-bias')">2.1 偏差-Bias</a></ul><li><a onclick="scrollToAdjust('接收阴影')">3. 接收阴影</a><ul><li><a onclick="scrollToAdjust('采样阴影')">3.1 采样阴影</a><li><a onclick="scrollToAdjust('内置函数使用')">3.2 内置函数使用</a></ul><li><a onclick="scrollToAdjust('聚光灯阴影')">4. 聚光灯阴影</a><ul><li><a onclick="scrollToAdjust('采样阴影纹理')">4.1 采样阴影纹理</a></ul><li><a onclick="scrollToAdjust('点光源阴影')">5. 点光源阴影</a><ul><li><a onclick="scrollToAdjust('投射阴影')">5.1 投射阴影</a><li><a onclick="scrollToAdjust('采样阴影纹理')">5.2 采样阴影纹理</a></ul></ul></div></div></div></div></main><section class="author-detail"><section class="post-footer-item author-card"><div class="avatar"> <img src="https://img.damonc.top/commons/avatar.png" alt=""></div><div class="author-name" rel="author">编程散记</div><div class="bio"><p>Developer & Maintainer</p></div><ul class="sns-links"><li> <a href="https://github.com/damonc-top" target="_blank" aria-label="github"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-github"></use> </svg> </a><li> <a href="https://segmentfault.com/u/junyidebocai" target="_blank" aria-label="segmentfault"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-segmentfault"></use> </svg> </a></ul></section><section class="post-footer-item read-next"><div class="read-next-item"> <a href="/Unity_Reflection.html" class="read-next-link" aria-label="Unity Reflection 反射(翻译八)"></a><section> <span>Unity Reflection 反射(翻译八)</span><p>本篇摘要: 采样坏境 使用reflection probes探针 创建粗糙或光滑的镜面 完成box投影与立...</p></section></div><div class="read-next-item"> <a href="/Unity_Advance_Texture.html" class="read-next-link" aria-label="Unity 纹理高级用法(翻译六)"></a><section> <span>Unity 纹理高级用法(翻译六)</span><p>本篇摘要: 扰动法线以模拟凹凸视觉 从高度场计算法线 采样和混合法线贴图 从切线空间转换到世界空间</p></section></div></section><script src="https://unpkg.com/@waline/client@3.3.2/dist/waline.umd.js" async onload="initWaline()"></script> <script> function initWaline() { $(document).ready(function () { Waline.init({ el: '#waline', serverURL: "https://comments.damonc.top", reaction: "true", comment: true, locale: "{reaction0: '赞一个', reaction1: '踩一下', reaction2: '有点酷', reaction3: '看不懂', reaction4: '啥玩意', reaction5: '想睡觉'}", }); }); } </script> <script> $(document).ready(function () { if ($("#comments-switch").length > 0) { var comment_status = $("#cmn-toggle-4")[0].checked; if (comment_status) { $("#waline").addClass("active"); } else { $("#disqus_thread").addClass("active"); } $("#cmn-toggle-4").click(function () { $("#disqus_thread").toggleClass("active"); $("#waline").toggleClass("active"); }) } else { if ($("#disqus_thread").length > 0) { $("#disqus_thread").addClass("active"); } else if ($("#waline").length > 0) { $("#waline").addClass("active"); } } }) </script><section class="post-footer-item comment"><div class="comments-headline"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-comment"></use> </svg> <span>评论</span></div></section><section class="post-footer-item comment"><div id="waline"></div></section></section><footer class="g-footer"><div class="g-container"><div class="g-left"><section class="links"> 本站由 <a href="//jekyllrb.com" target="_blank" class="extlinks">Jekyll</a> 和 基于 <a href="https://github.com/kaeyleo/jekyll-theme-H2O" target="_blank" class="extlinks">H2O主题模版</a> 强力驱动</section><section class="links">编程散记 © 2016 - 2025 <a href="https://icp.gov.moe/?keyword=20240160" target="_blank" class="extlinks">萌ICP备20240160号</a> <a href="/rss.xml" target="_blank" aria-label="Terms of Service" class="others"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-rss"></use> </svg> RSS </a> <a href="/tos" target="_blank" aria-label="Terms of Service" class="others"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-tos"></use> </svg> 使用条款 </a></section><section class="links"> <span id="busuanzi_container_site_pv"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-pv"></use> </svg> 总浏览量 <span id="busuanzi_value_site_pv"></span> <b>·</b> </span> <span id="busuanzi_container_site_uv"> <svg class="icon" aria-hidden="true"> <use xlink:href="#icon-user"></use> </svg> 总访问量 <span id="busuanzi_value_site_uv"></span> </span></section><section> 本站已运行 <span class="alivetime_days"></span> 天 <span class="alivetime_hours"></span> 小时 <span class="alivetime_minutes"></span> 分 <span class="alivetime_seconds"></span> 秒</section></div><div class="g-right"><section class="badges"> <a href="https://www.foreverblog.cn/" target="_blank" class="foreverblog" aria-label="foreverblog"> <img loading="lazy" src="https://img.foreverblog.cn/logo_en_default.png" alt=""> </a> <a href="https://www.foreverblog.cn/go.html" target="_blank" class="wormhole" aria-label="wormhole"> <img loading="lazy" src="https://img.foreverblog.cn/wormhole_3.gif" alt="" title="穿梭虫洞-随机访问十年之约友链博客"> </a> <a href="https://www.travellings.cn/go.html" target="_blank" class="travelling-badge" aria-label="Travelling" rel="noopener" title="开往-友链接力"> <img loading="lazy" src="https://cdn.jsdelivr.net/gh/travellings-link/travellings/assets/logo.gif" alt="开往-友链接力"> </a> <a href="https://notbyai.fyi/" target="_blank" class="notbyAI" aria-label="notbyAI"> <img loading="lazy" src="/assets/icons/notbyAI-white.png" alt="Written by Human, Not by AI"> </a></section></div></div></footer><div class="cookie-tip"> 为了提升本站的使用体验和必要功能的正常使用，本站会使用本地 Cookie。详细请查看「 <a href="/tos.html">本站使用条款</a> 」了解更多。 <button id="accept-tos">同意</button></div><section id="tools"><div class="tool toc"> <svg class="icon b1 active" aria-hidden="true"> <use xlink:href="#icon-toc"></use> </svg> <svg class="icon b2" aria-hidden="true"> <use xlink:href="#icon-exit"></use> </svg></div></section><section id="bttb" aria-label="Scroll back to top" class="bttb"><div class="tool"> <svg class="icon top" aria-hidden="true"> <use xlink:href="#icon-top"></use> </svg></div></section></div><div class="modal"><div class="modal-content"><header> <span class="close">&times;</span></header><div class="container"></div></div></div><script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" async></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/dayjs.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/plugin/customParseFormat.js"></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.2/plugin/relativeTime.js"></script> <script> $(document).ready(function () { var time_formats = ['YYYY-MM-DD HH:mm:ss ZZ', 'YYYY DD MMM HH:mm:ss ZZ', 'YYYY年MM月DD日 HH:mm:ss ZZ']; function dateFormat(date, format) { var date_org = dayjs(date, time_formats[format]); var date = date_org.format(time_formats[format]); return { "date_org": date_org, "date": date } } dayjs.extend(window.dayjs_plugin_customParseFormat); dayjs.extend(window.dayjs_plugin_relativeTime); var post_date = $("meta[property='post-date']").attr('content'); var post_date_format = $("meta[property='post-date-format']").attr('content'); var local_post_date = dateFormat(post_date, post_date_format); $(".post time span.create-at").html(local_post_date["date"]); var path = "post_project/_posts/2018/ShaderTranslate/2018-01-05-Unity_Shadows.md"; var workerUrl = "https://winter-meadow-170b.damoncbl.workers.dev?" + new URLSearchParams({ path: path }); fetch(workerUrl).then(function (res) { if (!res.ok) throw new Error("worker non-200: " + res.status); return res.json(); }).then(function (commits) { if (commits && commits.length) { var update_at = dayjs(commits[0]['commit']['committer']['date']); } else { var update_at = post_date; } var local_update_at = dateFormat(update_at, post_date_format); $('.post time span.update-at').html(local_update_at["date"]); var relative_time = dayjs().diff(local_update_at["date_org"], 'day'); $(".post-copyright .tips span").append(relative_time); if (relative_time > 365) { $(".post-copyright .tips").addClass("active"); } }).catch(function () { var local_update_at = dateFormat(post_date, post_date_format); $('.post time span.update-at').html(local_update_at["date"]); }); }); </script> <script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script> <script> socialShare('.social-share', { sites: [ 'wechat', 'weibo', 'douban', 'twitter' ], wechatQrcodeTitle: "分享到微信朋友圈", wechatQrcodeHelper: '<p>扫码后点击右上角</p><p>将本文分享至朋友圈</p>' }); $("a.social-share-icon").each(function () { $(this).attr("aria-label", $(this).attr("class").split(' ')[1]) }); </script> <script src="https://cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script> <script> function scrollToAdjust(id){ var element = document.getElementById(id); var headerOffset = 90; var elementPosition = element.getBoundingClientRect().top; var offsetPosition = elementPosition + window.scrollY - headerOffset; window.scrollTo({ top: offsetPosition, behavior: "smooth" }); } </script> <script src="/assets/js/app.min.js"></script> <script src="https://at.alicdn.com/t/c/font_3046306_ujr2yq34hw.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-WN45VXRK"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'GTM-WN45VXRK'); </script> <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> <script async src="https://cdn.jsdelivr.net/npm/promise-polyfill@8.3.0/dist/polyfill.min.js"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax-full@3.2.2/es5/tex-mml-svg.min.js"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ jax: ["input/TeX", "output/HTML-CSS"], tex2jax: { inlineMath: [['$', '$'], ["\\(", "\\)"]], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }, "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] } }); </script> <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.min.js"></script> <script> $(document).ready(function () { var baseurl = $("meta[property='og:baseurl']").attr('content'); $("center img").each(function () { $(this).attr('data-src', $(this).attr('src')).removeAttr('src').addClass("lazyload").attr('src', baseurl + '/assets/img/loading.gif'); var strA = "<a data-fancybox='gallery' ref='gallery' href='" + $(this).attr('data-src') + "' data-caption='" + $(this).attr('alt') + "'></a>"; $(this).wrapAll(strA); var caption = $(this)[0].alt; $(this).parent().after('<span class="caption">' + caption + '</span>'); }); Fancybox.bind('[data-fancybox]', { on: { load: function(fancybox, slide) { var gray = $("meta[property='og:gray']").attr('content'); if (gray == "true") { $(".fancybox__content img").addClass("gray"); $(".carousel__track .fancybox__thumb").addClass("gray"); } } } }); }); </script> <script src="https://cdn.jsdelivr.net/npm/hotkeys-js/dist/hotkeys.min.js"></script> <script> $(document).ready(function () { var previous_url = $("meta[property='og:previous_url']").attr('content'); var next_url = $("meta[property='og:next_url']").attr('content'); hotkeys('left', function (event, handler) { event.preventDefault(); if (previous_url) { console.log('you pressed left!'); window.location.href = previous_url; } else { $("#no-previous").addClass("active"); setTimeout(function () { $("#no-previous").removeClass("active"); }, 1500); } }); hotkeys('right', function (event, handler) { event.preventDefault(); if (next_url) { console.log('you pressed right!'); window.location.href = next_url; } else { $("#no-next").addClass("active"); setTimeout(function () { $("#no-next").removeClass("active"); }, 1500); } }); }); </script> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.6/dist/mermaid.min.js"></script> <script> $(document).ready(function () { mermaid.initialize({ startOnLoad: true, theme: "default", }); mermaid.init(undefined, $('.mermaid2')); }); </script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script> <script> if (window.Prism) { Prism.languages.mermaid2 = Prism.languages.none || {}; } </script> <script> if ("serviceWorker" in navigator) { var env = 'development'; var isDev = env === 'development'; navigator.serviceWorker .register('/sw.js', { scope: '/' }) .then(function (reg) { if (isDev) console.log("Service worker registered for scope:", reg.scope); }) .catch(function (err) { if (isDev) console.warn("Service worker registration failed:", err); }); } </script> <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script> <script type="text/javascript"> docsearch({ appId: "NCUJ5WJECO", apiKey: "b625a4b91a45af033cbdb526694e9e65", indexName: "damonc", lang: "zh", insights: true, debug: false, container: 'li#search', }); </script>
