/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};
var _Theme;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateGetter(s, r, a) { return a(_assertClassBrand(s, r)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Theme management class
 *
 * To reduce flickering during page load, this script should be loaded synchronously.
 */
class Theme {
  static get DARK() {
    return 'dark';
  }
  static get LIGHT() {
    return 'light';
  }

  /**
   * @returns {string} Theme mode identifier
   */
  static get ID() {
    return 'theme-mode';
  }

  /**
   * Gets the current visual state of the theme.
   *
   * @returns {string} The current visual state, either the mode if it exists,
   *                   or the system dark mode state ('dark' or 'light').
   */
  static get visualState() {
    if (_classPrivateGetter(Theme, this, _get_hasMode)) {
      return _classPrivateGetter(Theme, this, _get_mode);
    } else {
      return _classPrivateGetter(Theme, this, _get_sysDark) ? this.DARK : this.LIGHT;
    }
  }
  /**
   * Maps theme modes to provided values
   * @param {string} light Value for light mode
   * @param {string} dark Value for dark mode
   * @returns {Object} Mapped values
   */
  static getThemeMapper(light, dark) {
    return {
      [this.LIGHT]: light,
      [this.DARK]: dark
    };
  }

  /**
   * Initializes the theme based on system preferences or stored mode
   */
  static init() {
    if (!this.switchable) {
      return;
    }
    _assertClassBrand(Theme, this, _darkMedia)._.addEventListener('change', () => {
      const lastMode = _classPrivateGetter(Theme, this, _get_mode);
      _assertClassBrand(Theme, this, _clearMode).call(this);
      if (lastMode !== this.visualState) {
        _assertClassBrand(Theme, this, _notify).call(this);
      }
    });
    if (!_classPrivateGetter(Theme, this, _get_hasMode)) {
      return;
    }
    if (_classPrivateGetter(Theme, this, _get_isDarkMode)) {
      _assertClassBrand(Theme, this, _setDark).call(this);
    } else {
      _assertClassBrand(Theme, this, _setLight).call(this);
    }
  }

  /**
   * Flips the current theme mode
   */
  static flip() {
    if (_classPrivateGetter(Theme, this, _get_hasMode)) {
      _assertClassBrand(Theme, this, _clearMode).call(this);
    } else {
      _classPrivateGetter(Theme, this, _get_sysDark) ? _assertClassBrand(Theme, this, _setLight).call(this) : _assertClassBrand(Theme, this, _setDark).call(this);
    }
    _assertClassBrand(Theme, this, _notify).call(this);
  }
}
_Theme = Theme;
function _get_mode(_this) {
  return sessionStorage.getItem(_assertClassBrand(_Theme, _this, _modeKey)._) || document.documentElement.getAttribute(_assertClassBrand(_Theme, _this, _modeAttr)._);
}
function _get_isDarkMode(_this2) {
  return _classPrivateGetter(_Theme, _this2, _get_mode) === _this2.DARK;
}
function _get_hasMode(_this3) {
  return _classPrivateGetter(_Theme, _this3, _get_mode) !== null;
}
function _get_sysDark(_this4) {
  return _assertClassBrand(_Theme, _this4, _darkMedia)._.matches;
}
function _setDark() {
  document.documentElement.setAttribute(_assertClassBrand(_Theme, this, _modeAttr)._, this.DARK);
  sessionStorage.setItem(_assertClassBrand(_Theme, this, _modeKey)._, this.DARK);
}
function _setLight() {
  document.documentElement.setAttribute(_assertClassBrand(_Theme, this, _modeAttr)._, this.LIGHT);
  sessionStorage.setItem(_assertClassBrand(_Theme, this, _modeKey)._, this.LIGHT);
}
function _clearMode() {
  document.documentElement.removeAttribute(_assertClassBrand(_Theme, this, _modeAttr)._);
  sessionStorage.removeItem(_assertClassBrand(_Theme, this, _modeKey)._);
}
/**
 * Notifies other plugins that the theme mode has changed
 */
function _notify() {
  window.postMessage({
    id: this.ID
  }, '*');
}
var _modeKey = {
  _: 'mode'
};
var _modeAttr = {
  _: 'data-mode'
};
var _darkMedia = {
  _: window.matchMedia('(prefers-color-scheme: dark)')
};
_defineProperty(Theme, "switchable", !document.documentElement.hasAttribute(_assertClassBrand(_Theme, _Theme, _modeAttr)._));
Theme.init();
/* harmony default export */ __webpack_exports__["default"] = (Theme);
window.Theme = __webpack_exports__["default"];
/******/ })()
;
//# sourceMappingURL=theme.min.js.map