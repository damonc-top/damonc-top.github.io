[ { "title": "Claude Code(四)Hooks及用法：构建 Agent 的确定性神经系统", "url": "/posts/claude-code-hooks/", "categories": "AI, Claude Code", "tags": "ai, cli agent, prompt engineering, architecture", "date": "2026-01-15 21:00:00 +0800", "content": "在之前的文章中，我们探讨了 Claude Code 的基本交互。如果说 Prompt 是指挥 AI 的“语言”，那么 Hooks（钩子） 就是控制 AI 行为的“神经系统”。 今天，我们将跳出简单的命令配置，从架构设计的角度深入研究 Hooks。 核心概念：概率性 AI 与确定性系统 在软件工程中，LLM（大语言模型）本质上是一个概率性系统——你给它指令，它“很可能”会执行，但不是绝对。这在严谨的工程场景（如生产环境部署、敏感文件操作）中是不可接受的。 Hooks 的出现，是为了引入确定性。 架构视角： 你可以将 Hooks 想象成 Web 开发中的 Middleware（中间件） 或 Git 的 Pre-commit Hooks。它们是一道道刚性的逻辑“关卡”，包裹在柔软灵活的 AI 核心之外。 graph LR A[用户输入] --&gt; B{Pre-Hooks 拦截层} B -- 注入上下文 --&gt; C[Claude AI 核心] B -- 阻断/拒绝 --&gt; D[终止操作] C --&gt; E{Post-Hooks 处理层} E -- 格式化/审计 --&gt; F[最终输出/文件变更] E -- 触发后续任务 --&gt; G[自动化 Agent] 通过这种架构，我们实现了： 确定性控制：无论 AI 多么“有创意”，它都无法绕过硬编码的安全检查。 无感上下文：不需要用户手动输入背景信息，Hooks 自动在幕后“喂”给 AI。 副作用管理：将文件清理、日志记录等脏活累活从 AI 的 Token 消耗中剥离。 生命周期全景图 Claude Code 的生命周期比简单的“问答”要复杂得多，Hook 事件贯穿了从会话启动到结束的每一个微小环节。 下图展示了一个典型指令（如“帮我修改代码”）背后的 Hook 触发流： sequenceDiagram participant User participant System as Hook System participant Claude as Claude Agent participant Tool as File/Bash Tool Note over User, Claude: 阶段一：意图注入 User-&gt;&gt;System: 提交 Prompt System-&gt;&gt;System: 触发 UserPromptSubmit Note right of System: 自动检索 Skill/文档&lt;br/&gt;注入 Hidden Context System-&gt;&gt;Claude: 增强后的 Prompt Note over Claude, Tool: 阶段二：执行控制 Claude-&gt;&gt;System: 请求使用 Tool (Edit) System-&gt;&gt;System: 触发 PreToolUse/Permission Note right of System: 检查敏感文件&lt;br/&gt;安全审计 System--&gt;&gt;Claude: Allow/Deny Claude-&gt;&gt;Tool: 执行操作 Tool--&gt;&gt;System: 触发 PostToolUse Note right of System: 记录变更文件&lt;br/&gt;更新项目索引 System--&gt;&gt;Claude: 返回执行结果 Note over Claude, User: 阶段三：收尾质量门 Claude-&gt;&gt;System: 任务完成 (Stop) System-&gt;&gt;System: 触发 Stop Note right of System: 运行 TSC 检查&lt;br/&gt;运行 Prettier System-&gt;&gt;User: 最终响应 关键事件解析 事件 (Event) 核心价值 典型应用场景 SessionStart 环境初始化 加载项目特定的环境变量、检查依赖版本、恢复上次会话记忆。 UserPromptSubmit 上下文增强 (RAG) 这是实现“智能”的关键。在此处分析用户意图，悄悄注入相关的 API 文档或编码规范，而无需用户显式提供。 PreToolUse 安全卫士 防止 AI 修改 .env、锁定文件或在错误的分支上提交代码。它拥有“一票否决权”。 PostToolUse 状态追踪 AI 是无状态的，但项目是有状态的。在此处记录“AI 修改了哪些文件”，为后续的测试或回滚提供依据。 Stop 质量关口 在 AI 交差之前，强制执行编译检查。如果编译失败，甚至可以拒绝 AI 的停止请求，迫使它修复错误。 实战案例：构建“工程感知”基础设施 在 claude-code-infrastructure-showcase 项目中，展示了一套基于 Hooks 的高级基础设施。这不仅仅是配置，而是一套自动化工作流。 Skill 自动激活 (UserPromptSubmit) 最痛点的场景：你有 50 个项目的编码规范，如果全部放入 System Prompt，上下文窗口瞬间爆炸。 解决方案：动态注入。 工作原理： 用户输入：“优化这个数据库查询”。 UserPromptSubmit Hook 捕获输入，正则匹配关键词 数据库 SQL。 脚本读取本地 skills/database-best-practices.md。 将内容追加到 Prompt 尾部（对用户不可见）。 这样，Claude 在处理任务时，就像临时“回忆”起了相关的专业知识。 幽灵文件追踪器 (PostToolUse) Claude 有时会忘记自己刚刚改了什么，特别是在长会话中。 解决方案：构建外部记忆。 我们利用 PostToolUse 监听所有的 Write 和 Edit 操作。每当文件发生物理变更，Hook 脚本就会将文件路径记录到 .claude/session_context.json 中。 # 伪代码逻辑 if [ \"$TOOL_NAME\" == \"Edit\" ]; then echo \"$TARGET_FILE\" &gt;&gt; .claude/context/modified_files.log # 甚至可以自动触发 git add git add \"$TARGET_FILE\" fi 当你下次问“我今天改了哪些文件？”时，Claude 可以读取这个日志，精准回答，而不是靠幻觉瞎编。 闭环质量防御 (Stop) 这是从“玩具”到“工具”的质变。 在 Stop 钩子中，我们不仅运行格式化工具（Prettier），更关键的是运行编译检查。 强力模式： 如果 tsc (TypeScript Compiler) 检查失败，Hook 可以配置为拒绝停止。它会将错误日志反向喂给 Claude，并指令：“编译未通过，请修复这些错误后再结束任务。” 这构成了自动化的 ReAct (Reasoning + Acting) 循环，直到代码真正跑通。 配置指南与最佳实践 标准配置模板 推荐在项目根目录 .claude/settings.json 中使用如下配置，兼顾扩展性与维护性： { \"hooks\": { \"UserPromptSubmit\": [ { \"hooks\": [ { \"type\": \"command\", \"command\": \"$CLAUDE_PROJECT_DIR/.claude/hooks/skill-injector.sh\" } ] } ], \"PostToolUse\": [ { \"matcher\": \"Edit|Write\", \"hooks\": [ { \"type\": \"command\", \"command\": \"$CLAUDE_PROJECT_DIR/.claude/hooks/file-tracker.sh\" } ] } ], \"Stop\": [ { \"hooks\": [ { \"command\": \"$CLAUDE_PROJECT_DIR/.claude/hooks/auto-format.sh\" }, { \"command\": \"$CLAUDE_PROJECT_DIR/.claude/hooks/build-verifier.sh\" } ] } ] } } 进阶调优技巧 性能陷阱：Hooks 是同步执行的。如果你的 PostToolUse 脚本要跑 5 秒，Claude 就会卡住 5 秒。 对策：将耗时操作（如重型分析）放入后台运行（nohup ... &amp;），或者仅对增量文件进行检查。 环境隔离：Hook 脚本中的 $PATH 可能与你的终端不同。 对策：在脚本开头显式 source ~/.zshrc 或使用绝对路径调用工具（如 /usr/local/bin/npm）。 调试黑盒：当 Hook 不工作时，Claude 不会报错，只会默默失败。 对策：在脚本头部加上 set -x，并将日志输出到标准错误流 &gt;&amp;2。Claude 会将 stderr 的内容显示在调试日志中。 结语 Claude Code Hooks 的本质，是将 Software 1.0 (明确的代码逻辑) 的力量赋予 Software 2.0 (神经网络)。 通过合理配置 Hooks，我们不再是被动地“使用” AI，而是将 AI 作为一个高智商的模块，集成到我们要严密的软件工程体系中。这才是 Agent 开发的终极形态。 下一篇预告：Claude Code #5-斜杠命令- 学习如何配置自定义命令工具。" }, { "title": "Claude Code(三)核心解密：揭秘上下文引擎与提示词系统", "url": "/posts/claude-code-context-window/", "categories": "AI, Claude Code", "tags": "AI, CLI Agent, Prompt Engineering, Architecture", "date": "2026-01-14 23:15:10 +0800", "content": "在上一篇文章中，我们触及了 Claude Code 作为 CLI 助手的表面功能。但要真正精通这款工具，我们需要掀开它的引擎盖，看看它内部最核心、最精密的两个组件：Context Engine（上下文引擎） 和 Prompt System（提示词系统）。 大多数人只把 CLI Agent 当作一个“会聊天的命令行”，但实际上，它是一个复杂的分布式系统，通过精巧的工程手段来弥补 LLM 记忆力的缺陷。 Context Engine Context Engine 是 Claude Code 的“海马体”。在 LLM 的世界里，上下文窗口（Context Window）虽然越来越大（如 Claude 4.5 Sonnet 的 200k Token），但依然是昂贵且有限的资源。 Context Engine 的核心职责不是“记住所有事情”，而是“在有限的预算（Token）内，提供最相关的信息”。它必须时刻在“丢弃信息”和“保留细节”之间做艰难的权衡。 为什么上下文不是越大越好？ 你可能会问：“既然模型支持 200k 甚至更长的 Context，为什么我们还要费尽心思去压缩它？” 这里涉及到一个核心概念：上下文腐烂 (Context Rot)。 研究表明，随着上下文窗口的填充，LLM 的性能并不是线性的，而是会出现显著的边际递减效应： 注意力稀释：就像人类在嘈杂的房间里很难集中注意力听一个人说话一样，当上下文塞满无关信息时，模型提取关键指令的能力会下降（Recall Degradation）。 推理成本激增：Transformer 架构的计算复杂度是 $O(n^2)$。上下文长度翻倍，推理成本和延迟会增加四倍。 幻觉风险：过多的噪音数据（Distractors）会增加模型产生幻觉的概率。 因此，Context Engineering (上下文工程) 不仅仅是为了省钱，更是为了保智商。一个干净、紧凑的上下文环境，能让模型表现得更像一个资深工程师，而不是一个被淹没在文档堆里的实习生。 上下文的处理流水线 当你输入一个简单的指令时，后台发生了一系列复杂的操作。Claude Code 并不是简单地把你所有的历史记录扔给模型，而是经过了一个严密的流水线： Context Engine 的工作流程示意图 flowchart TD Input[原始输入源] --&gt; Filter(清洗 Filtering) Filter --&gt; Rank(优先级排序 Ranking) Rank --&gt; Budget{Token 预算检查} subgraph Sources User[用户指令] Files[加载的文件] Term[终端输出流] end Sources --&gt; Input Budget -- 溢出 --&gt; Compress[智能压缩 Compression] Budget -- 充足 --&gt; Final[构建 Context] Compress --&gt; Final Compress --&gt; A[截断头部/尾部] Compress --&gt; B[提取摘要] Compress --&gt; C[移除冗余日志] style Filter fill:#e1f5fe,stroke:#01579b style Compress fill:#fff9c4,stroke:#fbc02d 收集（Collection）：收集用户输入、终端历史输出、已通过 /add 加载的文件内容。 清洗（Filtering）：并非所有终端输出都是有用的。Context Engine 会自动识别并过滤掉冗余的进度条（Progress Bars）、ANSI 颜色代码、无效的报错堆栈或重复的日志行。 压缩（Compression）： 智能截断：对于超长文件，它只保留头部和尾部，中间用摘要或 ... 代替。 滚动摘要：当对话轮次过多时，早期的对话会被“垃圾回收”，只保留一个高层级的摘要（Summary），而丢弃具体的对话细节。 Claude Code 并不总是填满 200k 的窗口。为了保持响应速度和降低 API 成本，Context Engine 会动态调整上下文大小。这就是为什么有时候你觉得它“忘了”刚才具体的代码行——因为那部分信息被判定为“低优先级”而被丢弃了。 核心命令解析与策略 理解了 Context Engine，你就知道为什么要使用以下命令： /compact：强制触发压缩垃圾回收。这不仅是清理屏幕，更是告诉 Context Engine：“之前的细节不再重要，只保留结论。”当你结束了一个功能的开发，准备开始下一个功能时，务必执行此命令。 /clear : 格式化大脑。当任务上下文严重漂移（Drift），或者模型开始胡言乱语时，这是唯一的挽救手段。它会清空所有历史记忆，只保留加载的文件。 /omit：显式遗忘。告诉引擎忽略某个不再相关的文件，释放宝贵的 Token 空间。 Prompt System 如果说 Context Engine 是负责整理素材的管理员，那么 Prompt System 就是总导演。它负责将管理员提供的素材，组装成 LLM 能听懂的“剧本”。 Prompt 的解剖学 Claude Code 发送给模型的 Prompt 并不是简单的”用户说的话”，而是一个分层的”三明治结构”。每一层都有其特定的目的和权重： Prompt System 的分层结构示意图 classDiagram class FinalPrompt { +System Prompt (底层规则) +Context Layer (动态知识) +Current Turn (当前任务) } class SystemPrompt { +Persona: \"资深工程师\" +Tool Specs: \"grep, ls, edit...\" +Safety Rules: \"禁止 rm -rf /\" +Environment: \"Win32, Node v20\" } class ContextLayer { +Project Structure (File Tree) +File Contents (Active Set) +Conversation History (Summary) } class CurrentTurn { +User Query +Tool Results (Output) } FinalPrompt *-- SystemPrompt FinalPrompt *-- ContextLayer FinalPrompt *-- CurrentTurn System Prompt（基石）： 高度（Altitude）：提示词应处于“正确的飞行高度”。既要提供足够的背景和目标（避免过于笼统），又要留出启发式推理的空间（避免过于僵化的指令）。 结构化（Structuring）：使用 XML 标签（如 &lt;background&gt;, &lt;instructions&gt;, &lt;constraints&gt;）或 Markdown 标题来划分区块，这比纯文本更有利于模型理解复杂的指令结构。 定义了工具的使用规范（”在运行危险命令前必须由用户确认…“）。 注入了当前的时间、操作系统环境、工作目录等元数据。 Context Layer（中间层）： 这里是 Context Engine 输送进来的弹药。 少样本提示 (Few-shot Examples)：与其列出所有边界情况，不如提供 2-3 个最具代表性的、规范的端到端范例。多样性比数量更重要。 包括被 &lt;file_content&gt; 标签包裹的代码片段。 Current Turn（顶层）： 用户的最新指令。 工具设计 (Tool Design)：高质量的 Agent 依赖高质量的工具。工具应该是： Token 高效：返回精炼的信息而非原始 HTML/日志。 自包含 (Self-contained)：减少工具间的逻辑依赖。 参数明确：避免模棱两可的输入描述。 工具输出的隐形陷阱 当你让 Claude 运行 cat access.log 这样可能产生巨大输出的命令时，Prompt System 会面临巨大压力。如果输出超过 Token 限制，Prompt System 会强制截断，导致模型看到的信息不完整，从而产生幻觉。 永远建议使用 grep、head 或 tail 来预处理数据，而不是让 LLM 肉眼检索海量日志！ 两者的博弈与协作 理解这两个系统如何协作，能帮你写出更好的指令。我们来看一个典型的 Debug 场景： 场景：Debug 一个服务器启动失败的问题 sequenceDiagram autonumber actor User participant Engine as Context Engine participant Prompt as Prompt System participant LLM User-&gt;&gt;Engine: 输入 \"debug server.js\" Engine-&gt;&gt;Engine: 检索 server.js 内容 Note right of Engine: 文件较小，完整保留 Engine-&gt;&gt;Prompt: 注入 file_content Prompt-&gt;&gt;LLM: 组装 Prompt LLM-&gt;&gt;User: 思考: \"决定运行 npm test\" User-&gt;&gt;Engine: (自动执行) npm test Engine-&gt;&gt;Engine: 捕获输出: 5000行日志 Note right of Engine: 警报！输出过长 Engine-&gt;&gt;Engine: 截断中间4800行 Engine-&gt;&gt;Prompt: 注入 [Truncated] 标记的日志 Prompt-&gt;&gt;LLM: 发送截断后的上下文 LLM-&gt;&gt;User: \"日志被截断了，请帮我 grep 一下 'Error' 关键字\" 在这个过程中，你可以看到： Context Engine 保护了 Token 预算，防止 5000 行日志撑爆模型。 Prompt System 诚实地告诉模型“信息不全”，促使模型请求用户协助，而不是瞎猜。 如何利用这个机制？ 当你知道某个文件很重要，但不想让它被 Context Engine 压缩时，可以在对话中明确引用它。 ❌ 模糊指令：“帮我改下那个配置。”（Context Engine 可能会给予低权重） ✅ 精确指令：“请仔细阅读 config/app.json 的第 20-50 行，特别是 database 部分。”（这会给 Prompt System 一个强信号，提升该片段的权重） 进阶：上下文工程设计模式 掌握了基础原理后，我们可以借鉴 AI Agent 开发中的高级模式，将这些思想应用到我们日常使用 Claude Code 的工作流中。 子智能体架构 在复杂的编码任务中，试图在一个 Session 里解决所有问题是导致“上下文腐烂”的元凶。更高效的做法是模仿主智能体-子智能体模式： 主控模式 (Coordinator)：负责整体规划。例如，在根目录分析 README.md 和架构文档，生成一个任务列表。 执行模式 (Worker)：针对具体的子任务（如“重构 Auth 模块”），开启一个新的 Session（使用 /clear 或重启），只加载与 Auth 相关的文件。 汇报模式 (Reporter)：任务完成后，将结果压缩成一个简短的总结（Summary），带回给主控模式。 操作口诀：大局规划用全景，具体实施用特写，切忌混为一谈。 外部记忆与结构化笔记 LLM 的上下文是易失的内存（RAM），而你的文件系统是持久的硬盘（Disk）。不要让 LLM 仅仅在对话历史中“记住”重要的决定。 Spec-First Development (文档驱动开发)：在写代码前，先让 Agent 创建一个 PLAN.md 或 SPEC.md。 Context Offloading (记忆卸载)：当对话进行到一半，发现上下文开始混乱时，要求 Agent：“把我们目前的共识和下一步计划更新到 PLAN.md 中”，然后执行 /compact 或 /clear。 这样，PLAN.md 就充当了外部记忆，即使上下文被清空，Agent 也能通过读取该文件迅速恢复状态。 即时上下文 (Just-in-Time Context) 人类工程师不会在写代码时把整个 GitHub 仓库都背下来，我们会按需查找。同样的，不要预先加载整个文件夹。 Search &gt; Read：善用 grep 和 ls。先让 Agent 搜索关键词，定位到具体的文件路径，再 /add 那个特定的文件。 Progressive Disclosure (渐进式披露)：只给 Agent 解决当前这一步所需的最小信息集。 有意识的上下文压缩 在高级上下文工程中，我们推荐一种“呼吸式”开发流。不要试图一口气从头写到尾，而是根据任务节奏主动重置上下文。 典型的三段式工作流： 研究阶段 (Research)： 上下文状态：加载大量文档、grep 搜索日志、查看多个源文件。 目标：理解问题根因。 结束动作：当搞清楚逻辑后，要求 Claude 总结结论，然后 /clear。 计划阶段 (Plan)： 上下文状态：只加载第一阶段的结论和受影响的核心代码。 目标：编写 PLAN.md。 结束动作：确认计划无误后，执行 /compact。 实施阶段 (Implement)： 上下文状态：加载 PLAN.md 和需要修改的具体文件。 目标：编码与测试。 结束动作：完成一个模块后，再次 /clear 进入下一个循环。 这种流派的核心在于：通过频繁的主动重置，始终保持上下文的“低熵”状态。 手动挡驾驶 虽然 Claude Code 的自动挡很方便，但真正的“老司机”都懂得适时切换到手动挡。 显式上下文注入 (Prompt Injection) 不要依赖它“应该”知道。如果是一个它从未见过的库，手动提供上下文： &gt; /add docs/api_reference.md # 显式加载文档 &gt; 基于 api_reference.md 中的 Auth 章节，帮我重写 login 函数。 避免上下文污染 当你做完前端的工作，转去写后端 SQL 时，之前的 React 组件代码就是噪音 (Context Hygiene)。它们不仅浪费 Token，还可能干扰模型的判断（例如混淆 JS 和 SQL 的语法）。 最佳实践流程： 完成阶段性任务：前端页面写完了。 清理现场：/remove src/components/* （或者直接 /clear）。 固化记忆：/compact （将之前的改动压缩成一句话摘要）。 加载新环境：/add database/schema.sql。 开始新任务：“现在根据 schema 编写查询接口。” Token 计费机制与技术原理 了解 Claude Code 的计费机制，能让我们更加高效地使用这个工具。让我们深入探讨一下后台的技术原理。 Tokenization（分词）：文本到数学的转换 当您输入文本时，Claude Code 首先进行 Tokenization： flowchart TD Text[文本输入] --&gt; Tokenizer[Tokenizer分词] Tokenizer --&gt; TokenID[Token ID] TokenID --&gt; Embedding[嵌入层转换] Embedding --&gt; Vector[向量表示] Vector --&gt; TensorStack[堆叠成张量] TensorStack --&gt; ModelProcessing[模型处理] style Text fill:#e1f5fe style Tokenizer fill:#fff9c4 style Embedding fill:#f1f8e9 style Vector fill:#ffebee style ModelProcessing fill:#f3e5f5 为什么中文比英文费用高？ 这是由于中文的 Tokenization 特性决定的： 英文：”Hello world” → 2个Token 中文：”你好世界” → 4个Token 中文每个汉字通常对应两个Token，而英文每个单词通常只占用一个Token。这导致相同意思的表达，中文需要更多的Token，从而产生更高的计算成本。 计费机制详解 免费部分（本地处理）： Context Engine 的权重分析 Prompt System 的构建过程 文件内容的本地处理 终端显示和工具调用 计费部分（API调用）： 发送到 Claude API 的完整Prompt内容 模型的内部思考过程（reasoning） 响应内容的生成 技术栈深度解析 Token：文本的基本单位 向量：Token 的数学化表示（512-4096维） 张量：批量处理的多维数组 每个Token都会转换为向量参与复杂的张量运算，这直接决定了计算成本和性能。 最佳实践建议 避免高成本操作： # ❌ 应避免 &gt; cat huge_log_file.log # 会产生巨大Token消耗 &gt; /add entire_project_directory/ # 加载太多不相关文件 &gt; 过于完整的中文描述... # 中文Token效率低 推荐低成本操作： # ✅ 推荐使用 &gt; grep \"error\" logfile | head -20 # 免费本地预处理 &gt; /add specific_file.js:30-50 # 精准加载 &gt; 使用英文术语和简洁表达 # Token效率高 经济学原理 这不是”歧视”中文，而是技术限制的自然结果： 计算公平性：Token数量反映实际的计算工作量 资源消耗：更多Token = 更多GPU计算 = 更高成本 语言特性：中文信息密度高，但Token效率低 通过理解这些技术原理，我们可以更加智能地使用 Claude Code，在保持高质量输出的同时最大限度控制成本。 总结 Claude Code 不仅仅是一个 Chatbot，它是一个以 LLM 为核心的操作系统。 Context Engine 帮我们省钱、省脑子，处理繁杂的信息流。 Prompt System 帮我们规范化输入、提升执行力，确保模型听得懂指令。 学会在这两个系统之间跳舞，你就不再是被 AI 带着走的用户，而是驾驭 AI 的指挥官。 下一篇预告：Claude Code 实战：使用 Hooks 自动化你的工作流 - 学习如何配置 Pre-command 和 Post-command 钩子。" }, { "title": "Claude Code(二)环境配置", "url": "/posts/claude-code-config/", "categories": "AI, Claude Code", "tags": "AI, CLI Agent, Configuration", "date": "2026-01-10 17:21:00 +0800", "content": "配置体系概览 Claude Code 并非一个简单的 CLI 工具，它内置了一套企业级的多层级配置架构。这套架构的设计初衷是解决“个人偏好”与“团队规范”之间的矛盾，同时平衡“灵活性”与“安全性”。 通过全局设置、项目级配置及环境变量的组合，开发者可以精准控制 Agent 的行为模式（Behavior）、权限边界（Permissions）与上下文记忆（Memory）。 作用域系统 (Scope System) 作用域 (Scope) 是配置生效的逻辑边界。Claude Code 采用了类似于 CSS 的“层叠样式表”机制，配置项会按照特定的优先级由上至下覆盖。这种设计确保了企业安全策略的强制性，同时赋予了开发者在本地调试时的灵活性。 作用域 配置文件位置 逻辑定义 是否同步 (Git) 典型应用场景 Managed (管理级) 系统级目录 强制约束 是 (IT 部署) 企业统一的安全红线。例如：强制禁止访问生产数据库，强制开启审计日志。此层级普通用户无法修改。 User (用户级) ~/.claude/ 个人偏好 否 跨项目的通用习惯。例如：默认开启思维链模式，配置个人的 GitHub Token，安装常用的辅助插件。 Project (项目级) 项目根目录 .claude/ 团队规范 是 团队共享的“法律法规”。例如：统一的代码格式化命令，项目专属的 MCP 服务器配置，团队共用的 Lint 规则。 Local (本地级) .claude/*.local.* 临时环境 否 (Git 忽略) 仅针对当前机器的特定配置。例如：本地数据库的连接串，临时调试用的 API Key，或者为了绕过某个 Bug 的临时权限提升。 最佳实践 - 配置隔离: 始终遵循“配置隔离”原则。将涉及机密凭证（Credentials）的配置严格限制在 User 或 Local 作用域；将涉及工程规范（Standards）的配置显式提交到 Project 作用域。 核心机制：层叠与冲突解决 当同一个配置项在多个作用域中同时存在时，Claude Code 遵循 “Specific Overrides General” (具体覆盖通用) 的原则，但受限于 Managed 层的强制管控。 优先级链条：Managed (最高) &gt; Command Line Flags &gt; Local &gt; Project &gt; User (最低) 这意味着： 你在命令行指定的参数（如 --model）优先级极高，适合临时测试。 你的 Local 配置可以覆盖团队的 Project 配置（例如团队要求用 Python 3.9，你在本地测试 Python 3.10）。 任何配置都无法突破 Managed 层的限制（如果 IT 部门禁止了 rm 命令，你在本地怎么配置都无效）。 功能模块分布 配置系统不仅管理键值对，还管理着 Agent 的扩展能力和记忆： 功能模块 用户级 (User) 项目级 (Project) 本地级 (Local) Settings (行为) ~/.claude/settings.json .claude/settings.json .claude/settings.local.json Subagents (能力) ~/.claude/agents/ .claude/agents/ — MCP Servers (连接) ~/.claude.json .mcp.json ~/.claude.json (项目状态缓存) Memory (认知) ~/.claude/CLAUDE.md CLAUDE.md 或 .claude/CLAUDE.md CLAUDE.local.md 核心配置文件详解 Claude Code 的“大脑”由三个核心部分组成：Settings (控制中枢)、Memory (长期记忆) 和 MCP (外部手脚)。 1. Settings.json：控制 settings.json 定义了 Claude Code 的运行规则。它不关心你的代码业务逻辑，只关心 Agent 本身如何运作。 Permissions (权限模型): 采用“最小权限原则 (Least Privilege)”。 allow: 明确放行的命令白名单。 deny: 绝对禁止的高危操作（如读取 .env，上传私钥）。 ask: 需要人工审批的敏感操作（默认策略）。 Sandbox (沙箱环境): 强烈建议开启。启用后，Bash 工具将在隔离的容器化环境中运行。这不仅防止了误删系统文件，还保证了环境的一致性（Reproducibility）。 Hooks (生命周期钩子): 类似于 Git Hooks。 PreToolUse: 在工具执行前拦截，可用于强制 Lint 检查。 PostToolUse: 工具执行后触发，可用于自动化测试反馈。 示例：构建一个安全的开发环境 { \"permissions\": { \"allow\": [\"Bash(npm run *)\", \"Bash(git status)\", \"Bash(ls)\"], \"deny\": [\"Read(.env)\", \"Bash(curl -X POST *)\"], \"ask\": [\"Edit(package.json)\"] }, \"sandbox\": { \"enabled\": true, \"timeout\": 300 }, \"autoUpdater\": { \"enabled\": false } } 覆盖逻辑细节：权限系统的合并策略是 “Restrictive Merge” (收敛合并)。如果在 User 层允许了 curl，但在 Project 层禁止了 curl，最终结果是禁止。安全限制总是优先于许可。 2. CLAUDE.md：上下文 如果说 settings.json 是大脑的结构，那么 CLAUDE.md 就是大脑中的知识。它是 Claude Code 最独特的特性之一，充当了项目级系统提示词 (System Prompt) 的角色。 它与传统文档的区别在于：它是写给 AI 看的，不是给通过人看的。 构建指令: 并不是让 AI 去猜，而是明确告诉它：“在这个项目里，运行测试必须用 make test-unit，而不是 npm test。” 架构约束: 明确“负面约束”。例如：“禁止引入新的 npm 依赖，除非经过批准”、“UI 组件必须与逻辑 Hook 分离”。 风格指南: 统一代码风格，减少 Code Review 的摩擦。 3. MCP Servers：能力 通过 .mcp.json，Claude Code 利用 Model Context Protocol (MCP) 协议打破了文件系统的物理隔离。它允许 Claude 连接到： GitHub/GitLab: 直接读取 Issue 内容或 PR 评论。 PostgreSQL/MySQL: 在只读权限下查询数据库 Schema，辅助编写 SQL。 Browser: 实时抓取网页文档库。 记忆系统工作原理 Memory 机制是 Claude Code 区别于普通 Copilot 的核心。它通过结构化上下文注入，让 AI 获得“项目感”。 渐进式披露 (Progressive Disclosure) 为了解决 LLM 上下文窗口有限（Context Window Limit）的问题，Claude Code 设计了渐进式披露算法。它不会笨拙地把整个硬盘的文件都塞进 Prompt，而是根据你当前的工作目录 (CWD) 动态加载相关的记忆。 算法逻辑： 定位: 确定当前 Shell 所在的路径。 回溯: 从当前路径向上冒泡至根目录，收集沿途所有的 CLAUDE.md。 合并: 将收集到的 Markdown 文件按“子目录优先”的顺序合并。 注入: 将合并后的文本作为 System Context 的一部分发送给模型。 场景演示： /workspace/ ├── CLAUDE.md # [Layer 1] 全局规范：Java 项目通用配置 └── services/ ├── payment-service/ │ ├── CLAUDE.md # [Layer 2] 服务规范：支付网关接口定义 │ └── src/ └── user-service/ └── CLAUDE.md # [Layer 2] 服务规范：用户数据隐私标准 当你 cd services/payment-service 后，Claude 脑子里装的是 Layer 1 + Layer 2 (Payment)。它完全不知道 User Service 的隐私标准，这完美避免了上下文污染，并节省了 Token。 动态维护 记忆不是静态的。 /init: 智能脚手架。分析 package.json 等元数据，自动生成“第一份记忆”。 /memory: 热更新。当你在对话中纠正了 Claude 的一个错误（比如“不要用 Log4j，用 SLF4J”），应该立即使用 /memory 将这条规则写入文件。这实现了从“纠正”到“教会”的质变。 环境变量与模型调优 环境变量 (Env Vars) 环境变量不仅用于鉴权，还用于微调 Runtime 行为： ANTHROPIC_API_KEY: 必须。 BASH_DEFAULT_TIMEOUT_MS: 调整 Shell 命令的“耐心值”。对于大型编译任务，建议调大此值。 CLAUDE_LOG_LEVEL: 设置为 debug 可查看详细的 Prompt 交互日志，用于排查为何 Claude “不听话”。 思维扩展 (Extended Thinking) Claude 3.7+ 引入的 Thinking Mode 本质上是用时间换质量。 原理: 模型在输出最终代码前，会先生成一段隐藏的思维链（Chain of Thought），自我审视逻辑漏洞。 适用场景: 复杂的重构、算法设计、涉及多个文件联动的修改。 不适用场景: 简单的语法修正、文档补全（不仅慢，而且浪费 Token）。 高效协作技巧 1. 结构化需求 (Structured Prompting) 把 Claude 当作一名高级工程师，而非搜索引擎。使用 DOD (Definition of Done) 清单： “请实现用户登录功能。” (❌ 弱指令) “请实现用户登录 API，要求如下： 接口: POST /api/login，接收 JSON。 验证: 使用 Zod 进行 Schema 校验。 安全: 密码必须使用 Argon2 哈希。 测试: 编写对应的 Vitest 单元测试。 规范: 遵循 @docs/api-guide.md 中的错误码定义。” (✅ 强指令) 2. 模块化引用 (@References) CLAUDE.md 的 @ 语法支持引用文件，这实际上构建了一个知识超链接系统。 @package.json: 告诉 Claude 当前项目的依赖版本。 @src/types.ts: 告诉 Claude 全局的数据结构定义。 善用引用，可以让 Claude 在不读取整个文件的情况下，精准获取关键上下文。 结语：从“工具”进阶为“队友” 配置 Claude Code 的过程，本质上是一个对齐上下文 (Context Alignment) 的过程。不要被看似复杂的参数吓倒，你可以通过以下三个阶段轻松上手： 起步 (Start)：运行 /init 生成基础配置，让 Claude 知道“怎么跑通代码”。 调优 (Iterate)：当 Claude 犯错（如使用了错误的库或风格）时，不要仅在对话中纠正，而是立刻更新 CLAUDE.md。这能让错误“仅发生一次”。 定界 (Bound)：随着信任加深，通过 settings.json 逐步放开必要的权限，同时守住安全红线。 学好这套配置体系，你将获得什么？ 零启动成本：每次开启新会话，Claude 都已“这就位”，无需重复啰嗦项目背景。 一致性交付：产出的代码不再是通用的“网帖风格”，而是完美契合你团队规范的“原生代码”。 心流体验：你将不再把时间浪费在解释“如何做 (How)”上，而是专注于决策“做什么 (What)”。 这就是从“使用 AI 工具”到“拥有 AI 队友”的质变。 下一篇预告：Claude Code(三)环境配置-了解Claude Code如何管理上下文，了解如何节省token" }, { "title": "Claude Code(一)介绍与安装", "url": "/posts/claude-code-introduction/", "categories": "AI, Claude Code", "tags": "AI, CLI Agent", "date": "2026-01-10 16:21:00 +0800", "content": "Claude Code是什么 Claude Code 是 Anthropic 推出的基于 CLI（命令行界面）的下一代 AI 编程助手。不同于传统的 IDE 插件，它作为一个独立的 Agent 运行在终端中，能够直接访问本地文件系统、执行 Shell 命令、管理 Git 版本控制，并理解整个代码库的上下文结构。我从2024年9月开始一直是重症患者般地使用Cursor IDE，直到2025年12月底才真正认识到CLI Agent的威力。 它不只是在帮我写代码，而是在”代理”我进行开发。我可以直接告诉它”修复这个报错”或者”重构这个模块”，它会自动分析报错信息、定位文件、修改代码、运行测试验证，直到问题解决。 flowchart TD A[用户指令] --&gt; B[分析需求并制定计划] B --&gt; C[执行相应操作] C --&gt; D[进行验证与调整] D --&gt; E[交付最终结果] C -.-&gt;|git commit| F[版本控制] C -.-&gt;|npm install| G[包管理] C -.-&gt;|pytest| H[测试执行] style A fill:#e1f5fe style E fill:#f1f8e9 Claude Code的核心能力 虽然官方文档把它描述成agentic coding tool，它不仅具有强大的编码能力，还能理解整个项目上下文、自主执行终端命令、Git操作、调用外部工具。甚至基于多模态大模型，可以干非常非常多的事，比如图片识别、生图、语音交互等等。 功能场景 具体表现 核心价值 全项目理解 能够通过 ls, grep, glob 等工具自主探索文件结构，阅读代码依赖，分析配置文件。 它的上下文不仅限于我打开的文件，而是整个工程的架构逻辑。 终端自主权 可以直接执行 Bash 命令，包括安装依赖 (npm install)、运行构建 (make build)、执行测试 (pytest)。 打通了”编写代码”到”验证代码”的闭环，拥有了执行力。 任务规划 面对复杂需求（如”重构认证模块”），能拆解为多个步骤（Plan -&gt; Act -&gt; Verify），并维护任务列表。 具备了初级工程师的思维链（Chain of Thought）和自主纠错能力。 版本控制集成 理解 Git 状态，能查看 git diff，分析变更，甚至帮我撰写 Commit Message 和提交代码。 将开发流程整合到了单一的对话流中，无需频繁切换窗口。 与Cursor的区别 Cursor 的本质依然是一个极其强大的 IDE 编辑器（Fork 自 VS Code），它的优势在于无缝的编辑器体验，通过 Copilot++ 极其顺滑地预测我的下一个按键，或者通过 Composer 窗口进行多文件编辑。它的核心交互依然离不开”光标”和”编辑器窗口”，就像一个坐在旁边的副驾驶。 相比之下，Claude Code 彻底抛弃了 GUI 的束缚。我不再是操作一个编辑器，而是在与一个拥有 Shell 权限的 AI 结对编程。Cursor 擅长”写”（Writing），而 Claude Code 擅长”做”（Doing）。Cursor 适合在这个文件里快速实现一个函数，而 Claude Code 适合在整个项目中从头搭建一个功能或修复一个棘手的跨文件 Bug。 维度 Cursor (IDE + AI) Claude Code (CLI Agent) 核心形态 基于 VS Code 的定制编辑器 运行在终端的命令行工具 交互逻辑 补全(Tab)、聊天(Cmd+L)、内联编辑(Cmd+K) 对话式指令 (Prompt -&gt; Action -&gt; Result) 上下文范围 打开的文件、引用的代码块、向量索引 整个文件系统、终端输出、Git 历史 操作权限 主要是读写文件 读写文件 + 执行任意系统命令 适用场景 快速编码、浏览代码、即时修改 复杂重构、Debug调试、自动化脚本编写、脚手架生成 思维模式 辅助驾驶 (Copilot) 代理执行 (Agent) quadrantChart title \"AI编程工具位置对比\" x-axis \"代码编写\" --&gt; \"项目执行\" y-axis \"局部优化\" --&gt; \"全局管理\" \"Cursor\": [0.2, 0.8] \"Claude Code\": [0.8, 0.2] \"GitHub Copilot\": [0.3, 0.3] \"Tabnine\": [0.1, 0.1] 安装 官方提供了多种安装途径，但强烈建议选择 Native Install（原生安装脚本）。相比于常见的 npm install -g，原生安装包内置了独立的运行时环境，彻底避免了因本地 Node.js 版本差异导致的各种诡异报错，且升级维护更加稳定。 # 官方推荐的安装命令（示例） curl -sL https://code.claude.com/install.sh | bash 由于众所周知的网络原因，在国内网络环境下安装或使用时，大概率会遇到连接超时或区域限制的问题。 仅仅开启系统代理软件（VPN）往往是不够的，终端（Terminal）的流量默认可能不走系统代理。强烈建议在 Shell 中显式 export 代理变量，否则安装和使用过程中会频发连接超时错误。 通常需要在终端显式声明代理环境变量，确保流量正确转发： # 替换为自己的代理端口，通常是 7890 或 10808 export https_proxy=http://127.0.0.1:7890 export http_proxy=http://127.0.0.1:7890 模型配置 Anthropic 原生模型 (Claude 4.5 Sonnet) 这是 Claude Code 的默认且最佳体验配置。直接登录即可使用，无需复杂设置，原生支持开箱即用。 OpenAI (GPT-5.x) 虽然可以通过适配层使用 GPT-4o，但实际使用下来的感受是：模型定价太贵了，我用不起啊。对于高频的 Agent 交互来说，成本控制是不得不考虑的因素。 DeepSeek (V3.1) 国内之光 DeepSeek 也是很多人的首选。在配置时，通常需要指向兼容 OpenAI 格式的端点。实测下来，deepseek-v3.1能满足基本代码分析需求，可以分析定位常见bug，太极端的需求有点吃力，毕竟在长上下文和复杂逻辑推理上，Claude 4.5 Sonnet 依然是目前的TOP。 xAI Grok (Grok 4.1 Fast) + LiteLLM 这是一个非常有趣的非官方方案。由于 Grok 的 API 格式不兼容 Anthropic 标准，我们需要引入 LiteLLM 作为中间代理。 我现在就是用的这套方案，可以胜任95%以上的编码任务，只是litellm毕竟是代理转发工具，有很多参数是不支持的，有一定局限性。尽管如此，Grok 的推理速度和代码直觉令人印象深刻。 Google Gemini 3 (Pro/Flash) + LiteLLM 理论上 Gemini 的超长上下文非常适合全库分析，但现阶段通过 LiteLLM 接入的体验非常糟糕，gemini的很多参数都没有支持上，经常报错:invalide agument,非常不推荐，但是我自己又特别喜欢Gemini3系列模型，pro性能强悍flash价格诱人。只能期待后续工具链的完善了。 不推荐任何代理也不推荐OpenCode(至少目前)，体验太差，tooluse、webfetch、vision等功能由于各模型的协议格式没有一个统一标准，agent代理工具没有做到很好的适配，基本只能作为自然语言模型进行文本类工作 Anthropic 的风控极其严格，大陆及港澳地区 IP 直连会被立即封号，且申诉极难通过。请务必确保你的终端流量走在靠谱的海外节点上，并保持网络环境稳定。 使用 在终端中进入你的项目根目录，只需输入简单的命令即可唤醒这个强大的助手： claude 首次运行时，它会花一点时间对当前目录进行索引（Indexing），建立对项目结构的大局观。这个过程非常快，且索引完全在本地构建。一旦就绪，你就进入了一个交互式的 REPL（Read-Eval-Print Loop）环境，可以像和同事聊天一样与你的代码库对话。 Claude Code 具有执行终端命令的权限（如 rm, git push）。虽然它在执行敏感操作前会请求批准，但在授予权限（输入 y）之前，请务必阅读它打算执行的命令，避免误删文件。 工作流示范 参考官方的最佳实践，以下是两种最能体现 Claude Code 价值的经典工作流： 沉浸式代码探索 (Exploration) 当你接手一个遗留项目或面对复杂的开源库时，传统的做法是手动翻阅文件，试图在脑海中构建依赖关系图。而在 Claude Code 中，你可以直接提问： &gt; \"请解释一下 `auth` 模块的认证流程是如何实现的？\" &gt; \"找出所有使用了 `User` 模型的地方，并检查是否有潜在的类型安全问题。\" 它会自动运行 grep、阅读相关文件、分析引用关系，最后给出一份详尽的分析报告。这不仅是搜索，更是理解。 交互式重构与修复 (Refactoring &amp; Fixing) 这是 CLI Agent 最迷人的地方。你不再需要手动在一个个文件中复制粘贴。 &gt; \"运行测试，修复所有失败的用例。\" &gt; \"把 `src/utils` 下的大文件拆分成多个小的工具函数文件，并为它们补充单元测试。\" Claude Code 会生成一个执行计划（Plan），告诉你它准备读哪些文件、改哪些代码。在你批准后，它会像一个熟练的工程师一样，自动执行编辑、运行测试、根据报错再次修正代码，直到测试全部通过。你只需要扮演 “Tech Lead” 的角色进行 Code Review 和验收。 总结 Claude Code 的出现标志着 AI 辅助编程从”副驾驶”（Co-pilot）向”代理人”（Agent）的实质性跨越。如果说 Cursor 是让你写代码更爽的跑车，那么 Claude Code 就是能帮你自动驾驶的司机。尽管目前在模型成本和区域访问上仍有门槛，但它展示的终端自主权和全项目理解力，让我确信 CLI Agent 一定是走未来开发者的及其震撼人心的一步。从手动编码到指挥 AI 干活，我们的角色正在从 Coder 进化为 Manager。 下一篇预告：Claude Code(二)环境配置-了解Claude Code环境配置" }, { "title": "Claude Code学习总结：目录导航", "url": "/posts/claude-code-guide/", "categories": "AI, Claude Code", "tags": "AI, CLI Agent", "date": "2026-01-10 15:21:00 +0800", "content": "预览 从2024年9月开始，公司内部已经开始强推Cursor IDE，今年12月中公司做AI产品的部门分享了Claude Code CLI工程实践。听完之后就开始详细了解了Claude Code是如何使用，如何利用CLI Agent提升速度与效率。经过了大约20来天断断续续的学习使用，对Claude Code有了基本认知。现在开始梳理、细化、总结这个Agent工具使用的各个部分。 系列文章目录 文章导航 简介 Claude Code #1-介绍 如何安装、设置新项目、添加上下文 Claude Code #2-初始化配置 CLAUDE.md 文件与 /init Claude Code #3-上下文窗口 理解如何管理上下文，如何节省token Claude Code #4-hooks hooks能干什么，以及如何使用钩子 Claude Code #5-斜杠命令 创建自定义斜杠命令来简化工作流程 [Claude Code #6-Agent Skills] 介绍agent技能，如何使用 [Claude Code #7-Subagents] 使用专门的字AI处理特定任务的工作流程 [Claude Code #8-Plugins] 插件的介绍、使用、开发 [Claude Code #9-MCP服务] MCP服务配置、安装、使用 [Claude Code #10-思考与技巧] 克服空白瘫痪，不断向前演进 参考来源 参考资料(截至2016年1月)： 参考信息 简介 Claude Code docs Claude Code的官方文档 包含了所有的基本用法 Claude Code Github Claude Code官方仓库 不定时发布Claude Code重要更新说明 Claude Code tutorail 知名Youtube博主的入门教程 Claude Code handbbok 非常高质量的用AI学习并总结Claude Code的博客教程 prompts-tools 获得极高star的提示词工程学习仓库 ShareAI-learn-claude-code 获得非常高star的Claude Code学习仓库 Claude-Code-Infrastructure-Showcase 获得非常高star的Claude Code学习仓库 claude-code-templates 获得非常高star的Claude Code学习仓库 SuperClaude 值得肯定的Claude Code学习仓库 awesome-claude-code 收集了学习Claude Code一揽子仓库的仓库 下一篇预告：Claude Code(一)基本接扫-了解Claude Code如何管理上下文，了解如何节省token" }, { "title": "Customize the Favicon", "url": "/posts/customize-the-favicon/", "categories": "Blogging, Tutorial", "tags": "favicon", "date": "2019-08-11 00:34:00 +0800", "content": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons. Generate the favicon Prepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Pick your favicon image to upload your image file. In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Next → to generate the favicon. Download &amp; Replace Download the generated package, unzip and delete the following file(s) from the extracted files: site.webmanifest And then copy the remaining image files (.PNG, .ICO and .SVG) to cover the original files in the directory assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one. The following table will help you understand the changes to the favicon files: File(s) From Online Tool From Chirpy *.PNG ✓ ✗ *.ICO ✓ ✗ *.SVG ✓ ✗ ✓ means keep, ✗ means delete. The next time you build the site, the favicon will be replaced with a customized edition." }, { "title": "Getting Started", "url": "/posts/getting-started/", "categories": "Blogging, Tutorial", "tags": "getting started", "date": "2019-08-09 20:55:00 +0800", "content": "Creating a Site Repository When creating your site repository, you have two options depending on your needs: Option 1. Using the Starter (Recommended) This approach simplifies upgrades, isolates unnecessary files, and is perfect for users who want to focus on writing with minimal configuration. Sign in to GitHub and navigate to the starter. Click the Use this template button and then select Create a new repository. Name the new repository &lt;username&gt;.github.io, replacing username with your lowercase GitHub username. Option 2. Forking the Theme This approach is convenient for modifying features or UI design, but presents challenges during upgrades. So don’t try this unless you are familiar with Jekyll and plan to heavily modify this theme. Sign in to GitHub. Fork the theme repository. Name the new repository &lt;username&gt;.github.io, replacing username with your lowercase GitHub username. Setting up the Environment Once your repository is created, it’s time to set up your development environment. There are two primary methods: Using Dev Containers (Recommended for Windows) Dev Containers offer an isolated environment using Docker, which prevents conflicts with your system and ensures all dependencies are managed within the container. Steps: Install Docker: On Windows/macOS, install Docker Desktop. On Linux, install Docker Engine. Install VS Code and the Dev Containers extension. Clone your repository: For Docker Desktop: Start VS Code and clone your repo in a container volume. For Docker Engine: Clone your repo locally, then open it in a container via VS Code. Wait for the Dev Containers setup to complete. Setting up Natively (Recommended for Unix-like OS) For Unix-like systems, you can set up the environment natively for optimal performance, though you can also use Dev Containers as an alternative. Steps: Follow the Jekyll installation guide to install Jekyll and ensure Git is installed. Clone your repository to your local machine. If you forked the theme, install Node.js and run bash tools/init.sh in the root directory to initialize the repository. Run command bundle in the root of your repository to install the dependencies. Usage Start the Jekyll Server To run the site locally, use the following command: $ bundle exec jekyll serve If you are using Dev Containers, you must run that command in the VS Code Terminal. After a few seconds, the local server will be available at http://127.0.0.1:4000. Configuration Update the variables in _config.yml as needed. Some typical options include: url avatar timezone lang Social Contact Options Social contact options are displayed at the bottom of the sidebar. You can enable or disable specific contacts in the _data/contact.yml file. Customizing the Stylesheet To customize the stylesheet, copy the theme’s assets/css/jekyll-theme-chirpy.scss file to the same path in your Jekyll site, and add your custom styles at the end of the file. Customizing Static Assets Static assets configuration was introduced in version 5.1.0. The CDN of the static assets is defined in _data/origin/cors.yml. You can replace some of them based on the network conditions in the region where your website is published. If you prefer to self-host the static assets, refer to the chirpy-static-assets repository. Deployment Before deploying, check the _config.yml file and ensure the url is configured correctly. If you prefer a project site and don’t use a custom domain, or if you want to visit your website with a base URL on a web server other than GitHub Pages, remember to set the baseurl to your project name, starting with a slash, e.g., /project-name. Now you can choose ONE of the following methods to deploy your Jekyll site. Deploy Using Github Actions Prepare the following: If you’re on the GitHub Free plan, keep your site repository public. If you have committed Gemfile.lock to the repository, and your local machine is not running Linux, update the platform list of the lock file: $ bundle lock --add-platform x86_64-linux Next, configure the Pages service: Go to your repository on GitHub. Select the Settings tab, then click Pages in the left navigation bar. In the Source section (under Build and deployment), select GitHub Actions from the dropdown menu. Push any commits to GitHub to trigger the Actions workflow. In the Actions tab of your repository, you should see the workflow Build and Deploy running. Once the build is complete and successful, the site will be deployed automatically. You can now visit the URL provided by GitHub to access your site. Manual Build and Deployment For self-hosted servers, you will need to build the site on your local machine and then upload the site files to the server. Navigate to the root of the source project, and build your site with the following command: $ JEKYLL_ENV=production bundle exec jekyll b Unless you specified the output path, the generated site files will be placed in the _site folder of the project’s root directory. Upload these files to your target server." }, { "title": "Writing a New Post", "url": "/posts/write-a-new-post/", "categories": "Blogging, Tutorial", "tags": "writing", "date": "2019-08-08 14:10:00 +0800", "content": "This tutorial will guide you how to write a post in the Chirpy template, and it’s worth reading even if you’ve used Jekyll before, as many features require specific variables to be set. Naming and Path Create a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _posts of the root directory. Please note that the EXTENSION must be one of md and markdown. If you want to save time of creating files, please consider using the plugin Jekyll-Compose to accomplish this. Front Matter Basically, you need to fill the Front Matter as below at the top of the post: --- title: TITLE date: YYYY-MM-DD HH:MM:SS +/-TTTT categories: [TOP_CATEGORY, SUB_CATEGORY] tags: [TAG] # TAG names should always be lowercase --- The posts’ layout has been set to post by default, so there is no need to add the variable layout in the Front Matter block. Timezone of Date To accurately record the release date of a post, you should not only set up the timezone of _config.yml but also provide the post’s timezone in variable date of its Front Matter block. Format: +/-TTTT, e.g. +0800. Categories and Tags The categories of each post are designed to contain up to two elements, and the number of elements in tags can be zero to infinity. For instance: --- categories: [Animal, Insect] tags: [bee] --- Author Information The author information of the post usually does not need to be filled in the Front Matter , they will be obtained from variables social.name and the first entry of social.links of the configuration file by default. But you can also override it as follows: Adding author information in _data/authors.yml (If your website doesn’t have this file, don’t hesitate to create one). &lt;author_id&gt;: name: &lt;full name&gt; twitter: &lt;twitter_of_author&gt; url: &lt;homepage_of_author&gt; And then use author to specify a single entry or authors to specify multiple entries: --- author: &lt;author_id&gt; # for single entry # or authors: [&lt;author1_id&gt;, &lt;author2_id&gt;] # for multiple entries --- Having said that, the key author can also identify multiple entries. The benefit of reading the author information from the file _data/authors.yml is that the page will have the meta tag twitter:creator, which enriches the Twitter Cards and is good for SEO. Post Description By default, the first words of the post are used to display on the home page for a list of posts, in the Further Reading section, and in the XML of the RSS feed. If you don’t want to display the auto-generated description for the post, you can customize it using the description field in the Front Matter as follows: --- description: Short summary of the post. --- Additionally, the description text will also be displayed under the post title on the post’s page. Table of Contents By default, the Table of Contents (TOC) is displayed on the right panel of the post. If you want to turn it off globally, go to _config.yml and set the value of variable toc to false. If you want to turn off TOC for a specific post, add the following to the post’s Front Matter: --- toc: false --- Comments The global setting for comments is defined by the comments.provider option in the _config.yml file. Once a comment system is selected for this variable, comments will be enabled for all posts. If you want to close the comment for a specific post, add the following to the Front Matter of the post: --- comments: false --- Media We refer to images, audio and video as media resources in Chirpy. URL Prefix From time to time we have to define duplicate URL prefixes for multiple resources in a post, which is a boring task that you can avoid by setting two parameters. If you are using a CDN to host media files, you can specify the cdn in _config.yml. The URLs of media resources for site avatar and posts are then prefixed with the CDN domain name. cdn: https://cdn.com To specify the resource path prefix for the current post/page range, set media_subpath in the front matter of the post: --- media_subpath: /path/to/media/ --- The option site.cdn and page.media_subpath can be used individually or in combination to flexibly compose the final resource URL: [site.cdn/][page.media_subpath/]file.ext Images Caption Add italics to the next line of an image, then it will become the caption and appear at the bottom of the image: ![img-description](/path/to/image) _Image Caption_ Size To prevent the page content layout from shifting when the image is loaded, we should set the width and height for each image. ![Desktop View](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" } For an SVG, you have to at least specify its width, otherwise it won’t be rendered. Starting from Chirpy v5.0.0, height and width support abbreviations (height → h, width → w). The following example has the same effect as the above: ![Desktop View](/assets/img/sample/mockup.png){: w=\"700\" h=\"400\" } Position By default, the image is centered, but you can specify the position by using one of the classes normal, left, and right. Once the position is specified, the image caption should not be added. Normal position Image will be left aligned in below sample: ![Desktop View](/assets/img/sample/mockup.png){: .normal } Float to the left ![Desktop View](/assets/img/sample/mockup.png){: .left } Float to the right ![Desktop View](/assets/img/sample/mockup.png){: .right } Dark/Light mode You can make images follow theme preferences in dark/light mode. This requires you to prepare two images, one for dark mode and one for light mode, and then assign them a specific class (dark or light): ![Light mode only](/path/to/light-mode.png){: .light } ![Dark mode only](/path/to/dark-mode.png){: .dark } Shadow The screenshots of the program window can be considered to show the shadow effect: ![Desktop View](/assets/img/sample/mockup.png){: .shadow } Preview Image If you want to add an image at the top of the post, please provide an image with a resolution of 1200 x 630. Please note that if the image aspect ratio does not meet 1.91 : 1, the image will be scaled and cropped. Knowing these prerequisites, you can start setting the image’s attribute: --- image: path: /path/to/image alt: image alternative text --- Note that the media_subpath can also be passed to the preview image, that is, when it has been set, the attribute path only needs the image file name. For simple use, you can also just use image to define the path. --- image: /path/to/image --- LQIP For preview images: --- image: lqip: /path/to/lqip-file # or base64 URI --- You can observe LQIP in the preview image of post \"Text and Typography\". For normal images: ![Image description](/path/to/image){: lqip=\"/path/to/lqip-file\" } Social Media Platforms You can embed video/audio from social media platforms with the following syntax: {% include embed/{Platform}.html id='{ID}' %} Where Platform is the lowercase of the platform name, and ID is the video ID. The following table shows how to get the two parameters we need in a given video/audio URL, and you can also know the currently supported video platforms. Video URL Platform ID https://www.youtube.com/watch?v=H-B46URT4mg youtube H-B46URT4mg https://www.twitch.tv/videos/1634779211 twitch 1634779211 https://www.bilibili.com/video/BV1Q44y1B7Wf bilibili BV1Q44y1B7Wf https://www.open.spotify.com/track/3OuMIIFP5TxM8tLXMWYPGV spotify 3OuMIIFP5TxM8tLXMWYPGV Spotify supports some additional parameters: compact - to display compact player instead (ex. {% include embed/spotify.html id='3OuMIIFP5TxM8tLXMWYPGV' compact=1 %}); dark - to force dark theme (ex. {% include embed/spotify.html id='3OuMIIFP5TxM8tLXMWYPGV' dark=1 %}). Video Files If you want to embed a video file directly, use the following syntax: {% include embed/video.html src='{URL}' %} Where URL is a URL to a video file e.g. /path/to/sample/video.mp4. You can also specify additional attributes for the embedded video file. Here is a full list of attributes allowed. poster='/path/to/poster.png' — poster image for a video that is shown while video is downloading title='Text' — title for a video that appears below the video and looks same as for images autoplay=true — video automatically begins to play back as soon as it can loop=true — automatically seek back to the start upon reaching the end of the video muted=true — audio will be initially silenced types — specify the extensions of additional video formats separated by |. Ensure these files exist in the same directory as your primary video file. Consider an example using all of the above: {% include embed/video.html src='/path/to/video.mp4' types='ogg|mov' poster='poster.png' title='Demo video' autoplay=true loop=true muted=true %} Audio Files If you want to embed an audio file directly, use the following syntax: {% include embed/audio.html src='{URL}' %} Where URL is a URL to an audio file e.g. /path/to/audio.mp3. You can also specify additional attributes for the embedded audio file. Here is a full list of attributes allowed. title='Text' — title for an audio that appears below the audio and looks same as for images types — specify the extensions of additional audio formats separated by |. Ensure these files exist in the same directory as your primary audio file. Consider an example using all of the above: {% include embed/audio.html src='/path/to/audio.mp3' types='ogg|wav|aac' title='Demo audio' %} Pinned Posts You can pin one or more posts to the top of the home page, and the fixed posts are sorted in reverse order according to their release date. Enable by: --- pin: true --- Prompts There are several types of prompts: tip, info, warning, and danger. They can be generated by adding the class prompt-{type} to the blockquote. For example, define a prompt of type info as follows: &gt; Example line for prompt. {: .prompt-info } Syntax Inline Code `inline code part` Filepath Highlight `/path/to/a/file.extend`{: .filepath} Code Block Markdown symbols ``` can easily create a code block as follows: ``` This is a plaintext code snippet. ``` Specifying Language Using ```{language} you will get a code block with syntax highlight: ```yaml key: value ``` The Jekyll tag {% highlight %} is not compatible with this theme. Line Number By default, all languages except plaintext, console, and terminal will display line numbers. When you want to hide the line number of a code block, add the class nolineno to it: ```shell echo 'No more line numbers!' ``` {: .nolineno } Specifying the Filename You may have noticed that the code language will be displayed at the top of the code block. If you want to replace it with the file name, you can add the attribute file to achieve this: ```shell # content ``` {: file=\"path/to/file\" } Liquid Codes If you want to display the Liquid snippet, surround the liquid code with {% raw %} and {% endraw %}: {% raw %} ```liquid {% if product.title contains 'Pack' %} This product's title contains the word Pack. {% endif %} ``` {% endraw %} Or adding render_with_liquid: false (Requires Jekyll 4.0 or higher) to the post’s YAML block. Mathematics We use MathJax to generate mathematics. For website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by: --- math: true --- After enabling the mathematical feature, you can add math equations with the following syntax: Block math should be added with $$ math $$ with mandatory blank lines before and after $$ Inserting equation numbering should be added with $$\\begin{equation} math \\end{equation}$$ Referencing equation numbering should be done with \\label{eq:label_name} in the equation block and \\eqref{eq:label_name} inline with text (see example below) Inline math (in lines) should be added with $$ math $$ without any blank line before or after $$ Inline math (in lists) should be added with \\$$ math $$ &lt;!-- Block math, keep all blank lines --&gt; $$ LaTeX_math_expression $$ &lt;!-- Equation numbering, keep all blank lines --&gt; $$ \\begin{equation} LaTeX_math_expression \\label{eq:label_name} \\end{equation} $$ Can be referenced as \\eqref{eq:label_name}. &lt;!-- Inline math in lines, NO blank lines --&gt; \"Lorem ipsum dolor sit amet, $$ LaTeX_math_expression $$ consectetur adipiscing elit.\" &lt;!-- Inline math in lists, escape the first `$` --&gt; 1. \\$$ LaTeX_math_expression $$ 2. \\$$ LaTeX_math_expression $$ 3. \\$$ LaTeX_math_expression $$ Starting with v7.0.0, configuration options for MathJax have been moved to file assets/js/data/mathjax.js, and you can change the options as needed, such as adding extensions. If you are building the site via chirpy-starter, copy that file from the gem installation directory (check with command bundle info --path jekyll-theme-chirpy) to the same directory in your repository. Mermaid Mermaid is a great diagram generation tool. To enable it on your post, add the following to the YAML block: --- mermaid: true --- Then you can use it like other markdown languages: surround the graph code with ```mermaid and ```. Learn More For more knowledge about Jekyll posts, visit the Jekyll Docs: Posts." }, { "title": "Text and Typography", "url": "/posts/text-and-typography/", "categories": "Blogging, Demo", "tags": "typography", "date": "2019-08-08 11:33:00 +0800", "content": "Headings H1 — heading H2 — heading H3 — heading H4 — heading Paragraph Quisque egestas convallis ipsum, ut sollicitudin risus tincidunt a. Maecenas interdum malesuada egestas. Duis consectetur porta risus, sit amet vulputate urna facilisis ac. Phasellus semper dui non purus ultrices sodales. Aliquam ante lorem, ornare a feugiat ac, finibus nec mauris. Vivamus ut tristique nisi. Sed vel leo vulputate, efficitur risus non, posuere mi. Nullam tincidunt bibendum rutrum. Proin commodo ornare sapien. Vivamus interdum diam sed sapien blandit, sit amet aliquam risus mattis. Nullam arcu turpis, mollis quis laoreet at, placerat id nibh. Suspendisse venenatis eros eros. Lists Ordered list Firstly Secondly Thirdly Unordered list Chapter Section Paragraph ToDo list Job Step 1 Step 2 Step 3 Description list Sun the star around which the earth orbits Moon the natural satellite of the earth, visible by reflected light from the sun Block Quote This line shows the block quote. Prompts An example showing the tip type prompt. An example showing the info type prompt. An example showing the warning type prompt. An example showing the danger type prompt. Tables Company Contact Country Alfreds Futterkiste Maria Anders Germany Island Trading Helen Bennett UK Magazzini Alimentari Riuniti Giovanni Rovelli Italy Links http://127.0.0.1:4000 Footnote Click the hook will locate the footnote1, and here is another footnote2. Inline code This is an example of Inline Code. Filepath Here is the /path/to/the/file.extend. Code blocks Common This is a common code snippet, without syntax highlight and line number. Specific Language if [ $? -ne 0 ]; then echo \"The command was not successful.\"; #do the needful / exit fi; Specific filename @import \"colors/light-typography\", \"colors/dark-typography\"; Mathematics The mathematics powered by MathJax: [\\begin{equation} \\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6} \\label{eq:series} \\end{equation}] We can reference the equation as \\eqref{eq:series}. When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are [x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}] Mermaid SVG gantt title Adding GANTT diagram functionality to mermaid apple :a, 2017-07-20, 1w banana :crit, b, 2017-07-23, 1d cherry :active, c, after b a, 1d Images Default (with caption) Full screen width and center alignment Left aligned Float to left Praesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum. Float to right Praesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum. Dark/Light mode &amp; Shadow The image below will toggle dark/light mode based on theme preference, notice it has shadows. Image Gallery Test cases for the image gallery include. Basic 3-image gallery (using favicons for testing) Custom spacing and sizing Single image (edge case) Four images (responsive test) Video Reverse Footnote The footnote source &#8617;&#xfe0e; The 2nd footnote source &#8617;&#xfe0e;" } ]
