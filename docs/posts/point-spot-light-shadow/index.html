<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="自定义渲染管线:点光源与聚光灯阴影 (翻译十)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="为点光源和聚光灯添加实时阴影支持，使用透视投影渲染和采样阴影，并使用自定义立方体贴图。" /><meta property="og:description" content="为点光源和聚光灯添加实时阴影支持，使用透视投影渲染和采样阴影，并使用自定义立方体贴图。" /><link rel="canonical" href="www.damonc.top/posts/point-spot-light-shadow/" /><meta property="og:url" content="www.damonc.top/posts/point-spot-light-shadow/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/SRP/srp10/tutorial-image.jpg" /><meta property="og:image:alt" content="点光源和聚光灯阴影" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-06-30T18:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/SRP/srp10/tutorial-image.jpg" /><meta name="twitter:image:alt" content="点光源和聚光灯阴影" /><meta property="twitter:title" content="自定义渲染管线:点光源与聚光灯阴影 (翻译十)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2026-02-20T16:59:49+08:00","datePublished":"2020-06-30T18:00:00+08:00","description":"为点光源和聚光灯添加实时阴影支持，使用透视投影渲染和采样阴影，并使用自定义立方体贴图。","headline":"自定义渲染管线:点光源与聚光灯阴影 (翻译十)","image":{"lqip":"data:image/webp;base64,UklGRlAAAABXRUJQVlA4IEQAAAAwAwCdASoUAAoAP3Ggxli0q6gjsAgCkC4JYwAAg8QgnOLAAP7rqLsY75pUuE9Jmp7c5mLoK3TseCk73c9o7owtgAAAAA==","alt":"点光源和聚光灯阴影","url":"https://img.damonc.top/posts/SRP/srp10/tutorial-image.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/point-spot-light-shadow/"},"url":"www.damonc.top/posts/point-spot-light-shadow/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>自定义渲染管线:点光源与聚光灯阴影 (翻译十) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>自定义渲染管线:点光源与聚光灯阴影 (翻译十)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>自定义渲染管线:点光源与聚光灯阴影 (翻译十)</h1><p class="post-desc fw-light mb-4">为点光源和聚光灯添加实时阴影支持，使用透视投影渲染和采样阴影，并使用自定义立方体贴图。</p><div class="post-meta text-muted"> <span> Posted <time data-ts="1593511200" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jun 30, 2020 </time> </span> <span> Updated <time data-ts="1771577989" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 20, 2026 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/SRP/srp10/tutorial-image.jpg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/SRP/srp10/tutorial-image.jpg" alt="点光源和聚光灯阴影" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRlAAAABXRUJQVlA4IEQAAAAwAwCdASoUAAoAP3Ggxli0q6gjsAgCkC4JYwAAg8QgnOLAAP7rqLsY75pUuE9Jmp7c5mLoK3TseCk73c9o7owtgAAAAA=="></a><figcaption class="text-center pt-2 pb-2">点光源和聚光灯阴影</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/point-spot-light-shadow/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="8409 words" > <em>46 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">自定义渲染管线:点光源与聚光灯阴影 (翻译十)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">自定义渲染管线:点光源与聚光灯阴影 (翻译十)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>为点光源和聚光灯混合烘焙阴影和实时阴影。<li>添加第二个阴影图集。<li>使用透视投影渲染和采样阴影。<li>使用自定义立方体贴图。</ul><hr /><p>这是关于创建自定义可编程渲染管线系列教程的第十部分。它为点光源和聚光灯添加了实时阴影支持。</p><p>本教程使用 Unity 2019.4.1f1 制作，并升级到 2022.3.5f1。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/tutorial-image.jpg" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/tutorial-image.jpg" alt="100% 实时阴影。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">100% 实时阴影。</figcaption></figure><h2 id="聚光灯阴影"><span class="me-2">聚光灯阴影</span><a href="#聚光灯阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们首先为聚光灯添加实时阴影支持。我们将使用与方向光相同的方法，但会有一些变化。我们也会尽可能保持简单，使用均匀划分的阴影图集，并按照 Unity 提供的顺序填充有阴影的光源。</p><h3 id="阴影混合"><span class="me-2">阴影混合</span><a href="#阴影混合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>第一步是使烘焙阴影和实时阴影可以混合。修改 <code class="language-plaintext highlighter-rouge">Shadows</code> 中的 <code class="language-plaintext highlighter-rouge">GetOtherShadowAttenuation</code>，使其行为类似于 <code class="language-plaintext highlighter-rouge">GetDirectionalShadowAttenuation</code>，但它使用其他阴影数据并依赖于一个新的 <code class="language-plaintext highlighter-rouge">GetOtherShadow</code> 函数。新函数最初返回 1，因为其他光源还没有实时阴影。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetOtherShadow</span> <span class="p">(</span>
    <span class="n">OtherShadowData</span> <span class="n">other</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetOtherShadowAttenuation</span> <span class="p">(</span>
    <span class="n">OtherShadowData</span> <span class="n">other</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if !defined(_RECEIVE_SHADOWS)
</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="n">float</span> <span class="n">shadow</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">strength</span> <span class="o">*</span> <span class="n">global</span><span class="p">.</span><span class="n">strength</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="n">GetBakedShadow</span><span class="p">(</span>
            <span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">shadowMaskChannel</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">strength</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="n">GetOtherShadow</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">global</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="n">MixBakedAndRealtimeShadows</span><span class="p">(</span>
            <span class="n">global</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">shadowMaskChannel</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">strength</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>全局强度用于确定是否可以跳过实时阴影采样，原因可能是超出了阴影距离或位于最大级联球体之外。然而，级联仅适用于方向阴影。它们对其他光源没有意义，因为这些光源有固定位置，因此它们的阴影贴图不会随视图移动。话虽如此，以相同的方式淡出所有阴影是一个好主意，否则我们可能会在屏幕的某些区域没有方向阴影但有其他阴影。因此，我们对所有阴影使用相同的全局阴影强度。</p><p>我们必须处理的一个特殊情况是没有方向阴影但存在其他阴影的情况。当这种情况发生时，没有任何级联，因此它们不应影响全局阴影强度。我们仍然需要阴影距离淡入值。因此，让我们将设置级联计数和距离淡入的代码从 <code class="language-plaintext highlighter-rouge">Shadows.RenderDirectionShadows</code> 移到 <code class="language-plaintext highlighter-rouge">Shadows.Render</code>，并在适当的时候将级联计数设置为零。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalInt</span><span class="p">(</span>
        <span class="n">cascadeCountId</span><span class="p">,</span>
        <span class="n">shadowedDirLightCount</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">?</span> <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeCount</span> <span class="p">:</span> <span class="m">0</span>
    <span class="p">);</span>
    <span class="kt">float</span> <span class="n">f</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">-</span> <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeFade</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span>
        <span class="n">shadowDistanceFadeId</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
            <span class="m">1f</span> <span class="p">/</span> <span class="n">settings</span><span class="p">.</span><span class="n">maxDistance</span><span class="p">,</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">settings</span><span class="p">.</span><span class="n">distanceFade</span><span class="p">,</span>
            <span class="m">1f</span> <span class="p">/</span> <span class="p">(</span><span class="m">1f</span> <span class="p">-</span> <span class="n">f</span> <span class="p">*</span> <span class="n">f</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">//buffer.SetGlobalInt(cascadeCountId, settings.directional.cascadeCount);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVectorArray</span><span class="p">(</span>
        <span class="n">cascadeCullingSpheresId</span><span class="p">,</span> <span class="n">cascadeCullingSpheres</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVectorArray</span><span class="p">(</span><span class="n">cascadeDataId</span><span class="p">,</span> <span class="n">cascadeData</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalMatrixArray</span><span class="p">(</span><span class="n">dirShadowMatricesId</span><span class="p">,</span> <span class="n">dirShadowMatrices</span><span class="p">);</span>
    <span class="c1">//float f = 1f - settings.directional.cascadeFade;</span>
    <span class="c1">//buffer.SetGlobalVector(</span>
    <span class="c1">//    shadowDistanceFadeId, new Vector4(</span>
    <span class="c1">//        1f / settings.maxDistance, 1f / settings.distanceFade,</span>
    <span class="c1">//        1f / (1f - f * f)</span>
    <span class="c1">//    )</span>
    <span class="c1">//);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后我们必须确保在 <code class="language-plaintext highlighter-rouge">GetShadowData</code> 的级联循环之后，全局强度不会错误地设置为零。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_CascadeCount</span> <span class="o">&amp;&amp;</span> <span class="n">_CascadeCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="其他光源的实时阴影"><span class="me-2">其他光源的实时阴影</span><a href="#其他光源的实时阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>方向阴影有自己的图集贴图。我们将为所有其他有阴影的光源使用单独的图集，并单独计数。让我们使用最多十六个其他光源支持实时阴影。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">maxShadowedDirLightCount</span> <span class="p">=</span> <span class="m">4</span><span class="p">,</span> <span class="n">maxShadowedOtherLightCount</span> <span class="p">=</span> <span class="m">16</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxCascades</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">int</span> <span class="n">shadowedDirLightCount</span><span class="p">,</span> <span class="n">shadowedOtherLightCount</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">shadowedDirLightCount</span> <span class="p">=</span> <span class="n">shadowedOtherLightCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">useShadowMask</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这意味着我们可能会遇到启用了阴影但无法放入图集的光源。哪些光源不会获得阴影取决于它们在可见光源列表中的位置。我们只是不为那些失去资格的光源预留阴影，但如果它们有烘焙阴影，我们仍然可以允许使用这些。为此，首先重构 <code class="language-plaintext highlighter-rouge">ReserveOtherShadows</code>，使其在光源没有阴影时立即返回。否则，它会检查阴影遮罩通道——默认使用 -1——然后始终返回阴影强度和通道。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Vector4</span> <span class="nf">ReserveOtherShadows</span> <span class="p">(</span><span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">shadows</span> <span class="p">==</span> <span class="n">LightShadows</span><span class="p">.</span><span class="n">None</span> <span class="p">||</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span> <span class="p">&lt;=</span> <span class="m">0f</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="p">-</span><span class="m">1f</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">maskChannel</span> <span class="p">=</span> <span class="p">-</span><span class="m">1f</span><span class="p">;</span>
    <span class="c1">//if (light.shadows != LightShadows.None &amp;&amp; light.shadowStrength &gt; 0f) {</span>
        <span class="n">LightBakingOutput</span> <span class="n">lightBaking</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">bakingOutput</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">lightBaking</span><span class="p">.</span><span class="n">lightmapBakeType</span> <span class="p">==</span> <span class="n">LightmapBakeType</span><span class="p">.</span><span class="n">Mixed</span> <span class="p">&amp;&amp;</span>
            <span class="n">lightBaking</span><span class="p">.</span><span class="n">mixedLightingMode</span> <span class="p">==</span> <span class="n">MixedLightingMode</span><span class="p">.</span><span class="n">Shadowmask</span>
        <span class="p">)</span> <span class="p">{</span>
            <span class="n">useShadowMask</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">maskChannel</span> <span class="p">=</span> <span class="n">lightBaking</span><span class="p">.</span><span class="n">occlusionMaskChannel</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
            <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span>
            <span class="n">maskChannel</span>
        <span class="p">);</span>
    <span class="c1">//}</span>
    <span class="c1">//}</span>
    <span class="c1">//return new Vector4(0f, 0f, 0f, -1f);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在返回之前检查增加光源计数是否会超过最大值，或者该光源是否没有阴影可渲染。如果是，则返回负的阴影强度和遮罩通道，以便在适当的时候使用烘焙阴影。否则继续增加光源计数并设置tiled索引。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span>
    <span class="n">shadowedOtherLightCount</span> <span class="p">&gt;=</span> <span class="n">maxShadowedOtherLightCount</span> <span class="p">||</span>
    <span class="p">!</span><span class="n">cullingResults</span><span class="p">.</span><span class="nf">GetShadowCasterBounds</span><span class="p">(</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="k">out</span> <span class="n">Bounds</span> <span class="n">b</span><span class="p">)</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(-</span><span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="n">maskChannel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
    <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="n">shadowedOtherLightCount</span><span class="p">++,</span> <span class="m">0f</span><span class="p">,</span>
    <span class="n">maskChannel</span>
<span class="p">);</span>
</pre></table></code></div></div><h3 id="两个图集"><span class="me-2">两个图集</span><a href="#两个图集" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为方向阴影和其他阴影是分开的，我们可以对它们进行不同的配置。在 <code class="language-plaintext highlighter-rouge">ShadowSettings</code> 中为其他阴影添加一个新的配置结构和字段，只包含图集大小和过滤器，因为级联不适用。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">System</span><span class="p">.</span><span class="n">Serializable</span><span class="p">]</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">Other</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">MapSize</span> <span class="n">atlasSize</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">FilterMode</span> <span class="n">filter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">Other</span> <span class="n">other</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Other</span> <span class="p">{</span>
    <span class="n">atlasSize</span> <span class="p">=</span> <span class="n">MapSize</span><span class="p">.</span><span class="n">_1024</span><span class="p">,</span>
    <span class="n">filter</span> <span class="p">=</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">PCF2x2</span>
<span class="p">};</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/other-shadows-settings.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/other-shadows-settings.png" alt="其他阴影设置。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">其他阴影设置。</figcaption></figure><p>在我们的 Lit 着色器的 <code class="language-plaintext highlighter-rouge">CustomLit</code> pass 中添加一个 multi-compile 指令，以支持其他阴影的阴影过滤。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma multi_compile _ _OTHER_PCF3 _OTHER_PCF5 _OTHER_PCF7
</span></pre></table></code></div></div><p>并在 <code class="language-plaintext highlighter-rouge">Shadows</code> 中添加相应的关键字数组。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">string</span><span class="p">[]</span> <span class="n">otherFilterKeywords</span> <span class="p">=</span> <span class="p">{</span>
    <span class="s">"_OTHER_PCF3"</span><span class="p">,</span>
    <span class="s">"_OTHER_PCF5"</span><span class="p">,</span>
    <span class="s">"_OTHER_PCF7"</span><span class="p">,</span>
<span class="p">};</span>
</pre></table></code></div></div><p>我们还需要跟踪其他阴影图集和矩阵的着色器属性标识符，以及一个用于保存矩阵的数组。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="n">dirShadowAtlasId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalShadowAtlas"</span><span class="p">),</span>
    <span class="n">dirShadowMatricesId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalShadowMatrices"</span><span class="p">),</span>
    <span class="n">otherShadowAtlasId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_OtherShadowAtlas"</span><span class="p">),</span>
    <span class="n">otherShadowMatricesId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_OtherShadowMatrices"</span><span class="p">),</span>
    <span class="p">...;</span>
<span class="p">...</span>
<span class="k">static</span> <span class="n">Matrix4x4</span><span class="p">[]</span>
    <span class="n">dirShadowMatrices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Matrix4x4</span><span class="p">[</span><span class="n">maxShadowedDirLightCount</span> <span class="p">*</span> <span class="n">maxCascades</span><span class="p">],</span>
    <span class="n">otherShadowMatrices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Matrix4x4</span><span class="p">[</span><span class="n">maxShadowedOtherLightCount</span><span class="p">];</span>
</pre></table></code></div></div><p>我们已经使用向量的 XY 分量将方向图集的大小发送到 GPU。现在我们还需要发送其他图集的大小，可以将其放入同一向量的 ZW 分量中。将其提升为字段，并从 <code class="language-plaintext highlighter-rouge">RenderDirectionalShadows</code> 移动设置全局向量的操作到 <code class="language-plaintext highlighter-rouge">Render</code>。然后 <code class="language-plaintext highlighter-rouge">RenderDirectionalShadows</code> 只需要分配该字段的 XY 分量。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="n">Vector4</span> <span class="n">atlasSizes</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span><span class="n">shadowAtlasSizeId</span><span class="p">,</span> <span class="n">atlasSizes</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">atlasSize</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">atlasSize</span><span class="p">;</span>
    <span class="n">atlasSizes</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">atlasSize</span><span class="p">;</span>
    <span class="n">atlasSizes</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">atlasSize</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="c1">//buffer.SetGlobalVector(</span>
    <span class="c1">//    shadowAtlasSizeId, new Vector4(atlasSize, 1f / atlasSize)</span>
    <span class="c1">//);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>之后，复制 <code class="language-plaintext highlighter-rouge">RenderDirectionalShadows</code> 并将其重命名为 <code class="language-plaintext highlighter-rouge">RenderOtherShadows</code>。修改它以使用正确的设置、图集、矩阵，并设置正确的大小分量。然后从中移除级联和剔除球体代码。同时移除对 <code class="language-plaintext highlighter-rouge">RenderDirectionalShadows</code> 的调用，但保留循环。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderOtherShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">atlasSize</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">other</span><span class="p">.</span><span class="n">atlasSize</span><span class="p">;</span>
    <span class="n">atlasSizes</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="n">atlasSize</span><span class="p">;</span>
    <span class="n">atlasSizes</span><span class="p">.</span><span class="n">w</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">atlasSize</span><span class="p">;</span>

    <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
        <span class="n">otherShadowAtlasId</span><span class="p">,</span> <span class="n">atlasSize</span><span class="p">,</span> <span class="n">atlasSize</span><span class="p">,</span>
        <span class="m">32</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Shadowmap</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetRenderTarget</span><span class="p">(</span>
        <span class="n">otherShadowAtlasId</span><span class="p">,</span>
        <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">DontCare</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">ClearRenderTarget</span><span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">clear</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">tiles</span> <span class="p">=</span> <span class="n">shadowedOtherLightCount</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">split</span> <span class="p">=</span> <span class="n">tiles</span> <span class="p">&lt;=</span> <span class="m">1</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="n">tiles</span> <span class="p">&lt;=</span> <span class="m">4</span> <span class="p">?</span> <span class="m">2</span> <span class="p">:</span> <span class="m">4</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tileSize</span> <span class="p">=</span> <span class="n">atlasSize</span> <span class="p">/</span> <span class="n">split</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">shadowedOtherLightCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="c1">//RenderDirectionalShadows(i, split, tileSize);</span>
    <span class="p">}</span>
    <span class="c1">//buffer.SetGlobalVectorArray(</span>
    <span class="c1">//    cascadeCullingSpheresId, cascadeCullingSpheres</span>
    <span class="c1">//);</span>
    <span class="c1">//buffer.SetGlobalVectorArray(cascadeDataId, cascadeData);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalMatrixArray</span><span class="p">(</span><span class="n">otherShadowMatricesId</span><span class="p">,</span> <span class="n">otherShadowMatrices</span><span class="p">);</span>
    <span class="nf">SetKeywords</span><span class="p">(</span>
        <span class="n">otherFilterKeywords</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">other</span><span class="p">.</span><span class="n">filter</span> <span class="p">-</span> <span class="m">1</span>
    <span class="p">);</span>
    <span class="c1">//SetKeywords(</span>
    <span class="c1">//    cascadeBlendKeywords, (int)settings.directional.cascadeBlend - 1</span>
    <span class="c1">//);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在我们可以在 <code class="language-plaintext highlighter-rouge">RenderShadows</code> 中根据需要渲染方向阴影和其他阴影。如果没有其他阴影，我们需要为它们提供一个虚拟纹理，就像方向阴影一样。我们可以简单地使用方向阴影图集作为虚拟纹理。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shadowedDirLightCount</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">RenderDirectionalShadows</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
            <span class="n">dirShadowAtlasId</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span>
            <span class="m">32</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Shadowmap</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shadowedOtherLightCount</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">RenderOtherShadows</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalTexture</span><span class="p">(</span><span class="n">otherShadowAtlasId</span><span class="p">,</span> <span class="n">dirShadowAtlasId</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>并在 <code class="language-plaintext highlighter-rouge">Cleanup</code> 中释放其他阴影图集，在这种情况下仅当我们确实获得了一个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Cleanup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">dirShadowAtlasId</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shadowedOtherLightCount</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">otherShadowAtlasId</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="渲染聚光灯阴影"><span class="me-2">渲染聚光灯阴影</span><a href="#渲染聚光灯阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要渲染聚光灯的阴影，我们需要知道它的可见光源索引、斜率缩放偏移和法线偏移。因此创建一个 <code class="language-plaintext highlighter-rouge">ShadowedOtherLight</code> 结构，其中包含这些字段，并为其添加一个数组字段，类似于我们跟踪方向阴影数据的方式。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">ShadowedOtherLight</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">slopeScaleBias</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">normalBias</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ShadowedOtherLight</span><span class="p">[]</span> <span class="n">shadowedOtherLights</span> <span class="p">=</span>
    <span class="k">new</span> <span class="n">ShadowedOtherLight</span><span class="p">[</span><span class="n">maxShadowedOtherLightCount</span><span class="p">];</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">ReserveOtherShadows</code> 结束时、返回之前复制相关数据。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Vector4</span> <span class="nf">ReserveOtherShadows</span> <span class="p">(</span><span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">shadowedOtherLights</span><span class="p">[</span><span class="n">shadowedOtherLightCount</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ShadowedOtherLight</span> <span class="p">{</span>
        <span class="n">visibleLightIndex</span> <span class="p">=</span> <span class="n">visibleLightIndex</span><span class="p">,</span>
        <span class="n">slopeScaleBias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowBias</span><span class="p">,</span>
        <span class="n">normalBias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowNormalBias</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
        <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="n">shadowedOtherLightCount</span><span class="p">++,</span> <span class="m">0f</span><span class="p">,</span>
        <span class="n">maskChannel</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然而，此时我们应该意识到，我们无法保证在 <code class="language-plaintext highlighter-rouge">Lighting</code> 中向 <code class="language-plaintext highlighter-rouge">ReserveOtherShadows</code> 发送正确的光源索引，因为它传递的是自己用于其他光源的索引。当存在有阴影的方向光源时，该索引将是错误的。我们通过为光源设置方法添加一个参数来传递正确的可见光源索引来修复这个问题，并在预留阴影时使用该索引。为了一致性，我们也对方向光源这样做。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">SetupDirectionalLight</span> <span class="p">(</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleIndex</span><span class="p">,</span> <span class="k">ref</span> <span class="n">VisibleLight</span> <span class="n">visibleLight</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">dirLightShadowData</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span>
        <span class="n">shadows</span><span class="p">.</span><span class="nf">ReserveDirectionalShadows</span><span class="p">(</span><span class="n">visibleLight</span><span class="p">.</span><span class="n">light</span><span class="p">,</span> <span class="n">visibleIndex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">SetupPointLight</span> <span class="p">(</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleIndex</span><span class="p">,</span> <span class="k">ref</span> <span class="n">VisibleLight</span> <span class="n">visibleLight</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">otherLightShadowData</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span>
        <span class="n">shadows</span><span class="p">.</span><span class="nf">ReserveOtherShadows</span><span class="p">(</span><span class="n">light</span><span class="p">,</span> <span class="n">visibleIndex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">SetupSpotLight</span> <span class="p">(</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleIndex</span><span class="p">,</span> <span class="k">ref</span> <span class="n">VisibleLight</span> <span class="n">visibleLight</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">otherLightShadowData</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span>
        <span class="n">shadows</span><span class="p">.</span><span class="nf">ReserveOtherShadows</span><span class="p">(</span><span class="n">light</span><span class="p">,</span> <span class="n">visibleIndex</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>调整 <code class="language-plaintext highlighter-rouge">SetupLights</code> 以将可见光源索引传递给设置方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">switch</span> <span class="p">(</span><span class="n">visibleLight</span><span class="p">.</span><span class="n">lightType</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">LightType</span><span class="p">.</span><span class="n">Directional</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dirLightCount</span> <span class="p">&lt;</span> <span class="n">maxDirLightCount</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">SetupDirectionalLight</span><span class="p">(</span>
                <span class="n">dirLightCount</span><span class="p">++,</span> <span class="n">i</span><span class="p">,</span> <span class="k">ref</span> <span class="n">visibleLight</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">LightType</span><span class="p">.</span><span class="n">Point</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">otherLightCount</span> <span class="p">&lt;</span> <span class="n">maxOtherLightCount</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newIndex</span> <span class="p">=</span> <span class="n">otherLightCount</span><span class="p">;</span>
            <span class="nf">SetupPointLight</span><span class="p">(</span><span class="n">otherLightCount</span><span class="p">++,</span> <span class="n">i</span><span class="p">,</span> <span class="k">ref</span> <span class="n">visibleLight</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">LightType</span><span class="p">.</span><span class="n">Spot</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">otherLightCount</span> <span class="p">&lt;</span> <span class="n">maxOtherLightCount</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newIndex</span> <span class="p">=</span> <span class="n">otherLightCount</span><span class="p">;</span>
            <span class="nf">SetupSpotLight</span><span class="p">(</span><span class="n">otherLightCount</span><span class="p">++,</span> <span class="n">i</span><span class="p">,</span> <span class="k">ref</span> <span class="n">visibleLight</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>回到 <code class="language-plaintext highlighter-rouge">Shadows</code>，创建一个 <code class="language-plaintext highlighter-rouge">RenderSpotShadows</code> 方法，其功能与带参数的 <code class="language-plaintext highlighter-rouge">RenderDirectionalShadows</code> 方法相同，不同之处在于它不循环多个tiled、没有级联、也没有剔除因子。在这种情况下，我们可以使用 <code class="language-plaintext highlighter-rouge">CullingResults.ComputeSpotShadowMatricesAndCullingPrimitives</code>，它的工作方式类似于 <code class="language-plaintext highlighter-rouge">ComputeDirectionalShadowMatricesAndCullingPrimitives</code>，不同之处在于它只有可见光源索引、矩阵和分割数据作为参数。在 Unity 2022 中，我们还必须使用 <code class="language-plaintext highlighter-rouge">BatchCullingProjectionType.Perspective</code> 而不是正交投影。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderSpotShadows</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowedOtherLight</span> <span class="n">light</span> <span class="p">=</span> <span class="n">shadowedOtherLights</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="kt">var</span> <span class="n">shadowSettings</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ShadowDrawingSettings</span><span class="p">(</span>
        <span class="n">cullingResults</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span>
        <span class="n">BatchCullingProjectionType</span><span class="p">.</span><span class="n">Perspective</span>
    <span class="p">);</span>
    <span class="n">cullingResults</span><span class="p">.</span><span class="nf">ComputeSpotShadowMatricesAndCullingPrimitives</span><span class="p">(</span>
        <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">viewMatrix</span><span class="p">,</span>
        <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">projectionMatrix</span><span class="p">,</span> <span class="k">out</span> <span class="n">ShadowSplitData</span> <span class="n">splitData</span>
    <span class="p">);</span>
    <span class="n">shadowSettings</span><span class="p">.</span><span class="n">splitData</span> <span class="p">=</span> <span class="n">splitData</span><span class="p">;</span>
    <span class="n">otherShadowMatrices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ConvertToAtlasMatrix</span><span class="p">(</span>
        <span class="n">projectionMatrix</span> <span class="p">*</span> <span class="n">viewMatrix</span><span class="p">,</span>
        <span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">),</span> <span class="n">split</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetViewProjectionMatrices</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span> <span class="n">projectionMatrix</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">slopeScaleBias</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
    <span class="n">context</span><span class="p">.</span><span class="nf">DrawShadows</span><span class="p">(</span><span class="k">ref</span> <span class="n">shadowSettings</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">RenderOtherShadows</code> 的循环内调用此方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">shadowedOtherLightCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="nf">RenderSpotShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/spot-shadow-map.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/spot-shadow-map.png" alt="三个聚光灯的阴影图集。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">三个聚光灯的阴影图集。</figcaption></figure><h3 id="禁用-pancaking"><span class="me-2">禁用 Pancaking</span><a href="#禁用-pancaking" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>阴影现在可以为聚光灯渲染，使用与方向阴影相同的 <code class="language-plaintext highlighter-rouge">ShadowCaster</code> pass。这工作正常，但阴影 pancaking 只对正交阴影投影有效，用于被认为是无限远方向光源。对于聚光灯——它们确实有位置——阴影投射者可能最终部分位于光源位置后面。由于在这种情况下我们使用透视投影，将顶点约束到近平面会严重扭曲这些阴影。因此，当 pancaking 不适用时，我们应该关闭约束。</p><p>我们可以通过全局着色器属性告诉着色器 pancaking 是否激活，我们将其命名为 <code class="language-plaintext highlighter-rouge">_ShadowPancaking</code>。在 <code class="language-plaintext highlighter-rouge">Shadows</code> 中跟踪其标识符。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="p">...</span>
    <span class="n">shadowDistanceFadeId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_ShadowDistanceFade"</span><span class="p">),</span>
    <span class="n">shadowPancakingId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_ShadowPancaking"</span><span class="p">);</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">RenderDirectionalShadows</code> 渲染阴影之前将其设置为 1。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">ClearRenderTarget</span><span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">clear</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">shadowPancakingId</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
</pre></table></code></div></div><p>并在 <code class="language-plaintext highlighter-rouge">RenderOtherShadows</code> 中将其设置为零。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">ClearRenderTarget</span><span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">clear</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">shadowPancakingId</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
</pre></table></code></div></div><p>然后将其作为布尔值添加到我们的 Lit 着色器的 <code class="language-plaintext highlighter-rouge">ShadowCaster</code> pass 中，仅在适当的时候使用它来约束。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="n">_ShadowPancaking</span><span class="p">;</span>

<span class="n">Varyings</span> <span class="nf">ShadowCasterPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_ShadowPancaking</span><span class="p">)</span> <span class="p">{</span>
        <span class="cp">#if UNITY_REVERSED_Z
</span>            <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">UNITY_NEAR_CLIP_VALUE</span>
            <span class="p">);</span>
        <span class="cp">#else
</span>            <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">UNITY_NEAR_CLIP_VALUE</span>
            <span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="p">}</span>
    <span class="n">output</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">=</span> <span class="n">TransformBaseUV</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="采样聚光灯阴影"><span class="me-2">采样聚光灯阴影</span><a href="#采样聚光灯阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要采样其他阴影，我们必须调整 <code class="language-plaintext highlighter-rouge">Shadows</code>。首先定义其他过滤器和最大有阴影其他光源计数宏。然后添加其他阴影图集和其他阴影矩阵数组。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_OTHER_PCF3)
</span>    <span class="cp">#define OTHER_FILTER_SAMPLES 4
</span>    <span class="cp">#define OTHER_FILTER_SETUP SampleShadow_ComputeSamples_Tent_3x3
#elif defined(_OTHER_PCF5)
</span>    <span class="cp">#define OTHER_FILTER_SAMPLES 9
</span>    <span class="cp">#define OTHER_FILTER_SETUP SampleShadow_ComputeSamples_Tent_5x5
#elif defined(_OTHER_PCF7)
</span>    <span class="cp">#define OTHER_FILTER_SAMPLES 16
</span>    <span class="cp">#define OTHER_FILTER_SETUP SampleShadow_ComputeSamples_Tent_7x7
#endif
</span>
<span class="cp">#define MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT 4
#define MAX_SHADOWED_OTHER_LIGHT_COUNT 16
#define MAX_CASCADE_COUNT 4
</span>
<span class="n">TEXTURE2D_SHADOW</span><span class="p">(</span><span class="n">_DirectionalShadowAtlas</span><span class="p">);</span>
<span class="n">TEXTURE2D_SHADOW</span><span class="p">(</span><span class="n">_OtherShadowAtlas</span><span class="p">);</span>
<span class="cp">#define SHADOW_SAMPLER sampler_linear_clamp_compare
</span><span class="n">SAMPLER_CMP</span><span class="p">(</span><span class="n">SHADOW_SAMPLER</span><span class="p">);</span>

<span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomShadows</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="kt">float4x4</span> <span class="n">_DirectionalShadowMatrices</span>
        <span class="p">[</span><span class="n">MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT</span> <span class="o">*</span> <span class="n">MAX_CASCADE_COUNT</span><span class="p">];</span>
    <span class="kt">float4x4</span> <span class="n">_OtherShadowMatrices</span><span class="p">[</span><span class="n">MAX_SHADOWED_OTHER_LIGHT_COUNT</span><span class="p">];</span>
    <span class="p">...</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>复制 <code class="language-plaintext highlighter-rouge">SampleDirectionalShadowAtlas</code> 和 <code class="language-plaintext highlighter-rouge">FilterDirectionalShadow</code>，并将它们重命名并调整以适用于其他阴影。请注意，对于此版本，我们需要使用图集大小向量的另一个分量对。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">SampleOtherShadowAtlas</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionSTS</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">SAMPLE_TEXTURE2D_SHADOW</span><span class="p">(</span>
        <span class="n">_OtherShadowAtlas</span><span class="p">,</span> <span class="n">SHADOW_SAMPLER</span><span class="p">,</span> <span class="n">positionSTS</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">FilterOtherShadow</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionSTS</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(OTHER_FILTER_SETUP)
</span>        <span class="n">real</span> <span class="n">weights</span><span class="p">[</span><span class="n">OTHER_FILTER_SAMPLES</span><span class="p">];</span>
        <span class="n">real2</span> <span class="n">positions</span><span class="p">[</span><span class="n">OTHER_FILTER_SAMPLES</span><span class="p">];</span>
        <span class="kt">float4</span> <span class="n">size</span> <span class="o">=</span> <span class="n">_ShadowAtlasSize</span><span class="p">.</span><span class="n">wwzz</span><span class="p">;</span>
        <span class="n">OTHER_FILTER_SETUP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">positionSTS</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">positions</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">OTHER_FILTER_SAMPLES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">shadow</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">SampleOtherShadowAtlas</span><span class="p">(</span>
                <span class="kt">float3</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">xy</span><span class="p">,</span> <span class="n">positionSTS</span><span class="p">.</span><span class="n">z</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="n">SampleOtherShadowAtlas</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">OtherShadowData</code> 结构现在也需要一个tiled索引。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">OtherShadowData</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">strength</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">tileIndex</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">shadowMaskChannel</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>它由 <code class="language-plaintext highlighter-rouge">Light</code> 中的 <code class="language-plaintext highlighter-rouge">GetOtherShadowData</code> 设置。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">OtherShadowData</span> <span class="nf">GetOtherShadowData</span> <span class="p">(</span><span class="n">int</span> <span class="n">lightIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">OtherShadowData</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="n">_OtherLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">tileIndex</span> <span class="o">=</span> <span class="n">_OtherLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">shadowMaskChannel</span> <span class="o">=</span> <span class="n">_OtherLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在我们可以在 <code class="language-plaintext highlighter-rouge">GetOtherShadow</code> 中采样阴影贴图，而不是总是返回 1。它的工作方式类似于 <code class="language-plaintext highlighter-rouge">GetCascadedShadow</code>，不同之处在于没有第二个级联需要混合，并且它是透视投影，因此我们必须将转换后位置的 XYZ 分量除以其 W 分量。此外，我们还没有功能性的法线偏移，所以我们现在将其乘以零。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetOtherShadow</span> <span class="p">(</span>
    <span class="n">OtherShadowData</span> <span class="n">other</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">normalBias</span> <span class="o">=</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">interpolatedNormal</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">positionSTS</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span>
        <span class="n">_OtherShadowMatrices</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">tileIndex</span><span class="p">],</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">normalBias</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="k">return</span> <span class="n">FilterOtherShadow</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">positionSTS</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/with-shadows1.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/with-shadows1.png" alt="仅聚光灯直接照明，有和没有实时阴影。" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/without-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/without-shadows.png" alt="仅聚光灯直接照明，有和没有实时阴影。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">仅聚光灯直接照明，有和没有实时阴影。</figcaption></figure><h3 id="法线偏移"><span class="me-2">法线偏移</span><a href="#法线偏移" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>聚光灯与方向光一样会遭受阴影痤疮（shadow acne）。但由于透视投影，纹素大小不是恒定的，因此痤疮也不恒定。距离光源越远，痤疮越大。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/variable-texel-size.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/variable-texel-size.png" alt="纹素大小随距离光源的增加而增加。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">纹素大小随距离光源的增加而增加。</figcaption></figure><p>纹素大小随距光平面的距离线性增加，光平面是将世界分成光前和光后的平面。因此，我们可以在距离 1 处计算纹素大小，从而计算法线偏移，并将其发送到着色器，在那里我们将其缩放到适当的大小。</p><p>在世界空间中，距离光平面距离为 1 时，阴影tiled的大小是聚光角度一半弧度的正切值的两倍。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/tile-size-diagram.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/tile-size-diagram.png" alt="世界空间tiled大小推导。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">世界空间tiled大小推导。</figcaption></figure><p>这与透视投影相匹配，因此距离 1 处的世界空间纹素大小等于 2 除以投影缩放，我们可以使用其矩阵的左上角值。我们可以使用它来计算法线偏移，方法与方向光相同，不同之处在于我们可以立即将光源的法线偏移纳入其中，因为没有多个级联。在 <code class="language-plaintext highlighter-rouge">Shadows.RenderSpotShadows</code> 中设置阴影矩阵之前执行此操作。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">texelSize</span> <span class="p">=</span> <span class="m">2f</span> <span class="p">/</span> <span class="p">(</span><span class="n">tileSize</span> <span class="p">*</span> <span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m00</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">filterSize</span> <span class="p">=</span> <span class="n">texelSize</span> <span class="p">*</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">other</span><span class="p">.</span><span class="n">filter</span> <span class="p">+</span> <span class="m">1f</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">bias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">normalBias</span> <span class="p">*</span> <span class="n">filterSize</span> <span class="p">*</span> <span class="m">1.4142136f</span><span class="p">;</span>
<span class="n">otherShadowMatrices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ConvertToAtlasMatrix</span><span class="p">(</span>
    <span class="n">projectionMatrix</span> <span class="p">*</span> <span class="n">viewMatrix</span><span class="p">,</span>
    <span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">),</span> <span class="n">tileScale</span>
<span class="p">);</span>
</pre></table></code></div></div><p>现在我们必须将偏移发送到着色器。稍后我们需要为每个tiled发送更多数据，因此让我们添加一个 <code class="language-plaintext highlighter-rouge">_OtherShadowTiles</code> 向量数组着色器属性。为其添加标识符和数组到 <code class="language-plaintext highlighter-rouge">Shadows</code>，并在 <code class="language-plaintext highlighter-rouge">RenderOtherShadows</code> 中与矩阵一起设置它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="p">...</span>
    <span class="n">otherShadowMatricesId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_OtherShadowMatrices"</span><span class="p">),</span>
    <span class="n">otherShadowTilesId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_OtherShadowTiles"</span><span class="p">),</span>
    <span class="p">...;</span>

<span class="k">static</span> <span class="n">Vector4</span><span class="p">[]</span>
    <span class="n">cascadeCullingSpheres</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxCascades</span><span class="p">],</span>
    <span class="n">cascadeData</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxCascades</span><span class="p">],</span>
    <span class="n">otherShadowTiles</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxShadowedOtherLightCount</span><span class="p">];</span>
<span class="p">...</span>
<span class="k">void</span> <span class="nf">RenderOtherShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalMatrixArray</span><span class="p">(</span><span class="n">otherShadowMatricesId</span><span class="p">,</span> <span class="n">otherShadowMatrices</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVectorArray</span><span class="p">(</span><span class="n">otherShadowTilesId</span><span class="p">,</span> <span class="n">otherShadowTiles</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>创建一个新的 <code class="language-plaintext highlighter-rouge">SetOtherTileData</code> 方法，带有索引和偏移参数。让它将偏移放在向量的最后一个分量中，然后将其存储在tiled数据数组中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">SetOtherTileData</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">float</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Vector4</span> <span class="n">data</span> <span class="p">=</span> <span class="n">Vector4</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">w</span> <span class="p">=</span> <span class="n">bias</span><span class="p">;</span>
    <span class="n">otherShadowTiles</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">RenderSpotShadows</code> 中一旦我们有了偏移就调用它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">bias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">normalBias</span> <span class="p">*</span> <span class="n">filterSize</span> <span class="p">*</span> <span class="m">1.4142136f</span><span class="p">;</span>
<span class="nf">SetOtherTileData</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
</pre></table></code></div></div><p>然后将其他阴影tiled数组添加到阴影缓冲区，并使用它在 <code class="language-plaintext highlighter-rouge">Shadows</code> 中缩放法线偏移。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomShadows</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="kt">float4x4</span> <span class="n">_OtherShadowMatrices</span><span class="p">[</span><span class="n">MAX_SHADOWED_OTHER_LIGHT_COUNT</span><span class="p">];</span>
    <span class="kt">float4</span> <span class="n">_OtherShadowTiles</span><span class="p">[</span><span class="n">MAX_SHADOWED_OTHER_LIGHT_COUNT</span><span class="p">];</span>
    <span class="kt">float4</span> <span class="n">_ShadowAtlasSize</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">_ShadowDistanceFade</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>
<span class="p">...</span>
<span class="n">float</span> <span class="nf">GetOtherShadow</span> <span class="p">(</span>
    <span class="n">OtherShadowData</span> <span class="n">other</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">tileData</span> <span class="o">=</span> <span class="n">_OtherShadowTiles</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">tileIndex</span><span class="p">];</span>
    <span class="kt">float3</span> <span class="n">normalBias</span> <span class="o">=</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">interpolatedNormal</span> <span class="o">*</span> <span class="n">tileData</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/normal-bias-constant.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/normal-bias-constant.png" alt="恒定法线偏移，设置为 1。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">恒定法线偏移，设置为 1。</figcaption></figure><p>此时我们的法线偏移仅在固定距离处是正确的。要使其随距光平面的距离缩放，我们需要知道世界空间光源位置和聚光方向，因此将它们添加到 <code class="language-plaintext highlighter-rouge">OtherShadowData</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">OtherShadowData</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">strength</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">tileIndex</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">shadowMaskChannel</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">lightPositionWS</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">spotDirectionWS</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>让 <code class="language-plaintext highlighter-rouge">Light</code> 将值复制到其中。由于这些值来自光源本身而不是阴影数据，因此在 <code class="language-plaintext highlighter-rouge">GetOtherShadowData</code> 中将它们设置为零，并在 <code class="language-plaintext highlighter-rouge">GetOtherLight</code> 中复制它们。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="n">OtherShadowData</span> <span class="nf">GetOtherShadowData</span> <span class="p">(</span><span class="n">int</span> <span class="n">lightIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">data</span><span class="p">.</span><span class="n">lightPositionWS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">spotDirectionWS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Light</span> <span class="nf">GetOtherLight</span> <span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">shadowData</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Light</span> <span class="n">light</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_OtherLightColors</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">rgb</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">position</span> <span class="o">=</span> <span class="n">_OtherLightPositions</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">xyz</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">ray</span> <span class="o">=</span> <span class="n">position</span> <span class="o">-</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="kt">float3</span> <span class="n">spotDirection</span> <span class="o">=</span> <span class="n">_OtherLightDirections</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">spotAttenuation</span> <span class="o">=</span> <span class="n">Square</span><span class="p">(</span>
        <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">spotDirection</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">spotAngles</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">spotAngles</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="n">OtherShadowData</span> <span class="n">otherShadowData</span> <span class="o">=</span> <span class="n">GetOtherShadowData</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="n">otherShadowData</span><span class="p">.</span><span class="n">lightPositionWS</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">otherShadowData</span><span class="p">.</span><span class="n">spotDirectionWS</span> <span class="o">=</span> <span class="n">spotDirection</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们通过在 <code class="language-plaintext highlighter-rouge">GetOtherShadow</code> 中取表面到光源向量与聚光方向的点积来找到到平面的距离。使用它来缩放法线偏移。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="n">tileData</span> <span class="o">=</span> <span class="n">_OtherShadowTiles</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">tileIndex</span><span class="p">];</span>
<span class="kt">float3</span> <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">lightPositionWS</span> <span class="o">-</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
<span class="n">float</span> <span class="n">distanceToLightPlane</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">surfaceToLight</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">spotDirectionWS</span><span class="p">);</span>
<span class="kt">float3</span> <span class="n">normalBias</span> <span class="o">=</span>
    <span class="n">surfaceWS</span><span class="p">.</span><span class="n">interpolatedNormal</span> <span class="o">*</span> <span class="p">(</span><span class="n">distanceToLightPlane</span> <span class="o">*</span> <span class="n">tileData</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/normal-bias-variable.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/normal-bias-variable.png" alt="各处正确的法线偏移。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">各处正确的法线偏移。</figcaption></figure><h3 id="约束采样"><span class="me-2">约束采样</span><a href="#约束采样" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们为方向阴影配置了级联球体，以确保永远不会在适当的阴影tiled之外采样，但我们不能对其他阴影使用相同的方法。对于聚光灯，它们的tiled紧密贴合其圆锥体，因此法线偏移和过滤器大小将在圆锥边缘接近tiled边缘的地方将采样推到tiled边界之外。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/without-clamping.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/without-clamping.png" alt="来自错误tiled的阴影在边缘附近侵入。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">来自错误tiled的阴影在边缘附近侵入。</figcaption></figure><p>解决这个问题的最简单方法是手动约束采样以保持在tiled边界内，就好像每个tiled都是自己的单独纹理一样。这仍然会在边缘附近拉伸阴影，但不会引入无效阴影。</p><p>调整 <code class="language-plaintext highlighter-rouge">SetOtherTileData</code> 方法，使其还根据通过新参数提供的偏移和缩放来计算和存储tiled边界。tiled的最小纹理坐标是缩放的偏移，我们将其存储在数据向量的 XY 分量中。由于tiled是正方形的，我们可以只在 Z 分量中存储tiled的缩放，将 W 留给偏移。我们还必须在两个维度上将边界缩小半个纹素，以确保采样不会超出边缘。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">SetOtherTileData</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span><span class="p">,</span> <span class="kt">float</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">border</span> <span class="p">=</span> <span class="n">atlasSizes</span><span class="p">.</span><span class="n">w</span> <span class="p">*</span> <span class="m">0.5f</span><span class="p">;</span>
    <span class="n">Vector4</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">scale</span> <span class="p">+</span> <span class="n">border</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">scale</span> <span class="p">+</span> <span class="n">border</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="n">scale</span> <span class="p">-</span> <span class="n">border</span> <span class="p">-</span> <span class="n">border</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">w</span> <span class="p">=</span> <span class="n">bias</span><span class="p">;</span>
    <span class="n">otherShadowTiles</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">RenderSpotShadows</code> 中，使用通过 <code class="language-plaintext highlighter-rouge">SetTileViewport</code> 找到的偏移和分割的倒数作为 <code class="language-plaintext highlighter-rouge">SetOtherTileData</code> 的新参数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">Vector2</span> <span class="n">offset</span> <span class="p">=</span> <span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
<span class="nf">SetOtherTileData</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">split</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
<span class="n">otherShadowMatrices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ConvertToAtlasMatrix</span><span class="p">(</span>
    <span class="n">projectionMatrix</span> <span class="p">*</span> <span class="n">viewMatrix</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">split</span>
<span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">ConverToAtlasMatrix</code> 方法也使用分割的倒数，因此我们可以计算一次并将其传递给两个方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">tileScale</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">split</span><span class="p">;</span>
<span class="nf">SetOtherTileData</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">tileScale</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
<span class="n">otherShadowMatrices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ConvertToAtlasMatrix</span><span class="p">(</span>
    <span class="n">projectionMatrix</span> <span class="p">*</span> <span class="n">viewMatrix</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">tileScale</span>
<span class="p">);</span>
</pre></table></code></div></div><p>然后 <code class="language-plaintext highlighter-rouge">ConvertToAtlasMatrix</code> 就不必自己执行除法了。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">Matrix4x4</span> <span class="nf">ConvertToAtlasMatrix</span> <span class="p">(</span><span class="n">Matrix4x4</span> <span class="n">m</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">//float scale = 1f / split;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这需要 <code class="language-plaintext highlighter-rouge">RenderDirectionalShadows</code> 执行除法，它只需要为所有级联执行一次。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">float</span> <span class="n">tileScale</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">split</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">cascadeCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">dirShadowMatrices</span><span class="p">[</span><span class="n">tileIndex</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ConvertToAtlasMatrix</span><span class="p">(</span>
            <span class="n">projectionMatrix</span> <span class="p">*</span> <span class="n">viewMatrix</span><span class="p">,</span>
            <span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">tileIndex</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">),</span> <span class="n">tileScale</span>
        <span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>要应用边界，请为 <code class="language-plaintext highlighter-rouge">SampleOtherShadowAtlas</code> 添加一个 float3 参数，并使用它来约束阴影tiled空间中的位置。<code class="language-plaintext highlighter-rouge">FilterOtherShadows</code> 需要相同的参数，以便它可以传递它。而 <code class="language-plaintext highlighter-rouge">GetOtherShadow</code> 从tiled数据中检索它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">SampleOtherShadowAtlas</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionSTS</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">bounds</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">positionSTS</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="nb">clamp</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">SAMPLE_TEXTURE2D_SHADOW</span><span class="p">(</span>
        <span class="n">_OtherShadowAtlas</span><span class="p">,</span> <span class="n">SHADOW_SAMPLER</span><span class="p">,</span> <span class="n">positionSTS</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">FilterOtherShadow</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionSTS</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">bounds</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(OTHER_FILTER_SETUP)
</span>        <span class="p">...</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">OTHER_FILTER_SAMPLES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">shadow</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">SampleOtherShadowAtlas</span><span class="p">(</span>
                <span class="kt">float3</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">xy</span><span class="p">,</span> <span class="n">positionSTS</span><span class="p">.</span><span class="n">z</span><span class="p">),</span> <span class="n">bounds</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="n">SampleOtherShadowAtlas</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>

<span class="n">float</span> <span class="nf">GetOtherShadow</span> <span class="p">(</span>
    <span class="n">OtherShadowData</span> <span class="n">other</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">FilterOtherShadow</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">positionSTS</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">tileData</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/with-clamping.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/with-clamping.png" alt="不再有来自错误tiled的阴影。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">不再有来自错误tiled的阴影。</figcaption></figure><h2 id="点光源阴影"><span class="me-2">点光源阴影</span><a href="#点光源阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>点光源的阴影工作方式类似于聚光灯。不同之处在于点光源不限于圆锥体，因此我们需要将它们的阴影渲染到立方体贴图。这是通过分别渲染立方体所有六个面的阴影来完成的。因此，为了实时阴影的目的，我们将点光源视为六个光源。它将占用阴影图集中的六个tiled。这意味着我们最多可以同时支持两个点光源的实时阴影，因为它们将占用十六个可用tiled中的十二个。如果可用tiled少于六个，点光源将无法获得实时阴影。</p><h3 id="一个光源的六个tiled"><span class="me-2">一个光源的六个tiled</span><a href="#一个光源的六个tiled" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>首先，我们需要在渲染阴影时知道我们正在处理点光源，因此向 <code class="language-plaintext highlighter-rouge">ShadowedOtherLight</code> 添加一个布尔值来指示这一点。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">ShadowedOtherLight</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">isPoint</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">ReserveOtherShadows</code> 中检查我们是否有点光源。如果是，包括此光源在内的新光源计数将比当前计数大六，否则只大一。如果这会超过最大值，那么光源最多只能有烘焙阴影。如果图集中有足够的空间，则还要在返回的阴影数据的第三个分量中存储它是否为点光源，以便在着色器中轻松检测点光源。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Vector4</span> <span class="nf">ReserveOtherShadows</span> <span class="p">(</span><span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">bool</span> <span class="n">isPoint</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">type</span> <span class="p">==</span> <span class="n">LightType</span><span class="p">.</span><span class="n">Point</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">newLightCount</span> <span class="p">=</span> <span class="n">shadowedOtherLightCount</span> <span class="p">+</span> <span class="p">(</span><span class="n">isPoint</span> <span class="p">?</span> <span class="m">6</span> <span class="p">:</span> <span class="m">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">newLightCount</span> <span class="p">&gt;</span> <span class="n">maxShadowedOtherLightCount</span> <span class="p">||</span>
        <span class="p">!</span><span class="n">cullingResults</span><span class="p">.</span><span class="nf">GetShadowCasterBounds</span><span class="p">(</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="k">out</span> <span class="n">Bounds</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(-</span><span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="n">maskChannel</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">shadowedOtherLights</span><span class="p">[</span><span class="n">shadowedOtherLightCount</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ShadowedOtherLight</span> <span class="p">{</span>
        <span class="n">visibleLightIndex</span> <span class="p">=</span> <span class="n">visibleLightIndex</span><span class="p">,</span>
        <span class="n">slopeScaleBias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowBias</span><span class="p">,</span>
        <span class="n">normalBias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowNormalBias</span><span class="p">,</span>
        <span class="n">isPoint</span> <span class="p">=</span> <span class="n">isPoint</span>
    <span class="p">};</span>
    <span class="n">Vector4</span> <span class="n">data</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
        <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="n">shadowedOtherLightCount</span><span class="p">,</span>
        <span class="n">isPoint</span> <span class="p">?</span> <span class="m">1f</span> <span class="p">:</span> <span class="m">0f</span><span class="p">,</span> <span class="n">maskChannel</span>
    <span class="p">);</span>
    <span class="n">shadowedOtherLightCount</span> <span class="p">=</span> <span class="n">newLightCount</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="渲染点光源阴影"><span class="me-2">渲染点光源阴影</span><a href="#渲染点光源阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>调整 <code class="language-plaintext highlighter-rouge">RenderOtherShadows</code>，使其在循环中根据需要调用新的 <code class="language-plaintext highlighter-rouge">RenderPointShadows</code> 方法或现有的 <code class="language-plaintext highlighter-rouge">RenderSpotShadows</code> 方法。此外，由于点光源计为六个，因此为每种光源类型增加迭代器的正确数量，而不是仅递增它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">shadowedOtherLightCount</span><span class="p">;)</span> <span class="p">{</span> <span class="c1">//i++) {</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shadowedOtherLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isPoint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">RenderPointShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
        <span class="n">i</span> <span class="p">+=</span> <span class="m">6</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nf">RenderSpotShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
        <span class="n">i</span> <span class="p">+=</span> <span class="m">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>新的 <code class="language-plaintext highlighter-rouge">RenderPointShadows</code> 方法是 <code class="language-plaintext highlighter-rouge">RenderSpotShadows</code> 的副本，有两个不同之处。首先，它必须渲染六次而不是只渲染一次，循环遍历其六个tiled。其次，它必须使用 <code class="language-plaintext highlighter-rouge">ComputePointShadowMatricesAndCullingPrimitives</code> 而不是 <code class="language-plaintext highlighter-rouge">ComputeSpotShadowMatricesAndCullingPrimitives</code>。此方法在光源索引之后需要两个额外的参数：一个 <code class="language-plaintext highlighter-rouge">CubemapFace</code> 索引和一个偏移。我们为每个面渲染一次，现在将偏移保留为零。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderPointShadows</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowedOtherLight</span> <span class="n">light</span> <span class="p">=</span> <span class="n">shadowedOtherLights</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="kt">var</span> <span class="n">shadowSettings</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ShadowDrawingSettings</span><span class="p">(</span>
        <span class="n">cullingResults</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span>
        <span class="n">BatchCullingProjectionType</span><span class="p">.</span><span class="n">Perspective</span>
    <span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">6</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">cullingResults</span><span class="p">.</span><span class="nf">ComputePointShadowMatricesAndCullingPrimitives</span><span class="p">(</span>
            <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="p">(</span><span class="n">CubemapFace</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span>
            <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">viewMatrix</span><span class="p">,</span> <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">projectionMatrix</span><span class="p">,</span>
            <span class="k">out</span> <span class="n">ShadowSplitData</span> <span class="n">splitData</span>
        <span class="p">);</span>
        <span class="n">shadowSettings</span><span class="p">.</span><span class="n">splitData</span> <span class="p">=</span> <span class="n">splitData</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">tileIndex</span> <span class="p">=</span> <span class="n">index</span> <span class="p">+</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">texelSize</span> <span class="p">=</span> <span class="m">2f</span> <span class="p">/</span> <span class="p">(</span><span class="n">tileSize</span> <span class="p">*</span> <span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m00</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">filterSize</span> <span class="p">=</span> <span class="n">texelSize</span> <span class="p">*</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">other</span><span class="p">.</span><span class="n">filter</span> <span class="p">+</span> <span class="m">1f</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">bias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">normalBias</span> <span class="p">*</span> <span class="n">filterSize</span> <span class="p">*</span> <span class="m">1.4142136f</span><span class="p">;</span>
        <span class="n">Vector2</span> <span class="n">offset</span> <span class="p">=</span> <span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">tileIndex</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">tileScale</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">split</span><span class="p">;</span>
        <span class="nf">SetOtherTileData</span><span class="p">(</span><span class="n">tileIndex</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">tileScale</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
        <span class="n">otherShadowMatrices</span><span class="p">[</span><span class="n">tileIndex</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ConvertToAtlasMatrix</span><span class="p">(</span>
            <span class="n">projectionMatrix</span> <span class="p">*</span> <span class="n">viewMatrix</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">tileScale</span>
        <span class="p">);</span>

        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetViewProjectionMatrices</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span> <span class="n">projectionMatrix</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">slopeScaleBias</span><span class="p">);</span>
        <span class="nf">ExecuteBuffer</span><span class="p">();</span>
        <span class="n">context</span><span class="p">.</span><span class="nf">DrawShadows</span><span class="p">(</span><span class="k">ref</span> <span class="n">shadowSettings</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/point-shadow-map-back-faces.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/point-shadow-map-back-faces.png" alt="两个点光源的阴影图集。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">两个点光源的阴影图集。</figcaption></figure><p>立方体贴图面的视野始终为 90°，因此距离 1 处的世界空间tiled大小始终为 2。这意味着我们可以将偏移的计算提升到循环之外。我们也可以对tiled缩放这样做。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">texelSize</span> <span class="p">=</span> <span class="m">2f</span> <span class="p">/</span> <span class="n">tileSize</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">filterSize</span> <span class="p">=</span> <span class="n">texelSize</span> <span class="p">*</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">other</span><span class="p">.</span><span class="n">filter</span> <span class="p">+</span> <span class="m">1f</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">bias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">normalBias</span> <span class="p">*</span> <span class="n">filterSize</span> <span class="p">*</span> <span class="m">1.4142136f</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">tileScale</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">split</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">6</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">//float texelSize = 2f / (tileSize * projectionMatrix.m00);</span>
    <span class="c1">//float filterSize = texelSize * ((float)settings.other.filter + 1f);</span>
    <span class="c1">//float bias = light.normalBias * filterSize * 1.4142136f;</span>
    <span class="n">Vector2</span> <span class="n">offset</span> <span class="p">=</span> <span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">tileIndex</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
    <span class="c1">//float tileScale = 1f / split;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="采样点光源阴影"><span class="me-2">采样点光源阴影</span><a href="#采样点光源阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>其思想是点光源阴影存储在立方体贴图中，着色器对其进行采样。然而，我们将立方体贴图面作为tiled存储在图集中，因此我们不能使用标准立方体贴图采样。我们必须自己确定要从中采样的适当面。为此，我们需要知道我们是否正在处理点光源以及表面到光源的方向。将两者都添加到 <code class="language-plaintext highlighter-rouge">OtherShadowData</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">OtherShadowData</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">strength</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">tileIndex</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">isPoint</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">shadowMaskChannel</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">lightPositionWS</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">lightDirectionWS</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">spotDirectionWS</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">Light</code> 中设置两个值。如果其他光源的阴影数据的第三个分量等于 1，则它是点光源。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">OtherShadowData</span> <span class="nf">GetOtherShadowData</span> <span class="p">(</span><span class="n">int</span> <span class="n">lightIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">data</span><span class="p">.</span><span class="n">isPoint</span> <span class="o">=</span> <span class="n">_OtherLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">z</span> <span class="o">==</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">lightPositionWS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">lightDirectionWS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">spotDirectionWS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Light</span> <span class="nf">GetOtherLight</span> <span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">shadowData</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">otherShadowData</span><span class="p">.</span><span class="n">lightPositionWS</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">otherShadowData</span><span class="p">.</span><span class="n">lightDirectionWS</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">;</span>
    <span class="n">otherShadowData</span><span class="p">.</span><span class="n">spotDirectionWS</span> <span class="o">=</span> <span class="n">spotDirection</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接下来，在点光源的情况下，我们必须调整 <code class="language-plaintext highlighter-rouge">GetOtherShadow</code> 中的tiled索引和光平面。首先将它们转换为变量，最初为聚光灯配置。将tiled索引设为浮点数，因为我们将向其添加一个也定义为浮点数的偏移。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetOtherShadow</span> <span class="p">(</span>
    <span class="n">OtherShadowData</span> <span class="n">other</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">tileIndex</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">tileIndex</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">lightPlane</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">spotDirectionWS</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">tileData</span> <span class="o">=</span> <span class="n">_OtherShadowTiles</span><span class="p">[</span><span class="n">tileIndex</span><span class="p">];</span>
    <span class="kt">float3</span> <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">lightPositionWS</span> <span class="o">-</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">distanceToLightPlane</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">surfaceToLight</span><span class="p">,</span> <span class="n">lightPlane</span><span class="p">);</span>
    <span class="kt">float3</span> <span class="n">normalBias</span> <span class="o">=</span>
        <span class="n">surfaceWS</span><span class="p">.</span><span class="n">interpolatedNormal</span> <span class="o">*</span> <span class="p">(</span><span class="n">distanceToLightPlane</span> <span class="o">*</span> <span class="n">tileData</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">positionSTS</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span>
        <span class="n">_OtherShadowMatrices</span><span class="p">[</span><span class="n">tileIndex</span><span class="p">],</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">normalBias</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="k">return</span> <span class="n">FilterOtherShadow</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">positionSTS</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">tileData</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果我们有点光源，那么我们必须使用适当的轴对齐平面。我们可以使用 <code class="language-plaintext highlighter-rouge">CubeMapFaceID</code> 函数通过传递取反的光方向来找到面偏移。此函数要么是内在的，要么在 Core RP Library 中定义，返回一个浮点数。立方体贴图面的顺序是 +X、−X、+Y、−Y、+Z、−Z，这与我们渲染它们的方式相匹配。将偏移添加到tiled索引。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetOtherShadow</span> <span class="p">(</span>
    <span class="n">OtherShadowData</span> <span class="n">other</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">tileIndex</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">tileIndex</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">lightPlane</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">spotDirectionWS</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">isPoint</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float</span> <span class="n">faceOffset</span> <span class="o">=</span> <span class="n">CubeMapFaceID</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">.</span><span class="n">lightDirectionWS</span><span class="p">);</span>
        <span class="n">tileIndex</span> <span class="o">+=</span> <span class="n">faceOffset</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接下来，我们需要使用与面方向匹配的光平面。为它们创建一个静态常量数组，并使用面偏移来索引它。平面法线必须指向与面相反的方向，就像聚光方向指向光源一样。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="k">const</span> <span class="kt">float3</span> <span class="n">pointShadowPlanes</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kt">float3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span>
    <span class="kt">float3</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span>
    <span class="kt">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span>
    <span class="kt">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span>
    <span class="kt">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span>
    <span class="kt">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
<span class="p">};</span>

<span class="n">float</span> <span class="nf">GetOtherShadow</span> <span class="p">(</span>
    <span class="n">OtherShadowData</span> <span class="n">other</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">tileIndex</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">tileIndex</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">plane</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">spotDirectionWS</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">isPoint</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float</span> <span class="n">faceOffset</span> <span class="o">=</span> <span class="n">CubeMapFaceID</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">.</span><span class="n">lightDirectionWS</span><span class="p">);</span>
        <span class="n">tileIndex</span> <span class="o">+=</span> <span class="n">faceOffset</span><span class="p">;</span>
        <span class="n">lightPlane</span> <span class="o">=</span> <span class="n">pointShadowPlanes</span><span class="p">[</span><span class="n">faceOffset</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/with-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/with-shadows.png" alt="仅点光源直接照明，有和没有实时阴影；无偏移。" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/without-shadows2.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/without-shadows2.png" alt="仅点光源直接照明，有和没有实时阴影；无偏移。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">仅点光源直接照明，有和没有实时阴影；无偏移。</figcaption></figure><h3 id="绘制正确的面"><span class="me-2">绘制正确的面</span><a href="#绘制正确的面" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们现在可以看到点光源的实时阴影。即使偏移为零，它们似乎也不会受到阴影痤疮的影响。不幸的是，光现在会通过物体泄漏到相反一侧非常接近它们的表面。增加阴影偏移会使这种情况变得更糟，并且似乎还会在靠近其他表面的物体阴影中切出孔洞。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/normal-bias-3.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/normal-bias-3.png" alt="最大法线偏移 3。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">最大法线偏移 3。</figcaption></figure><p>这是因为 Unity 渲染点光源阴影的方式。它将它们倒置绘制，这会反转三角形的缠绕顺序。通常会绘制前面（从光源的角度来看），但现在会渲染背面。这可以防止大多数痤疮，但会引入光泄漏。我们无法阻止翻转，但我们可以通过取反从 <code class="language-plaintext highlighter-rouge">ComputePointShadowMatricesAndCullingPrimitives</code> 获得的视图矩阵的一行来撤消它。让我们取反其第二行。这会第二次在图集中将所有内容上下翻转，这会将所有内容恢复正常。因为该行的第一个分量始终为零，我们只需取反其他三个分量即可。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">cullingResults</span><span class="p">.</span><span class="nf">ComputePointShadowMatricesAndCullingPrimitives</span><span class="p">(</span>
    <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="p">(</span><span class="n">CubemapFace</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="n">fovBias</span><span class="p">,</span>
    <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">viewMatrix</span><span class="p">,</span> <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">projectionMatrix</span><span class="p">,</span>
    <span class="k">out</span> <span class="n">ShadowSplitData</span> <span class="n">splitData</span>
<span class="p">);</span>
<span class="n">viewMatrix</span><span class="p">.</span><span class="n">m11</span> <span class="p">=</span> <span class="p">-</span><span class="n">viewMatrix</span><span class="p">.</span><span class="n">m11</span><span class="p">;</span>
<span class="n">viewMatrix</span><span class="p">.</span><span class="n">m12</span> <span class="p">=</span> <span class="p">-</span><span class="n">viewMatrix</span><span class="p">.</span><span class="n">m12</span><span class="p">;</span>
<span class="n">viewMatrix</span><span class="p">.</span><span class="n">m13</span> <span class="p">=</span> <span class="p">-</span><span class="n">viewMatrix</span><span class="p">.</span><span class="n">m13</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/normal-shadows-bias-0.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/normal-shadows-bias-0.png" alt="正面阴影渲染，法线偏移 0 和 1。" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/normal-shadow-bias-1.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/normal-shadow-bias-1.png" alt="正面阴影渲染，法线偏移 0 和 1。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">正面阴影渲染，法线偏移 0 和 1。</figcaption></figure><p>这如何改变渲染的阴影在比较阴影贴图时最为明显。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/point-shadow-map-front-faces.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/point-shadow-map-front-faces.png" alt="阴影贴图的正面和背面版本。" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/point-shadow-map-back-faces.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/point-shadow-map-back-faces.png" alt="阴影贴图的正面和背面版本。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">阴影贴图的正面和背面版本。</figcaption></figure><p>请注意，将 <code class="language-plaintext highlighter-rouge">MeshRenderer</code> 的 Cast Shadows 模式设置为 Two Sided 的对象不受影响，因为它们的任何面都不会被剔除。例如，我让所有带有 clip 或透明材质的球体投射双面阴影，所以它们看起来更实心。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/two-sided-sphere-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/two-sided-sphere-shadows.png" alt="带有双面阴影的 clip 和透明球体。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">带有双面阴影的 clip 和透明球体。</figcaption></figure><h3 id="视野偏移"><span class="me-2">视野偏移</span><a href="#视野偏移" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>立方体贴图的面之间总是存在不连续性，因为纹理平面的方向突然改变 90°。常规立方体贴图采样可以在某种程度上隐藏这一点，因为它可以在面之间进行插值，但我们从每个片段的单个tiled采样。我们遇到了聚光阴影tiled边缘存在的相同问题，但现在它们没有被隐藏，因为没有聚光衰减。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/without-fov-bias-with-clamping.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/without-fov-bias-with-clamping.png" alt="面之间的不连续性，有和没有tiled约束。" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/without-fov-bias-without-claming.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/without-fov-bias-without-claming.png" alt="面之间的不连续性，有和没有tiled约束。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">面之间的不连续性，有和没有tiled约束。</figcaption></figure><p>我们可以通过在渲染阴影时稍微增加视野（FOV）来减少这些伪影，这样我们就永远不会在tiled边缘之外采样。这就是 <code class="language-plaintext highlighter-rouge">ComputePointShadowMatricesAndCullingPrimitives</code> 的偏移参数的作用。我们通过使距离光源距离 1 处的tiled大小略大于 2 来实现这一点。具体来说，我们在每一侧添加法线偏移加上过滤器大小。然后对应的半 FOV 角度的正切值等于 1 加上偏移和过滤器大小。将其加倍，转换为度数，减去 90°，并在 <code class="language-plaintext highlighter-rouge">RenderPointShadows</code> 中将其用于 FOV 偏移。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/fov-bias-diagram.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/fov-bias-diagram.png" alt="增加世界空间tiled大小。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">增加世界空间tiled大小。</figcaption></figure><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">fovBias</span> <span class="p">=</span>
    <span class="n">Mathf</span><span class="p">.</span><span class="nf">Atan</span><span class="p">(</span><span class="m">1f</span> <span class="p">+</span> <span class="n">bias</span> <span class="p">+</span> <span class="n">filterSize</span><span class="p">)</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">Rad2Deg</span> <span class="p">*</span> <span class="m">2f</span> <span class="p">-</span> <span class="m">90f</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">6</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="n">cullingResults</span><span class="p">.</span><span class="nf">ComputePointShadowMatricesAndCullingPrimitives</span><span class="p">(</span>
        <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="p">(</span><span class="n">CubemapFace</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="n">fovBias</span><span class="p">,</span>
        <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">viewMatrix</span><span class="p">,</span> <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">projectionMatrix</span><span class="p">,</span>
        <span class="k">out</span> <span class="n">ShadowSplitData</span> <span class="n">splitData</span>
    <span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp10/with-fov-bias.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp10/with-fov-bias.png" alt="使用 FOV 偏移。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">使用 FOV 偏移。</figcaption></figure><p>请注意，这种方法并不完美，因为通过增加tiled大小，纹素大小也会增加。因此，过滤器大小会增加，法线偏移也应该增加，这意味着我们必须再次增加 FOV。但是，差异通常足够小，我们可以忽略tiled大小的增加，除非结合使用大的法线偏移和过滤器与小的图集大小。</p><aside class="collapsible-aside"><h3>我们可以对聚光灯使用相同的方法吗？</h3><div><p>我们可以，这将使tiled约束不再需要一些额外的工作。但是，<code class="language-plaintext highlighter-rouge">ComputeSpotShadowMatricesAndCullingPrimitives</code> 没有 FOV 偏移参数，所以我们必须创建自己的变体，这超出了本教程的范围。</p></div></aside><hr /><p>下一个教程是后期处理<a href="../post-processing">Post Processing</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/scriptrenderpipeline/">ScriptRenderPipeline</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/srp/" class="post-tag no-text-decoration" >SRP</a> <a href="/tags/shadow/" class="post-tag no-text-decoration" >Shadow</a> <a href="/tags/point-light/" class="post-tag no-text-decoration" >Point Light</a> <a href="/tags/spot-light/" class="post-tag no-text-decoration" >Spot Light</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF:%E7%82%B9%E5%85%89%E6%BA%90%E4%B8%8E%E8%81%9A%E5%85%89%E7%81%AF%E9%98%B4%E5%BD%B1%20(%E7%BF%BB%E8%AF%91%E5%8D%81)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Fpoint-spot-light-shadow%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF:%E7%82%B9%E5%85%89%E6%BA%90%E4%B8%8E%E8%81%9A%E5%85%89%E7%81%AF%E9%98%B4%E5%BD%B1%20(%E7%BF%BB%E8%AF%91%E5%8D%81)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Fpoint-spot-light-shadow%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Fpoint-spot-light-shadow%2F&text=%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF:%E7%82%B9%E5%85%89%E6%BA%90%E4%B8%8E%E8%81%9A%E5%85%89%E7%81%AF%E9%98%B4%E5%BD%B1%20(%E7%BF%BB%E8%AF%91%E5%8D%81)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/particles/">粒子系统：颜色和深度纹理</a><li class="text-truncate lh-lg"> <a href="/posts/color-grading/">Unity自定义渲染管线13：色彩分级</a><li class="text-truncate lh-lg"> <a href="/posts/post-processing/">自定义渲染管线:后处理 (翻译十一)</a><li class="text-truncate lh-lg"> <a href="/posts/hdr/">自定义渲染管线:HDR (翻译十二)</a><li class="text-truncate lh-lg"> <a href="/posts/point-spot-light-shadow/">自定义渲染管线:点光源与聚光灯阴影 (翻译十)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/point-spot-lights/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1590919200" data-df="ll" > May 31, 2020 </time><h4 class="pt-0 my-2">自定义渲染管线:点光源与聚光灯 (翻译九)</h4><div class="text-muted"><p>扩展渲染管线以支持点光源和聚光灯，包含实时渲染和烘焙光照，同时实现每物体最多8个光源的限制。</p></div></div></a></article><article class="col"> <a href="/posts/particles/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1606406400" data-df="ll" > Nov 27, 2020 </time><h4 class="pt-0 my-2">粒子系统：颜色和深度纹理</h4><div class="text-muted"><p>深入探索Unity粒子系统的渲染技术，包括翻书动画、近距离淡入淡出、软粒子和扭曲效果的实现原理与实践。</p></div></div></a></article><article class="col"> <a href="/posts/multiple-camera/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1603641600" data-df="ll" > Oct 26, 2020 </time><h4 class="pt-0 my-2">自定义渲染管线:多摄像机渲染 (翻译十四)</h4><div class="text-muted"><p>深入探讨Unity自定义渲染管线中的多摄像机渲染技术，包括分屏渲染、摄像机混合以及渲染层遮罩的实现。</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/point-spot-lights/" class="btn btn-outline-primary" aria-label="Older" ><p>自定义渲染管线:点光源与聚光灯 (翻译九)</p></a> <a href="/posts/post-processing/" class="btn btn-outline-primary" aria-label="Newer" ><p>自定义渲染管线:后处理 (翻译十一)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
