<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="自定义管线:LOD和反射细节 (翻译七)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="使用LOD Groups。 LOD 级别之间的渐变淡入淡出。 通过采样反射探针来反射环境。 支持可选的菲涅尔反射。" /><meta property="og:description" content="使用LOD Groups。 LOD 级别之间的渐变淡入淡出。 通过采样反射探针来反射环境。 支持可选的菲涅尔反射。" /><link rel="canonical" href="www.damonc.top/posts/lod-reflections/" /><meta property="og:url" content="www.damonc.top/posts/lod-reflections/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/SRP/srp7/image_01.jpeg" /><meta property="og:image:alt" content="LOD 组和反射探针" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-03-30T00:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/SRP/srp7/image_01.jpeg" /><meta name="twitter:image:alt" content="LOD 组和反射探针" /><meta property="twitter:title" content="自定义管线:LOD和反射细节 (翻译七)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2020-03-30T00:00:00+08:00","datePublished":"2020-03-30T00:00:00+08:00","description":"使用LOD Groups。 LOD 级别之间的渐变淡入淡出。 通过采样反射探针来反射环境。 支持可选的菲涅尔反射。","headline":"自定义管线:LOD和反射细节 (翻译七)","image":{"lqip":"data:image/webp;base64,UklGRl4AAABXRUJQVlA4IFIAAACwAwCdASoUAAoAP3Ggxli0q6ejsAgCkC4JZwAAVOhsA2nIgrIeUAD56cL9RgDrQNF6QXSkbEzHPOLx5AussxbgG+jGtYoX7+WqdWk5iy2PQoAA","alt":"LOD 组和反射探针","url":"https://img.damonc.top/posts/SRP/srp7/image_01.jpeg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/lod-reflections/"},"url":"www.damonc.top/posts/lod-reflections/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>自定义管线:LOD和反射细节 (翻译七) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>自定义管线:LOD和反射细节 (翻译七)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>自定义管线:LOD和反射细节 (翻译七)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1585497600" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Mar 30, 2020 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/SRP/srp7/image_01.jpeg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/SRP/srp7/image_01.jpeg" alt="LOD 组和反射探针" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRl4AAABXRUJQVlA4IFIAAACwAwCdASoUAAoAP3Ggxli0q6ejsAgCkC4JZwAAVOhsA2nIgrIeUAD56cL9RgDrQNF6QXSkbEzHPOLx5AussxbgG+jGtYoX7+WqdWk5iy2PQoAA"></a><figcaption class="text-center pt-2 pb-2">LOD 组和反射探针</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/lod-reflections/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="5558 words" > <em>30 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">自定义管线:LOD和反射细节 (翻译七)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">自定义管线:LOD和反射细节 (翻译七)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>使用LOD Groups。<li>LOD 级别之间的渐变淡入淡出。<li>通过采样反射探针来反射环境。<li>支持可选的菲涅尔反射。</ul><hr /><h2 id="core-principles"><span class="me-2">Core Principles</span><a href="#core-principles" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>许多小型物体可以为场景增添细节，使其更加有趣。然而，太小而无法覆盖多个像素的细节会退化为模糊的噪点。在这些视觉尺度上，最好不渲染它们，这样也可以释放 CPU 和 GPU 来渲染更重要的东西。我们还可以决定在物体仍然可以区分时更早地剔除它们。这会进一步提高性能，但会导致物体根据其视觉大小突然弹出和消失。我们还可以添加中间步骤，在最终完全剔除物体之前，逐步切换到细节更少的可视化效果。Unity 通过使用 LOD 组来实现所有这些功能。</p><h3 id="lod-group-组件"><span class="me-2">LOD Group 组件</span><a href="#lod-group-组件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>你可以通过创建一个空游戏对象并为其添加 LODGroup 组件来向场景添加细节层次组。默认组定义了四个级别：LOD 0、LOD 1、LOD 2，最后是剔除，这意味着什么都不渲染。这些百分比代表估计视觉大小的阈值，相对于显示窗口尺寸。因此，LOD 0 用于覆盖窗口超过 60% 的物体，通常考虑垂直尺寸，因为这是最小的。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_02.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_02.png" alt="默认 LOD 组组件" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">默认 LOD 组组件</figcaption></figure><p>然而，Quality 项目设置部分包含一个 LOD Bias，用于缩放这些阈值。它默认设置为 2，这意味着它将估计的视觉大小翻倍。因此，LOD 0 最终用于超过 30% 而不是仅 60% 的所有物体。当偏差设置为除 1 以外的值时，组件的检视面板会显示警告。除此之外，还有一个 Maximum LOD Level 选项，可用于限制最高的 LOD 级别。例如，如果设置为 1，则 LOD 1 也会被使用，而不是 LOD 0。</p><p>这个想法是，你可以将所有表示 LOD 级别的游戏对象作为组对象的子对象。例如，我为三个 LOD 级别使用了三个相同大小的彩色球体。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_03.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_03.png" alt="包含三个球的 LOD 组" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">包含三个球的 LOD 组</figcaption></figure><p>每个物体必须分配到适当的 LOD 级别。你可以通过在组组件中选择一个级别块，然后将其拖动到其 Renderers 列表中，或者直接将其放到 LOD 级别块上来完成此操作。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_04.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_04.png" alt="LOD 0 的渲染器" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">LOD 0 的渲染器</figcaption></figure><p>Unity 会自动渲染适当的物体。在编辑器中选择特定物体会覆盖此行为，因此你可以在场景中看到你的选择。如果你选择了 LOD 组本身，编辑器还会指示当前哪个 LOD 级别是可见的。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_05.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_05.png" alt="带有 LOD 球体预制体实例的场景" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_06.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_06.png" alt="带有 LOD 球体预制体实例的场景" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">带有 LOD 球体预制体实例的场景</figcaption></figure><p>移动相机会改变每个组使用的 LOD 级别。或者，你可以调整 LOD 偏差以在保持其他所有内容相同的情况下看到可视化效果的变化。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_07.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_07.png" alt="调整 LOD 偏差" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">调整 LOD 偏差</figcaption></figure><h3 id="附加型-lod-组"><span class="me-2">附加型 LOD 组</span><a href="#附加型-lod-组" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>物体可以添加到多个 LOD 级别。你可以用它来为更高级别添加较小的细节，而相同较大的物体可用于多个级别。例如，我用堆叠的扁平立方体制作了一个三级金字塔。基础立方体是三个级别的一部分。中间立方体是 LOD 0 和 LOD 1 的一部分，而最小的顶部立方体只是 LOD 0 的一部分。因此，细节根据视觉大小添加到组中或从中移除，而不是替换整个物体。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_08.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_08.png" alt="堆叠立方体 LOD 组" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">堆叠立方体 LOD 组</figcaption></figure><aside class="collapsible-aside"><h3>LOD 组可以进行光照贴图吗？</h3><div><p>是的。当你让 LOD 组参与 GI 时，它确实会被包含在光照贴图中。LOD 0 会按预期用于光照贴图。其他 LOD 级别也会获得烘焙光照，但场景的其余部分只考虑 LOD 0。你也可以决定只烘焙某些级别，而让其他级别依赖光照探针。</p></div></aside><h3 id="lod-过渡"><span class="me-2">LOD 过渡</span><a href="#lod-过渡" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>LOD 级别的突然切换在视觉上可能很刺眼，特别是如果物体由于自身或相机的轻微移动而快速来回切换。可以将组的 Fade Mode 设置为 Cross Fade 来使过渡逐渐发生，这会使旧级别淡出同时新级别淡入。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_09.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_09.png" alt="交叉淡入淡出模式" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">交叉淡入淡出模式</figcaption></figure><aside class="collapsible-aside"><h3>Speed Tree 淡入淡出模式选项是什么？</h3><div><p>该模式专门用于 SpeedTree 树木，它使用自己的 LOD 系统来折叠树木并在 3D 模型和广告牌表示之间过渡。我们不会使用它。</p></div></aside><p>你可以控制每个 LOD 级别何时开始向下一级别交叉淡入。此选项在启用交叉淡入淡出时变得可见。Fade Transition Width 为零意味着此级别和下一较低级别之间没有淡入，而值为 1 意味着它立即开始淡入。在 0.5 处，使用默认设置，LOD 0 将在 80% 开始交叉淡入到 LOD 1。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_10.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_10.png" alt="淡入淡出过渡宽度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">淡入淡出过渡宽度</figcaption></figure><p>当交叉淡入淡出处于活动状态时，两个 LOD 级别会同时渲染。由着色器以某种方式混合它们来负责。Unity 为 LOD_FADE_CROSSFADE 关键字选择一个着色器变体，因此请将此多编译指令添加到我们的 Lit 着色器。为 CustomLit 和 ShadowCaster 这两个 Pass 都要添加。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma multi_compile _ LOD_FADE_CROSSFADE
</span></pre></table></code></div></div><p>物体淡出多少通过 UnityPerDraw 缓冲区的 unity_LODFade 向量传达，我们已经定义了它。它的 X 分量包含淡入淡出因子。Y 分量包含相同的因子，但量化为十六步，我们不会使用。让我们在 LitPassFragment 开头可视化淡入淡出因子（如果正在使用）。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">LitPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="k">return</span> <span class="n">unity_LODFade</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_11.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_11.png" alt="LOD 淡入淡出因子" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">LOD 淡入淡出因子</figcaption></figure><p>开始淡出的物体的因子从 1 开始减少到零，这是预期的。但我们也会看到代表更高 LOD 级别的纯黑色物体。发生这种情况是因为正在淡入的物体的淡入淡出因子被取反了。我们可以通过返回取反的淡入淡出因子来看到这一点。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="o">-</span><span class="n">unity_LODFade</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_12.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_12.png" alt="取反的淡入淡出因子" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">取反的淡入淡出因子</figcaption></figure><p>请注意，同时处于两个 LOD 级别的物体不会与自己进行交叉淡入淡出。</p><h3 id="抖动混合"><span class="me-2">抖动混合</span><a href="#抖动混合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了混合两个 LOD 级别，我们可以使用裁剪，采用与近似半透明阴影类似的方法。由于我们需要为表面及其阴影执行此操作，让我们为此在 Common 中添加一个 ClipLOD 函数。给它裁剪空间 XY 坐标和淡入淡出因子作为参数。然后——如果启用了交叉淡入淡出——根据淡入淡出因子减去抖动图案来裁剪。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ClipLOD</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">positionCS</span><span class="p">,</span> <span class="n">float</span> <span class="n">fade</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">float</span> <span class="n">dither</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nb">clip</span><span class="p">(</span><span class="n">fade</span> <span class="o">-</span> <span class="n">dither</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p>为了验证裁剪是否按预期工作，我们从每 32 像素重复的垂直渐变开始。这应该创建交替的水平条纹。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">dither</span> <span class="o">=</span> <span class="p">(</span><span class="n">positionCS</span><span class="p">.</span><span class="n">y</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
</pre></table></code></div></div><p>在 LitPassFragment 中调用 ClipLOD 而不是返回淡入淡出因子。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">//#if defined(LOD_FADE_CROSSFADE)</span>
<span class="c1">//    return unity_LODFade.x;</span>
<span class="c1">//#endif</span>
<span class="n">ClipLOD</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">unity_LODFade</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</pre></table></code></div></div><p>同时也在 ShadowCasterPassFragment 开头调用它来交叉淡入淡出阴影。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ShadowCasterPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="n">ClipLOD</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">unity_LODFade</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_13.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_13.png" alt="LOD 条纹，一半" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">LOD 条纹，一半</figcaption></figure><p>我们获得了条纹渲染，但交叉淡入淡出时只有两个 LOD 级别中的一个显示出来。这是因为两个中有一个具有负的淡入淡出因子。我们通过在这种情况下添加而不是减去抖动图案来修复它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">clip</span><span class="p">(</span><span class="n">fade</span> <span class="o">+</span> <span class="p">(</span><span class="n">fade</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="o">?</span> <span class="n">dither</span> <span class="o">:</span> <span class="o">-</span><span class="n">dither</span><span class="p">));</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_14.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_14.png" alt="LOD 条纹，完成" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">LOD 条纹，完成</figcaption></figure><p>既然它可以工作了，我们可以切换到适当的抖动图案。让我们选择与半透明阴影相同的那个。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">dither</span> <span class="o">=</span> <span class="n">InterleavedGradientNoise</span><span class="p">(</span><span class="n">positionCS</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_15.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_15.png" alt="抖动的 LOD" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">抖动的 LOD</figcaption></figure><h3 id="动画交叉淡入淡出"><span class="me-2">动画交叉淡入淡出</span><a href="#动画交叉淡入淡出" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然抖动创建了相当平滑的过渡，但图案很明显。就像半透明阴影一样，淡入淡出的阴影不稳定且分散注意力。理想情况下，交叉淡入淡出只是暂时的，即使那样没有其他变化。我们可以通过启用 LOD 组的 Animate Cross-fading 选项来实现。这会忽略淡入淡出过渡宽度，而是在组通过 LOD 阈值时快速交叉淡入淡出一次。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_16.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_16.png" alt="动画交叉淡入淡出" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">动画交叉淡入淡出</figcaption></figure><p>默认动画持续时间为半秒，可以通过设置静态 LODGroup.crossFadeAnimationDuration 属性为所有组更改此值。然而，在 Unity 2022 中，不在播放模式时过渡会更快。</p><hr /><h2 id="deep-analysis"><span class="me-2">Deep Analysis</span><a href="#deep-analysis" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="反射"><span class="me-2">反射</span><a href="#反射" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>另一个为场景增添细节和真实感的现象是环境镜面反射——其中镜子是最明显的例子——我们还没有支持这一点。这对于金属表面尤其重要，目前它们大多是黑色的。为了更明显这一点，我在烘焙光照场景中添加了更多具有不同颜色和光滑度的金属球体。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_17.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_17.png" alt="没有反射的场景" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">没有反射的场景</figcaption></figure><h3 id="间接-brdf"><span class="me-2">间接 BRDF</span><a href="#间接-brdf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们已经支持了漫反射全局光照，它取决于 BRDF 的漫反射颜色。现在我们添加镜面全局光照，它也取决于 BRDF。所以让我们在 BRDF 中添加一个 IndirectBRDF 函数，带有 surface 和 brdf 参数，加上从全局光照获得的漫反射和镜面反射颜色。最初让它只返回反射的漫反射光。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">IndirectBRDF</span> <span class="p">(</span>
    <span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">specular</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">diffuse</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>添加镜面反射开始时类似：简单地将 BRDF 的镜面反射颜色乘以的镜面反射 GI 包含在内。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">reflection</span> <span class="o">=</span> <span class="n">specular</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">specular</span><span class="p">;</span>
<span class="k">return</span> <span class="n">diffuse</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+</span> <span class="n">reflection</span><span class="p">;</span>
</pre></table></code></div></div><p>但是粗糙度会散射这个反射，所以它应该减少我们最终看到的镜面反射。我们通过将其除以平方粗糙度加一来实现。因此，低粗糙度值不太重要，而最大粗糙度会使反射减半。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">reflection</span> <span class="o">=</span> <span class="n">specular</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">specular</span><span class="p">;</span>
<span class="n">reflection</span> <span class="o">/=</span> <span class="n">brdf</span><span class="p">.</span><span class="n">roughness</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">roughness</span> <span class="o">+</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><p>在 GetLighting 中调用 IndirectBRDF 而不是直接计算漫反射间接光。从使用白色的镜面反射 GI 颜色开始。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">GI</span> <span class="n">gi</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowData</span> <span class="n">shadowData</span> <span class="o">=</span> <span class="n">GetShadowData</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
    <span class="n">shadowData</span><span class="p">.</span><span class="n">shadowMask</span> <span class="o">=</span> <span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">IndirectBRDF</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GetDirectionalLightCount</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Light</span> <span class="n">light</span> <span class="o">=</span> <span class="n">GetDirectionalLight</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">shadowData</span><span class="p">);</span>
        <span class="n">color</span> <span class="o">+=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">light</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_18.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_18.png" alt="反射白色环境" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">反射白色环境</figcaption></figure><p>一切都变得更亮了一些，因为我们添加了之前缺失的光照。对金属表面的变化是戏剧性的：它们的颜色现在明亮而明显。</p><h3 id="采样环境"><span class="me-2">采样环境</span><a href="#采样环境" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>镜面反射镜像环境，默认情况下是天空盒。它作为立方体贴图纹理通过 unity_SpecCube0 提供。在 GI 中声明它及其采样器状态，这次使用 TEXTURECUBE 宏。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">TEXTURECUBE</span><span class="p">(</span><span class="n">unity_SpecCube0</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">samplerunity_SpecCube0</span><span class="p">);</span>
</pre></table></code></div></div><p>然后添加一个 SampleEnvironment 函数，带有世界空间表面参数，采样纹理，并返回其 RGB 分量。我们通过 SAMPLE_TEXTURECUBE_LOD 宏采样立方体贴图，它接受贴图、采样器状态、UVW 坐标和 mip 级别作为参数。由于它是立方体贴图，我们需要 3D 纹理坐标，因此是 UVW。我们从始终使用最高 mip 级别开始，这样我们可以采样全分辨率纹理。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">SampleEnvironment</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">uvw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">environment</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURECUBE_LOD</span><span class="p">(</span>
        <span class="n">unity_SpecCube0</span><span class="p">,</span> <span class="n">samplerunity_SpecCube0</span><span class="p">,</span> <span class="n">uvw</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span>
    <span class="p">);</span>
    <span class="k">return</span> <span class="n">environment</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>使用方向采样立方体贴图，在这种情况下方向是从相机到表面的视图方向在表面法线上反射得到。我们通过使用负视图方向和表面法线作为参数调用 reflect 函数来获得它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">uvw</span> <span class="o">=</span> <span class="nb">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
</pre></table></code></div></div><p>接下来，在 GI 中添加镜面反射颜色并在 GetGI 中将采样的环境存储到其中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">GI</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">diffuse</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">specular</span><span class="p">;</span>
    <span class="n">ShadowMask</span> <span class="n">shadowMask</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="n">GI</span> <span class="nf">GetGI</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GI</span> <span class="n">gi</span><span class="p">;</span>
    <span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SampleLightMap</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">)</span> <span class="o">+</span> <span class="n">SampleLightProbe</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
    <span class="n">gi</span><span class="p">.</span><span class="n">specular</span> <span class="o">=</span> <span class="n">SampleEnvironment</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在我们可以在 GetLighting 中将正确的颜色传递给 IndirectBRDF。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">IndirectBRDF</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">gi</span><span class="p">.</span><span class="n">specular</span><span class="p">);</span>
</pre></table></code></div></div><p>最后，为了让它工作，我们必须指示 Unity 在设置每对象数据时包含反射探针，在 CameraRenderer.DrawVisibleGeometry 中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">perObjectData</span> <span class="o">=</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">ReflectionProbes</span> <span class="o">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">Lightmaps</span> <span class="o">|</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">ShadowMask</span> <span class="o">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbe</span> <span class="o">|</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">OcclusionProbe</span> <span class="o">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbeProxyVolume</span> <span class="o">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">OcclusionProbeProxyVolume</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_19.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_19.png" alt="反射环境探针" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">反射环境探针</figcaption></figure><p>表面现在反射环境。这对金属表面很明显，但其他表面也会反射它。由于它只是天空盒，没有其他东西被反射，但我们稍后会看到这一点。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_20.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_20.png" alt="环境探针" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">环境探针</figcaption></figure><h3 id="粗糙反射"><span class="me-2">粗糙反射</span><a href="#粗糙反射" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>由于粗糙度散射镜面反射，它不仅降低其强度，还会使其模糊，就像失焦一样。Unity 通过在较低 mip 级别存储模糊版本的环境贴图来近似这种效果。为了访问正确的 mip 级别，我们需要感知粗糙度，所以让我们将其添加到 BRDF 结构中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">BRDF</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">float</span> <span class="n">perceptualRoughness</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="n">BRDF</span> <span class="nf">GetBRDF</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">bool</span> <span class="n">applyAlphaToDiffuse</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">perceptualRoughness</span> <span class="o">=</span>
        <span class="n">PerceptualSmoothnessToPerceptualRoughness</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">smoothness</span><span class="p">);</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">roughness</span> <span class="o">=</span> <span class="n">PerceptualRoughnessToRoughness</span><span class="p">(</span><span class="n">brdf</span><span class="p">.</span><span class="n">perceptualRoughness</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">brdf</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们可以依赖 PerceptualRoughnessToMipmapLevel 函数来计算给定感知粗糙度的正确 mip 级别。它在 Core RP 库的 ImageBasedLighting 文件中定义。这要求我们为 SampleEnvironment 添加一个 BRDF 参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"</span><span class="cp">
</span><span class="p">...</span>
<span class="kt">float3</span> <span class="nf">SampleEnvironment</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">uvw</span> <span class="o">=</span> <span class="nb">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">mip</span> <span class="o">=</span> <span class="n">PerceptualRoughnessToMipmapLevel</span><span class="p">(</span><span class="n">brdf</span><span class="p">.</span><span class="n">perceptualRoughness</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">environment</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURECUBE_LOD</span><span class="p">(</span>
        <span class="n">unity_SpecCube0</span><span class="p">,</span> <span class="n">samplerunity_SpecCube0</span><span class="p">,</span> <span class="n">uvw</span><span class="p">,</span> <span class="n">mip</span>
    <span class="p">);</span>
    <span class="k">return</span> <span class="n">environment</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>同样在 GetGI 中添加必要的参数并传递它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">GI</span> <span class="nf">GetGI</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GI</span> <span class="n">gi</span><span class="p">;</span>
    <span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SampleLightMap</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">)</span> <span class="o">+</span> <span class="n">SampleLightProbe</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
    <span class="n">gi</span><span class="p">.</span><span class="n">specular</span> <span class="o">=</span> <span class="n">SampleEnvironment</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">,</span> <span class="n">brdf</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，在 LitPassFragment 中提供它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">GI</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">GetGI</span><span class="p">(</span><span class="n">GI_FRAGMENT_DATA</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">surface</span><span class="p">,</span> <span class="n">brdf</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_21.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_21.png" alt="粗糙度模糊反射" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">粗糙度模糊反射</figcaption></figure><h3 id="fresnel-反射"><span class="me-2">Fresnel 反射</span><a href="#fresnel-反射" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>所有表面都有一个特性：当以掠射角观察时，它们开始像完美镜子一样，因为光在它们上面几乎不受影响地反弹。这种现象称为 Fresnel 反射。实际上它更复杂，因为它涉及不同介质边界处光的透射和反射，但我们只使用与 Universal RP 相同的近似，即假设空气-固体边界。</p><p>我们使用 Schlick 近似的变体。它用纯白色替换理想情况下的镜面反射 BRDF 颜色，但粗糙度可以防止反射显示出来。我们通过将表面光滑度和反射率加在一起，最终颜色不超过 1 来到达最终颜色。由于它是灰度值，我们可以为它在 BRDF 中添加一个值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">BRDF</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">float</span> <span class="n">fresnel</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="n">BRDF</span> <span class="nf">GetBRDF</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">bool</span> <span class="n">applyAlphaToDiffuse</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">fresnel</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">smoothness</span> <span class="o">+</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">oneMinusReflectivity</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">brdf</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 IndirectBRDF 中，我们通过获取表面法线和视图方向的点积，从 1 中减去它，并将结果提升到第四次方来找到 Fresnel 效果的强度。我们可以使用 Core RP 库中的便捷 Pow4 函数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">fresnelStrength</span> <span class="o">=</span>
    <span class="n">Pow4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">)));</span>
<span class="kt">float3</span> <span class="n">reflection</span> <span class="o">=</span> <span class="n">specular</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">specular</span><span class="p">;</span>
</pre></table></code></div></div><p>然后我们根据强度在 BRDF 镜面反射和 fresnel 颜色之间进行插值，然后使用结果来着色环境反射。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">reflection</span> <span class="o">=</span>
    <span class="n">specular</span> <span class="o">*</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">brdf</span><span class="p">.</span><span class="n">specular</span><span class="p">,</span> <span class="n">brdf</span><span class="p">.</span><span class="n">fresnel</span><span class="p">,</span> <span class="n">fresnelStrength</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_22.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_22.png" alt="Fresnel 反射" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Fresnel 反射</figcaption></figure><h3 id="fresnel-滑块"><span class="me-2">Fresnel 滑块</span><a href="#fresnel-滑块" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Fresnel 反射主要沿着几何体的边缘添加反射。当环境贴图正确匹配物体后面的颜色时效果很微妙，但如果不是这种情况，反射可能会显得奇怪且分散注意力。结构内部球体边缘的明亮反射就是一个很好的例子。降低光滑度可以消除 Fresnel 反射，但也会使整个表面变暗。此外，在某些情况下 Fresnel 近似不合适，例如水下。所以让我们添加一个滑块来缩小它在 Lit 着色器中的效果。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">_Metallic</span> <span class="p">(</span><span class="s">"Metallic"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_Smoothness</span> <span class="p">(</span><span class="s">"Smoothness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span>
<span class="n">_Fresnel</span> <span class="p">(</span><span class="s">"Fresnel"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
</pre></table></code></div></div><p>将其添加到 LitInput 中的 UnityPerMaterial 缓冲区，并为其创建一个 GetFresnel 函数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Fresnel</span><span class="p">)</span>
    <span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">float</span> <span class="nf">GetFresnel</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Fresnel</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>同时在 UnlitInput 中为其添加一个虚拟函数，以保持它们同步。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetFresnel</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Surface 现在为其 Fresnel 强度添加一个字段。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Surface</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">float</span> <span class="n">smoothness</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">fresnelStrength</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">dither</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>我们在 LitPassFragment 中将其设置为等于滑块属性的值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">surface</span><span class="p">.</span><span class="n">smoothness</span> <span class="o">=</span> <span class="n">GetSmoothness</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
<span class="n">surface</span><span class="p">.</span><span class="n">fresnelStrength</span> <span class="o">=</span> <span class="n">GetFresnel</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
</pre></table></code></div></div><p>最后，使用它在 IndirectBRDF 中缩放我们使用的 Fresnel 强度。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">fresnelStrength</span> <span class="o">=</span> <span class="n">surface</span><span class="p">.</span><span class="n">fresnelStrength</span> <span class="o">*</span>
    <span class="nf">Pow4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">)));</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_23.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_23.png" alt="调整 Fresnel 强度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">调整 Fresnel 强度</figcaption></figure><h3 id="反射探针"><span class="me-2">反射探针</span><a href="#反射探针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>默认环境立方体贴图只包含天空盒。为了反射场景中的任何其他东西，我们可以通过 GameObject / Light / Reflection Probe 向其添加反射探针。这些探针从它们的位置将场景渲染到立方体贴图中。因此，反射只会在接近探针的表面上显得比较正确。因此，通常需要在场景中放置多个探针。它们具有 Importance 和 Box Size 属性，可用于控制每个探针影响的区域。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_24.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_24.png" alt="结构内部的反射探针" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">结构内部的反射探针</figcaption></figure><p>探针的 Type 默认设置为 Baked，这意味着它被渲染一次，立方体贴图存储在构建中。你也可以将其设置为 Realtime，这会保持贴图与动态场景同步。它就像任何其他相机一样被渲染，使用我们的 RP，每个立方体贴图的六个面渲染一次。因此，实时反射探针非常昂贵。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_25.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_25.png" alt="使用三个反射探针" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">使用三个反射探针</figcaption></figure><p>每个对象只使用单个环境探针，但场景中可以有多个探针。因此，你可能需要拆分对象以获得可接受的反射。例如，用于构建结构的立方体理想情况下应该拆分为单独的内部和外部部分，这样每个都可以使用不同的反射探针。这也意味着 GPU 批处理会被反射探针分解。不幸的是，网格球根本无法使用反射探针，始终只得到天空盒。</p><p>MeshRenderer 组件有一个 Anchor Override，可用于微调它们使用的探针，而不必担心盒子大小和位置。还有一个 Reflection Probes 选项，默认设置为 Blend Probes。Unity 允许在两个最重要的反射探针之间进行混合。但是，此模式与 SRP 批量处理器不兼容，因此 Unity 的其他 RP 不支持它，我们也不会。支持它的方式在我的 2018 年 SRP 教程的 Reflections 教程中有解释，但我预计一旦旧管线被移除，此功能就会消失。我们将在未来研究其他反射技术。因此，只有两种功能模式：Off（始终使用天空盒）和 Simple（选择最重要的探针）。其他功能与 Simple 完全一样。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp7/image_26.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp7/image_26.png" alt="选择简单反射探针模式" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">选择简单反射探针模式</figcaption></figure><p>除此之外，反射探针还有启用盒投影模式的选项。这应该会改变反射的确定方式，以更好地匹配其有限的影响区域，但这也与 SRP 批量处理器不兼容，所以我们也不会支持它。</p><h3 id="解码探针"><span class="me-2">解码探针</span><a href="#解码探针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>最后，我们必须确保正确解释来自立方体贴图的数据。它可能是 HDR 或 LDR，其强度也可以调整。这些设置通过 unity_SpecCube0_HDR 向量提供，它在 UnityPerDraw 缓冲区中位于 unity_ProbesOcclusion 之后。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityPerDraw</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="kt">float4</span> <span class="n">unity_ProbesOcclusion</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_SpecCube0_HDR</span><span class="p">;</span>
    <span class="p">...</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>我们通过在 SampleEnvironment 末尾使用原始环境数据和设置作为参数调用 DecodeHDREnvironment 来获得正确的颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">SampleEnvironment</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">DecodeHDREnvironment</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">unity_SpecCube0_HDR</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h2 id="practical-implementation"><span class="me-2">Practical Implementation</span><a href="#practical-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>本教程中我们实现的关键功能：</p><ol><li><strong>LOD Groups</strong>: 使用 <code class="language-plaintext highlighter-rouge">LODGroup</code> 组件管理不同细节级别的物体切换<li><strong>Cross-Fade</strong>: 通过 <code class="language-plaintext highlighter-rouge">LOD_FADE_CROSSFADE</code> 关键字和 <code class="language-plaintext highlighter-rouge">ClipLOD</code> 函数实现平滑过渡<li><strong>环境反射</strong>: 通过 <code class="language-plaintext highlighter-rouge">unity_SpecCube0</code> 立方体贴图采样实现<li><strong>Fresnel 效果</strong>: 使用 Schlick 近似实现掠射角的镜面反射增强<li><strong>反射探针</strong>: 支持在场景中添加多个探针来捕捉环境</ol><hr /><h2 id="advanced-topics"><span class="me-2">Advanced Topics</span><a href="#advanced-topics" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="性能优化建议"><span class="me-2">性能优化建议</span><a href="#性能优化建议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>LOD 过渡应尽量使用动画交叉淡入淡出，避免抖动模式产生的视觉噪点<li>实时反射探针非常昂贵，谨慎使用<li>金属表面强烈依赖反射，非金属表面主要显示漫反射</ul><h3 id="扩展方向"><span class="me-2">扩展方向</span><a href="#扩展方向" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>后续教程将介绍复杂贴图（Complex Maps）<li>可以研究探针混合技术<li>盒投影模式（需要 SRP 批量处理器支持）</ul><hr /><p>下一个教程<a href="../complex-maps">Complex Maps - 复杂贴图</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/scriptrenderpipeline/">ScriptRenderPipeline</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/srp/" class="post-tag no-text-decoration" >SRP</a> <a href="/tags/reflection/" class="post-tag no-text-decoration" >Reflection</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:LOD%E5%92%8C%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%20(%E7%BF%BB%E8%AF%91%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Flod-reflections%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:LOD%E5%92%8C%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%20(%E7%BF%BB%E8%AF%91%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Flod-reflections%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Flod-reflections%2F&text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:LOD%E5%92%8C%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%20(%E7%BF%BB%E8%AF%91%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/particles/">粒子系统：颜色和深度纹理</a><li class="text-truncate lh-lg"> <a href="/posts/color-grading/">Unity自定义渲染管线13：色彩分级</a><li class="text-truncate lh-lg"> <a href="/posts/post-processing/">自定义渲染管线:后处理 (翻译十一)</a><li class="text-truncate lh-lg"> <a href="/posts/hdr/">自定义渲染管线:HDR (翻译十二)</a><li class="text-truncate lh-lg"> <a href="/posts/point-spot-light-shadow/">自定义渲染管线:点光源与聚光灯阴影 (翻译十)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/particles/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1606406400" data-df="ll" > Nov 27, 2020 </time><h4 class="pt-0 my-2">粒子系统：颜色和深度纹理</h4><div class="text-muted"><p>深入探索Unity粒子系统的渲染技术，包括翻书动画、近距离淡入淡出、软粒子和扭曲效果的实现原理与实践。</p></div></div></a></article><article class="col"> <a href="/posts/multiple-camera/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1603641600" data-df="ll" > Oct 26, 2020 </time><h4 class="pt-0 my-2">自定义渲染管线:多摄像机渲染 (翻译十四)</h4><div class="text-muted"><p>深入探讨Unity自定义渲染管线中的多摄像机渲染技术，包括分屏渲染、摄像机混合以及渲染层遮罩的实现。</p></div></div></a></article><article class="col"> <a href="/posts/color-grading/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1601344800" data-df="ll" > Sep 29, 2020 </time><h4 class="pt-0 my-2">Unity自定义渲染管线13：色彩分级</h4><div class="text-muted"><p>通过色彩分级调整图像的颜色，复制 URP/HDRP 的多种色彩分级工具，并使用色彩查找表（LUT）来优化性能。</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/shadow-masks/" class="btn btn-outline-primary" aria-label="Older" ><p>自定义管线:Shadow Masks (翻译六)</p></a> <a href="/posts/complex-maps/" class="btn btn-outline-primary" aria-label="Newer" ><p>自定义管线:遮罩、细节与法线贴图 (翻译八)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
