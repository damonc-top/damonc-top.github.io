<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="曲面细分表面置换(翻译二十三)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="在 GPU 上调整顶点位置。 细分阴影几何体。 跳过细分不可见的三角形。" /><meta property="og:description" content="在 GPU 上调整顶点位置。 细分阴影几何体。 跳过细分不可见的三角形。" /><link rel="canonical" href="www.damonc.top/posts/unity-surface-displacement/" /><meta property="og:url" content="www.damonc.top/posts/unity-surface-displacement/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/2018/month1/catRender23/01-create-surface-details.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-01-28T09:12:01+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/2018/month1/catRender23/01-create-surface-details.jpg" /><meta property="twitter:title" content="曲面细分表面置换(翻译二十三)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2018-01-28T09:12:01+08:00","datePublished":"2018-01-28T09:12:01+08:00","description":"在 GPU 上调整顶点位置。 细分阴影几何体。 跳过细分不可见的三角形。","headline":"曲面细分表面置换(翻译二十三)","image":{"lqip":"data:image/webp;base64,UklGRlAAAABXRUJQVlA4IEQAAADwAgCdASoUAAoAP3Gixlk0rCejsAgCkC4JYwC/OAVSAAD5rg9Kar5JE2RA0spkrdTu3bnfVH5Xjh/RhxJfwm+tgQAAAA==","url":"https://img.damonc.top/posts/2018/month1/catRender23/01-create-surface-details.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/unity-surface-displacement/"},"url":"www.damonc.top/posts/unity-surface-displacement/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>曲面细分表面置换(翻译二十三) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘摊手</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>曲面细分表面置换(翻译二十三)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>曲面细分表面置换(翻译二十三)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1517101921" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jan 28, 2018 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/01-create-surface-details.jpg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/2018/month1/catRender23/01-create-surface-details.jpg" alt="Preview Image" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRlAAAABXRUJQVlA4IEQAAADwAgCdASoUAAoAP3Gixlk0rCejsAgCkC4JYwC/OAVSAAD5rg9Kar5JE2RA0spkrdTu3bnfVH5Xjh/RhxJfwm+tgQAAAA=="></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/unity-surface-displacement/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="7249 words" > <em>40 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">曲面细分表面置换(翻译二十三)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">曲面细分表面置换(翻译二十三)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>在 GPU 上调整顶点位置。<li>细分阴影几何体。<li>跳过细分不可见的三角形。</ul><hr /><h2 id="1-重定位顶点"><span class="me-2">1 重定位顶点</span><a href="#1-重定位顶点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>网格通常由三角形组成，而三角形总是平坦的。曲率的错觉是通过顶点法线添加的。法线贴图可用于添加更多表面不规则的错觉，这些不规则比单个网格三角形还要小。除此之外，视差贴图（Parallax Mapping）使得伪造表面置换成为可能。但所有这些方法都是错觉。使表面更复杂的所谓“最稳健”的方法就是简单地使用更多更小的三角形。更小的三角形意味着我们有更多的顶点，足以描述我们想要的所有表面细节。不幸的是，这将导致更大的网格，需要更多的存储空间、CPU 和 GPU 内存以及内存带宽。曲面细分是解决这个问题的一种方法，因为它允许我们在需要时在 GPU 上生成更多三角形。这意味着 GPU 必须做更多的工作，但我们可以将其限制在真正需要的时候。</p><p>仅仅切割现有的三角形并插值顶点数据不足以添加更多细节。这只是给了我们更多描述相同平坦表面的三角形。我们必须引入新数据，以某种方式调整三角形的顶点。</p><p>添加更多细节的一个直接方法是通过置换贴图（Displacement Map）调整网格的顶点。该贴图用于向上或向下移动顶点，就像高度场（Height Field）可用于将平坦的地形网格变成实际的景观一样。本教程将介绍如何做到这一点。</p><h3 id="11-劫持视差贴图"><span class="me-2">1.1 劫持视差贴图</span><a href="#11-劫持视差贴图" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要置换顶点，我们需要一个置换贴图。虽然我们的 Tessellation Shader 没有这样一个贴图的属性，但它有一个我们在<a href="https://www.damonc.top/posts/unity-parallax-normals-heightmap/">视差贴图</a>教程中使用的视差贴图。视差贴图实际上就是一个置换贴图，只是我们用它来伪造置换。我们也可以将同一个贴图用于实际的置换。</p><p>假设一个 Shader 可以决定使用真正的顶点置换而不是视差贴图，只需定义 <code class="language-plaintext highlighter-rouge">VERTEX_DISPLACEMENT_INSTEAD_OF_PARALLAX</code> 即可。如果定义了该宏并且我们有视差贴图，那么我们必须确保不包含视差代码，而是将其替换为适当的顶点置换代码。为此，当我们有视差贴图且应该使用顶点置换时，在 <code class="language-plaintext highlighter-rouge">My Lighting Input</code> 中取消定义 <code class="language-plaintext highlighter-rouge">_PARALLAX_MAP</code> 并定义一个方便的 <code class="language-plaintext highlighter-rouge">VERTEX_DISPLACEMENT</code> 宏。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="err">#</span><span class="n">include</span> <span class="s">"UnityPBSLighting.cginc"</span>
<span class="err">#</span><span class="n">include</span> <span class="s">"AutoLight.cginc"</span>

<span class="cp">#if defined(_PARALLAX_MAP) &amp;&amp; defined(VERTEX_DISPLACEMENT_INSTEAD_OF_PARALLAX)
</span>    <span class="err">#</span><span class="n">undef</span> <span class="n">_PARALLAX_MAP</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">VERTEX_DISPLACEMENT</span> <span class="m">1</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>让我们也为 <code class="language-plaintext highlighter-rouge">_ParallaxMap</code> 和 <code class="language-plaintext highlighter-rouge">_ParallaxStrength</code> 变量创建宏别名，这样我们可以使用 <code class="language-plaintext highlighter-rouge">_DisplacementMap</code> 和 <code class="language-plaintext highlighter-rouge">_DisplacementStrength</code> 代替。这使得以后如果你想摆脱视差代码并切换到适当的置换属性时更容易。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_PARALLAX_MAP) &amp;&amp; defined(VERTEX_DISPLACEMENT_INSTEAD_OF_PARALLAX)
</span>    <span class="err">#</span><span class="n">undef</span> <span class="n">_PARALLAX_MAP</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">VERTEX_DISPLACEMENT</span> <span class="m">1</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">_DisplacementMap</span> <span class="n">_ParallaxMap</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">_DisplacementStrength</span> <span class="n">_ParallaxStrength</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>由于我们不会同时使用视差贴图和曲面细分，我们可以在 Tessellation Shader 的 <code class="language-plaintext highlighter-rouge">CGINCLUDE</code> 块中删除所有与视差相关的定义。相反，我们只需要定义 <code class="language-plaintext highlighter-rouge">VERTEX_DISPLACEMENT_INSTEAD_OF_PARALLAX</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">CGINCLUDE</span>

<span class="cp">#define BINORMAL_PER_FRAGMENT
#define FOG_DISTANCE
</span>
<span class="c1">// #define PARALLAX_BIAS 0</span>
<span class="c1">// #define PARALLAX_OFFSET_LIMITING</span>
<span class="c1">// #define PARALLAX_RAYMARCHING_STEPS 10</span>
<span class="c1">// #define PARALLAX_RAYMARCHING_INTERPOLATE</span>
<span class="c1">// #define PARALLAX_RAYMARCHING_SEARCH_STEPS 3</span>
<span class="c1">// #define PARALLAX_FUNCTION ParallaxRaymarching</span>
<span class="c1">// #define PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING</span>

<span class="cp">#define VERTEX_DISPLACEMENT_INSTEAD_OF_PARALLAX
</span>
<span class="n">ENDCG</span>
</pre></table></code></div></div><p>我们将在对象空间（Object Space）中执行顶点置换。为了允许相当数量的置换，将最大强度从 0.1 增加到 1。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">_ParallaxStrength</span> <span class="p">(</span><span class="s">"Parallax Strength"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/02-parallax-map-strength-1.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/02-parallax-map-strength-1.png" alt="Parallax map with strength set to 1" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="12-改变顶点位置"><span class="me-2">1.2 改变顶点位置</span><a href="#12-改变顶点位置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>置换顶点必须在 <code class="language-plaintext highlighter-rouge">My Lighting</code> 的顶点程序中完成，在我们使用顶点位置做任何其他事情之前。这意味着如果我们想支持像所有其他贴图一样缩放和偏移置换贴图，我们必须在此点之前转换纹理坐标。所以让我们将 <code class="language-plaintext highlighter-rouge">TRANSFORM_TEX</code> 行移动到第一次使用顶点位置之前。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="nf">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">InterpolatorsVertex</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="nf">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="nf">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="p">=</span> <span class="nf">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="p">=</span> <span class="nf">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">);</span>

    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="p">=</span> <span class="nf">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">FOG_DEPTH</span>
        <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">w</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="n">i</span><span class="p">.</span><span class="n">normal</span> <span class="p">=</span> <span class="nf">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>

    <span class="err">#</span><span class="k">if</span> <span class="nf">defined</span><span class="p">(</span><span class="n">BINORMAL_PER_FRAGMENT</span><span class="p">)</span>
        <span class="n">i</span><span class="p">.</span><span class="n">tangent</span> <span class="p">=</span> <span class="nf">float4</span><span class="p">(</span><span class="nf">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">),</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="err">#</span><span class="k">else</span>
        <span class="n">i</span><span class="p">.</span><span class="n">tangent</span> <span class="p">=</span> <span class="nf">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">binormal</span> <span class="p">=</span> <span class="nf">CreateBinormal</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">tangent</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="err">#</span><span class="n">endif</span>

    <span class="c1">// i.uv.xy = TRANSFORM_TEX(v.uv, _MainTex);</span>
    <span class="c1">// i.uv.zw = TRANSFORM_TEX(v.uv, _DetailTex);</span>

    <span class="err">…</span>
<span class="p">}</span>
</pre></table></code></div></div><p>一旦我们有了最终的纹理坐标，我们就可以采样置换贴图。这与采样视差贴图相同，所以我们将使用它的绿色纹理通道。但是，因为我们不是在片元程序中这样做，所以没有屏幕空间导数（Screen-space Derivatives）可用，因此 GPU 无法确定使用哪个 Mipmap 级别。我们不能使用 <code class="language-plaintext highlighter-rouge">tex2D</code>，而必须使用 <code class="language-plaintext highlighter-rouge">tex2Dlod</code> 来指定显式 Mip 级别。这是通过提供两个额外的纹理坐标来完成的，第三个是未使用的 3D 坐标，第四个指定 Mip 级别。我们将对两者都使用 0，实际上不使用 Mipmaps。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="p">=</span> <span class="nf">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">zw</span> <span class="p">=</span> <span class="nf">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_DetailTex</span><span class="p">);</span>

    <span class="err">#</span><span class="k">if</span> <span class="n">VERTEX_DISPLACEMENT</span>
        <span class="kt">float</span> <span class="n">displacement</span> <span class="p">=</span> <span class="nf">tex2Dlod</span><span class="p">(</span><span class="n">_DisplacementMap</span><span class="p">,</span> <span class="nf">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)).</span><span class="n">g</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
</pre></table></code></div></div><p>就像我们对视差贴图所做的那样，让我们解释贴图，使 0.5 的值意味着没有变化，从而可以向上和向下移动顶点。之后，计入置换强度，以便我们可以控制顶点在对象空间中移动的程度。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="err">#</span><span class="k">if</span> <span class="n">VERTEX_DISPLACEMENT</span>
        <span class="kt">float</span> <span class="n">displacement</span> <span class="p">=</span> <span class="nf">tex2Dlod</span><span class="p">(</span><span class="n">_DisplacementMap</span><span class="p">,</span> <span class="nf">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)).</span><span class="n">g</span><span class="p">;</span>
        <span class="n">displacement</span> <span class="p">=</span> <span class="p">(</span><span class="n">displacement</span> <span class="p">-</span> <span class="m">0.5</span><span class="p">)</span> <span class="p">*</span> <span class="n">_DisplacementStrength</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
</pre></table></code></div></div><p>如果我们使用默认的高度场，那么我们只需在此点将置换添加到顶点 Y 位置。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>        <span class="kt">float</span> <span class="n">displacement</span> <span class="p">=</span> <span class="nf">tex2Dlod</span><span class="p">(</span><span class="n">_DisplacementMap</span><span class="p">,</span> <span class="nf">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)).</span><span class="n">g</span><span class="p">;</span>
        <span class="n">displacement</span> <span class="p">=</span> <span class="p">(</span><span class="n">displacement</span> <span class="p">-</span> <span class="m">0.5</span><span class="p">)</span> <span class="p">*</span> <span class="n">_DisplacementStrength</span><span class="p">;</span>
        <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">y</span> <span class="p">+=</span> <span class="n">displacement</span><span class="p">;</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/03-quad-vertices-displaced-y.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/03-quad-vertices-displaced-y.png" alt="Quad vertices displaced along Y" width="100%" height="auto" loading="lazy"></a></div></div><p>当将此方法应用于 Quad 时，结果看起来像一团乱七八糟的三角形，但仍然是平坦的。这是因为 Quad 在对象空间中与 XY 平面对齐。如果我们想扰动其原本平坦的表面，我们必须调整其 Z 坐标。一般来说，从网格的角度来看，正置换应该向上移动顶点。但并非所有网格都是平面。在球体的情况下，置换向外移动顶点是有意义的。所以通常最合理的做法是沿顶点法线进行置换。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>        <span class="c1">// v.vertex.y += displacement;</span>
        <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span> <span class="p">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="p">*</span> <span class="n">displacement</span><span class="p">;</span>
</pre></table></code></div></div><p>因为我们使用的是曲面细分，新顶点的法线向量是通过插值创建的。所以只有当所有顶点法线具有相同的方向时，它们才保证是单位长度的。为了保证我们通常获得单位长度的法线向量，我们在使用它们进行置换之前应该将它们归一化。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>        <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="p">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span> <span class="p">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="p">*</span> <span class="n">displacement</span><span class="p">;</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/04-displacement-along-normal.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/04-displacement-along-normal.png" alt="Displacement along normal vector" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="13-使用足够的三角形"><span class="me-2">1.3 使用足够的三角形</span><a href="#13-使用足够的三角形" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>支持所需的细节级别需要多少三角形？这取决于情况。我们在全强度下的置换贴图产生了相当大的变化，所以我们需要相当多的三角形才能使其看起来不错。但我们不想使用比我们需要的更多的三角形，所以我们应该使用 Edge 曲面细分模式而不是 Uniform 模式。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/05-variable-tessellation-quad.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/05-variable-tessellation-quad.png" alt="Variable tessellation of a quad" width="100%" height="auto" loading="lazy"></a></div></div><p>处于 Edge 模式时，曲面细分由 Edge Length 属性和视图距离控制。所以使用的三角形数量可能会有很大差异。一个 Quad 本身只包含两个三角形。我们需要大量的曲面细分才能获得比低多边形锯齿平面更好的东西。我们可以通过使用具有更多三角形的基础网格来大大帮助曲面细分。例如，Unity 的默认平面网格由 10×10 个 Quad 组成。使用它而不是 Quad 可以防止完全退化，如果需要，也可以产生比 Quad 高得多的顶点分辨率。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/06-variable-tessellation-plane.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/06-variable-tessellation-plane.png" alt="Variable tessellation of a plane" width="100%" height="auto" loading="lazy"></a></div></div><p>使用平面代替 Quad 允许更微调的曲面细分，这使得更容易从所有视角实现视觉上均匀的三角形密度。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/07-shallow-view-angle.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/07-shallow-view-angle.png" alt="Shallow view angle, uniform triangle density" width="100%" height="auto" loading="lazy"></a></div></div><p>然而，这仍然不能保证所有三角形最终具有相同的视觉大小。细分的三角形仅在其顶点被置换之前大约是相同的大小。如果三角形的顶点最终被不同程度地置换，它将沿法线向量被拉伸。通常，顶点置换并不像我们在本教程中使用的示例那样极端。如果你将其用于地形网格，常规网格应该有足够的分辨率来表示地形的大特征。如果你使用平坦网格作为地形的基础，请考虑在确定曲面细分因子之前置换原始顶点，以便在细分时将粗略的高程考虑在内。</p><h3 id="14-法线着色"><span class="me-2">1.4 法线着色</span><a href="#14-法线着色" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>到目前为止，我们一直在使用平坦线框着色效果，以使其在视觉上明显地显示三角形是如何被细分的。但大多数时候，目标是在没有明显曲面细分的情况下增强网格。所以让我们恢复到默认的着色方法。我们通过从 Tessellation Shader 的 forward base、additive 和 deferred 通道中删除几何着色器指令来做到这一点。我们还必须在相同的通道中用 <code class="language-plaintext highlighter-rouge">My Lighting</code> 替换 <code class="language-plaintext highlighter-rouge">MyFlatWireframe</code> 包含文件的使用。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// #pragma geometry MyGeometryProgram</span>
<span class="err">…</span>
<span class="c1">// #include "MyFlatWireframe.cginc"</span>
<span class="err">#</span><span class="n">include</span> <span class="s">"My Lighting.cginc"</span>
<span class="err">#</span><span class="n">include</span> <span class="s">"MyTessellation.cginc"</span>
</pre></table></code></div></div><p>随着平坦线框效果的移除，我们也不再需要线框属性了。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// _WireframeColor ("Wireframe Color", Color) = (0, 0, 0)</span>
<span class="c1">// _WireframeSmoothing ("Wireframe Smoothing", Range(0, 10)) = 1</span>
<span class="c1">// _WireframeThickness ("Wireframe Thickness", Range(0, 10)) = 1</span>
</pre></table></code></div></div><p>我们现在回到了正常的着色，结果看起来很平坦。这是因为我们置换了顶点位置，但没有调整顶点法线以匹配。确切的最终结果取决于你是使用 forward 还是 deferred 渲染路径。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/08-forward-and-deferred.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/08-forward-and-deferred.png" alt="Forward and deferred rendering" width="100%" height="auto" loading="lazy"></a></div></div><p>渲染路径之间的视觉差异是由于阴影造成的。我们还没有为阴影做任何特殊处理，所以我们得到了平面的默认阴影。在 forward 渲染的情况下，用于屏幕空间阴影的深度通道和阴影投射都是用这个平面完成的。所以我们的平面最终没有投射阴影给自己。在 deferred 渲染的情况下，细分的几何体用于填充 G-buffer，包括深度缓冲。所以向下置换的细分几何体最终被平坦平面的阴影所遮挡。我们将在下一节处理阴影，所以现在我将使用 forward 渲染路径。</p><p>为了让我们的置换表面获得正确的着色，我们必须使用正确的法线向量。幸运的是，我们有一个与视差贴图匹配的法线贴图，所以我们可以直接使用它。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/09-with-normal-map.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/09-with-normal-map.png" alt="With normal map" width="100%" height="auto" loading="lazy"></a></div></div><p>这种方法适用于任何网格，但重要的是没有纹理接缝。任何接缝都会导致不连续性。如果我们只使用法线贴图，这将导致着色中的伪影，暗示在不应该有硬边的地方出现了硬边。在置换的情况下，它会导致网格中的间隙，这要糟糕得多。要看到这一点的一个好例子是，将我们的曲面细分材质应用于默认球体并检查其极点。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/10-displacing-sphere-gaps.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/10-displacing-sphere-gaps.png" alt="Displacing sphere vertices creates gaps" width="100%" height="auto" loading="lazy"></a></div></div><blockquote><p><strong>我们怎样才能让它适用于球体？</strong> 你必须使用一种没有不连续性的置换贴图方法。例如，你可以使用立方体贴图（Cubemap）而不是经纬度贴图。</p></blockquote><p>此时，我们已经通过曲面细分完成了一个置换效果，取代了之前教程中的视差效果。曲面细分相对于视差贴图的一大优势是它与其他所有东西都能很好地配合，因为它只是三角形。所有适用于常规三角形的技术都适用，并且它与其他几何体正确相交。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/11-tessellated-geometry-intersects.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/11-tessellated-geometry-intersects.png" alt="Tessellated geometry intersects correctly" width="100%" height="auto" loading="lazy"></a></div></div><h2 id="2-阴影"><span class="me-2">2 阴影</span><a href="#2-阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>目前，阴影的表现就像我们的平面仍然是平坦的一样。只有在使用 deferred 渲染时，置换的几何体才被用于接收阴影，但投射的阴影仍然是平坦的。我们现在要确保障阴影与置换表面匹配。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/12-incorrect-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/12-incorrect-shadows.png" alt="Incorrect shadows, forward and deferred" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="21-带曲面细分的-shadow-caster-pass"><span class="me-2">2.1 带曲面细分的 Shadow Caster Pass</span><a href="#21-带曲面细分的-shadow-caster-pass" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要使阴影工作，我们要做的第一件事是为 Shadow Caster Pass 启用曲面细分。这意味着此通道的 Shader Target 级别必须增加到 4.6。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma target 4.6
</span></pre></table></code></div></div><p>由于我们的置换方法使用视差贴图，我们必须为其添加适当的 Shader Feature，还要为 Edge 曲面细分模式添加一个 Feature。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _SMOOTHNESS_ALBEDO
#pragma shader_feature _PARALLAX_MAP
#pragma shader_feature _TESSELLATION_EDGE
</span></pre></table></code></div></div><p>然后我们必须将阴影的顶点程序替换为曲面细分顶点程序，并添加所需的 Hull 和 Domain 程序。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// #pragma vertex MyShadowVertexProgram</span>
<span class="cp">#pragma vertex MyTessellationVertexProgram
#pragma fragment MyShadowFragmentProgram
#pragma hull MyHullProgram
#pragma domain MyDomainProgram
</span></pre></table></code></div></div><p>这些程序定义在 <code class="language-plaintext highlighter-rouge">MyTessellation</code> 中，所以在 <code class="language-plaintext highlighter-rouge">My Shadows</code> 之后包含它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="err">#</span><span class="n">include</span> <span class="s">"My Shadows.cginc"</span>
<span class="err">#</span><span class="n">include</span> <span class="s">"MyTessellation.cginc"</span>
</pre></table></code></div></div><h3 id="22-使细分阴影工作"><span class="me-2">2.2 使细分阴影工作</span><a href="#22-使细分阴影工作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>此时我们的 Shadow Caster Pass 无法在没有错误的情况下编译。这是因为 <code class="language-plaintext highlighter-rouge">My Shadows</code> 没有遵循与 <code class="language-plaintext highlighter-rouge">My Lighting</code> 完全相同的方法。第一个问题是 <code class="language-plaintext highlighter-rouge">MyTessellation</code> 期望 <code class="language-plaintext highlighter-rouge">VertexData</code> 的顶点位置字段名为 <code class="language-plaintext highlighter-rouge">vertex</code>，而在 <code class="language-plaintext highlighter-rouge">My Shadows</code> 中它被称为 <code class="language-plaintext highlighter-rouge">position</code>。让我们通过在 <code class="language-plaintext highlighter-rouge">My Shadows</code> 中将其重命名为 <code class="language-plaintext highlighter-rouge">vertex</code> 来解决这个问题。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">VertexData</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
    <span class="c1">// float4 position : POSITION;</span>
    <span class="n">float4</span> <span class="n">vertex</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normal</span> <span class="p">:</span> <span class="n">NORMAL</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>顶点位置在 <code class="language-plaintext highlighter-rouge">MyShadowVertexProgram</code> 中使用了两次，所以也要更改这些引用。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="err">#</span><span class="k">if</span> <span class="nf">defined</span><span class="p">(</span><span class="n">SHADOWS_CUBE</span><span class="p">)</span>
        <span class="n">i</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="nf">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">lightVec</span> <span class="p">=</span>
            <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span> <span class="p">-</span> <span class="n">_LightPositionRange</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="err">#</span><span class="k">else</span>
        <span class="n">i</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="nf">UnityClipSpaceShadowCasterPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="nf">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="err">…</span>
<span class="p">}</span>
</pre></table></code></div></div><p>下一个问题是阴影使用的顶点数据比其他三个通道少。具体来说，它们不需要 tangent、uv1 和 uv2 数据。我们可以无论如何都添加这些数据，但那会不必要地使阴影变慢。相反，让我们调整 <code class="language-plaintext highlighter-rouge">MyTessellation</code> 以便它可以支持更少的顶点数据。我们可以通过仅在定义了适当的宏时才在 <code class="language-plaintext highlighter-rouge">TessellationControlPoint</code> 结构中包含 tangent、uv1 和 uv2 来做到这一点。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">TessellationControlPoint</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">vertex</span> <span class="p">:</span> <span class="n">INTERNALTESSPOS</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normal</span> <span class="p">:</span> <span class="n">NORMAL</span><span class="p">;</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">TESSELLATION_TANGENT</span>
        <span class="n">float4</span> <span class="n">tangent</span> <span class="p">:</span> <span class="n">TANGENT</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="n">float2</span> <span class="n">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">TESSELLATION_UV1</span>
        <span class="n">float2</span> <span class="n">uv1</span> <span class="p">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">TESSELLATION_UV2</span>
        <span class="n">float2</span> <span class="n">uv2</span> <span class="p">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
<span class="p">};</span>
</pre></table></code></div></div><p>使用相同的技巧，我们可以控制 <code class="language-plaintext highlighter-rouge">MyTessellationVertexProgram</code> 是否将相关字段从顶点数据复制到控制点。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">TessellationControlPoint</span> <span class="nf">MyTessellationVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TessellationControlPoint</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">vertex</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">normal</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">;</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">TESSELLATION_TANGENT</span>
        <span class="n">p</span><span class="p">.</span><span class="n">tangent</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="n">p</span><span class="p">.</span><span class="n">uv</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">TESSELLATION_UV1</span>
        <span class="n">p</span><span class="p">.</span><span class="n">uv1</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">TESSELLATION_UV2</span>
        <span class="n">p</span><span class="p">.</span><span class="n">uv2</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv2</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>以及 <code class="language-plaintext highlighter-rouge">MyDomainProgram</code> 是否插值数据。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="n">InterpolatorsVertex</span> <span class="nf">MyDomainProgram</span> <span class="p">(</span>
    <span class="err">…</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">TESSELLATION_TANGENT</span>
        <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">tangent</span><span class="p">)</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">TESSELLATION_UV1</span>
        <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">uv1</span><span class="p">)</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">TESSELLATION_UV2</span>
        <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">uv2</span><span class="p">)</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="k">return</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这种方法允许我们微调在细分时包含哪些网格数据。我们不需要阴影的 tangent、uv1 和 uv2，但其他三个通道可能都需要它们。所以让我们在 <code class="language-plaintext highlighter-rouge">My Lighting Input</code> 的顶部定义相关的宏。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#define TESSELLATION_TANGENT 1
#define TESSELLATION_UV1 1
#define TESSELLATION_UV2 1
</span>
<span class="cp">#if defined(_PARALLAX_MAP) &amp;&amp; defined(VERTEX_DISPLACEMENT_INSTEAD_OF_PARALLAX)
</span>    <span class="err">…</span>
<span class="cp">#endif
</span></pre></table></code></div></div><blockquote><p><strong>我们在其他通道中总是需要所有这些数据吗？</strong> 不，但我们只是假设我们需要。你可以进一步微调，仅在真正需要时才包含 UV1 和 UV2。</p></blockquote><p>最后一个问题是 <code class="language-plaintext highlighter-rouge">My Lighting</code> 依赖于 <code class="language-plaintext highlighter-rouge">MyVertexProgram</code> 的存在，但我们已将 Shadow Caster Pass 的顶点程序命名为 <code class="language-plaintext highlighter-rouge">MyShadowVertexProgram</code>。快速解决方案是在 <code class="language-plaintext highlighter-rouge">My Shadows</code> 中定义一个宏别名。这样 <code class="language-plaintext highlighter-rouge">MyVertexProgram</code> 也适用于阴影，而不会破坏现有的 Shader。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#define MyVertexProgram MyShadowVertexProgram
</span>
<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="23-置换阴影几何体"><span class="me-2">2.3 置换阴影几何体</span><a href="#23-置换阴影几何体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>阴影现在被细分了。下一步是置换它们的顶点，为此我们可以使用应用于 <code class="language-plaintext highlighter-rouge">My Lighting</code> 的相同方法。首先，将适当的宏定义复制到 <code class="language-plaintext highlighter-rouge">My Shadows</code> 的顶部。唯一的区别是我们还必须定义 <code class="language-plaintext highlighter-rouge">SHADOWS_NEED_UV</code>，如果它尚未定义的话。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#if SHADOWS_SEMITRANSPARENT || defined(_RENDERING_CUTOUT)
</span>    <span class="err">#</span><span class="k">if</span> <span class="p">!</span><span class="nf">defined</span><span class="p">(</span><span class="n">_SMOOTHNESS_ALBEDO</span><span class="p">)</span>
        <span class="err">#</span><span class="n">define</span> <span class="n">SHADOWS_NEED_UV</span> <span class="m">1</span>
    <span class="err">#</span><span class="n">endif</span>
<span class="cp">#endif
</span>
<span class="cp">#if defined(_PARALLAX_MAP) &amp;&amp; defined(VERTEX_DISPLACEMENT_INSTEAD_OF_PARALLAX)
</span>    <span class="err">#</span><span class="n">undef</span> <span class="n">_PARALLAX_MAP</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">VERTEX_DISPLACEMENT</span> <span class="m">1</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">_DisplacementMap</span> <span class="n">_ParallaxMap</span>
    <span class="err">#</span><span class="n">define</span> <span class="n">_DisplacementStrength</span> <span class="n">_ParallaxStrength</span>
    <span class="err">#</span><span class="k">if</span> <span class="p">!</span><span class="nf">defined</span><span class="p">(</span><span class="n">SHADOWS_NEED_UV</span><span class="p">)</span>
        <span class="err">#</span><span class="n">define</span> <span class="n">SHADOWS_NEED_UV</span> <span class="m">1</span>
    <span class="err">#</span><span class="n">endif</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>阴影没有使用视差贴图，所以我们现在必须添加所需的变量。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">sampler2D</span> <span class="n">_ParallaxMap</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_ParallaxStrength</span><span class="p">;</span>
</pre></table></code></div></div><p>在阴影顶点程序中，将纹理坐标的变换移动到顶点位置的使用之上。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="nf">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="nf">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">SHADOWS_NEED_UV</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="p">=</span> <span class="nf">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="err">#</span><span class="k">if</span> <span class="nf">defined</span><span class="p">(</span><span class="n">SHADOWS_CUBE</span><span class="p">)</span>
        <span class="n">i</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="nf">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">lightVec</span> <span class="p">=</span>
            <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span> <span class="p">-</span> <span class="n">_LightPositionRange</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="err">#</span><span class="k">else</span>
        <span class="n">i</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="nf">UnityClipSpaceShadowCasterPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="nf">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
    <span class="err">#</span><span class="n">endif</span>

    <span class="c1">// #if SHADOWS_NEED_UV</span>
    <span class="c1">//  i.uv = TRANSFORM_TEX(v.uv, _MainTex);</span>
    <span class="c1">// #endif</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后置换顶点位置。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="err">#</span><span class="k">if</span> <span class="n">SHADOWS_NEED_UV</span>
        <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="p">=</span> <span class="nf">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="err">#</span><span class="n">endif</span>
    
    <span class="err">#</span><span class="k">if</span> <span class="n">VERTEX_DISPLACEMENT</span>
        <span class="kt">float</span> <span class="n">displacement</span> <span class="p">=</span> <span class="nf">tex2Dlod</span><span class="p">(</span><span class="n">_DisplacementMap</span><span class="p">,</span> <span class="nf">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)).</span><span class="n">g</span><span class="p">;</span>
        <span class="n">displacement</span> <span class="p">=</span> <span class="p">(</span><span class="n">displacement</span> <span class="p">-</span> <span class="m">0.5</span><span class="p">)</span> <span class="p">*</span> <span class="n">_DisplacementStrength</span><span class="p">;</span>
        <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="p">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span> <span class="p">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="p">*</span> <span class="n">displacement</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/13-displaced-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/13-displaced-shadows.png" alt="Displaced shadows" width="100%" height="auto" loading="lazy"></a></div></div><p>我们现在得到了正确置换的阴影。接收和投射阴影现在都是正确的，对于两个渲染路径都是如此。</p><p>阴影工作正常，曲面细分相对于视差贴图的另一个优势是我们自动获得了自阴影（Self-shadowing）。它不需要任何额外的工作。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/14-with-without-self-shadowing.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/14-with-without-self-shadowing.png" alt="With and without self-shadowing" width="100%" height="auto" loading="lazy"></a></div></div><p>当然，你必须牢记阴影贴图的局限性。此外，当使用 Edge 曲面细分模式时，阴影贴图的视图距离与常规摄像机不同。这意味着细分的阴影几何体并不完全匹配常规细分几何体，这可能会产生阴影伪影。曲面细分越精细，这个问题就越小。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/15-varying-tessellation-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/15-varying-tessellation-shadows.png" alt="Varying tessellation with shadows" width="100%" height="auto" loading="lazy"></a></div></div><h2 id="3-剔除三角形"><span class="me-2">3 剔除三角形</span><a href="#3-剔除三角形" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>虽然曲面细分很好，但它并不便宜，特别是当需要高水平的曲面细分时。需要意识到的一件重要事情是，网格的每个三角形都会被细分，无论它最终是否可见。然而，可以对此做些什么。</p><p>场景中并非所有东西都会被渲染。只有位于摄像机视锥体（View Frustum）内的对象才能被看到。这些对象由 Unity 发送到 GPU，其他所有东西都被剔除。但是，如果对象的包围盒哪怕只有一小部分位于视锥体内，它的整个网格都将由 GPU 处理，从而被细分。幸运的是，有一种方法可以在细分时跳过三角形，有效地在曲面细分阶段之前剔除它们。</p><h3 id="31-跳过一些三角形"><span class="me-2">3.1 跳过一些三角形</span><a href="#31-跳过一些三角形" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>曲面细分的数量由 Edge 和 Inside 曲面细分因子控制。因子 1 对应于不添加三角形。更高的因子导致更多的三角形。但也可以使用因子 0。当曲面细分因子之一为零时，原始三角形被丢弃，根本不会被渲染。</p><p>如果我们能弄清楚三角形是否位于视锥体之外，我们就可以将其曲面细分因子设置为 0，有效地在 GPU 上逐三角形执行视锥体剔除。让我们在 <code class="language-plaintext highlighter-rouge">MyTessellation</code> 中添加一个函数来解决这个问题。将其放在 <code class="language-plaintext highlighter-rouge">MyPatchConstantFunction</code> 之上，因为该函数将调用它。我们将从一个非常简单的测试开始。如果三角形的所有三个顶点都有负的 X 坐标，我们将认为它被剔除了。我们可以使用布尔值来传达这一点。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">TriangleIsCulled</span> <span class="p">(</span><span class="n">float3</span> <span class="n">p0</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p1</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">MyPatchConstantFunction</code> 中使用此函数来检查我们是否可以跳过三角形。如果是，将所有边因子设置为零。否则，像往常一样确定因子。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">TessellationFactors</span> <span class="nf">MyPatchConstantFunction</span> <span class="p">(</span>
    <span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">TessellationControlPoint</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">p0</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">p1</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">p2</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">TessellationFactors</span> <span class="n">f</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nf">TriangleIsCulled</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
        <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p0</span><span class="p">);</span>
        <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">);</span>
        <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span>
            <span class="p">(</span><span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="p">+</span>
            <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span> <span class="p">+</span>
            <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">))</span> <span class="p">*</span> <span class="p">(</span><span class="m">1</span> <span class="p">/</span> <span class="m">3.0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/16-negative-x-culling.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/16-negative-x-culling.png" alt="Culling triangles with only negative X coordinates" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="32-视锥体剔除"><span class="me-2">3.2 视锥体剔除</span><a href="#32-视锥体剔除" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要执行实际的视锥体剔除，我们必须验证三角形是否位于摄像机的视锥体内。视锥体是一个金字塔，其顶部被平行于其底部的平面切断。金字塔的底部和侧面也可以由平面定义。这些平面形成一个系统，其中视锥体内的空间被认为位于所有六个裁剪平面之上。所以我们必须检查每个平面，点是否位于其上方或下方。让我们创建一个布尔函数来检查单个平面，默认返回 true。在 <code class="language-plaintext highlighter-rouge">TriangleIsCulled</code> 内部调用该函数，替换我们的测试代码。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">TriangleIsBelowClipPlane</span> <span class="p">(</span><span class="n">float3</span> <span class="n">p0</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p1</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">TriangleIsCulled</span> <span class="p">(</span><span class="n">float3</span> <span class="n">p0</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p1</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// return p0.x &lt; 0 &amp;&amp; p1.x &lt; 0 &amp;&amp; p2.x &lt; 0;</span>
    <span class="k">return</span> <span class="nf">TriangleIsBelowClipPlane</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>因为摄像机可能有任何位置和方向，我们无法提前对其裁剪平面做出任何假设。所以我们必须能够处理任意方向和位置的平面。一般来说，平面可以由定义其局部向上方向的法线向量以及相对于世界原点的偏移来定义。此数据可以存储在一个四分量向量中，其中 W 分量包含偏移。对应于我们之前丢弃具有负 X 坐标的三角形的测试用例的平面向量将是 (1, 0, 0, 0)。如果我们改为丢弃 X 坐标高达 2 的三角形，则向量将是 (1, 0, 0, 2)。</p><p>要弄清楚点是否位于平面上方或下方，我们可以通过点积将该点的向量投影到平面的法线向量上。如果结果为负，则它们的角度大于 90°，因此点位于平面下方。平面的偏移也必须考虑在内，方法是将其添加到计算中，例如将其设为 (px, py, pz, 1) 和平面向量之间的点积，其中 px, py 和 pz 是点的坐标。相应地调整 <code class="language-plaintext highlighter-rouge">TriangleIsBelowClipPlane</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">TriangleIsBelowClipPlane</span> <span class="p">(</span><span class="n">float3</span> <span class="n">p0</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p1</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">plane</span> <span class="p">=</span> <span class="nf">float4</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="k">return</span>
        <span class="nf">dot</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">plane</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span>
        <span class="nf">dot</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">plane</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span>
        <span class="nf">dot</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">plane</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>摄像机的实际裁剪平面通过 <code class="language-plaintext highlighter-rouge">UnityShaderVariables</code> 中定义的 <code class="language-plaintext highlighter-rouge">unity_CameraWorldClipPlanes</code> 数组提供。它包含六个平面定义，分别用于左、右、底、顶、近和远平面。所以要使用摄像机的左平面，我们必须使用 <code class="language-plaintext highlighter-rouge">unity_CameraWorldClipPlanes[0]</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="c1">// float4 plane = float4(1, 0, 0, 0);</span>
    <span class="n">float4</span> <span class="n">plane</span> <span class="p">=</span> <span class="n">unity_CameraWorldClipPlanes</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</pre></table></code></div></div><p>为了使 <code class="language-plaintext highlighter-rouge">TriangleIsBelowClipPlane</code> 适用于任何摄像机裁剪平面，添加平面索引作为附加参数，并使用它来选择适当的摄像机平面。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">TriangleIsBelowClipPlane</span> <span class="p">(</span>
    <span class="n">float3</span> <span class="n">p0</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p1</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">planeIndex</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">plane</span> <span class="p">=</span> <span class="n">unity_CameraWorldClipPlanes</span><span class="p">[</span><span class="n">planeIndex</span><span class="p">];</span>
    <span class="k">return</span>
        <span class="nf">dot</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">plane</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span>
        <span class="nf">dot</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">plane</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span>
        <span class="nf">dot</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">plane</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在我们可以在 <code class="language-plaintext highlighter-rouge">TriangleIsCulled</code> 内部检查所有裁剪平面。如果三角形最终位于其中任何一个之下，那么它就不可能是可见的，应该被裁剪。我们必须检查左、右、底和顶平面。近平面实际上并不需要，因为视锥体通常在摄像机后方很短的距离处汇聚成一点。所以检查近平面不值得额外努力。远平面也不必要，因为在这个距离上，曲面细分通常无论如何都不会发生。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">TriangleIsCulled</span> <span class="p">(</span><span class="n">float3</span> <span class="n">p0</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p1</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span>
        <span class="nf">TriangleIsBelowClipPlane</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span> <span class="p">||</span>
        <span class="nf">TriangleIsBelowClipPlane</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="p">||</span>
        <span class="nf">TriangleIsBelowClipPlane</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="p">||</span>
        <span class="nf">TriangleIsBelowClipPlane</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="m">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="33-偏移剔除"><span class="me-2">3.3 偏移剔除</span><a href="#33-偏移剔除" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为我们只裁剪那些我们看不到的三角形，所以除了帧率可能存在差异外，我们不应该能够区分裁剪和不裁剪。然而，这只有在我们不置换任何顶点时才是真的。当顶点确实被置换时，即使原始三角形位于视锥体之外，置换的顶点也有可能最终位于视锥体内。在我们置换平面的情况下，你可以通过以浅角度观察平面来验证这一点，这样它的一些网格三角形最终刚好位于视图底部下方。你会很快遇到孔洞，因为三角形突然消失，而它们不应该消失。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/17-hole-incorrect-culling.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/17-hole-incorrect-culling.png" alt="Hole created by incorrect culling" width="100%" height="auto" loading="lazy"></a></div></div><p>这个问题的解决方案是在确定三角形是否位于裁剪平面下方时，将最大置换量考虑在内。这可以通过向 <code class="language-plaintext highlighter-rouge">TriangleIsBelowClipPlane</code> 添加偏移（Bias）来完成。与其检查点积是否小于零，不如检查它是否小于此偏移。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">TriangleIsBelowClipPlane</span> <span class="p">(</span>
    <span class="n">float3</span> <span class="n">p0</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p1</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">planeIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">bias</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">plane</span> <span class="p">=</span> <span class="n">unity_CameraWorldClipPlanes</span><span class="p">[</span><span class="n">planeIndex</span><span class="p">];</span>
    <span class="k">return</span>
        <span class="nf">dot</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">plane</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">bias</span> <span class="p">&amp;&amp;</span>
        <span class="nf">dot</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">plane</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">bias</span> <span class="p">&amp;&amp;</span>
        <span class="nf">dot</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">plane</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">bias</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们应该对所有平面检查使用相同的偏移，所以将其作为参数添加到 <code class="language-plaintext highlighter-rouge">TriangleIsCulled</code> 中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">TriangleIsCulled</span> <span class="p">(</span><span class="n">float3</span> <span class="n">p0</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p1</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span>
        <span class="nf">TriangleIsBelowClipPlane</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span> <span class="p">||</span>
        <span class="nf">TriangleIsBelowClipPlane</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span> <span class="p">||</span>
        <span class="nf">TriangleIsBelowClipPlane</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span> <span class="p">||</span>
        <span class="nf">TriangleIsBelowClipPlane</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让我们在 <code class="language-plaintext highlighter-rouge">MyPatchConstantFunction</code> 中使用偏移 1，看看会发生什么。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="kt">float</span> <span class="n">bias</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nf">TriangleIsCulled</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">bias</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender23/18-positive-bias.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender23/18-positive-bias.png" alt="Using a positive bias" width="100%" height="auto" loading="lazy"></a></div></div><p>正偏移有效地将裁剪平面向上推，减小了视锥体的大小。结果，当三角形靠近视图边缘时，它们会被过快地裁剪。负偏移具有相反的效果，因此位于视锥体之外但仍在其附近的三角形不会被裁剪。所以当使用顶点置换时，我们必须使用负偏移。由于我们在任何维度上的最大置换等于置换强度的一半，这就是我们需要的负偏移。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="kt">float</span> <span class="n">bias</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">VERTEX_DISPLACEMENT</span>
        <span class="n">bias</span> <span class="p">=</span> <span class="p">-</span><span class="m">0.5</span> <span class="p">*</span> <span class="n">_DisplacementStrength</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
    <span class="k">if</span> <span class="p">(</span><span class="nf">TriangleIsCulled</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">bias</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>我们现在正在尽可能多地裁剪三角形，同时保证永远不会出现孔洞。当然，确定我们是否应该裁剪三角形也需要工作，所以它不会提高完全在视图中的网格的性能，实际上会让它变得更糟。但是当你渲染具有大量曲面细分的大型网格，并且它们通常只是部分可见时，你最终可以显着提高帧率。</p><p>曲面细分的介绍到此结束。现在你知道如何细分三角形以及如何通过置换贴图添加几何细节。这并不是你可以用曲面细分做的唯一事情。例如，还有 PN 三角形、Phong 曲面细分、程序化置换等等。祝你在尝试这些方法时玩得开心！</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/shader/">Shader</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E8%A1%A8%E9%9D%A2%E7%BD%AE%E6%8D%A2(%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%8D%81%E4%B8%89)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Funity-surface-displacement%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E8%A1%A8%E9%9D%A2%E7%BD%AE%E6%8D%A2(%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%8D%81%E4%B8%89)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Funity-surface-displacement%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Funity-surface-displacement%2F&text=%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E8%A1%A8%E9%9D%A2%E7%BD%AE%E6%8D%A2(%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%8D%81%E4%B8%89)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/Unity-Matrix-Transform/">Unity 基本矩阵(翻译一)</a><li class="text-truncate lh-lg"> <a href="/posts/Unity_Shader_Fundamentals/">Unity Shader 基本语法(翻译二)</a><li class="text-truncate lh-lg"> <a href="/posts/Unity_Combine_Texture/">Unity 多纹理融合(翻译三)</a><li class="text-truncate lh-lg"> <a href="/posts/Unity_First_light/">Unity 基础光照(翻译四)</a><li class="text-truncate lh-lg"> <a href="/posts/Unity_Multi_Light/">Unity 基础光照多光源采样(翻译五)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a> <a class="post-tag btn btn-outline-primary" href="/tags/context-engine/">Context Engine</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_2/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515333600" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展二(翻译十)</h4><div class="text-muted"><p>本篇摘要: 把自身阴影烘焙进材质 增加细节纹理部分 支持更丰富的shader变体 一次编辑多个材质球 遮挡区域的Self-Shading 美术能够创作非常复杂丰富的表面纹理，它只是一个视错觉。为了增强表面纹理视觉真实感，引入Self-Shading。 如何增强呢？通常我们使用了法线来增强模型表面的凹凸层次感，法线带来的视觉增强是第一步，但是法线只适用于采样直接光...</p></div></div></a></article><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515326400" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展一(翻译九)</h4><div class="text-muted"><p>选中当前材质后，若材质使用的Shader调用了GUI拓展，则会自动读取该Shader的所有属性。通过重实现OnGUI函数后，获取其参数地址就能读取。</p></div></div></a></article><article class="col"> <a href="/posts/Unity_Reflection/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515240000" data-df="ll" > Jan 6, 2018 </time><h4 class="pt-0 my-2">Unity Reflection 反射(翻译八)</h4><div class="text-muted"><p>一块完美的镜子是不会发生漫反射，但现在我们自己的Shader包含的光照：环境光、漫反射、高光反射、纹理、阴影，结果看起来蛮好。但是当把Metallic设为1，Smoothness设位0.95，看起来很亮就很不自然了。从下图看尽管颜色是白色但整个表面都是黑色，只有一个很小的高亮点。这个亮点形成1是光源的入射，2朝向观察者的反射。</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/unity-tessellation/" class="btn btn-outline-primary" aria-label="Older" ><p>曲面细分(翻译二十二)</p></a> <a href="/posts/unity-bloom/" class="btn btn-outline-primary" aria-label="Newer" ><p>Bloom模糊光照(翻译二十四)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a> <a class="post-tag btn btn-outline-primary" href="/tags/context-engine/">Context Engine</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
