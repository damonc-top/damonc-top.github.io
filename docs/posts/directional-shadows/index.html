<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="自定义管线:方向阴影 (翻译四)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="渲染阴影" /><meta property="og:description" content="渲染阴影" /><link rel="canonical" href="www.damonc.top/posts/directional-shadows/" /><meta property="og:url" content="www.damonc.top/posts/directional-shadows/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/SRP/srp4/tutorial-image.jpg" /><meta property="og:image:alt" content="cascaded阴影贴图示例" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-12-18T00:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/SRP/srp4/tutorial-image.jpg" /><meta name="twitter:image:alt" content="cascaded阴影贴图示例" /><meta property="twitter:title" content="自定义管线:方向阴影 (翻译四)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2019-12-18T00:00:00+08:00","datePublished":"2019-12-18T00:00:00+08:00","description":"渲染阴影","headline":"自定义管线:方向阴影 (翻译四)","image":{"lqip":"data:image/webp;base64,UklGRnAAAABXRUJQVlA4IGQAAADwAwCdASoUAAoAP3Ggxli0q6ejsAgCkC4JZQDKABxlCjX7FioeGgAAAP4y+Hg1OeW8zCvbdIPGhtQd/vF9UlEkRiqaf8rff78DpFD0S/FWhkkLOtg7RekXX4y9VMRT5v8bYgAA","alt":"cascaded阴影贴图示例","url":"https://img.damonc.top/posts/SRP/srp4/tutorial-image.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/directional-shadows/"},"url":"www.damonc.top/posts/directional-shadows/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>自定义管线:方向阴影 (翻译四) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘摊手</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>自定义管线:方向阴影 (翻译四)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>自定义管线:方向阴影 (翻译四)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1576598400" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Dec 18, 2019 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/SRP/srp4/tutorial-image.jpg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/SRP/srp4/tutorial-image.jpg" alt="cascaded阴影贴图示例" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRnAAAABXRUJQVlA4IGQAAADwAwCdASoUAAoAP3Ggxli0q6ejsAgCkC4JZQDKABxlCjX7FioeGgAAAP4y+Hg1OeW8zCvbdIPGhtQd/vF9UlEkRiqaf8rff78DpFD0S/FWhkkLOtg7RekXX4y9VMRT5v8bYgAA"></a><figcaption class="text-center pt-2 pb-2">cascaded阴影贴图示例</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/directional-shadows/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="19521 words" > <em>108 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">自定义管线:方向阴影 (翻译四)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">自定义管线:方向阴影 (翻译四)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><h2 id="渲染阴影"><span class="me-2">渲染阴影</span><a href="#渲染阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>当绘制物体时，表面和光照信息就足以计算光照了。但是两者之间可能有东西阻挡光线，在我们正在绘制的表面上投下阴影。为了使阴影成为可能，我们必须以某种方式让着色器知道阴影投射物体。有多种技术可以做到这一点。最常见的方法是生成一个阴影贴图，存储光线从光源出发在击中表面之前可以传播多远。同一方向上更远的任何东西都不能被同一个光源照亮。Unity 的渲染管线使用这种方法，我们也一样。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/test-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/test-scene.png" alt="阴影测试场景" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">阴影测试场景</figcaption></figure><h3 id="阴影设置"><span class="me-2">阴影设置</span><a href="#阴影设置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在我们开始渲染阴影之前，我们首先需要就质量做出一些决定，具体来说是我们将渲染多远的阴影以及我们的阴影贴图有多大。</p><p>虽然我们可以渲染到相机能看到的距离那么远，但这需要大量的绘制和一个非常大的贴图来充分覆盖该区域，这几乎永远不实用。所以我们将引入一个最大阴影距离，最小值为零，默认设置为 100 个单位。创建一个新的可序列化 ShadowSettings 类来包含这个选项。这个类纯粹是配置选项的容器，所以我们给它一个 maxDistance 公共字段。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="p">[</span><span class="n">System</span><span class="p">.</span><span class="n">Serializable</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ShadowSettings</span> <span class="p">{</span>
    <span class="p">[</span><span class="nf">Min</span><span class="p">(</span><span class="m">0f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">maxDistance</span> <span class="p">=</span> <span class="m">100f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>对于贴图大小，我们将在 ShadowSettings 内部引入一个 TextureSize 枚举类型。使用它来定义允许的贴图大小，都是在 256—8192 范围内的 2 的幂。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">enum</span> <span class="n">TextureSize</span> <span class="p">{</span>
    <span class="n">_256</span> <span class="p">=</span> <span class="m">256</span><span class="p">,</span> <span class="n">_512</span> <span class="p">=</span> <span class="m">512</span><span class="p">,</span> <span class="n">_1024</span> <span class="p">=</span> <span class="m">1024</span><span class="p">,</span>
    <span class="n">_2048</span> <span class="p">=</span> <span class="m">2048</span><span class="p">,</span> <span class="n">_4096</span> <span class="p">=</span> <span class="m">4096</span><span class="p">,</span> <span class="n">_8192</span> <span class="p">=</span> <span class="m">8192</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后添加阴影贴图的大小字段，默认为 1024。我们将使用单个纹理包含多个阴影贴图，所以将其命名为 atlasSize。因为目前我们只支持方向光，所以在这个点我们只适用于方向阴影贴图。但我们将在未来支持其他光源类型，它们将获得自己的阴影设置。所以把 atlasSize 放到一个内部 Directional 结构中。这样我们就自动获得了检查器中的层次配置。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">System</span><span class="p">.</span><span class="n">Serializable</span><span class="p">]</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">Directional</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">TextureSize</span> <span class="n">atlasSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">Directional</span> <span class="n">directional</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Directional</span> <span class="p">{</span>
    <span class="n">atlasSize</span> <span class="p">=</span> <span class="n">TextureSize</span><span class="p">.</span><span class="n">_1024</span>
<span class="p">};</span>
</pre></table></code></div></div><p>向 CustomRenderPipelineAsset 添加一个阴影设置字段。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
<span class="n">ShadowSettings</span> <span class="n">shadows</span> <span class="p">=</span> <span class="k">default</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/shadow-settings.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/shadow-settings.png" alt="阴影设置" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">阴影设置</figcaption></figure><p>在构造 CustomRenderPipeline 实例时传递这些设置。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">protected</span> <span class="k">override</span> <span class="n">RenderPipeline</span> <span class="nf">CreatePipeline</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">CustomRenderPipeline</span><span class="p">(</span>
        <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="n">useSRPBatcher</span><span class="p">,</span> <span class="n">shadows</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让它跟踪它们。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">ShadowSettings</span> <span class="n">shadowSettings</span><span class="p">;</span>

<span class="k">public</span> <span class="nf">CustomRenderPipeline</span> <span class="p">(</span>
    <span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useSRPBatcher</span><span class="p">,</span>
    <span class="n">ShadowSettings</span> <span class="n">shadowSettings</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">shadowSettings</span> <span class="p">=</span> <span class="n">shadowSettings</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="传递设置"><span class="me-2">传递设置</span><a href="#传递设置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>从现在开始，当我们调用它的 Render 方法时，我们将这些设置传递给相机渲染器。这样添加运行时更改阴影设置的支持很容易，但我们不会在本教程中处理这个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(</span>
    <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Camera</span><span class="p">&gt;</span> <span class="n">cameras</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">cameras</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">renderer</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span>
            <span class="n">context</span><span class="p">,</span> <span class="n">cameras</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">,</span>
            <span class="n">shadowSettings</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>CameraRenderer.Render 然后将它传递给 Lighting.Setup 以及它自己的 Cull 方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(</span>
    <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">Camera</span> <span class="n">camera</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span><span class="p">,</span>
    <span class="n">ShadowSettings</span> <span class="n">shadowSettings</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(!</span><span class="nf">Cull</span><span class="p">(</span><span class="n">shadowSettings</span><span class="p">.</span><span class="n">maxDistance</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nf">Setup</span><span class="p">();</span>
    <span class="n">lighting</span><span class="p">.</span><span class="nf">Setup</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">cullingResults</span><span class="p">,</span> <span class="n">shadowSettings</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们需要 Cull 中的设置，因为阴影距离是通过剔除参数设置的。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">Cull</span> <span class="p">(</span><span class="kt">float</span> <span class="n">maxShadowDistance</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="nf">TryGetCullingParameters</span><span class="p">(</span><span class="k">out</span> <span class="n">ScriptableCullingParameters</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">.</span><span class="n">shadowDistance</span> <span class="p">=</span> <span class="n">maxShadowDistance</span><span class="p">;</span>
        <span class="n">cullingResults</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="nf">Cull</span><span class="p">(</span><span class="k">ref</span> <span class="n">p</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>渲染比相机能看到的更远的阴影没有意义，所以取最大阴影距离和相机远剪裁平面的最小值。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">p</span><span class="p">.</span><span class="n">shadowDistance</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="n">maxShadowDistance</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">farClipPlane</span><span class="p">);</span>
</pre></table></code></div></div><p>为了让代码编译，我们还必须添加阴影设置参数给 Lighting.Setup，但我们暂时不会对它们做任何操作。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(</span>
    <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">CullingResults</span> <span class="n">cullingResults</span><span class="p">,</span>
    <span class="n">ShadowSettings</span> <span class="n">shadowSettings</span>
<span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></table></code></div></div><h3 id="shadows-类"><span class="me-2">Shadows 类</span><a href="#shadows-类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然阴影在逻辑上是光照的一部分，但它们相当复杂，所以让我们创建一个新的 Shadows 类专门处理它们。它开始是 Lighting 的一个剥离存根副本，有自己的缓冲区、上下文字段、剔除结果和设置字段，一个 Setup 方法来初始化字段，以及一个 ExecuteBuffer 方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.Rendering</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Shadows</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">string</span> <span class="n">bufferName</span> <span class="p">=</span> <span class="s">"Shadows"</span><span class="p">;</span>

    <span class="n">CommandBuffer</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CommandBuffer</span> <span class="p">{</span>
        <span class="n">name</span> <span class="p">=</span> <span class="n">bufferName</span>
    <span class="p">};</span>

    <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">;</span>
    <span class="n">CullingResults</span> <span class="n">cullingResults</span><span class="p">;</span>
    <span class="n">ShadowSettings</span> <span class="n">settings</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(</span>
        <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">CullingResults</span> <span class="n">cullingResults</span><span class="p">,</span>
        <span class="n">ShadowSettings</span> <span class="n">settings</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">context</span> <span class="p">=</span> <span class="n">context</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">cullingResults</span> <span class="p">=</span> <span class="n">cullingResults</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">settings</span> <span class="p">=</span> <span class="n">settings</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">ExecuteBuffer</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">context</span><span class="p">.</span><span class="nf">ExecuteCommandBuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">Clear</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后 Lighting 所需要做的就是跟踪一个 Shadows 实例，并在它自己的 Setup 方法中 SetupLights 之前调用它的 Setup 方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">Shadows</span> <span class="n">shadows</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Shadows</span><span class="p">();</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">cullingResults</span> <span class="p">=</span> <span class="n">cullingResults</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="n">shadows</span><span class="p">.</span><span class="nf">Setup</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">cullingResults</span><span class="p">,</span> <span class="n">shadowSettings</span><span class="p">);</span>
    <span class="nf">SetupLights</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="带阴影的光"><span class="me-2">带阴影的光</span><a href="#带阴影的光" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为渲染阴影需要额外工作，它会降低帧率，所以我们将限制有多少阴影方向光，独立于有多少方向光受支持。为那个添加一个常量到 Shadows，最初只设置为一个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">maxShadowedDirectionalLightCount</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
</pre></table></code></div></div><p>我们不知道哪个可见光会获得阴影，所以我们必须跟踪它。除此之外，我们稍后还要跟踪每个阴影光的一些更多数据，所以让我们定义一个内部 ShadowedDirectionalLight 结构，目前只包含索引，并跟踪它们的数组。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">ShadowedDirectionalLight</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ShadowedDirectionalLight</span><span class="p">[]</span> <span class="n">ShadowedDirectionalLights</span> <span class="p">=</span>
    <span class="k">new</span> <span class="n">ShadowedDirectionalLight</span><span class="p">[</span><span class="n">maxShadowedDirectionalLightCount</span><span class="p">];</span>
</pre></table></code></div></div><p>为了找出哪个光获得阴影，我们将添加一个公共 ReserveDirectionalShadows 方法，带有光和可见光索引参数。它的工作是为光的阴影贴图在阴影贴集中保留空间，并存储渲染它们所需的信息。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">ReserveDirectionalShadows</span> <span class="p">(</span><span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span><span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><p>因为阴影光的数量有限，我们必须跟踪已经保留了多少。在 Setup 中将计数重置为零。然后在 ReserveDirectionalShadows 中检查我们是否还没有达到最大值。如果还有空间则存储光的可见索引并增加计数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ShadowedDirectionalLightCount</span><span class="p">;</span>

<span class="p">...</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">ShadowedDirectionalLightCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">ReserveDirectionalShadows</span> <span class="p">(</span><span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ShadowedDirectionalLightCount</span> <span class="p">&lt;</span> <span class="n">maxShadowedDirectionalLightCount</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ShadowedDirectionalLights</span><span class="p">[</span><span class="n">ShadowedDirectionalLightCount</span><span class="p">++]</span> <span class="p">=</span>
            <span class="k">new</span> <span class="n">ShadowedDirectionalLight</span> <span class="p">{</span>
                <span class="n">visibleLightIndex</span> <span class="p">=</span> <span class="n">visibleLightIndex</span>
            <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但阴影应该只为有阴影的光保留。如果光的阴影模式设置为无或者它的阴影强度为零那么它没有阴影，应该被忽略。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span>
    <span class="n">ShadowedDirectionalLightCount</span> <span class="p">&lt;</span> <span class="n">maxShadowedDirectionalLightCount</span> <span class="p">&amp;&amp;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">shadows</span> <span class="p">!=</span> <span class="n">LightShadows</span><span class="p">.</span><span class="n">None</span> <span class="p">&amp;&amp;</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span> <span class="p">&gt;</span> <span class="m">0f</span>
<span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></table></code></div></div><p>除此之外，一个可见光可能最终不影响任何投射阴影的物体，要么是因为配置为不投射，要么是因为光只影响最大阴影距离之外的物体。我们可以通过为剔除结果的可见光索引调用 GetShadowCasterBounds 来检查这个。它有一个第二个输出参数用于边界——我们不需要——并返回边界是否有效。如果不是那么这个光没有阴影需要渲染，应该被忽略。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span>
    <span class="n">ShadowedDirectionalLightCount</span> <span class="p">&lt;</span> <span class="n">maxShadowedDirectionalLightCount</span> <span class="p">&amp;&amp;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">shadows</span> <span class="p">!=</span> <span class="n">LightShadows</span><span class="p">.</span><span class="n">None</span> <span class="p">&amp;&amp;</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span> <span class="p">&gt;</span> <span class="m">0f</span> <span class="p">&amp;&amp;</span>
    <span class="n">cullingResults</span><span class="p">.</span><span class="nf">GetShadowCasterBounds</span><span class="p">(</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="k">out</span> <span class="n">Bounds</span> <span class="n">b</span><span class="p">)</span>
<span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></table></code></div></div><p>现在我们可以在 Lighting.SetupDirectionalLight 中保留阴影。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">SetupDirectionalLight</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">ref</span> <span class="n">VisibleLight</span> <span class="n">visibleLight</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dirLightColors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">visibleLight</span><span class="p">.</span><span class="n">finalColor</span><span class="p">;</span>
    <span class="n">dirLightDirections</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="p">-</span><span class="n">visibleLight</span><span class="p">.</span><span class="n">localToWorldMatrix</span><span class="p">.</span><span class="nf">GetColumn</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
    <span class="n">shadows</span><span class="p">.</span><span class="nf">ReserveDirectionalShadows</span><span class="p">(</span><span class="n">visibleLight</span><span class="p">.</span><span class="n">light</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="创建阴影贴集"><span class="me-2">创建阴影贴集</span><a href="#创建阴影贴集" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>保留阴影之后我们需要渲染它们。我们在 Lighting.Render 中的 SetupLights 完成后做这个，通过调用一个新的 Shadows.Render 方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">shadows</span><span class="p">.</span><span class="nf">Setup</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">cullingResults</span><span class="p">,</span> <span class="n">shadowSettings</span><span class="p">);</span>
<span class="nf">SetupLights</span><span class="p">();</span>
<span class="n">shadows</span><span class="p">.</span><span class="nf">Render</span><span class="p">();</span>
</pre></table></code></div></div><p>Shadows.Render 方法将把方向阴影的渲染委托给另一个 RenderDirectionalShadows 方法，但只有当有任何阴影光时。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ShadowedDirectionalLightCount</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">RenderDirectionalShadows</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{}</span>
</pre></table></code></div></div><p>创建阴影贴图是通过将阴影投射物体绘制到纹理来完成的。我们将使用 _DirectionalShadowAtlas 来引用方向阴影贴集。从设置中检索贴图大小为整数，然后以纹理标识符为参数在命令缓冲区上调用 GetTemporaryRT，加上它宽度的高度像素数大小。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="n">dirShadowAtlasId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalShadowAtlas"</span><span class="p">);</span>

<span class="p">...</span>

<span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">atlasSize</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">atlasSize</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span><span class="n">dirShadowAtlasId</span><span class="p">,</span> <span class="n">atlasSize</span><span class="p">,</span> <span class="n">atlasSize</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这声明了一个方形渲染纹理，但默认是一个普通 ARGB 纹理。我们需要一个阴影贴图，我们通过添加三个更多参数到调用来指定。第一个是深度缓冲区的位数。我们要尽可能高，所以让我们使用 32。第二个是过滤模式，对此我们使用默认双线性过滤。第三个是渲染纹理类型，必须是 RenderTextureFormat.Shadowmap。这给了我们一个适合渲染阴影贴图的纹理，虽然确切格式取决于目标平台。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
    <span class="n">dirShadowAtlasId</span><span class="p">,</span> <span class="n">atlasSize</span><span class="p">,</span> <span class="n">atlasSize</span><span class="p">,</span>
    <span class="m">32</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Shadowmap</span>
<span class="p">);</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>我们会得到什么样的纹理格式？</h3><div><p>它通常是 24 或 32 位整数或浮点纹理。你也可以选择 16 位，这是 Unity 的渲染管线所做的。</p></div></aside><p>当我们获得一个临时渲染纹理时，我们也应该在完成后释放它。我们必须保持它直到我们用相机完成渲染，之后我们可以通过在缓冲区上调用 ReleaseTemporaryRT 并执行它来释放它。我们将通过在一个新的公共 Cleanup 方法中做这个来完成。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Cleanup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">dirShadowAtlasId</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>给 Lighting 一个公共 Cleanup 方法，它将调用转发给 Shadows。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Cleanup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">shadows</span><span class="p">.</span><span class="nf">Cleanup</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后 CameraRenderer 可以在提交之前直接请求清理。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">lighting</span><span class="p">.</span><span class="nf">Cleanup</span><span class="p">();</span>
    <span class="nf">Submit</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们只能释放一个纹理，如果我们首先声明了它，我们目前只在有方向阴影需要渲染时才做那个。显而易见的解决方案是只有当我们有阴影时才释放纹理。然而，不声明纹理将导致 WebGL 2.0 的问题，因为它绑定纹理和采样器在一起。当一个使用我们着色器的材质在纹理缺失时加载时它会失败，因为它会获得一个与阴影采样器不兼容的默认纹理。我们可以通过引入着色器关键字来生成省略阴影采样代码的着色器变体来避免这个。一个替代方法是当不需要阴影时获取一个 1×1 虚纹理，避免额外的着色器变体。让我们做那个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shadowedDirLightCount</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">RenderDirectionalShadows</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
            <span class="n">dirShadowAtlasId</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span>
            <span class="m">32</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Shadowmap</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>请求渲染纹理后，Shadows.RenderDirectionalShadows 还必须指示 GPU 渲染到这个纹理而不是相机的目标。这是通过在缓冲区上调用 SetRenderTarget 来完成的，标识一个渲染纹理以及它的数据应该如何加载和存储。我们不关心它的初始状态因为我们将立即清除它，所以我们将使用 RenderBufferLoadAction.DontCare。纹理的目的是包含阴影数据，所以我们需要使用 RenderBufferStoreAction.Store 作为第三个参数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(...);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetRenderTarget</span><span class="p">(</span>
    <span class="n">dirShadowAtlasId</span><span class="p">,</span>
    <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">DontCare</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span>
<span class="p">);</span>
</pre></table></code></div></div><p>一旦那个完成我们可以像清除相机目标一样使用 ClearRenderTarget，在这种情况下只关心深度缓冲区。通过执行缓冲区完成。如果你有至少一个阴影方向光活动那么你会看到阴影贴集的清除动作显示在帧调试器中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetRenderTarget</span><span class="p">(</span>
    <span class="n">dirShadowAtlasId</span><span class="p">,</span>
    <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">DontCare</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span>
<span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">ClearRenderTarget</span><span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">clear</span><span class="p">);</span>
<span class="nf">ExecuteBuffer</span><span class="p">();</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/clearing-two-render-targets.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/clearing-two-render-targets.png" alt="清除两个渲染目标" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">清除两个渲染目标</figcaption></figure><aside class="collapsible-aside"><h3>为什么我得到一个关于尺寸不匹配的错误？</h3><div><p>这在 Unity 2020 的这个点可能发生。继续，它会在下一节被解决。</p></div></aside><h3 id="阴影优先"><span class="me-2">阴影优先</span><a href="#阴影优先" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为我们在阴影贴集之前设置常规相机，我们最终在渲染常规几何体之前切换到阴影贴集，这不是我们想要的。我们应该在 CameraRenderer.Render 中调用 CameraRenderer.Setup 之前渲染阴影，这样常规渲染将不受影响。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">//Setup();</span>
<span class="n">lighting</span><span class="p">.</span><span class="nf">Setup</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">cullingResults</span><span class="p">,</span> <span class="n">shadowSettings</span><span class="p">);</span>
<span class="nf">Setup</span><span class="p">();</span>
<span class="nf">DrawVisibleGeometry</span><span class="p">(</span><span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/shadows-first.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/shadows-first.png" alt="阴影优先" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">阴影优先</figcaption></figure><p>我们可以通过在设置光照之前开始一个采样并在清除相机目标之前立即结束它来将阴影入口保留在相机内部的帧调试器中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">SampleName</span><span class="p">);</span>
<span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="n">lighting</span><span class="p">.</span><span class="nf">Setup</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">cullingResults</span><span class="p">,</span> <span class="n">shadowSettings</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">SampleName</span><span class="p">);</span>
<span class="nf">Setup</span><span class="p">();</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/nested-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/nested-shadows.png" alt="嵌套阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">嵌套阴影</figcaption></figure><h3 id="渲染"><span class="me-2">渲染</span><a href="#渲染" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要为单个光渲染阴影，我们将添加一个变体 RenderDirectionalShadows 方法到 Shadow，带有两个参数：第一个是阴影光索引，第二个是它在贴集中的瓦片的大小。然后在另一个 RenderDirectionalShadows 方法中为所有阴影光调用这个方法，被 BeginSample 和 EndSample 调用包裹。因为我们目前只支持一个阴影光，它的瓦片大小等于贴集大小。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">ClearRenderTarget</span><span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">clear</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">ShadowedDirectionalLightCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="nf">RenderDirectionalShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">atlasSize</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><p>要渲染阴影我们需要一个 ShadowDrawingSettings 结构值。我们可以通过使用剔除结果和适当的可见光索引调用它的构造方法来创建一个正确配置的，这是我们之前存储的。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowedDirectionalLight</span> <span class="n">light</span> <span class="p">=</span> <span class="n">ShadowedDirectionalLights</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="kt">var</span> <span class="n">shadowSettings</span> <span class="p">=</span>
        <span class="k">new</span> <span class="nf">ShadowDrawingSettings</span><span class="p">(</span><span class="n">cullingResults</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Unity 2022 也要求我们提供一个额外参数来指示我们使用正交投影，虽然这个要求在 2023 又被移除了。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">shadowSettings</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ShadowDrawingSettings</span><span class="p">(</span>
    <span class="n">cullingResults</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span>
    <span class="n">BatchCullingProjectionType</span><span class="p">.</span><span class="n">Orthographic</span>
<span class="p">);</span>
</pre></table></code></div></div><p>阴影贴图的想法是我们从光的角度渲染场景，只存储深度信息。结果告诉我们光线在击中某物之前传播多远。</p><p>然而，方向光假设为无限远，因此没有真正的位置。所以我们所做的替代是找出视图和投影矩阵，它们匹配光的方向并给我们一个裁剪空间立方体，它与包含光阴影的相机可见区域重叠。与其自己想出这个，我们可以使用剔除结果的 ComputeDirectionalShadowMatricesAndCullingPrimitives 方法为我们做这个，传递它九个参数。</p><p>第一个参数是可见光索引。接下来三个参数是两个整数和一个 Vector3，它们控制阴影cascaded。我们稍后将处理cascaded，所以现在使用零、一和零向量。之后是纹理大小，对此我们需要使用瓦片大小。第六个参数是阴影近剪裁平面，我们将忽略并现在设置为零。</p><p>那些是输入参数，剩余三个是输出参数。第一个是视图矩阵，然后是投影矩阵，最后一个参数是 ShadowSplitData 结构。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">shadowSettings</span> <span class="p">=</span> <span class="p">...;</span>

<span class="n">cullingResults</span><span class="p">.</span><span class="nf">ComputeDirectionalShadowMatricesAndCullingPrimitives</span><span class="p">(</span>
    <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span>
    <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">viewMatrix</span><span class="p">,</span> <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">projectionMatrix</span><span class="p">,</span>
    <span class="k">out</span> <span class="n">ShadowSplitData</span> <span class="n">splitData</span>
<span class="p">);</span>
</pre></table></code></div></div><p>分割数据包含关于如何剔除阴影投射物体的信息，我们必须把它复制到阴影设置。我们必须通过在缓冲区上调用 SetViewProjectionMatrices 来应用视图和投影矩阵。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">cullingResults</span><span class="p">.</span><span class="nf">ComputeDirectionalShadowMatricesAndCullingPrimitives</span><span class="p">(...);</span>
<span class="n">shadowSettings</span><span class="p">.</span><span class="n">splitData</span> <span class="p">=</span> <span class="n">splitData</span><span class="p">;</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetViewProjectionMatrices</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span> <span class="n">projectionMatrix</span><span class="p">);</span>
</pre></table></code></div></div><p>我们最终通过执行缓冲区然后在上下文上调用 DrawShadows 来调度阴影投射体的绘制，阴影设置通过引用传递给它们。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">shadowSettings</span><span class="p">.</span><span class="n">splitData</span> <span class="p">=</span> <span class="n">splitData</span><span class="p">;</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetViewProjectionMatrices</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span> <span class="n">projectionMatrix</span><span class="p">);</span>
<span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="n">context</span><span class="p">.</span><span class="nf">DrawShadows</span><span class="p">(</span><span class="k">ref</span> <span class="n">shadowSettings</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="shadow-caster-pass"><span class="me-2">Shadow Caster Pass</span><a href="#shadow-caster-pass" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在这个点阴影投射体应该被渲染，但贴集保持空白。这是因为 DrawShadows 只渲染材质有 ShadowCaster 通道的物体。所以给我们的 Lit 着色器添加第二个 Pass 块，设置它的光照模式为 ShadowCaster。使用相同的目标级别，给它实例化支持，加上 _CLIPPING 着色器特性。然后让它使用特殊阴影投射体函数，我们将在一个新的 ShadowCasterPass HLSL 文件中定义它们。也因为我们要只写深度，通过在 HLSL 程序之前添加 ColorMask 0 来禁用写颜色数据。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Tags</span> <span class="p">{</span>
        <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"CustomLit"</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Tags</span> <span class="p">{</span>
        <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ShadowCaster"</span>
    <span class="p">}</span>

    <span class="n">ColorMask</span> <span class="mi">0</span>

    <span class="n">HLSLPROGRAM</span>
    <span class="cp">#pragma target 3.5
</span>    <span class="cp">#pragma shader_feature _CLIPPING
</span>    <span class="cp">#pragma multi_compile_instancing
</span>    <span class="cp">#pragma vertex ShadowCasterPassVertex
</span>    <span class="cp">#pragma fragment ShadowCasterPassFragment
</span>    <span class="cp">#include</span> <span class="cpf">"ShadowCasterPass.hlsl"</span><span class="cp">
</span>    <span class="n">ENDHLSL</span>
<span class="p">}</span>
</pre></table></code></div></div><p>通过复制 LitPass 并移除对阴影投射体不必要的所有东西来创建 ShadowCasterPass 文件。所以我们只需要裁剪空间位置，加上基础颜色用于剪裁。片段函数没有任何要返回的所以变成没有语义的 void。它唯一做的是可能剪裁片段。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_SHADOW_CASTER_PASS_INCLUDED
#define CUSTOM_SHADOW_CASTER_PASS_INCLUDED
</span>
<span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Common.hlsl"</span><span class="cp">
</span>
<span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">sampler_BaseMap</span><span class="p">);</span>

<span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseMap_ST</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>

<span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">positionCS</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="n">VAR_BASE_UV</span><span class="p">;</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="n">Varyings</span> <span class="nf">ShadowCasterPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Varyings</span> <span class="n">output</span><span class="p">;</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
    <span class="kt">float3</span> <span class="n">positionWS</span> <span class="o">=</span> <span class="n">TransformObjectToWorld</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span> <span class="o">=</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">positionWS</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">baseST</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_BaseMap_ST</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">*</span> <span class="n">baseST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">baseST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ShadowCasterPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">baseMap</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">baseColor</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">base</span> <span class="o">=</span> <span class="n">baseMap</span> <span class="o">*</span> <span class="n">baseColor</span><span class="p">;</span>
    <span class="cp">#if defined(_CLIPPING)
</span>        <span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">));</span>
    <span class="cp">#endif
</span><span class="p">}</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>我们现在能够渲染阴影投射体。我创建了一个简单的测试场景，包含一些在一个平面上的不透明物体，有一个以全强度启用阴影的方向光来尝试它。光被设置为使用硬阴影还是软阴影没关系。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/test-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/test-scene.png" alt="阴影测试场景" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">阴影测试场景</figcaption></figure><p>阴影还没有影响最终渲染的图像，但我们已经可以通过帧调试器看到被渲染到阴影贴集中的东西了。它通常可视化为单色纹理，随着距离增加从白色到黑色，但当使用 OpenGL 时是红色并向另一个方向。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/distance-100.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/distance-100.png" alt="512 贴集；最大距离 100" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">512 贴集；最大距离 100</figcaption></figure><p>当最大阴影距离设置为 100 时，我们最终得到所有东西只被渲染到纹理的一小部分。减少最大距离有效地使阴影贴图放大到相机前面的东西。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/distance-20.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/distance-20.png" alt="最大距离 20 和 10" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/distance-10.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/distance-10.png" alt="最大距离 20 和 10" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">最大距离 20 和 10</figcaption></figure><p>注意阴影投射体是用正交投影渲染的，因为我们为方向光渲染。</p><h3 id="多个光"><span class="me-2">多个光</span><a href="#多个光" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们可以有最多四个方向光，所以让我们也支持最多四个阴影方向光。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">maxShadowedDirectionalLightCount</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>
</pre></table></code></div></div><p>作为一个快速测试我使用了四个等效的方向光，除了我把它们的 Y 旋转调整了 90° 增量。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/four-lights.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/four-lights.png" alt="四个光的阴影投射体，叠加" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">四个光的阴影投射体，叠加</figcaption></figure><p>虽然我们最终正确为所有光渲染了阴影投射体，但它们是叠加的，因为我们对每个光渲染到整个贴集。我们必须分割我们的贴集，这样我们可以给每个光自己的瓦片来渲染。</p><p>我们支持最多四个阴影光，我们将在我们的方形贴集中给每个光一个方形瓦片。所以如果我们最终有多于一个阴影光我们必须将贴集分割为四个瓦片，通过将瓦片大小减半。在 Shadows.RenderDirectionalShadows 中确定分割数量和瓦片大小并每光传递给另一个方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">split</span> <span class="p">=</span> <span class="n">ShadowedDirectionalLightCount</span> <span class="p">&lt;=</span> <span class="m">1</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="m">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tileSize</span> <span class="p">=</span> <span class="n">atlasSize</span> <span class="p">/</span> <span class="n">split</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">ShadowedDirectionalLightCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="nf">RenderDirectionalShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></table></code></div></div><p>我们可以通过调整渲染视口来渲染到单个瓦片。为此创建一个方法，带有瓦片索引和分割作为参数。它首先计算瓦片偏移，以索引模除分割作为 X 偏移，索引除以分割作为 Y 偏移。这些是整数操作但我们最终定义一个 Rect，所以将结果存储为 Vector2。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">SetTileViewport</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Vector2</span> <span class="n">offset</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">index</span> <span class="p">%</span> <span class="n">split</span><span class="p">,</span> <span class="n">index</span> <span class="p">/</span> <span class="n">split</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在缓冲区上以一个 Rect 调用 SetViewPort，带有偏移缩放瓦片大小，瓦片大小应该立即成为一个浮点数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">SetTileViewport</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Vector2</span> <span class="n">offset</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">index</span> <span class="p">%</span> <span class="n">split</span><span class="p">,</span> <span class="n">index</span> <span class="p">/</span> <span class="n">split</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetViewport</span><span class="p">(</span><span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span>
        <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">tileSize</span><span class="p">,</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">tileSize</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">,</span> <span class="n">tileSize</span>
    <span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在设置矩阵时在 RenderDirectionalShadows 中调用 SetTileViewport。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetViewProjectionMatrices</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span> <span class="n">projectionMatrix</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/four-tiles.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/four-tiles.png" alt="四个瓦片在使用中的阴影贴集" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">四个瓦片在使用中的阴影贴集</figcaption></figure><h2 id="采样阴影"><span class="me-2">采样阴影</span><a href="#采样阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>现在我们渲染阴影投射体，但这还不影响最终图像。为了让阴影显示，我们必须在 CustomLit 通道中采样阴影贴图并使用它来确定一个表面片段是否被阴影。</p><h3 id="阴影矩阵"><span class="me-2">阴影矩阵</span><a href="#阴影矩阵" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>对于每个片段我们必须从阴影贴集中的适当瓦片采样深度信息。所以我们必须找到一个给世界空间位置的阴影纹理坐标。我们将通过为每个阴影方向光创建一个阴影变换矩阵并把它们发送到 GPU 使这成为可能。为这个给 Shadows 添加一个 _DirectionalShadowMatrices 着色器属性标识符和静态矩阵数组。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="n">dirShadowAtlasId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalShadowAtlas"</span><span class="p">),</span>
    <span class="n">dirShadowMatricesId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalShadowMatrices"</span><span class="p">);</span>

<span class="k">static</span> <span class="n">Matrix4x4</span><span class="p">[]</span>
    <span class="n">dirShadowMatrices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Matrix4x4</span><span class="p">[</span><span class="n">maxShadowedDirectionalLightCount</span><span class="p">];</span>
</pre></table></code></div></div><p>我们可以在 RenderDirectionalShadows 中通过乘以光的阴影投影矩阵和视图矩阵来创建从世界空间到光空间的转换矩阵。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
    <span class="n">dirShadowMatrices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">projectionMatrix</span> <span class="p">*</span> <span class="n">viewMatrix</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetViewProjectionMatrices</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span> <span class="n">projectionMatrix</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后一旦所有阴影光被渲染，通过在缓冲区上调用 SetGlobalMatrixArray 把矩阵发送到 GPU。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalMatrixArray</span><span class="p">(</span><span class="n">dirShadowMatricesId</span><span class="p">,</span> <span class="n">dirShadowMatrices</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然而，这忽略了我们正在使用阴影贴集的事实。让我们创建一个 ConvertToAtlasMatrix 方法，它接受一个光矩阵、瓦片偏移和分割，并返回一个从世界空间转换到阴影瓦片空间的矩阵。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">Matrix4x4</span> <span class="nf">ConvertToAtlasMatrix</span> <span class="p">(</span><span class="n">Matrix4x4</span> <span class="n">m</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们已经在 SetTileViewport 中计算瓦片偏移，所以让它返回那个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">Vector2</span> <span class="nf">SetTileViewport</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后调整 RenderDirectionalShadows 使它调用 ConvertToAtlasMatrix。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">//SetTileViewport(index, split, tileSize);</span>
<span class="n">dirShadowMatrices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ConvertToAtlasMatrix</span><span class="p">(</span>
    <span class="n">projectionMatrix</span> <span class="p">*</span> <span class="n">viewMatrix</span><span class="p">,</span>
    <span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">),</span> <span class="n">split</span>
<span class="p">);</span>
</pre></table></code></div></div><p>在 ConvertToAtlasMatrix 中我们应该做的第一件事是如果使用反转 Z 缓冲区则否定 Z 维度。我们可以通过 SystemInfo.usesReversedZBuffer 检查这个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">Matrix4x4</span> <span class="nf">ConvertToAtlasMatrix</span> <span class="p">(</span><span class="n">Matrix4x4</span> <span class="n">m</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SystemInfo</span><span class="p">.</span><span class="n">usesReversedZBuffer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span><span class="p">.</span><span class="n">m20</span> <span class="p">=</span> <span class="p">-</span><span class="n">m</span><span class="p">.</span><span class="n">m20</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">m21</span> <span class="p">=</span> <span class="p">-</span><span class="n">m</span><span class="p">.</span><span class="n">m21</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">m22</span> <span class="p">=</span> <span class="p">-</span><span class="n">m</span><span class="p">.</span><span class="n">m22</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">m23</span> <span class="p">=</span> <span class="p">-</span><span class="n">m</span><span class="p">.</span><span class="n">m23</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>为什么 Z 缓冲区被反转？</h3><div><p>零表示零深度和一表示最大深度是最直观的。这是 OpenGL 做的。但由于深度缓冲区中精度受限以及它是非线性存储的事实，我们通过反转来更好地使用位。其他图形 API 使用反转方法。通常我们不需要担心这个，除非我们显式工作在裁剪空间。</p></div></aside><p>其次，裁剪空间定义在内部一个立方体中，坐标从 −1 到 1，零在中心。但纹理坐标和深度从零到一。我们可以通过缩放和偏移 XYZ 维度一半来把这个转换烤入矩阵中。我们可以用矩阵乘法做这个，但它会导致很多与零的乘法和不必要的加法。所以让我们直接调整矩阵。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">m</span><span class="p">.</span><span class="n">m00</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m00</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m30</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">m01</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m01</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m31</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">m02</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m02</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m32</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">m03</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m03</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m33</span><span class="p">);</span>

<span class="n">m</span><span class="p">.</span><span class="n">m10</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m10</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m30</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">m11</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m11</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m31</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">m12</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m12</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m32</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">m13</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m13</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m33</span><span class="p">);</span>

<span class="n">m</span><span class="p">.</span><span class="n">m20</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m20</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m30</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">m21</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m21</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m31</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">m22</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m22</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m32</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">m23</span> <span class="p">=</span> <span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m23</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m33</span><span class="p">);</span>

<span class="k">return</span> <span class="n">m</span><span class="p">;</span>
</pre></table></code></div></div><p>最后，我们必须应用瓦片偏移和缩放。我们可以再次直接做这个以避免很多不必要的计算。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">scale</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">split</span><span class="p">;</span>

<span class="n">m</span><span class="p">.</span><span class="n">m00</span> <span class="p">=</span> <span class="p">(</span><span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m00</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m30</span><span class="p">)</span> <span class="p">+</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">m</span><span class="p">.</span><span class="n">m30</span><span class="p">)</span> <span class="p">*</span> <span class="n">scale</span><span class="p">;</span>
<span class="n">m</span><span class="p">.</span><span class="n">m01</span> <span class="p">=</span> <span class="p">(</span><span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m01</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m31</span><span class="p">)</span> <span class="p">+</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">m</span><span class="p">.</span><span class="n">m31</span><span class="p">)</span> <span class="p">*</span> <span class="n">scale</span><span class="p">;</span>
<span class="n">m</span><span class="p">.</span><span class="n">m02</span> <span class="p">=</span> <span class="p">(</span><span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m02</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m32</span><span class="p">)</span> <span class="p">+</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">m</span><span class="p">.</span><span class="n">m32</span><span class="p">)</span> <span class="p">*</span> <span class="n">scale</span><span class="p">;</span>
<span class="n">m</span><span class="p">.</span><span class="n">m03</span> <span class="p">=</span> <span class="p">(</span><span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m03</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m33</span><span class="p">)</span> <span class="p">+</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">m</span><span class="p">.</span><span class="n">m33</span><span class="p">)</span> <span class="p">*</span> <span class="n">scale</span><span class="p">;</span>

<span class="n">m</span><span class="p">.</span><span class="n">m10</span> <span class="p">=</span> <span class="p">(</span><span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m10</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m30</span><span class="p">)</span> <span class="p">+</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">m</span><span class="p">.</span><span class="n">m30</span><span class="p">)</span> <span class="p">*</span> <span class="n">scale</span><span class="p">;</span>
<span class="n">m</span><span class="p">.</span><span class="n">m11</span> <span class="p">=</span> <span class="p">(</span><span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m11</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m31</span><span class="p">)</span> <span class="p">+</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">m</span><span class="p">.</span><span class="n">m31</span><span class="p">)</span> <span class="p">*</span> <span class="n">scale</span><span class="p">;</span>
<span class="n">m</span><span class="p">.</span><span class="n">m12</span> <span class="p">=</span> <span class="p">(</span><span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m12</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m32</span><span class="p">)</span> <span class="p">+</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">m</span><span class="p">.</span><span class="n">m32</span><span class="p">)</span> <span class="p">*</span> <span class="n">scale</span><span class="p">;</span>
<span class="n">m</span><span class="p">.</span><span class="n">m13</span> <span class="p">=</span> <span class="p">(</span><span class="m">0.5f</span> <span class="p">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">m13</span> <span class="p">+</span> <span class="n">m</span><span class="p">.</span><span class="n">m33</span><span class="p">)</span> <span class="p">+</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">m</span><span class="p">.</span><span class="n">m33</span><span class="p">)</span> <span class="p">*</span> <span class="n">scale</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="每光存储阴影数据"><span class="me-2">每光存储阴影数据</span><a href="#每光存储阴影数据" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要为一个光采样阴影我们需要知道它在阴影贴集中的瓦片索引，如果它有一个。这是必须每个光存储的东西，所以让 ReserveDirectionalShadows 返回所需数据。我们将提供两个值：阴影强度和阴影瓦片偏移，打包在一个 Vector2 中。如果光不获得阴影那么结果是零向量。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Vector2</span> <span class="nf">ReserveDirectionalShadows</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">ShadowedDirectionalLights</span><span class="p">[</span><span class="n">ShadowedDirectionalLightCount</span><span class="p">]</span> <span class="p">=</span>
            <span class="k">new</span> <span class="n">ShadowedDirectionalLight</span> <span class="p">{</span>
                <span class="n">visibleLightIndex</span> <span class="p">=</span> <span class="n">visibleLightIndex</span>
            <span class="p">};</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span>
            <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="n">ShadowedDirectionalLightCount</span><span class="p">++</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让 Lighting 通过一个 _DirectionalLightShadowData 向量数组使这些数据可用于着色器。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="n">dirLightCountId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalLightCount"</span><span class="p">),</span>
    <span class="n">dirLightColorsId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalLightColors"</span><span class="p">),</span>
    <span class="n">dirLightDirectionsId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalLightDirections"</span><span class="p">),</span>
    <span class="n">dirLightShadowDataId</span> <span class="p">=</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalLightShadowData"</span><span class="p">);</span>

<span class="k">static</span> <span class="n">Vector4</span><span class="p">[]</span>
    <span class="n">dirLightColors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxDirLightCount</span><span class="p">],</span>
    <span class="n">dirLightDirections</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxDirLightCount</span><span class="p">],</span>
    <span class="n">dirLightShadowData</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxDirLightCount</span><span class="p">];</span>

<span class="p">...</span>

<span class="k">void</span> <span class="nf">SetupLights</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVectorArray</span><span class="p">(</span><span class="n">dirLightShadowDataId</span><span class="p">,</span> <span class="n">dirLightShadowData</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">SetupDirectionalLight</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">ref</span> <span class="n">VisibleLight</span> <span class="n">visibleLight</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dirLightColors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">visibleLight</span><span class="p">.</span><span class="n">finalColor</span><span class="p">;</span>
    <span class="n">dirLightDirections</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="p">-</span><span class="n">visibleLight</span><span class="p">.</span><span class="n">localToWorldMatrix</span><span class="p">.</span><span class="nf">GetColumn</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
    <span class="n">dirLightShadowData</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span>
        <span class="n">shadows</span><span class="p">.</span><span class="nf">ReserveDirectionalShadows</span><span class="p">(</span><span class="n">visibleLight</span><span class="p">.</span><span class="n">light</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>并把它添加到 Light HLSL 文件的 _CustomLight 缓冲区中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomLight</span><span class="p">)</span>
    <span class="n">int</span> <span class="n">_DirectionalLightCount</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">_DirectionalLightColors</span><span class="p">[</span><span class="n">MAX_DIRECTIONAL_LIGHT_COUNT</span><span class="p">];</span>
    <span class="kt">float4</span> <span class="n">_DirectionalLightDirections</span><span class="p">[</span><span class="n">MAX_DIRECTIONAL_LIGHT_COUNT</span><span class="p">];</span>
    <span class="kt">float4</span> <span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">MAX_DIRECTIONAL_LIGHT_COUNT</span><span class="p">];</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><h3 id="shadows-hlsl-文件"><span class="me-2">Shadows HLSL 文件</span><a href="#shadows-hlsl-文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们还将创建一个专用的 Shadows HLSL 文件用于阴影采样。为方向光定义相同的最大阴影方向光计数，加上 _DirectionalShadowAtlas 纹理，加上 _CustomShadows 缓冲区中的 _DirectionalShadowMatrices 数组。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_SHADOWS_INCLUDED
#define CUSTOM_SHADOWS_INCLUDED
</span>
<span class="cp">#define MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT 4
</span>
<span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_DirectionalShadowAtlas</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">sampler_DirectionalShadowAtlas</span><span class="p">);</span>

<span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomShadows</span><span class="p">)</span>
    <span class="kt">float4x4</span> <span class="n">_DirectionalShadowMatrices</span><span class="p">[</span><span class="n">MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT</span><span class="p">];</span>
<span class="n">CBUFFER_END</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>因为贴集不是普通纹理，让我们通过 TEXTURE2D_SHADOW 宏观定义它以更清晰，即使这对我们支持的平台没有区别。我们将使用一个特殊的 SAMPLER_CMP 宏观来定义采样器状态，因为这确实为阴影贴图定义了一个不同的采样方式，因为普通双线性过滤对深度数据没有意义。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">TEXTURE2D_SHADOW</span><span class="p">(</span><span class="n">_DirectionalShadowAtlas</span><span class="p">);</span>
<span class="n">SAMPLER_CMP</span><span class="p">(</span><span class="n">sampler_DirectionalShadowAtlas</span><span class="p">);</span>
</pre></table></code></div></div><p>事实上，只有一种适当的方式采样阴影贴图，所以我们可以定义一个明确的采样器状态而不是依赖 Unity 为我们的渲染纹理推导的那个。采样器状态可以通过创建一个名称中有特定词的内联来定义。我们可以使用 sampler_linear_clamp_compare。让我们也为它定义一个简写 SHADOW_SAMPLER 宏观。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">TEXTURE2D_SHADOW</span><span class="p">(</span><span class="n">_DirectionalShadowAtlas</span><span class="p">);</span>
<span class="cp">#define SHADOW_SAMPLER sampler_linear_clamp_compare
</span>
<span class="n">SAMPLER_CMP</span><span class="p">(</span><span class="n">SHADOW_SAMPLER</span><span class="p">);</span>
</pre></table></code></div></div><p>在 LitPass 中的 Light 之前包含 Shadows。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Surface.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Shadows.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Light.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><h3 id="采样阴影-1"><span class="me-2">采样阴影</span><a href="#采样阴影-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要采样阴影我们需要知道每光阴影数据，所以让我们在 Shadows 中定义一个结构，专门用于方向光。它包含强度和瓦片偏移，但 Shadows 中的代码不知道它存储在哪里。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">DirectionalShadowData</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">strength</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">tileIndex</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>我们还需要知道表面位置，所以把它添加到 Surface 结构。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Surface</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">position</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></table></code></div></div><p>并在 LitPassFragment 中分配它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">Surface</span> <span class="n">surface</span><span class="p">;</span>
<span class="n">surface</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">positionWS</span><span class="p">;</span>
<span class="n">surface</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">normalWS</span><span class="p">);</span>
</pre></table></code></div></div><p>给 Shadows 添加一个 SampleDirectionalShadowAtlas 函数来通过 SAMPLE_TEXTURE2D_SHADOW 宏观采样阴影贴集，传递给它贴图、阴影采样器和阴影纹理空间中的位置，这是一个相应的参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">SampleDirectionalShadowAtlas</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionSTS</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">SAMPLE_TEXTURE2D_SHADOW</span><span class="p">(</span>
        <span class="n">_DirectionalShadowAtlas</span><span class="p">,</span> <span class="n">SHADOW_SAMPLER</span><span class="p">,</span> <span class="n">positionSTS</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后添加一个 GetDirectionalShadowAttenuation 函数，它返回阴影衰减，给定方向阴影数据和应该在世界空间定义的表面。它使用瓦片偏移来检索正确的矩阵，把表面位置转换到阴影瓦片空间，然后采样贴集。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetDirectionalShadowAttenuation</span> <span class="p">(</span><span class="n">DirectionalShadowData</span> <span class="n">data</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">positionSTS</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span>
        <span class="n">_DirectionalShadowMatrices</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">tileIndex</span><span class="p">],</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SampleDirectionalShadowAtlas</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>采样阴影贴集的结果是一个因子，确定多少光到达表面，只考虑阴影。它是一个在 0–1 范围中的值，称为衰减因子。如果片段被完全阴影我们得到零，当完全没有被阴影我们得到一。之间的值表示片段被部分阴影。</p><p>除此之外，光的阴影强度可以被降低，要么为了艺术原因要么表示半透明表面的阴影。当强度被降低为零那么衰减不受阴影影响，应该是一。所以最终衰减是基于强度在一和采样衰减之间线性插值找到的。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="nf">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
</pre></table></code></div></div><p>但当阴影强度为零则不需要采样阴影，因为它们没有影响甚至没有被渲染。在那个情况我们有一个无阴影光并应该总返回一。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetDirectionalShadowAttenuation</span> <span class="p">(</span><span class="n">DirectionalShadowData</span> <span class="n">data</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>在着色器中分支是个好主意吗？</h3><div><p>分支过去是低效的，但现代 GPU 能很好地处理它们。你必须记住的是片段块被并行着色。如果即使一个片段以一种特定方式分支那么整个块都做，即使所有其他片段忽略那个代码路径的结果。在这个情况我们基于光的强度分支，这——至少在这个点——对所有片段是一样的。</p></div></aside><h3 id="衰减光"><span class="me-2">衰减光</span><a href="#衰减光" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们将把光的衰减存储在 Light 结构中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">color</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">direction</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>给 Light 添加一个获取方向阴影数据的函数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">DirectionalShadowData</span> <span class="nf">GetDirectionalShadowData</span> <span class="p">(</span><span class="n">int</span> <span class="n">lightIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DirectionalShadowData</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">tileIndex</span> <span class="o">=</span> <span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后给 GetDirectionalLight 添加一个世界空间表面参数，让它检索方向阴影数据并使用 GetDirectionalShadowAttenuation 来设置光的衰减。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">Light</span> <span class="nf">GetDirectionalLight</span> <span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Light</span> <span class="n">light</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_DirectionalLightColors</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">_DirectionalLightDirections</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">DirectionalShadowData</span> <span class="n">shadowData</span> <span class="o">=</span> <span class="n">GetDirectionalShadowData</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="n">light</span><span class="p">.</span><span class="n">attenuation</span> <span class="o">=</span> <span class="n">GetDirectionalShadowAttenuation</span><span class="p">(</span><span class="n">shadowData</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在 Lighting 中的 GetLighting 也必须把表面传递给 GetDirectionalLight。表面现在预期被定义在世界空间，所以相应地重命名参数。只有 BRDF 不关心光和表面的空间，只要它们匹配。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GetDirectionalLightCount</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">color</span> <span class="o">+=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">GetDirectionalLight</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让阴影工作的最后一步是将衰减因子考虑到光的强度中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">IncomingLight</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span>
        <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">)</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">attenuation</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">light</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/one-shadowed-light.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/one-shadowed-light.png" alt="一个带阴影的光；最大距离 10；贴集大小 512" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">一个带阴影的光；最大距离 10；贴集大小 512</figcaption></figure><p>我们最终得到了阴影，但它们看起来很糟糕。不应该被阴影的表面最终被阴影伪影覆盖，形成像素化带。这些是由错误自阴影引起的，由于阴影贴图的有限分辨率。使用不同的分辨率改变伪影模式但不会消除它们。表面最终部分阴影自己，但我们稍后将处理这个问题。伪影使看到阴影贴图覆盖的区域变得容易，所以让我们暂时保留它们。</p><p>例如，我们可以看到阴影贴图只覆盖可见区域的一部分，由最大阴影距离控制。改变最大值增长或收缩区域。阴影贴图与光方向对齐，不与相机。一些阴影在最大距离之外可见，但一些缺失，并且当阴影在贴图边缘之外采样时变得奇怪。如果只有一个阴影光活动那么结果被钳位，否则采样可以穿越瓦片边界，一个光最终使用来自另一个光的阴影。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/two-shadowed-lights.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/two-shadowed-lights.png" alt="两个带阴影的光，都以一半强度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">两个带阴影的光，都以一半强度</figcaption></figure><p>我们稍后将正确在最大距离切除阴影，但目前这些无效阴影保持可见。</p><h2 id="cascaded阴影贴图"><span class="me-2">cascaded阴影贴图</span><a href="#cascaded阴影贴图" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>因为方向光影响最大阴影距离内的所有东西，它们的阴影贴图最终覆盖一个大区域。因为阴影贴图使用正交投影，阴影贴图中的每个纹素都有固定的世界空间大小。如果这个大小太大那么个别阴影纹素清晰可见，导致锯齿状阴影边缘和小阴影可以消失。这可以通过增加贴集大小来缓解，但只能达到一个点。</p><p>当使用透视相机时，更远的东西看起来更小。在某视觉距离一个阴影贴图纹素将映射到单个显示像素，这意味着阴影分辨率理论上是最佳的。更接近相机我们需要更高的阴影分辨率，而更远更低的分辨率就够了。这建议理想情况下我们使用一个变量阴影贴图分辨率，基于阴影接收器的视图距离。</p><p>cascaded阴影贴图是这个问题的解决方案。想法是阴影投射体被渲染不止一次，所以每个光在贴集中获得多个瓦片，称为cascaded。第一个cascaded只覆盖接近相机的小区域，随后的cascaded放大来用相同数量的纹素覆盖一个越来越大的区域。着色器然后为每个片段采样可用的最佳cascaded。</p><h3 id="设置"><span class="me-2">设置</span><a href="#设置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Unity 的阴影代码支持每个方向光最多四个cascaded。到目前为止我们只使用一个cascaded，覆盖最大阴影距离内的所有东西。为了支持更多我们将向方向阴影设置添加一个cascaded计数滑块。虽然我们可以每个方向光使用不同数量，但为所有阴影方向光使用相同的最有意义。</p><p>每个cascaded覆盖阴影区域的一部分，直到最大阴影距离。我们将通过为前三个cascaded添加比例滑块来使确切部分可配置。最后一个cascaded总是覆盖整个范围所以不需要滑块。将cascaded计数设置默认为四，cascaded比例为 0.1、0.25 和 0.5。这些比例应该每cascaded增加，但我们不会在 UI 中强制这个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">struct</span> <span class="nc">Directional</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">MapSize</span> <span class="n">atlasSize</span><span class="p">;</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">cascadeCount</span><span class="p">;</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">cascadeRatio1</span><span class="p">,</span> <span class="n">cascadeRatio2</span><span class="p">,</span> <span class="n">cascadeRatio3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">Directional</span> <span class="n">directional</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Directional</span> <span class="p">{</span>
    <span class="n">atlasSize</span> <span class="p">=</span> <span class="n">MapSize</span><span class="p">.</span><span class="n">_1024</span><span class="p">,</span>
    <span class="n">cascadeCount</span> <span class="p">=</span> <span class="m">4</span><span class="p">,</span>
    <span class="n">cascadeRatio1</span> <span class="p">=</span> <span class="m">0.1f</span><span class="p">,</span>
    <span class="n">cascadeRatio2</span> <span class="p">=</span> <span class="m">0.25f</span><span class="p">,</span>
    <span class="n">cascadeRatio3</span> <span class="p">=</span> <span class="m">0.5f</span>
<span class="p">};</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/cascade-count-ratios.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/cascade-count-ratios.png" alt="cascaded计数和比例" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">cascaded计数和比例</figcaption></figure><p>ComputeDirectionalShadowMatricesAndCullingPrimitives 方法要求我们提供一个打包在 Vector3 中的比例，所以让我们向设置添加一个方便的属性以那种形式检索它们。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Vector3</span> <span class="n">CascadeRatios</span> <span class="p">=&gt;</span>
    <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">cascadeRatio1</span><span class="p">,</span> <span class="n">cascadeRatio2</span><span class="p">,</span> <span class="n">cascadeRatio3</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="渲染cascaded"><span class="me-2">渲染cascaded</span><a href="#渲染cascaded" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>每个cascaded需要它自己的变换矩阵，所以 Shadows 的阴影矩阵数组大小必须被每个光最大cascaded数量乘，这是四。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">maxShadowedDirectionalLightCount</span> <span class="p">=</span> <span class="m">4</span><span class="p">,</span> <span class="n">maxCascades</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>

<span class="p">...</span>

<span class="k">static</span> <span class="n">Matrix4x4</span><span class="p">[]</span>
    <span class="n">dirShadowMatrices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Matrix4x4</span><span class="p">[</span><span class="n">maxShadowedDirectionalLightCount</span> <span class="p">*</span> <span class="n">maxCascades</span><span class="p">];</span>
</pre></table></code></div></div><p>在 Shadows 中也增加数组的大小。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#define MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT 4
#define MAX_CASCADE_COUNT 4
</span>
<span class="p">...</span>

<span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomShadows</span><span class="p">)</span>
    <span class="kt">float4x4</span> <span class="n">_DirectionalShadowMatrices</span>
        <span class="p">[</span><span class="n">MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT</span> <span class="o">*</span> <span class="n">MAX_CASCADE_COUNT</span><span class="p">];</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>做这个之后 Unity 会抱怨着色器的数组大小改变了，但它不能使用新大小。那是因为固定数组一旦被着色器声明它们的大小不能在同一会话期间的 GPU 上被更改。我们必须重启 Unity 来重新初始化它。</p><p>做完那个后，在 Shadows.ReserveDirectionalShadows 中乘以返回的瓦片偏移被配置的cascaded数量，因为每个方向光现在将声明多个连续瓦片。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span>
    <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span>
    <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeCount</span> <span class="p">*</span> <span class="n">ShadowedDirectionalLightCount</span><span class="p">++</span>
<span class="p">);</span>
</pre></table></code></div></div><p>同样，使用的瓦片数量在 RenderDirectionalShadows 中被乘，这意味着我们最终可能总共十六个瓦片，需要分割为四。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">tiles</span> <span class="p">=</span> <span class="n">ShadowedDirectionalLightCount</span> <span class="p">*</span> <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeCount</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">split</span> <span class="p">=</span> <span class="n">tiles</span> <span class="p">&lt;=</span> <span class="m">1</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="n">tiles</span> <span class="p">&lt;=</span> <span class="m">4</span> <span class="p">?</span> <span class="m">2</span> <span class="p">:</span> <span class="m">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tileSize</span> <span class="p">=</span> <span class="n">atlasSize</span> <span class="p">/</span> <span class="n">split</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>为什么也不支持分割为三？</strong></p><p>我们将自己限制为 2 的幂，我们应用于贴集大小的相同限制。这样整数除法总是可能的，否则我们可以得到错位问题。这意味着一些光配置不会使用所有可用瓦片，浪费纹理空间。如果这是一个问题那么你可以添加对不需要是方形的矩形贴集的支持。然而，你更可能被你可以渲染的瓦片数量而不是纹理空间限制。</p><p>现在 RenderDirectionalShadows 必须为每个cascaded绘制阴影。把从 ComputeDirectionalShadowMatricesAndCullingPrimitives 到并包括 DrawShadows 的代码放在每个配置cascaded的循环中。ComputeDirectionalShadowMatricesAndCullingPrimitives 的第二个参数现在成为cascaded索引，然后是cascaded数量和cascaded比例。也调整瓦片索引使它成为光的瓦片偏移加cascaded索引。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowedDirectionalLight</span> <span class="n">light</span> <span class="p">=</span> <span class="n">shadowedDirectionalLights</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="kt">var</span> <span class="n">shadowSettings</span> <span class="p">=</span> <span class="p">...;</span>
    <span class="kt">int</span> <span class="n">cascadeCount</span> <span class="p">=</span> <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeCount</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tileOffset</span> <span class="p">=</span> <span class="n">index</span> <span class="p">*</span> <span class="n">cascadeCount</span><span class="p">;</span>
    <span class="n">Vector3</span> <span class="n">ratios</span> <span class="p">=</span> <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">CascadeRatios</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">cascadeCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">cullingResults</span><span class="p">.</span><span class="nf">ComputeDirectionalShadowMatricesAndCullingPrimitives</span><span class="p">(</span>
            <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cascadeCount</span><span class="p">,</span> <span class="n">ratios</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span>
            <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">viewMatrix</span><span class="p">,</span> <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">projectionMatrix</span><span class="p">,</span>
            <span class="k">out</span> <span class="n">ShadowSplitData</span> <span class="n">splitData</span>
        <span class="p">);</span>
        <span class="n">shadowSettings</span><span class="p">.</span><span class="n">splitData</span> <span class="p">=</span> <span class="n">splitData</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">tileIndex</span> <span class="p">=</span> <span class="n">tileOffset</span> <span class="p">+</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">dirShadowMatrices</span><span class="p">[</span><span class="n">tileIndex</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ConvertToAtlasMatrix</span><span class="p">(</span>
            <span class="n">projectionMatrix</span> <span class="p">*</span> <span class="n">viewMatrix</span><span class="p">,</span>
            <span class="nf">SetTileViewport</span><span class="p">(</span><span class="n">tileIndex</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">),</span> <span class="n">split</span>
        <span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetViewProjectionMatrices</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span> <span class="n">projectionMatrix</span><span class="p">);</span>
        <span class="nf">ExecuteBuffer</span><span class="p">();</span>
        <span class="n">context</span><span class="p">.</span><span class="nf">DrawShadows</span><span class="p">(</span><span class="k">ref</span> <span class="n">shadowSettings</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/one-light-four-cascades.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/one-light-four-cascades.png" alt="一个或四个光源对应的cascaded；最大距离 30；比例 0.3, 0.4, 0.5" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/four-lights-four-cascades.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/four-lights-four-cascades.png" alt="一个或四个光源对应的cascaded；最大距离 30；比例 0.3, 0.4, 0.5" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">一个或四个光源对应的cascaded；最大距离 30；比例 0.3, 0.4, 0.5</figcaption></figure><h3 id="剔除球体"><span class="me-2">剔除球体</span><a href="#剔除球体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Unity 通过为它创建一个剔除球体来确定每个cascaded覆盖的区域。因为阴影投影是正交和方形的，它们最终紧密拟合它们的剔除球体但也覆盖一些周围的空间。那就是为什么一些阴影可以在剔除区域之外可见。还有，光方向对球体不重要，所以所有方向光最终使用相同的剔除球体。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/culling-spheres.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/culling-spheres.png" alt="用透明球体可视化的剔除球体" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">用透明球体可视化的剔除球体</figcaption></figure><p>这些球体也需要来确定从哪个cascaded采样，所以我们必须把它们发送到 GPU。为cascaded计数添加一个标识符和一个cascaded剔除球体数组，加上一个球体数据的静态数组。它们被四分量定义，包含它们的 XYZ 位置加上 W 组件中的半径。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="n">dirShadowAtlasId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalShadowAtlas"</span><span class="p">),</span>
    <span class="n">dirShadowMatricesId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalShadowMatrices"</span><span class="p">),</span>
    <span class="n">cascadeCountId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CascadeCount"</span><span class="p">),</span>
    <span class="n">cascadeCullingSpheresId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CascadeCullingSpheres"</span><span class="p">);</span>

<span class="k">static</span> <span class="n">Vector4</span><span class="p">[]</span> <span class="n">cascadeCullingSpheres</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxCascades</span><span class="p">];</span>
</pre></table></code></div></div><p>cascaded的剔除球体是 ComputeDirectionalShadowMatricesAndCullingPrimitives 输出的分割数据的一部分。在 RenderDirectionalShadows 的循环中把它赋值给球体数组。但我们只需要对第一个光做这个，因为所有光的cascaded是等效的。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">cascadeCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="n">cullingResults</span><span class="p">.</span><span class="nf">ComputeDirectionalShadowMatricesAndCullingPrimitives</span><span class="p">(...);</span>
    <span class="n">shadowSettings</span><span class="p">.</span><span class="n">splitData</span> <span class="p">=</span> <span class="n">splitData</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cascadeCullingSpheres</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">splitData</span><span class="p">.</span><span class="n">cullingSphere</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们需要着色器中的球体来检查表面片段是否位于它们内部，这可以通过比较从球体中心到它的半径平方距离来完成。所以让我们存储平方半径而不是，这样我们不必在着色器中计算它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">Vector4</span> <span class="n">cullingSphere</span> <span class="p">=</span> <span class="n">splitData</span><span class="p">.</span><span class="n">cullingSphere</span><span class="p">;</span>
<span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span> <span class="p">*=</span> <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="n">cascadeCullingSpheres</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">cullingSphere</span><span class="p">;</span>
</pre></table></code></div></div><p>在渲染cascaded后将cascaded计数和球体发送到 GPU。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalInt</span><span class="p">(</span><span class="n">cascadeCountId</span><span class="p">,</span> <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeCount</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVectorArray</span><span class="p">(</span>
        <span class="n">cascadeCullingSpheresId</span><span class="p">,</span> <span class="n">cascadeCullingSpheres</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalMatrixArray</span><span class="p">(</span><span class="n">dirShadowMatricesId</span><span class="p">,</span> <span class="n">dirShadowMatrices</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="采样cascaded"><span class="me-2">采样cascaded</span><a href="#采样cascaded" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>向 Shadows 添加cascaded计数和剔除球体数组。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomShadows</span><span class="p">)</span>
    <span class="n">int</span> <span class="n">_CascadeCount</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">_CascadeCullingSpheres</span><span class="p">[</span><span class="n">MAX_CASCADE_COUNT</span><span class="p">];</span>
    <span class="kt">float4x4</span> <span class="n">_DirectionalShadowMatrices</span>
        <span class="p">[</span><span class="n">MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT</span> <span class="o">*</span> <span class="n">MAX_CASCADE_COUNT</span><span class="p">];</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>cascaded索引是每片段确定的，不是每光。所以让我们引入一个全局 ShadowData 结构包含它。我们稍后将给它添加更多数据。也添加一个 GetShadowData 函数，它返回世界空间表面的阴影数据，最初cascaded索引总是设置为零。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">ShadowData</span> <span class="p">{</span>
    <span class="n">int</span> <span class="n">cascadeIndex</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ShadowData</span> <span class="nf">GetShadowData</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowData</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">cascadeIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>添加新数据作为参数到 GetDirectionalShadowData，所以它可以通过加cascaded索引到光的阴影瓦片偏移来选择正确的瓦片索引。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">DirectionalShadowData</span> <span class="nf">GetDirectionalShadowData</span> <span class="p">(</span>
    <span class="n">int</span> <span class="n">lightIndex</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">shadowData</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">DirectionalShadowData</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">tileIndex</span> <span class="o">=</span>
        <span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">shadowData</span><span class="p">.</span><span class="n">cascadeIndex</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>也给 GetDirectionalLight 添加相同参数，这样它可以转发数据给 GetDirectionalShadowData。相应地重命名方向阴影数据变量。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">Light</span> <span class="nf">GetDirectionalLight</span> <span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">shadowData</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">DirectionalShadowData</span> <span class="n">dirShadowData</span> <span class="o">=</span>
        <span class="n">GetDirectionalShadowData</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">shadowData</span><span class="p">);</span>
    <span class="n">light</span><span class="p">.</span><span class="n">attenuation</span> <span class="o">=</span> <span class="n">GetDirectionalShadowAttenuation</span><span class="p">(</span><span class="n">dirShadowData</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 GetLighting 中获取阴影数据并传递它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowData</span> <span class="n">shadowData</span> <span class="o">=</span> <span class="n">GetShadowData</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
    <span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GetDirectionalLightCount</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Light</span> <span class="n">light</span> <span class="o">=</span> <span class="n">GetDirectionalLight</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">shadowData</span><span class="p">);</span>
        <span class="n">color</span> <span class="o">+=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">light</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/selecting-cascade.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/selecting-cascade.png" alt="总是使用第一个 vs. 最后一个cascaded" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">总是使用第一个 vs. 最后一个cascaded</figcaption></figure><p>要选择正确的cascaded我们需要计算两点之间的平方距离。让我们给 Common 添加一个方便的函数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">DistanceSquared</span><span class="p">(</span><span class="kt">float3</span> <span class="n">pA</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">pB</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">dot</span><span class="p">(</span><span class="n">pA</span> <span class="o">-</span> <span class="n">pB</span><span class="p">,</span> <span class="n">pA</span> <span class="o">-</span> <span class="n">pB</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 GetShadowData 中循环遍历所有cascaded剔除球体直到我们找到一个包含表面位置的。一旦找到就跳出循环然后使用当前循环迭代器作为cascaded索引。这意味着如果片段位于所有球体之外，我们最终得到一个无效索引，但目前我们将忽略这个。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_CascadeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">sphere</span> <span class="o">=</span> <span class="n">_CascadeCullingSpheres</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">float</span> <span class="n">distanceSqr</span> <span class="o">=</span> <span class="n">DistanceSquared</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">sphere</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">distanceSqr</span> <span class="o">&lt;</span> <span class="n">sphere</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">data</span><span class="p">.</span><span class="n">cascadeIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/selecting-cascade.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/selecting-cascade.png" alt="选择最佳cascaded" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">选择最佳cascaded</figcaption></figure><p>我们现在得到阴影，纹素密度分布好得多。cascaded之间弯曲的过渡边界也由于自阴影伪影可见，虽然我们可以通过用cascaded索引除以四替换阴影衰减使它们更容易发现。</p><h3 id="剔除阴影采样"><span class="me-2">剔除阴影采样</span><a href="#剔除阴影采样" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果我们最终在最后一个cascaded之后那么很可能没有有效阴影数据，我们应该根本不采样阴影。强制这个的一个简单方法是在 ShadowData 中添加一个强度字段，设置默认为一，如果在最后一个cascaded之后则设置为零。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">ShadowData</span> <span class="p">{</span>
    <span class="n">int</span> <span class="n">cascadeIndex</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">strength</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ShadowData</span> <span class="nf">GetShadowData</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowData</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_CascadeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_CascadeCount</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">data</span><span class="p">.</span><span class="n">cascadeIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在 GetDirectionalShadowData 中将全局阴影强度考虑到方向阴影强度。这剔除了最后一个cascaded之外的所有阴影。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span>
    <span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">x</span> <span class="o">*</span> <span class="n">shadowData</span><span class="p">.</span><span class="n">strength</span><span class="p">;</span>
</pre></table></code></div></div><p>也在 GetDirectionalLight 中恢复正确的衰减。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/culled-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/culled-shadows.png" alt="剔除阴影；最大距离 12" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">剔除阴影；最大距离 12</figcaption></figure><h3 id="最大距离"><span class="me-2">最大距离</span><a href="#最大距离" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>一些对最大阴影距离的实验将揭示一些阴影投射体突然消失而仍然位于最后一个cascaded的剔除球体内部。这发生是因为最外层剔除球体没有精确结束在配置的最大距离但稍微延伸到它之外。这个差异在小最大距离时最明显。</p><p>我们也可以在最大距离停止采样阴影来修复阴影的突然出现。要使这成为可能我们必须把最大距离发送到 GPU 中的 Shadows。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="p">...</span>
    <span class="n">cascadeCullingSpheresId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CascadeCullingSpheres"</span><span class="p">),</span>
    <span class="n">shadowDistanceId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_ShadowDistance"</span><span class="p">);</span>

<span class="p">...</span>

<span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">shadowDistanceId</span><span class="p">,</span> <span class="n">settings</span><span class="p">.</span><span class="n">maxDistance</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最大距离基于视图空间深度，不是到相机位置的距离。所以为了执行这个剔除我们需要知道表面的深度。为此给 Surface 添加一个字段。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Surface</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">position</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">normal</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">viewDirection</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">depth</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></table></code></div></div><p>深度可以通过 TransformWorldToView 从世界空间转换到视图空间并取否定 Z 坐标在 LitPassFragment 中找到。因为这个转换只是相对于世界空间的旋转和偏移，深度在视图空间和世界空间中都是相同的。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">surface</span><span class="p">.</span><span class="n">viewDirection</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">input</span><span class="p">.</span><span class="n">positionWS</span><span class="p">);</span>
<span class="n">surface</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="o">-</span><span class="n">TransformWorldToView</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionWS</span><span class="p">).</span><span class="n">z</span><span class="p">;</span>
</pre></table></code></div></div><p>现在总是在 GetShadowData 中初始化强度为一，只有当表面深度小于最大距离时，否则设置为零。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomShadows</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="n">float</span> <span class="n">_ShadowDistance</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>

<span class="p">...</span>

<span class="n">ShadowData</span> <span class="nf">GetShadowData</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowData</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="n">_ShadowDistance</span> <span class="o">?</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/depth-culled-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/depth-culled-shadows.png" alt="也基于深度剔除" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">也基于深度剔除</figcaption></figure><h3 id="衰减阴影"><span class="me-2">衰减阴影</span><a href="#衰减阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>突然在最大距离切除阴影可能非常明显，所以让我们通过线性衰减它们使过渡更平滑。衰减在最大之前一些距离开始，直到我们在最大达到零强度。我们可以使用函数 clamped 到 0–1，其中 $d$ 是表面深度，$m$ 是最大阴影距离，$f$ 是衰减范围，表示为最大距离的一部分。</p>\[\text{饱和度}( \frac{1- \dfrac{d}{m}}{f} )\] \[f = 0.1, 0.2, 和 0.5\]<p>向阴影设置添加一个距离衰减滑块。因为衰减和最大值都用作除数它们不应该为零，所以设置它们的最小值为 0.001。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">Min</span><span class="p">(</span><span class="m">0.001f</span><span class="p">)]</span>
<span class="k">public</span> <span class="kt">float</span> <span class="n">maxDistance</span> <span class="p">=</span> <span class="m">100f</span><span class="p">;</span>
<span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.001f</span><span class="p">,</span> <span class="m">1f</span><span class="p">)]</span>
<span class="k">public</span> <span class="kt">float</span> <span class="n">distanceFade</span> <span class="p">=</span> <span class="m">0.1f</span><span class="p">;</span>
</pre></table></code></div></div><p>在 Shadows 中用距离值和衰减值都的标识符替换阴影距离标识符。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">//shadowDistanceId = Shader.PropertyToID("_ShadowDistance");</span>
<span class="n">shadowDistanceFadeId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_ShadowDistanceFade"</span><span class="p">);</span>
</pre></table></code></div></div><p>当把它们作为向量的 XY 组件发送到 GPU 时，使用一除以值这样我们可以在着色器中避免除法，因为乘法更快。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">shadowDistanceId</span><span class="p">,</span> <span class="n">settings</span><span class="p">.</span><span class="n">maxDistance</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span>
    <span class="n">shadowDistanceFadeId</span><span class="p">,</span>
    <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="m">1f</span> <span class="p">/</span> <span class="n">settings</span><span class="p">.</span><span class="n">maxDistance</span><span class="p">,</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">settings</span><span class="p">.</span><span class="n">distanceFade</span><span class="p">)</span>
<span class="p">);</span>
</pre></table></code></div></div><p>调整 Shadows 中的 _CustomShadows 缓冲区来匹配。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">//float _ShadowDistance;</span>
<span class="kt">float4</span> <span class="n">_ShadowDistanceFade</span><span class="p">;</span>
</pre></table></code></div></div><p>现在我们可以使用 $(1-ds)f \text{ 饱和度 }$来计算衰减阴影强度，使用$\frac{1}{m}$作为缩放，使用 $s$作为新的褪色乘数$\dfrac{1}{f}$。为此创建一个 FadedShadowStrength 函数并在 GetShadowData 中使用它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">FadedShadowStrength</span> <span class="p">(</span><span class="n">float</span> <span class="nb">distance</span><span class="p">,</span> <span class="n">float</span> <span class="n">scale</span><span class="p">,</span> <span class="n">float</span> <span class="n">fade</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">saturate</span><span class="p">((</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="nb">distance</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span> <span class="o">*</span> <span class="n">fade</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ShadowData</span> <span class="nf">GetShadowData</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowData</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="n">FadedShadowStrength</span><span class="p">(</span>
        <span class="n">surfaceWS</span><span class="p">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">_ShadowDistanceFade</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">_ShadowDistanceFade</span><span class="p">.</span><span class="n">y</span>
    <span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/distance-fade-graph.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/distance-fade-graph.png" alt="距离衰减" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/distance-fade-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/distance-fade-scene.png" alt="距离衰减" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">距离衰减</figcaption></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/distance-fade-inspector.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/distance-fade-inspector.png" alt="距离衰减检查器" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">距离衰减检查器</figcaption></figure><h3 id="衰减cascaded"><span class="me-2">衰减cascaded</span><a href="#衰减cascaded" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们可以在最后一个cascaded的边缘也衰减阴影而不是切除它们，使用相同方法。为此添加一个cascaded衰减阴影设置滑块。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">struct</span> <span class="nc">Directional</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.001f</span><span class="p">,</span> <span class="m">1f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">cascadeFade</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">Directional</span> <span class="n">directional</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Directional</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">cascadeRatio3</span> <span class="p">=</span> <span class="m">0.5f</span><span class="p">,</span>
    <span class="n">cascadeFade</span> <span class="p">=</span> <span class="m">0.1f</span>
<span class="p">};</span>
</pre></table></code></div></div><p>唯一的区别是我们对cascaded使用平方距离和半径而不是线性深度和最大。这意味着过渡变得非线性$\dfrac{1-\dfrac{d^2}{r^2}}{f}$，其中 $r$ 是剔除球体半径。区别不是很大，但为了保持配置的衰减比例相同，我们必须用 $1-(1-f)^2$ 替换 $f$。然后我们将它存储在阴影距离衰减向量的 $Z$ 组件中，再次反转。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/cascade-fade-graph.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/cascade-fade-graph.png" alt="$ \text{带平方距离的 } f = 0.1, 0.2, 和 0.5 $" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">$ \text{带平方距离的 } f = 0.1, 0.2, 和 0.5 $</figcaption></figure><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">f</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">-</span> <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeFade</span><span class="p">;</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span>
    <span class="n">shadowDistanceFadeId</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
        <span class="m">1f</span> <span class="p">/</span> <span class="n">settings</span><span class="p">.</span><span class="n">maxDistance</span><span class="p">,</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">settings</span><span class="p">.</span><span class="n">distanceFade</span><span class="p">,</span>
        <span class="m">1f</span> <span class="p">/</span> <span class="p">(</span><span class="m">1f</span> <span class="p">-</span> <span class="n">f</span> <span class="p">*</span> <span class="n">f</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></table></code></div></div><p>要执行cascaded衰减，检查我们在循环中的最后一个cascaded同时仍在内部。如果是，为cascaded计算衰减阴影强度并把它因子到最终强度。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_CascadeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">sphere</span> <span class="o">=</span> <span class="n">_CascadeCullingSpheres</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">float</span> <span class="n">distanceSqr</span> <span class="o">=</span> <span class="n">DistanceSquared</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">sphere</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">distanceSqr</span> <span class="o">&lt;</span> <span class="n">sphere</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_CascadeCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">*=</span> <span class="n">FadedShadowStrength</span><span class="p">(</span>
                <span class="n">distanceSqr</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="n">sphere</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">_ShadowDistanceFade</span><span class="p">.</span><span class="n">z</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/cascade-fade-graph.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/cascade-fade-graph.png" alt="cascaded和距离衰减" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/cascade-fade-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/cascade-fade-scene.png" alt="cascaded和距离衰减" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">cascaded和距离衰减</figcaption></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/cascade-fade-inspector.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/cascade-fade-inspector.png" alt="cascaded衰减检查器" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">cascaded衰减检查器</figcaption></figure><h2 id="阴影质量"><span class="me-2">阴影质量</span><a href="#阴影质量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>现在我们有功能性的cascaded阴影贴图，让我们专注于改善阴影的质量。我们观察到的所有时间的伪影称为阴影黑斑，这是由表面与光方向不完全对齐时的错误自阴影引起的。当表面更接近与光方向平行时，黑斑变得更糟。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/shadow-acne.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/shadow-acne.png" alt="阴影黑斑" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">阴影黑斑</figcaption></figure><p>增加贴集大小减少阴影纹素的世界空间大小，所以黑斑伪影变得更小。然而，伪影数量也增加，所以问题不能简单地通过增加贴集大小解决。</p><h3 id="深度偏移"><span class="me-2">深度偏移</span><a href="#深度偏移" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>有各种方法可以缓解阴影黑斑。最简单的是给阴影投射体的深度添加一个恒定偏移，把它们推离光使错误自阴影不再发生。添加这个技术最快的方法是在渲染时通过在 DrawShadows 之前在缓冲区上调用 SetGlobalDepthBias 来应用一个全局深度偏移，之后设置它为零。这是一个在裁剪空间应用的深度偏移，是一个非常小值的倍数，确切取决于用于阴影贴图的精确格式。我们可以通过使用一个大值比如 50000 来了解它如何工作。对斜率-缩放偏移也有第二个参数，但目前我们将保持它为零。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">50000f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="n">context</span><span class="p">.</span><span class="nf">DrawShadows</span><span class="p">(</span><span class="k">ref</span> <span class="n">shadowSettings</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/constant-depth-bias.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/constant-depth-bias.png" alt="恒定深度偏移" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">恒定深度偏移</figcaption></figure><p>恒定偏移简单但只能移除大部分被直射照亮的表面的伪影。移除所有黑斑需要大得多的偏移，比如大一个数量级。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">500000f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/large-depth-bias.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/large-depth-bias.png" alt="更大的深度偏移" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">更大的深度偏移</figcaption></figure><p>然而，因为深度偏移把阴影投射体推离光，采样的阴影也在同一方向被移动。大到足以移除大多数黑斑，但这种偏移虽然不会把阴影移得太远，却会使它们看起来与它们的投射体分离，导致称为 Peter-Panning 的视觉伪影。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/without-peter-panning.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/without-peter-panning.png" alt="偏移导致彼得平移" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/with-peter-panning.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/with-peter-panning.png" alt="偏移导致彼得平移" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">偏移导致彼得平移</figcaption></figure><p>替代方法是应用斜率-缩放偏移，这是通过给 <code class="language-plaintext highlighter-rouge">SetGlobalDepthBias</code> 的第二个参数使用非零值来完成的。这个值用于缩放 $X$ 和 $Y$ 维度上的绝对裁剪空间深度导数的最大值。所以对于直射照亮的表面它是零，当光在两个维度的至少一个中以 $45°$ 角度击中时它是 $1$，当表面法线和光方向的点积达到零时它接近无穷大。所以偏移在需要更多时自动增加，但没有上界。结果需要低得多的因子来消除黑斑，比如 $3$ 而不是 $500000$。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">3f</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/slope-scale-bias.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/slope-scale-bias.png" alt="斜率-缩放偏移" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">斜率-缩放偏移</figcaption></figure><p>斜率-缩放偏移有效但不直观。需要实验来找到一个可接受的结果，它用黑斑换取彼得平移。所以让我们现在禁用它并寻找一个更直观和可预测的方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">//buffer.SetGlobalDepthBias(0f, 3f);</span>
<span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="n">context</span><span class="p">.</span><span class="nf">DrawShadows</span><span class="p">(</span><span class="k">ref</span> <span class="n">shadowSettings</span><span class="p">);</span>
<span class="c1">//buffer.SetGlobalDepthBias(0f, 0f);</span>
</pre></table></code></div></div><h3 id="cascaded数据"><span class="me-2">cascaded数据</span><a href="#cascaded数据" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为黑斑的大小取决于世界空间纹素大小，一个在所有情况下都工作的一致方法必须考虑这个。因为纹素大小每个cascaded变化，这意味着我们必须把更多cascaded数据发送到 GPU。为此给 Shadows 添加一个通用cascaded数据向量数组。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="p">...</span>
    <span class="n">cascadeCullingSpheresId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CascadeCullingSpheres"</span><span class="p">),</span>
    <span class="n">cascadeDataId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CascadeData"</span><span class="p">),</span>
    <span class="n">shadowDistanceFadeId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_ShadowDistanceFade"</span><span class="p">);</span>

<span class="k">static</span> <span class="n">Vector4</span><span class="p">[]</span>
    <span class="n">cascadeCullingSpheres</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxCascades</span><span class="p">],</span>
    <span class="n">cascadeData</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxCascades</span><span class="p">];</span>
</pre></table></code></div></div><p>与其他一切一起把它发送到 GPU。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVectorArray</span><span class="p">(</span>
    <span class="n">cascadeCullingSpheresId</span><span class="p">,</span> <span class="n">cascadeCullingSpheres</span>
<span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVectorArray</span><span class="p">(</span><span class="n">cascadeDataId</span><span class="p">,</span> <span class="n">cascadeData</span><span class="p">);</span>
</pre></table></code></div></div><p>我们可以做的一件事是把这些向量的 X 组件中剔除球体半径的倒数放入。这样我们不必在着色器中执行这个除法。在一个新的 SetCascadeData 方法中做这个，同时存储剔除球体并在 RenderDirectionalShadows 中调用它。向它传递cascaded索引、剔除球体和作为浮点的瓦片大小。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">split</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">cascadeCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">SetCascadeData</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">splitData</span><span class="p">.</span><span class="n">cullingSphere</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">SetCascadeData</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Vector4</span> <span class="n">cullingSphere</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cascadeData</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">x</span> <span class="p">=</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span> <span class="p">*=</span> <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">cascadeCullingSpheres</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">cullingSphere</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>添加cascaded数据到 Shadows 中的 _CustomShadows 缓冲区。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomShadows</span><span class="p">)</span>
    <span class="n">int</span> <span class="n">_CascadeCount</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">_CascadeCullingSpheres</span><span class="p">[</span><span class="n">MAX_CASCADE_COUNT</span><span class="p">];</span>
    <span class="kt">float4</span> <span class="n">_CascadeData</span><span class="p">[</span><span class="n">MAX_CASCADE_COUNT</span><span class="p">];</span>
    <span class="p">...</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>并在 GetShadowData 中使用新的预计算倒数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">*=</span> <span class="n">FadedShadowStrength</span><span class="p">(</span>
    <span class="n">distanceSqr</span><span class="p">,</span> <span class="n">_CascadeData</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">_ShadowDistanceFade</span><span class="p">.</span><span class="n">z</span>
<span class="p">);</span>
</pre></table></code></div></div><h3 id="法线偏移"><span class="me-2">法线偏移</span><a href="#法线偏移" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>错误自阴影发生是因为阴影投射体深度纹素覆盖多于一个片段，这导致投射体的体积从它的表面突出。所以如果我们足够缩小投射体这不应该再发生。然而，缩小阴影投射体会使阴影比它们应该的小，并可以引入不应该存在的孔。</p><p>我们也可以做相反：在采样阴影时膨胀表面。然后我们离表面采样一点点，刚好足够避免错误自阴影。这将调整阴影位置一点点，可能导致边缘错位并添加假阴影，但这些伪影远比彼得平移不明显。</p><p>我们可以通过为采样阴影的目的沿表面法线向量移动表面位置一点点来做这个。如果我们只考虑单维那么等于世界空间纹素大小的偏移应该足够。我们可以通过用瓦片大小除剔除球体直径在 SetCascadeData 中找到纹素大小。把它存储在cascaded数据向量的 Y 组件中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">texelSize</span> <span class="p">=</span> <span class="m">2f</span> <span class="p">*</span> <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span> <span class="p">/</span> <span class="n">tileSize</span><span class="p">;</span>
<span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span> <span class="p">*=</span> <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="n">cascadeCullingSpheres</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">cullingSphere</span><span class="p">;</span>
<span class="c1">//cascadeData[index].x = 1f / cullingSphere.w;</span>
<span class="n">cascadeData</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
    <span class="m">1f</span> <span class="p">/</span> <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
    <span class="n">texelSize</span>
<span class="p">);</span>
</pre></table></code></div></div><p>然而，这并不总是足够，因为纹素是方形。在最坏情况我们最终不得不沿方形对角线偏移，所以让我们用 √2 缩放它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">texelSize</span> <span class="p">*</span> <span class="m">1.4142136f</span>
</pre></table></code></div></div><p>在着色器端，给 GetDirectionalShadowAttenuation 添加全局阴影数据参数。乘以表面法线与偏移来找到法线偏移并在计算阴影瓦片空间位置之前把它加到世界位置。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetDirectionalShadowAttenuation</span> <span class="p">(</span>
    <span class="n">DirectionalShadowData</span> <span class="n">directional</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">strength</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">float3</span> <span class="n">normalBias</span> <span class="o">=</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span> <span class="n">_CascadeData</span><span class="p">[</span><span class="n">global</span><span class="p">.</span><span class="n">cascadeIndex</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">positionSTS</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span>
        <span class="n">_DirectionalShadowMatrices</span><span class="p">[</span><span class="n">directional</span><span class="p">.</span><span class="n">tileIndex</span><span class="p">],</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">normalBias</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SampleDirectionalShadowAtlas</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">directional</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 GetDirectionalLight 中传递额外数据给它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">light</span><span class="p">.</span><span class="n">attenuation</span> <span class="o">=</span>
    <span class="n">GetDirectionalShadowAttenuation</span><span class="p">(</span><span class="n">dirShadowData</span><span class="p">,</span> <span class="n">shadowData</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/normal-bias-sphere.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/normal-bias-sphere.png" alt="等于纹素大小的法线偏移" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">等于纹素大小的法线偏移</figcaption></figure><h3 id="可配置偏移"><span class="me-2">可配置偏移</span><a href="#可配置偏移" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>法线偏移移除了阴影黑斑而不引入明显的新伪影，但它不能消除所有阴影问题。例如，有可见的阴影线在地板下的墙上不应该在那里。这不是自阴影，而是从墙突出的阴影影响下面的地板。添加一点斜率-缩放偏移可以处理那些，但没有完美的值。所以让我们使用它们现有的 Bias 滑块每个光配置它。给 Shadows 中的 ShadowedDirectionalLight 结构添加一个字段。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">ShadowedDirectionalLight</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">slopeScaleBias</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>光的偏移通过它的 shadowBias 属性可用。在 ReserveDirectionalShadows 中把数据添加到它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">shadowedDirectionalLights</span><span class="p">[</span><span class="n">ShadowedDirectionalLightCount</span><span class="p">]</span> <span class="p">=</span>
    <span class="k">new</span> <span class="n">ShadowedDirectionalLight</span> <span class="p">{</span>
        <span class="n">visibleLightIndex</span> <span class="p">=</span> <span class="n">visibleLightIndex</span><span class="p">,</span>
        <span class="n">slopeScaleBias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowBias</span>
    <span class="p">};</span>
</pre></table></code></div></div><p>并在 RenderDirectionalShadows 中使用它来配置斜率-缩放偏移。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">slopeScaleBias</span><span class="p">);</span>
<span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="n">context</span><span class="p">.</span><span class="nf">DrawShadows</span><span class="p">(</span><span class="k">ref</span> <span class="n">shadowSettings</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalDepthBias</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
</pre></table></code></div></div><p>让我们也使用光现有的 Normal Bias 滑块来调制我们应用的法线偏移。让 ReserveDirectionalShadows 返回一个 Vector3 并为新 Z 组件使用光的 shadowNormalBias。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Vector3</span> <span class="nf">ReserveDirectionalShadows</span> <span class="p">(</span>
    <span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span>
            <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span>
            <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeCount</span> <span class="p">*</span> <span class="n">ShadowedDirectionalLightCount</span><span class="p">++,</span>
            <span class="n">light</span><span class="p">.</span><span class="n">shadowNormalBias</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>给 DirectionalShadowData 添加新法线偏移并在 Shadows 的 GetDirectionalShadowAttenuation 中应用它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">DirectionalShadowData</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">strength</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">tileIndex</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">normalBias</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>

<span class="n">float</span> <span class="nf">GetDirectionalShadowAttenuation</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">float3</span> <span class="n">normalBias</span> <span class="o">=</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span>
        <span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">normalBias</span> <span class="o">*</span> <span class="n">_CascadeData</span><span class="p">[</span><span class="n">global</span><span class="p">.</span><span class="n">cascadeIndex</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>并在 Light 的 GetDirectionalShadowData 中配置它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">data</span><span class="p">.</span><span class="n">tileIndex</span> <span class="o">=</span>
    <span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">y</span> <span class="o">+</span> <span class="n">shadowData</span><span class="p">.</span><span class="n">cascadeIndex</span><span class="p">;</span>
<span class="n">data</span><span class="p">.</span><span class="n">normalBias</span> <span class="o">=</span> <span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">z</span><span class="p">;</span>
</pre></table></code></div></div><p>我们现在可以每个光调整两个偏移。斜率-缩放偏移为零和法线偏移为一是好默认。如果你增加第一个你可以减少第二个。但记住我们以不同方式解释这些光设置而不是它们原本目的。它们过去是裁剪空间深度偏移和世界空间缩小法线偏移。所以当你创建一个新光你会得到重彼得平移直到你调整偏移。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/configured-bias-sphere.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/configured-bias-sphere.png" alt="两个偏移都设置为 0.6" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">两个偏移都设置为 0.6</figcaption></figure><h3 id="阴影平移"><span class="me-2">阴影平移</span><a href="#阴影平移" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>另一个可能导致伪影的潜在问题是 Unity 应用阴影平移。想法是当为方向光渲染阴影投射体时近剪裁平面尽可能向前移动。这增加深度精度，但意味着不在相机视图中的阴影投射体可能最终在近剪裁平面前面，导致它们不应该时被剪裁。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/clipped-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/clipped-shadows.png" alt="阴影被剪裁" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">阴影被剪裁</figcaption></figure><p>这是通过在 ShadowCasterPassVertex 中钳位顶点位置到近剪裁平面来解决的，有效展平位于近剪裁平面前面的阴影投射体，把它们粘在近剪裁平面上。我们通过取裁剪空间 Z 和 W 坐标的最大值，或当 <code class="language-plaintext highlighter-rouge">UNITY_REVERSED_Z</code> 被定义时的最小值来做这个。要为 W 坐标使用正确符号用 <code class="language-plaintext highlighter-rouge">UNITY_NEAR_CLIP_VALUE</code> 乘它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">output</span><span class="p">.</span><span class="n">positionCS</span> <span class="o">=</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">positionWS</span><span class="p">);</span>
<span class="cp">#if UNITY_REVERSED_Z
</span><span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span>
    <span class="nb">min</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">UNITY_NEAR_CLIP_VALUE</span><span class="p">);</span>
<span class="cp">#else
</span><span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span>
    <span class="nb">max</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">UNITY_NEAR_CLIP_VALUE</span><span class="p">);</span>
<span class="cp">#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/clamped-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/clamped-shadows.png" alt="阴影被约束" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">阴影被约束</figcaption></figure><p>这对于完全在近剪裁平面任一侧的阴影投射体完美工作，但穿越平面的阴影投射体变得变形，因为只有它们的一些顶点受影响。这对小三角形不可见，但大三角形可以最终变形很多，弯曲它们并经常导致它们下沉到表面。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/deformed-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/deformed-shadows.png" alt="非常长的立方体的变形阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">非常长的立方体的变形阴影</figcaption></figure><p>这个问题可以通过把近剪裁平面拉回一点来缓解。那是光的 Near Plane 滑块的用途。给 ShadowedDirectionalLight 添加一个近剪裁平面偏移字段。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">ShadowedDirectionalLight</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">slopeScaleBias</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">nearPlaneOffset</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>并把光的 shadowNearPlane 属性复制给它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">shadowedDirectionalLights</span><span class="p">[</span><span class="n">ShadowedDirectionalLightCount</span><span class="p">]</span> <span class="p">=</span>
    <span class="k">new</span> <span class="n">ShadowedDirectionalLight</span> <span class="p">{</span>
        <span class="n">visibleLightIndex</span> <span class="p">=</span> <span class="n">visibleLightIndex</span><span class="p">,</span>
        <span class="n">slopeScaleBias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowBias</span><span class="p">,</span>
        <span class="n">nearPlaneOffset</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowNearPlane</span>
    <span class="p">};</span>
</pre></table></code></div></div><p>我们通过填写 ComputeDirectionalShadowMatricesAndCullingPrimitives 的最后一个参数来应用它，我们之前给了一个固定值零。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">cullingResults</span><span class="p">.</span><span class="nf">ComputeDirectionalShadowMatricesAndCullingPrimitives</span><span class="p">(</span>
    <span class="n">light</span><span class="p">.</span><span class="n">visibleLightIndex</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cascadeCount</span><span class="p">,</span> <span class="n">ratios</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">,</span>
    <span class="n">light</span><span class="p">.</span><span class="n">nearPlaneOffset</span><span class="p">,</span> <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">viewMatrix</span><span class="p">,</span>
    <span class="k">out</span> <span class="n">Matrix4x4</span> <span class="n">projectionMatrix</span><span class="p">,</span> <span class="k">out</span> <span class="n">ShadowSplitData</span> <span class="n">splitData</span>
<span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/near-plane-offset.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/near-plane-offset.png" alt="带近剪裁平面偏移" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">带近剪裁平面偏移</figcaption></figure><h3 id="pcf-过滤"><span class="me-2">PCF 过滤</span><a href="#pcf-过滤" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>到目前为止我们只使用硬阴影，每片段采样一次阴影贴图。阴影比较采样器使用一种特殊形式的双线性插值，在插值之前执行深度比较。这称为百分比近距过滤——简称 PCF——具体是一个 2×2 PCF 过滤器，因为涉及四个纹素。</p><p>但这不是我们可以过滤阴影贴图的唯一方式。我们也可以使用更大的过滤器，使阴影更柔和且更少锯齿，虽然也不太准确。让我们添加 2×2、3×3、5×5 和 7×7 过滤的支持。我们不会使用现有的软阴影模式来每个光控制这个。我们将反而让所有方向光使用相同的过滤器。</p><p>为那个给 ShadowSettings 添加一个 FilterMode 枚举，加上一个过滤器选项到 Directional，默认设置 $2×2$。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">enum</span> <span class="n">FilterMode</span> <span class="p">{</span>
    <span class="n">PCF2x2</span><span class="p">,</span> <span class="n">PCF3x3</span><span class="p">,</span> <span class="n">PCF5x5</span><span class="p">,</span> <span class="n">PCF7x7</span>
<span class="p">}</span>

<span class="p">[</span><span class="n">System</span><span class="p">.</span><span class="n">Serializable</span><span class="p">]</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">Directional</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">MapSize</span> <span class="n">atlasSize</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">FilterMode</span> <span class="n">filter</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">Directional</span> <span class="n">directional</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Directional</span> <span class="p">{</span>
    <span class="n">atlasSize</span> <span class="p">=</span> <span class="n">MapSize</span><span class="p">.</span><span class="n">_1024</span><span class="p">,</span>
    <span class="n">filter</span> <span class="p">=</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">PCF2x2</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/filter.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/filter.png" alt="过滤器设置为 PCF 2x2" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">过滤器设置为 PCF 2x2</figcaption></figure><p>我们将为新过滤器模式创建着色器变体。给 Shadows 添加三个关键字的静态数组。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">string</span><span class="p">[]</span> <span class="n">directionalFilterKeywords</span> <span class="p">=</span> <span class="p">{</span>
    <span class="s">"_DIRECTIONAL_PCF3"</span><span class="p">,</span>
    <span class="s">"_DIRECTIONAL_PCF5"</span><span class="p">,</span>
    <span class="s">"_DIRECTIONAL_PCF7"</span><span class="p">,</span>
<span class="p">};</span>
</pre></table></code></div></div><p>创建一个 SetKeywords 方法，它启用或禁用适当的关键字。在执行缓冲区之前在 RenderDirectionalShadows 中调用它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nf">SetKeywords</span><span class="p">();</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">SetKeywords</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">enabledIndex</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">filter</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">directionalFilterKeywords</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">==</span> <span class="n">enabledIndex</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">EnableShaderKeyword</span><span class="p">(</span><span class="n">directionalFilterKeywords</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">DisableShaderKeyword</span><span class="p">(</span><span class="n">directionalFilterKeywords</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>更大的过滤器需要更多纹理采样。我们需要知道着色器中的贴集大小和纹素大小来做这个。为此添加一个着色器标识符。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">cascadeDataId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CascadeData"</span><span class="p">),</span>
<span class="n">shadowAtlasSizeId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_ShadowAtlasSize"</span><span class="p">),</span>
<span class="n">shadowDistanceFadeId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_ShadowDistanceFade"</span><span class="p">);</span>
</pre></table></code></div></div><p>并在着色器端的 _CustomShadow 添加它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomShadows</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="kt">float4</span> <span class="n">_ShadowAtlasSize</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">_ShadowDistanceFade</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>把大小存储在它的 X 组件和纹素大小在它的 Y 组件。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nf">SetKeywords</span><span class="p">();</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span>
    <span class="n">shadowAtlasSizeId</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="n">atlasSize</span><span class="p">,</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">atlasSize</span><span class="p">)</span>
<span class="p">);</span>
</pre></table></code></div></div><p>给 Lit 的 CustomLit 通道添加 #pragma multi_compile 指令用于三个关键字，加上下划线用于无关键字选项匹配 2×2 过滤器。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _PREMULTIPLY_ALPHA
#pragma multi_compile _ _DIRECTIONAL_PCF3 _DIRECTIONAL_PCF5 _DIRECTIONAL_PCF7
#pragma multi_compile_instancing
</span></pre></table></code></div></div><p>我们将使用 Core RP 库的 Shadow/ShadowSamplingTent HLSL 文件中定义的函数，所以在 Shadows 顶部包含它。如果定义了 3×3 关键字我们需要总共四个过滤器采样，我们将用 SampleShadow_ComputeSamples_Tent_3x3 函数设置它。我们只需要取四个采样，因为每个都使用双线性 2×2 过滤器。那些在所有方向偏移半个纹素在所有方向覆盖 3×3 纹素及帐篷过滤器，中心比边缘有更强权重。</p><p><strong>帐篷过滤器如何工作？</strong></p><p>Bloom 教程涵盖利用双线性纹理采样的过滤器内核，而 Depth of Field 教程包含一个 3×3 帐篷过滤器的例子。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Shadow/ShadowSamplingTent.hlsl"</span><span class="cp">
</span>
<span class="cp">#if defined(_DIRECTIONAL_PCF3)
</span>    <span class="cp">#define DIRECTIONAL_FILTER_SAMPLES 4
</span>    <span class="cp">#define DIRECTIONAL_FILTER_SETUP SampleShadow_ComputeSamples_Tent_3x3
#endif
</span>
<span class="cp">#define MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT 4
#define MAX_CASCADE_COUNT 4
</span></pre></table></code></div></div><p>出于相同原因我们可以为 5×5 过滤器用九个采样为 7×7 过滤器用十六个采样，加上适当命名的函数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_DIRECTIONAL_PCF3)
</span>    <span class="cp">#define DIRECTIONAL_FILTER_SAMPLES 4
</span>    <span class="cp">#define DIRECTIONAL_FILTER_SETUP SampleShadow_ComputeSamples_Tent_3x3
#elif defined(_DIRECTIONAL_PCF5)
</span>    <span class="cp">#define DIRECTIONAL_FILTER_SAMPLES 9
</span>    <span class="cp">#define DIRECTIONAL_FILTER_SETUP SampleShadow_ComputeSamples_Tent_5x5
#elif defined(_DIRECTIONAL_PCF7)
</span>    <span class="cp">#define DIRECTIONAL_FILTER_SAMPLES 16
</span>    <span class="cp">#define DIRECTIONAL_FILTER_SETUP SampleShadow_ComputeSamples_Tent_7x7
#endif
</span></pre></table></code></div></div><p>为阴影瓦片空间位置创建一个新的 FilterDirectionalShadow 函数。当定义了 DIRECTIONAL_FILTER_SETUP 它需要多次采样，否则它可以用一次调用 SampleDirectionalShadowAtlas 来满足。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">FilterDirectionalShadow</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionSTS</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(DIRECTIONAL_FILTER_SETUP)
</span>        <span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="n">SampleDirectionalShadowAtlas</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p>过滤器设置函数有四个参数。第一个是 float4 中的大小，前两个组件中有 X 和 Y 纹素大小，Z 和 W 中有总纹理大小。然后是原始采样位置，后面是每个采样的权重和位置的输出参数。它们被定义为 float 和 float2 数组。之后我们可以循环遍历所有采样，累积它们被它们的权重调制。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#if defined(DIRECTIONAL_FILTER_SETUP)
</span>    <span class="n">float</span> <span class="n">weights</span><span class="p">[</span><span class="n">DIRECTIONAL_FILTER_SAMPLES</span><span class="p">];</span>
    <span class="kt">float2</span> <span class="n">positions</span><span class="p">[</span><span class="n">DIRECTIONAL_FILTER_SAMPLES</span><span class="p">];</span>
    <span class="kt">float4</span> <span class="n">size</span> <span class="o">=</span> <span class="n">_ShadowAtlasSize</span><span class="p">.</span><span class="n">yyxx</span><span class="p">;</span>
    <span class="n">DIRECTIONAL_FILTER_SETUP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">positionSTS</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">positions</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DIRECTIONAL_FILTER_SAMPLES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shadow</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">SampleDirectionalShadowAtlas</span><span class="p">(</span>
            <span class="kt">float3</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">xy</span><span class="p">,</span> <span class="n">positionSTS</span><span class="p">.</span><span class="n">z</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="cp">#else
</span></pre></table></code></div></div><p>在 GetDirectionalShadowAttenuation 中调用这个新函数而不是直接去 SampleDirectionalShadowAtlas。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">FilterDirectionalShadow</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">directional</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/pcf2.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/pcf2.png" alt="PCF 2x2, 3x3" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/pcf3.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/pcf3.png" alt="PCF 2x2, 3x3" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">PCF 2x2, 3x3</figcaption></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/pcf5.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/pcf5.png" alt="PCF 5x5, 7x7" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/pcf7.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/pcf7.png" alt="PCF 5x5, 7x7" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">PCF 5x5, 7x7</figcaption></figure><p>增加过滤器大小使阴影更柔和，但也导致黑斑再次出现。我们必须增加法线偏移来匹配过滤器大小。我们可以在 SetCascadeData 中通过乘以纹素大小与一加过滤器模式来自动做这个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">SetCascadeData</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Vector4</span> <span class="n">cullingSphere</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tileSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">texelSize</span> <span class="p">=</span> <span class="m">2f</span> <span class="p">*</span> <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span> <span class="p">/</span> <span class="n">tileSize</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">filterSize</span> <span class="p">=</span> <span class="n">texelSize</span> <span class="p">*</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">filter</span> <span class="p">+</span> <span class="m">1f</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="m">1f</span> <span class="p">/</span> <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
    <span class="n">filterSize</span> <span class="p">*</span> <span class="m">1.4142136f</span>
<span class="p">);</span>
</pre></table></code></div></div><p>除此之外，增加采样区域也意味着我们最终可能采样在cascaded的剔除球体之外。我们可以通过在平方之前用过滤器大小减少球体的半径来避免那个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span> <span class="p">-=</span> <span class="n">filterSize</span><span class="p">;</span>
<span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span> <span class="p">*=</span> <span class="n">cullingSphere</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/pcf5-scaled-bias.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/pcf5-scaled-bias.png" alt="带缩放偏移的 PCF 5x5 和 7x7" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/pcf7-scaled-bias.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/pcf7-scaled-bias.png" alt="带缩放偏移的 PCF 5x5 和 7x7" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">带缩放偏移的 PCF 5x5 和 7x7</figcaption></figure><p>这再次解决阴影黑斑，但增加的过滤器大小加剧了应用法线偏移的缺点，并使我们在之前看到的墙阴影问题更糟。一些斜率-缩放偏移或更大的贴集大小需要来缓解这些伪影。</p><aside class="collapsible-aside"><h3>我们也应该减少半径来考虑法线偏移吗？</h3><div><p>法线偏移是每光源定义的，所以不能每cascaded设置。幸运的是，它只在偏移会把阴影采样推离选择的cascaded时成为问题。这只可靠发生在法线远离相机的表面，这意味着它几乎总是局限于不可见表面。如果偏移导致问题，那么你可以增加半径减少一些可配置因子。</p></div></aside><h3 id="混合cascaded"><span class="me-2">混合cascaded</span><a href="#混合cascaded" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>更柔和的阴影看起来更好，但也使cascaded之间的突然过渡更明显。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/hard-cascade-transition.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/hard-cascade-transition.png" alt="硬cascaded过渡；PCF 7x7" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">硬cascaded过渡；PCF 7x7</figcaption></figure><p>我们可以通过在cascaded之间添加一个过渡区域，我们在那里混合两者，使过渡不那么明显——虽然不能完全隐藏。我们已经有一个cascaded衰减因子可以用于这个目的。</p><p>首先，给 Shadows 中的 ShadowData 添加一个cascaded混合值，我们将用它来插值相邻cascaded之间。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">ShadowData</span> <span class="p">{</span>
    <span class="n">int</span> <span class="n">cascadeIndex</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">cascadeBlend</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">strength</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>最初在 GetShadowData 中把混合设置为 1，指示选择的cascaded在全强度。然后当在循环中找到cascaded时总是计算衰减因子。如果我们最后一个cascaded因子把它像之前一样考虑为强度，否则使用它为混合。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">data</span><span class="p">.</span><span class="n">cascadeBlend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="n">FadedShadowStrength</span><span class="p">(</span>
    <span class="n">surfaceWS</span><span class="p">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">_ShadowDistanceFade</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">_ShadowDistanceFade</span><span class="p">.</span><span class="n">y</span>
<span class="p">);</span>

<span class="n">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_CascadeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">sphere</span> <span class="o">=</span> <span class="n">_CascadeCullingSpheres</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">float</span> <span class="n">distanceSqr</span> <span class="o">=</span> <span class="n">DistanceSquared</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">sphere</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">distanceSqr</span> <span class="o">&lt;</span> <span class="n">sphere</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float</span> <span class="n">fade</span> <span class="o">=</span> <span class="n">FadedShadowStrength</span><span class="p">(</span>
            <span class="n">distanceSqr</span><span class="p">,</span> <span class="n">_CascadeData</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">_ShadowDistanceFade</span><span class="p">.</span><span class="n">z</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_CascadeCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">*=</span> <span class="n">fade</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">.</span><span class="n">cascadeBlend</span> <span class="o">=</span> <span class="n">fade</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在在 GetDirectionalShadowAttenuation 中检查cascaded混合是否小于一，在检索第一个阴影值之后。如果是那么我们在过渡区域，必须也从下一个cascaded采样并在两者之间插值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">FilterDirectionalShadow</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">cascadeBlend</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">normalBias</span> <span class="o">=</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span>
        <span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">normalBias</span> <span class="o">*</span> <span class="n">_CascadeData</span><span class="p">[</span><span class="n">global</span><span class="p">.</span><span class="n">cascadeIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
    <span class="n">positionSTS</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span>
        <span class="n">_DirectionalShadowMatrices</span><span class="p">[</span><span class="n">directional</span><span class="p">.</span><span class="n">tileIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
        <span class="kt">float4</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">normalBias</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">shadow</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span>
        <span class="n">FilterDirectionalShadow</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">),</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">global</span><span class="p">.</span><span class="n">cascadeBlend</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nf">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">directional</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/soft-cascade-transition.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/soft-cascade-transition.png" alt="软cascaded过渡" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">软cascaded过渡</figcaption></figure><p>注意cascaded衰减比例应用于每个cascaded的整个半径，不只是它的可见部分。所以确保比例不一直延伸到下个cascaded。一般这不是问题，因为你想要保持过渡区域小。</p><h3 id="抖动过渡"><span class="me-2">抖动过渡</span><a href="#抖动过渡" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然cascaded之间混合看起来更好，但它也使我们在混合区域中必须采样阴影贴图的次数加倍。替代方法是总是基于一个抖动模式从一个cascaded采样。这不看起来好但更便宜，特别是当使用大过滤器时。</p><p>给 Directional 添加一个cascaded混合模式选项，支持硬、软或抖动方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">enum</span> <span class="n">CascadeBlendMode</span> <span class="p">{</span>
    <span class="n">Hard</span><span class="p">,</span> <span class="n">Soft</span><span class="p">,</span> <span class="n">Dither</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">CascadeBlendMode</span> <span class="n">cascadeBlend</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">Directional</span> <span class="n">directional</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Directional</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">cascadeFade</span> <span class="p">=</span> <span class="m">0.1f</span><span class="p">,</span>
    <span class="n">cascadeBlend</span> <span class="p">=</span> <span class="n">Directional</span><span class="p">.</span><span class="n">CascadeBlendMode</span><span class="p">.</span><span class="n">Hard</span>
<span class="p">};</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/cascade-blend-mode.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/cascade-blend-mode.png" alt="cascaded混合模式" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">cascaded混合模式</figcaption></figure><p>给 Shadows 添加软和抖动cascaded混合关键字的静态数组。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">string</span><span class="p">[]</span> <span class="n">cascadeBlendKeywords</span> <span class="p">=</span> <span class="p">{</span>
    <span class="s">"_CASCADE_BLEND_SOFT"</span><span class="p">,</span>
    <span class="s">"_CASCADE_BLEND_DITHER"</span>
<span class="p">};</span>
</pre></table></code></div></div><p>调整 SetKeywords 使它为任意关键字数组和索引工作，然后也设置cascaded混合关键字。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">RenderDirectionalShadows</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nf">SetKeywords</span><span class="p">(</span>
        <span class="n">directionalFilterKeywords</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">filter</span> <span class="p">-</span> <span class="m">1</span>
    <span class="p">);</span>
    <span class="nf">SetKeywords</span><span class="p">(</span>
        <span class="n">cascadeBlendKeywords</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeBlend</span> <span class="p">-</span> <span class="m">1</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span>
        <span class="n">shadowAtlasSizeId</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="n">atlasSize</span><span class="p">,</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">atlasSize</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">SetKeywords</span> <span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">keywords</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enabledIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">keywords</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">==</span> <span class="n">enabledIndex</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">EnableShaderKeyword</span><span class="p">(</span><span class="n">keywords</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">DisableShaderKeyword</span><span class="p">(</span><span class="n">keywords</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>给 CustomLit 通道添加所需的多编译方向。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#pragma multi_compile _ _CASCADE_BLEND_SOFT _CASCADE_BLEND_DITHER
#pragma multi_compile_instancing
</span></pre></table></code></div></div><p>要执行抖动我们需要一个抖动浮点值，我们可以添加到 Surface。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Surface</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">float</span> <span class="n">dither</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>在 LitPassFragment 中生成抖动值有多种方法。最简单的是使用 Core RP 库的 InterleavedGradientNoise 函数，它给定一个屏幕空间 XY 位置生成一个旋转的瓦片抖动模式。在片段函数中这等于裁剪空间 XY 位置。它还需要一个用于动画的第二个参数，我们不需要并可以保持为零。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">surface</span><span class="p">.</span><span class="n">smoothness</span> <span class="o">=</span>
    <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Smoothness</span><span class="p">);</span>
<span class="n">surface</span><span class="p">.</span><span class="n">dither</span> <span class="o">=</span> <span class="n">InterleavedGradientNoise</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>在 GetShadowData 中设置cascaded索引之前，当不使用软混合时设置cascaded混合为零。这样整个分支将从那些着色器变体中消除。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_CascadeCount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#if !defined(_CASCADE_BLEND_SOFT)
</span><span class="n">data</span><span class="p">.</span><span class="n">cascadeBlend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="n">data</span><span class="p">.</span><span class="n">cascadeIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</pre></table></code></div></div><p>当使用抖动混合时，如果我们不在最后一个cascaded，如果混合值小于抖动值则跳到下一个cascaded。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_CascadeCount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#if defined(_CASCADE_BLEND_DITHER)
</span><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">cascadeBlend</span> <span class="o">&lt;</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">dither</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
#if !defined(_CASCADE_BLEND_SOFT)
</span><span class="n">data</span><span class="p">.</span><span class="n">cascadeBlend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/dithered-cascades.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/dithered-cascades.png" alt="抖动cascaded" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">抖动cascaded</figcaption></figure><p>可接受的抖动混合有多好取决于我们渲染帧的分辨率。如果使用一个涂抹最终结果的后效果那么它可以相当有效，例如与时间抗锯齿和动画抖动模式结合。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/dithered-zoomed-in.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/dithered-zoomed-in.png" alt="放大抖动" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">放大抖动</figcaption></figure><h2 id="透明度"><span class="me-2">透明度</span><a href="#透明度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们将通过考虑透明阴影投射体来结束本教程。剪裁、淡化和透明材质可以像不透明材质一样接收阴影，但目前只有剪裁材质自己投射正确阴影。透明物体表现得好像它们是固体阴影投射体。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/transparent.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/transparent.png" alt="剪裁和透明带阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">剪裁和透明带阴影</figcaption></figure><h3 id="阴影模式"><span class="me-2">阴影模式</span><a href="#阴影模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>有几种我们可以修改阴影投射体的方法。因为涉及写深度缓冲区，我们的阴影是二元的，要么存在要么不存在，但这仍然给我们一些灵活性。它们可以开启和完全固体，剪裁，抖动或完全关闭。我们可以独立于其他材质属性做这个，以支持最大灵活性。所以让我们为它添加一个单独的 _Shadows 着色器属性。我们可以使用 KeywordEnum 属性为它创建一个关键字下拉菜单，默认阴影开启。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">KeywordEnum</span><span class="p">(</span><span class="n">On</span><span class="p">,</span> <span class="n">Clip</span><span class="p">,</span> <span class="n">Dither</span><span class="p">,</span> <span class="n">Off</span><span class="p">)]</span> <span class="n">_Shadows</span> <span class="p">(</span><span class="s">"Shadows"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/shadow-modes.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/shadow-modes.png" alt="阴影开启" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">阴影开启</figcaption></figure><p>为这些模式添加着色器特性，替换现有的 _CLIPPING 特性。我们只需要三个变体，使用无关键字用于开启和关闭，_SHADOWS_CLIP 和 _SHADOWS_DITHER。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">//#pragma shader_feature _CLIPPING</span>
<span class="cp">#pragma shader_feature _ _SHADOWS_CLIP _SHADOWS_DITHER
</span></pre></table></code></div></div><p>在 CustomShaderGUI 中为阴影创建一个设置器属性。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">ShadowMode</span> <span class="p">{</span>
    <span class="n">On</span><span class="p">,</span> <span class="n">Clip</span><span class="p">,</span> <span class="n">Dither</span><span class="p">,</span> <span class="n">Off</span>
<span class="p">}</span>

<span class="n">ShadowMode</span> <span class="n">Shadows</span> <span class="p">{</span>
    <span class="k">set</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">SetProperty</span><span class="p">(</span><span class="s">"_Shadows"</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="k">value</span><span class="p">))</span> <span class="p">{</span>
            <span class="nf">SetKeyword</span><span class="p">(</span><span class="s">"_SHADOWS_CLIP"</span><span class="p">,</span> <span class="k">value</span> <span class="p">==</span> <span class="n">ShadowMode</span><span class="p">.</span><span class="n">Clip</span><span class="p">);</span>
            <span class="nf">SetKeyword</span><span class="p">(</span><span class="s">"_SHADOWS_DITHER"</span><span class="p">,</span> <span class="k">value</span> <span class="p">==</span> <span class="n">ShadowMode</span><span class="p">.</span><span class="n">Dither</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在预设方法中适当设置阴影。那将是不透明开启，剪裁剪裁，让我们淡化和透明都使用抖动。</p><h3 id="剪裁阴影"><span class="me-2">剪裁阴影</span><a href="#剪裁阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在 ShadowCasterPassFragment 中，用 _SHADOWS_CLIP 的检查替换 _CLIPPED 的检查。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_SHADOWS_CLIP)
</span><span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">));</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>现在可能给透明材质剪裁阴影，这对于有大部分完全不透明或透明但需要 alpha 混合的表面可能是适当的。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/transparent-clipped-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/transparent-clipped-shadows.png" alt="带剪裁阴影的透明" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">带剪裁阴影的透明</figcaption></figure><p>注意剪裁阴影不像固体阴影稳定，因为阴影矩阵当视图移动时改变，这导致片段移动一点点。这可能导致阴影贴图的一个纹素突然从剪裁到不剪裁过渡。</p><h3 id="抖动阴影"><span class="me-2">抖动阴影</span><a href="#抖动阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>抖动阴影工作像剪裁阴影一样，除了标准不同。在这种情况下，我们从表面 alpha 减去一个抖动值并基于那个剪裁。我们可以再次使用 InterleavedGradientNoise 函数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_SHADOWS_CLIP)
</span><span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">));</span>
<span class="cp">#elif defined(_SHADOWS_DITHER)
</span><span class="n">float</span> <span class="n">dither</span> <span class="o">=</span> <span class="n">InterleavedGradientNoise</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">dither</span><span class="p">);</span>
<span class="cp">#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/dithered-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/dithered-shadows.png" alt="抖动阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">抖动阴影</figcaption></figure><p>抖动可以用于近似半透明阴影投射体，但它是一个相当粗糙的方法。硬抖动阴影看起来糟，但当使用更大 PCF 过滤器时可能看起来可接受。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/dithered-pcf7.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/dithered-pcf7.png" alt="带 PCF7x7 的抖动" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">带 PCF7x7 的抖动</figcaption></figure><p>因为抖动模式每个纹素固定，重叠半透明阴影投射体不投射一个组合更暗的阴影。效果和最不透明阴影投射体一样强。还有，因为结果模式有噪声，它当阴影矩阵改变时遭受更多时间伪影，这可以使阴影看起来颤抖。这个方法对有固定投影的其他光源类型工作更好，只要物体不移动。对半透明物体使用剪裁阴影或根本没有阴影通常更实用。</p><h3 id="无阴影"><span class="me-2">无阴影</span><a href="#无阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>每个物体可以通过调整物体的 MeshRenderer 组件的 Cast Shadows 设置来关闭阴影投射。然而，如果你想为所有使用相同材质的东西关闭阴影这不实用，所以我们也支持每材质禁用它们。我们通过禁用材质的 ShadowCaster 通道来做这个。</p><p>给 CustomShaderGUI 添加一个 SetShadowCasterPass 方法，它首先通过检查 _Shadows 着色器属性是否存在来开始。如果是这样，也通过它的 hasMixedValue 属性检查所有选择的材质是否设置为相同模式。如果没有模式或混合则中止。否则，对每个材质启用或禁用 ShadowCaster 通道，通过在它们上调用 SetShaderPassEnabled，传递通道名称和启用状态作为参数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">SetShadowCasterPass</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialProperty</span> <span class="n">shadows</span> <span class="p">=</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_Shadows"</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shadows</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">shadows</span><span class="p">.</span><span class="n">hasMixedValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">enabled</span> <span class="p">=</span> <span class="n">shadows</span><span class="p">.</span><span class="n">floatValue</span> <span class="p">&lt;</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">ShadowMode</span><span class="p">.</span><span class="n">Off</span><span class="p">;</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">materials</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span><span class="p">.</span><span class="nf">SetShaderPassEnabled</span><span class="p">(</span><span class="s">"ShadowCaster"</span><span class="p">,</span> <span class="n">enabled</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>确保通道正确设置的最简单方法是在材质通过 GUI 被更改时总是调用 SetShadowCasterPass。我们可以通过在 OnGUI 开始时调用 EditorGUI.BeginChangeCheck 并在它结束时调用 EditorGUI.EndChangeCheck 来做这个。后者方法返回自我们开始检查以来是否有东西更改。如果是这样，设置阴影投射体通道。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnGUI</span> <span class="p">(</span>
    <span class="n">MaterialEditor</span> <span class="n">materialEditor</span><span class="p">,</span> <span class="n">MaterialProperty</span><span class="p">[]</span> <span class="n">properties</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="nf">BeginChangeCheck</span><span class="p">();</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="nf">EndChangeCheck</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">SetShadowCasterPass</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/not-casting-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/not-casting-shadows.png" alt="不投射阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">不投射阴影</figcaption></figure><h3 id="无光照阴影投射体"><span class="me-2">无光照阴影投射体</span><a href="#无光照阴影投射体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然无光照材质不受光照影响，你可能想让它们投射阴影。我们可以通过简单地从 Lit 复制 ShadowCaster 通道到 Unlit 着色器来支持那个。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/unlit-shadow-casters.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/unlit-shadow-casters.png" alt="无光照但投射阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">无光照但投射阴影</figcaption></figure><h3 id="接收阴影"><span class="me-2">接收阴影</span><a href="#接收阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>最后，我们也可以让光照表面忽略阴影，这对全息图之类的东西或只是为了艺术目的可能有用。给 Lit 添加一个 _RECEIVE_SHADOWS 关键字切换属性为此。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">Toggle</span><span class="p">(</span><span class="n">_RECEIVE_SHADOWS</span><span class="p">)]</span> <span class="n">_ReceiveShadows</span> <span class="p">(</span><span class="s">"Receive Shadows"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
</pre></table></code></div></div><p>加上在 CustomLit 通道的伴随着色器特性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _RECEIVE_SHADOWS
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/receiving-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/receiving-shadows.png" alt="接影阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">接影阴影</figcaption></figure><p>我们所需要做的是在定义了关键字时在 GetDirectionalShadowAttenuation 中强制将阴影衰减为一。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetDirectionalShadowAttenuation</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="cp">#if !defined(_RECEIVE_SHADOWS)
</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp4/not-receiving-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp4/not-receiving-shadows.png" alt="投射但不接影阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">投射但不接影阴影</figcaption></figure><p>下一篇<a href="../baked-light">Baked Light</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/scriptrenderpipeline/">ScriptRenderPipeline</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/srp/" class="post-tag no-text-decoration" >SRP</a> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a> <a href="/tags/shadows/" class="post-tag no-text-decoration" >Shadows</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:%E6%96%B9%E5%90%91%E9%98%B4%E5%BD%B1%20(%E7%BF%BB%E8%AF%91%E5%9B%9B)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Fdirectional-shadows%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:%E6%96%B9%E5%90%91%E9%98%B4%E5%BD%B1%20(%E7%BF%BB%E8%AF%91%E5%9B%9B)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Fdirectional-shadows%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Fdirectional-shadows%2F&text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:%E6%96%B9%E5%90%91%E9%98%B4%E5%BD%B1%20(%E7%BF%BB%E8%AF%91%E5%9B%9B)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/Unity_Shader_Transparent_1/">Unity 透明渲染(翻译十一)</a><li class="text-truncate lh-lg"> <a href="/posts/Unity_Deferred_Shading/">Unity Shader 延迟渲染(翻译十三)</a><li class="text-truncate lh-lg"> <a href="/posts/Unity_Static_Lightting/">Unity 光照烘焙(翻译十六)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-tessellation/">曲面细分(翻译二十二)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-surface-displacement/">曲面细分表面置换(翻译二十三)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/directional-lights/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1575043200" data-df="ll" > Nov 30, 2019 </time><h4 class="pt-0 my-2">自定义管线:方向光 (翻译三)</h4><div class="text-muted"><p>增加对多个方向光着色（shading）的支持。 已升级至 2022.3.62f2 1 光照 (Lighting) 如果我们想创建一个更真实的场景，那么我们就必须模拟光如何与表面相互作用。这需要一个比我们目前拥有的不发光（unlit）着色器更复杂的着色器。 1.1 受光着色器 (Lit Shader) 复制 UnlitPass.hlsl 文件并将其重命名为 LitPass.h...</p></div></div></a></article><article class="col"> <a href="/posts/drawcalls-shaders-batches/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1572451200" data-df="ll" > Oct 31, 2019 </time><h4 class="pt-0 my-2">自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</h4><div class="text-muted"><p>编写一个 HLSL shader 支持 SRP batcher、GPU instancing 以及 dynamic batching 为每个对象配置材质属性，并随机绘制多个对象 创建透明（transparent）和镂空（cutout）材质 Shaders 为了绘制物体，CPU 必须告诉 GPU 绘制什么以及如何绘制。绘制的内容通常是一个 mesh。如何绘制则由 shad...</p></div></div></a></article><article class="col"> <a href="/posts/custom-render-pipeline/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1569427200" data-df="ll" > Sep 26, 2019 </time><h4 class="pt-0 my-2">自定义渲染管线:初识渲染流程 (翻译一)</h4><div class="text-muted"><p>这是关于创建自定义脚本化渲染管线（Scriptable Render Pipeline, SRP）的系列教程的第一部分。它涵盖了我们将要在未来扩展的准系统渲染管线的初始创建。 创建渲染管线资源和实例 渲染摄像机视图 执行剔除、过滤和排序 分离不透明、透明和无效阶段 处理多个摄像机。 1 Render Pipeline 为了渲染任何内容，Unity 必须确定需...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/directional-lights/" class="btn btn-outline-primary" aria-label="Older" ><p>自定义管线:方向光 (翻译三)</p></a> <a href="/posts/claude-code-guide/" class="btn btn-outline-primary" aria-label="Newer" ><p>Claude Code学习总结：目录导航</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
