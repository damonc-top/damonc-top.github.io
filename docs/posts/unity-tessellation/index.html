<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="曲面细分(翻译二十二)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="创建 Hull Shader 和 Domain Shader。 细分三角形。 控制细分的方式。" /><meta property="og:description" content="创建 Hull Shader 和 Domain Shader。 细分三角形。 控制细分的方式。" /><link rel="canonical" href="www.damonc.top/posts/unity-tessellation/" /><meta property="og:url" content="www.damonc.top/posts/unity-tessellation/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/2018/month1/catRender22/01-shading-with-tessellation.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-01-27T10:00:02+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/2018/month1/catRender22/01-shading-with-tessellation.jpg" /><meta property="twitter:title" content="曲面细分(翻译二十二)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2026-02-15T23:10:59+08:00","datePublished":"2018-01-27T10:00:02+08:00","description":"创建 Hull Shader 和 Domain Shader。 细分三角形。 控制细分的方式。","headline":"曲面细分(翻译二十二)","image":{"lqip":"data:image/webp;base64,UklGRlYAAABXRUJQVlA4IEoAAADQAwCdASoUAAoAP3Ggxli0q6gjsAgCkC4JZwDM0Bn0JhcGlU6AU5AA+cyAZlS3iF3x1stJVRra7ZI8QHz6SrSYl4n8uRy+w4AAAA==","url":"https://img.damonc.top/posts/2018/month1/catRender22/01-shading-with-tessellation.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/unity-tessellation/"},"url":"www.damonc.top/posts/unity-tessellation/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>曲面细分(翻译二十二) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘摊手</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>曲面细分(翻译二十二)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>曲面细分(翻译二十二)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1517018402" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jan 27, 2018 </time> </span> <span> Updated <time data-ts="1771168259" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 15, 2026 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/01-shading-with-tessellation.jpg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/2018/month1/catRender22/01-shading-with-tessellation.jpg" alt="Preview Image" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRlYAAABXRUJQVlA4IEoAAADQAwCdASoUAAoAP3Ggxli0q6gjsAgCkC4JZwDM0Bn0JhcGlU6AU5AA+cyAZlS3iF3x1stJVRra7ZI8QHz6SrSYl4n8uRy+w4AAAA=="></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/unity-tessellation/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="8037 words" > <em>44 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">曲面细分(翻译二十二)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">曲面细分(翻译二十二)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>创建 Hull Shader 和 Domain Shader。<li>细分三角形。<li>控制细分的方式。</ul><hr /><h2 id="1-hull-和-domain"><span class="me-2">1 Hull 和 Domain</span><a href="#1-hull-和-domain" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>曲面细分是将物体切割成更小部分的艺术。在我们的案例中，我们将细分三角形，从而得到覆盖相同空间的小三角形。这使得为几何体添加更多细节成为可能，尽管在本教程中我们将重点关注曲面细分过程本身。</p><p>GPU 能够细分喂给它进行渲染的三角形。它这样做有多种原因，例如当三角形的一部分被剪裁时。我们无法控制这一点，但也有一个我们可以配置的曲面细分阶段。该阶段位于顶点（Vertex）和片元（Fragment）着色器阶段之间。但它不仅仅是向我们的 Shader 添加另一个程序那么简单。我们需要一个 <strong>Hull 程序</strong>和一个 <strong>Domain 程序</strong>。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/03-inside-hull-shader.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/03-inside-hull-shader.png" alt="Inside a hull shader" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="11-创建曲面细分-shader"><span class="me-2">1.1 创建曲面细分 Shader</span><a href="#11-创建曲面细分-shader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>第一步是创建一个启用了曲面细分的 Shader。让我们将需要的代码放在它自己的文件 <code class="language-plaintext highlighter-rouge">MyTessellation.cginc</code> 中，并带上包含保护。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#if !defined(TESSELLATION_INCLUDED)
#define TESSELLATION_INCLUDED
#endif
</span></pre></table></code></div></div><p>为了清楚地看到三角形被细分，我们将使用 Flat Wireframe Shader。复制该 Shader，重命名为 <code class="language-plaintext highlighter-rouge">Tessellation Shader</code> 并调整其菜单名称。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Custom/Tessellation"</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</pre></table></code></div></div><p>使用曲面细分时的最低 Shader Target 级别是 4.6。如果我们不手动设置，Unity 将发出警告并自动使用该级别。我们将为 forward base、additive 通道以及 deferred 通道添加曲面细分阶段。还要在这些通道中包含 <code class="language-plaintext highlighter-rouge">MyTessellation</code>，放在 <code class="language-plaintext highlighter-rouge">MyFlatWireframe</code> 之后。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#pragma target 4.6
</span><span class="err">…</span>
<span class="err">#</span><span class="n">include</span> <span class="s">"MyFlatWireframe.cginc"</span>
<span class="err">#</span><span class="n">include</span> <span class="s">"MyTessellation.cginc"</span>
</pre></table></code></div></div><blockquote><p><strong>那 Shadow 通道呢？</strong> 在渲染阴影时也可以使用曲面细分，但在本教程中我们不会这样做。</p></blockquote><p>创建一个依赖于此 Shader 的材质，并在场景中添加一个使用该材质的 Quad。我将材质设为灰色，这样它就不会太亮，就像 Flat Wireframe 材质一样。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/02-quad.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/02-quad.png" alt="A quad" width="100%" height="auto" loading="lazy"></a></div></div><p>请注意，它由两个等腰直角三角形组成。短边长度为 1，而长对角线长度为 $\sqrt{2}$。</p><h3 id="12-hull-shader"><span class="me-2">1.2 Hull Shader</span><a href="#12-hull-shader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>与几何着色器（Geometry Shader）类似，曲面细分阶段非常灵活，可以处理三角形、四边形或等值线。我们必须告诉它它要处理什么表面，并提供必要的数据。这是 Hull 程序的工作。在 <code class="language-plaintext highlighter-rouge">MyTessellation</code> 中添加一个 Hull 程序，从一个不执行任何操作的 void 函数开始。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">MyHullProgram</span> <span class="p">()</span> <span class="p">{}</span>
</pre></table></code></div></div><p>Hull 程序操作一个 <strong>Surface Patch</strong>，它作为参数传递给程序。我们必须添加一个 <code class="language-plaintext highlighter-rouge">InputPatch</code> 参数来实现这一点。</p><pre><code class="language-csharpsharp">void MyHullProgram (InputPatch patch) {}
</code></pre><p>Patch 是网格顶点的集合。就像我们为几何函数的流参数所做的那样，我们必须指定顶点的数据格式。我们现在将使用 <code class="language-plaintext highlighter-rouge">VertexData</code> 结构。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">MyHullProgram</span> <span class="p">(</span><span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">VertexData</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><blockquote><p>**不应该是 InputPatch<InterpolatorsVertex> 吗？** 由于 Hull 阶段在 Vertex 阶段之后，逻辑上 Hull 函数的输入类型必须与 Vertex 函数的输出类型匹配。这是事实，但我们现在将忽略这一点。</InterpolatorsVertex></p></blockquote><p>由于我们处理的是三角形，每个 Patch 将包含三个顶点。这个数量必须指定为 <code class="language-plaintext highlighter-rouge">InputPatch</code> 的第二个模板参数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">MyHullProgram</span> <span class="p">(</span><span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">VertexData</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><p>Hull 程序的工作是将所需的顶点数据传递给曲面细分阶段。虽然它被喂给了一个完整的 Patch，但函数一次只能输出一个顶点。它将针对 Patch 中的每个顶点调用一次，并带有一个额外的参数，指定它应该处理哪个控制点（顶点）。该参数是一个带有 <code class="language-plaintext highlighter-rouge">SV_OutputControlPointID</code> 语义的无符号整数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">MyHullProgram</span> <span class="p">(</span>
    <span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">VertexData</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">,</span>
    <span class="kt">uint</span> <span class="n">id</span> <span class="p">:</span> <span class="n">SV_OutputControlPointID</span>
<span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><p>只需将 Patch 像数组一样建立索引并返回所需的元素。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">VertexData</span> <span class="nf">MyHullProgram</span> <span class="p">(</span>
    <span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">VertexData</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">,</span>
    <span class="kt">uint</span> <span class="n">id</span> <span class="p">:</span> <span class="n">SV_OutputControlPointID</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">patch</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这看起来像是一个功能性的程序，所以让我们添加一个编译器指令来将其用作 Hull Shader。为涉及的三个 Shader 通道都这样做。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#pragma vertex MyVertexProgram
#pragma fragment MyFragmentProgram
#pragma hull MyHullProgram
#pragma geometry MyGeometryProgram
</span></pre></table></code></div></div><p>这将产生一些编译器错误，抱怨我们没有正确配置 Hull Shader。与几何函数一样，它需要属性来配置。首先，我们必须明确告诉它它正在处理三角形。这是通过 <code class="language-plaintext highlighter-rouge">UNITY_domain</code> 属性完成的，使用 <code class="language-plaintext highlighter-rouge">tri</code> 作为参数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="n">VertexData</span> <span class="n">MyHullProgram</span> <span class="err">…</span>
</pre></table></code></div></div><p>这还不够。我们还必须明确指定我们每个 Patch 输出三个控制点，三角形的每个角对应一个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_outputcontrolpoints</span><span class="p">(</span><span class="m">3</span><span class="p">)]</span>
<span class="n">VertexData</span> <span class="n">MyHullProgram</span> <span class="err">…</span>
</pre></table></code></div></div><p>当 GPU 创建新的三角形时，它需要知道我们要将它们定义为顺时针还是逆时针。与 Unity 中的所有其他三角形一样，它们应该是顺时针的。这通过 <code class="language-plaintext highlighter-rouge">UNITY_outputtopology</code> 属性控制。其参数应为 <code class="language-plaintext highlighter-rouge">triangle_cw</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_outputcontrolpoints</span><span class="p">(</span><span class="m">3</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_outputtopology</span><span class="p">(</span><span class="s">"triangle_cw"</span><span class="p">)]</span>
<span class="n">VertexData</span> <span class="n">MyHullProgram</span> <span class="err">…</span>
</pre></table></code></div></div><p>还需要告诉 GPU 它应该如何切割 Patch，这通过 <code class="language-plaintext highlighter-rouge">UNITY_partitioning</code> 属性完成。有几种不同的划分方法，我们稍后将研究它们。目前，只需使用 <code class="language-plaintext highlighter-rouge">integer</code> 模式。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_outputcontrolpoints</span><span class="p">(</span><span class="m">3</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_outputtopology</span><span class="p">(</span><span class="s">"triangle_cw"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_partitioning</span><span class="p">(</span><span class="s">"integer"</span><span class="p">)]</span>
<span class="n">VertexData</span> <span class="n">MyHullProgram</span> <span class="err">…</span>
</pre></table></code></div></div><p>除了划分方法之外，GPU 还必须知道 Patch 应该被切割成多少部分。这不是一个常数值，它可以针对每个 Patch 而变化。我们必须提供一个函数来评估这一点，称为 <strong>Patch Constant 函数</strong>。让我们假设我们有这样一个函数，名为 <code class="language-plaintext highlighter-rouge">MyPatchConstantFunction</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_outputcontrolpoints</span><span class="p">(</span><span class="m">3</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_outputtopology</span><span class="p">(</span><span class="s">"triangle_cw"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_partitioning</span><span class="p">(</span><span class="s">"integer"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_patchconstantfunc</span><span class="p">(</span><span class="s">"MyPatchConstantFunction"</span><span class="p">)]</span>
<span class="n">VertexData</span> <span class="n">MyHullProgram</span> <span class="err">…</span>
</pre></table></code></div></div><h3 id="13-patch-constant-函数"><span class="me-2">1.3 Patch Constant 函数</span><a href="#13-patch-constant-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Patch 如何被细分是 Patch 的属性。这意味着 Patch Constant 函数对每个 Patch 仅调用一次，而不是对每个控制点调用一次。这就是为什么它被称为 Constant 函数，在整个 Patch 上保持不变。实际上，这个函数是与 <code class="language-plaintext highlighter-rouge">MyHullProgram</code> 并行运行的一个子阶段。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/03-inside-hull-shader.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/03-inside-hull-shader.png" alt="Inside a hull shader" width="100%" height="auto" loading="lazy"></a></div></div><p>为了确定如何细分三角形，GPU 使用四个<strong>曲面细分因子（Tessellation Factors）</strong>。三角形 Patch 的每条边都有一个因子。三角形内部也有一个因子。三个边向量必须作为具有 <code class="language-plaintext highlighter-rouge">SV_TessFactor</code> 语义的 float 数组传递。内部因子使用 <code class="language-plaintext highlighter-rouge">SV_InsideTessFactor</code> 语义。让我们为此创建一个结构。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">TessellationFactors</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">edge</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">:</span> <span class="n">SV_TessFactor</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">inside</span> <span class="p">:</span> <span class="n">SV_InsideTessFactor</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Patch Constant 函数将 Patch 作为输入参数并输出曲面细分因子。现在让我们创建这个缺失的函数。只需将其所有因子设置为 1。这将指示曲面细分阶段不细分 Patch。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">TessellationFactors</span> <span class="nf">MyPatchConstantFunction</span> <span class="p">(</span><span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">VertexData</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TessellationFactors</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="14-domain-shader"><span class="me-2">1.4 Domain Shader</span><a href="#14-domain-shader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>此时，Shader 编译器会抱怨 Shader 不能在没有曲面细分评估着色器（Tessellation Evaluation Shader）的情况下拥有曲面细分控制着色器（Tessellation Control Shader）。Hull Shader 只是我们需要让曲面细分工作的一部分。一旦曲面细分阶段确定了 Patch 应该如何细分，就轮到 Domain Shader（在 HLSL 中也称为几何评估着色器）来评估结果并生成最终三角形的顶点。所以让我们为我们的 Domain Shader 创建一个函数，再次从一个存根开始。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">MyDomainProgram</span> <span class="p">()</span> <span class="p">{}</span>
</pre></table></code></div></div><p>Hull 和 Domain Shader 都作用于同一个域（Domain），即三角形。我们再次通过 <code class="language-plaintext highlighter-rouge">UNITY_domain</code> 属性发出信号。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="k">void</span> <span class="nf">MyDomainProgram</span> <span class="p">()</span> <span class="p">{}</span>
</pre></table></code></div></div><p>Domain 程序被喂给了所使用的曲面细分因子，以及原始 Patch，在这种情况下其类型为 <code class="language-plaintext highlighter-rouge">OutputPatch</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="k">void</span> <span class="nf">MyDomainProgram</span> <span class="p">(</span>
    <span class="n">TessellationFactors</span> <span class="n">factors</span><span class="p">,</span>
    <span class="n">OutputPatch</span><span class="p">&lt;</span><span class="n">VertexData</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span>
<span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><p>虽然曲面细分阶段决定了 Patch 应该如何细分，但它并不生成任何新的顶点。相反，它为这些顶点提供了<strong>重心坐标（Barycentric Coordinates）</strong>。由 Domain Shader 使用这些坐标来导出最终顶点。为了使这成为可能，Domain 函数对每个顶点调用一次，并为其提供重心坐标。它们具有 <code class="language-plaintext highlighter-rouge">SV_DomainLocation</code> 语义。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="k">void</span> <span class="nf">MyDomainProgram</span> <span class="p">(</span>
    <span class="n">TessellationFactors</span> <span class="n">factors</span><span class="p">,</span>
    <span class="n">OutputPatch</span><span class="p">&lt;</span><span class="n">VertexData</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">,</span>
    <span class="n">float3</span> <span class="n">barycentricCoordinates</span> <span class="p">:</span> <span class="n">SV_DomainLocation</span>
<span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><p>在函数内部，我们必须生成最终的顶点数据。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="k">void</span> <span class="nf">MyDomainProgram</span> <span class="p">(</span>
    <span class="n">TessellationFactors</span> <span class="n">factors</span><span class="p">,</span>
    <span class="n">OutputPatch</span><span class="p">&lt;</span><span class="n">VertexData</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">,</span>
    <span class="n">float3</span> <span class="n">barycentricCoordinates</span> <span class="p">:</span> <span class="n">SV_DomainLocation</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">VertexData</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>要找到此顶点的中心位置，我们必须使用重心坐标在原始三角形域上进行插值。X、Y 和 Z 坐标决定了第一、第二和第三个控制点的权重。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">VertexData</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">vertex</span> <span class="p">=</span>
        <span class="n">patch</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">vertex</span> <span class="p">*</span> <span class="n">barycentricCoordinates</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span>
        <span class="n">patch</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">vertex</span> <span class="p">*</span> <span class="n">barycentricCoordinates</span><span class="p">.</span><span class="n">y</span> <span class="p">+</span>
        <span class="n">patch</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">vertex</span> <span class="p">*</span> <span class="n">barycentricCoordinates</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</pre></table></code></div></div><p>我们必须以同样的方式插值所有顶点数据。让我们为此定义一个方便的宏，它可以用于所有向量大小。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#define MY_DOMAIN_PROGRAM_INTERPOLATE(fieldName) data.fieldName = 
</span>    <span class="n">patch</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">fieldName</span> <span class="p">*</span> <span class="n">barycentricCoordinates</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> 
    <span class="n">patch</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">fieldName</span> <span class="p">*</span> <span class="n">barycentricCoordinates</span><span class="p">.</span><span class="n">y</span> <span class="p">+</span> 
    <span class="n">patch</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">fieldName</span> <span class="p">*</span> <span class="n">barycentricCoordinates</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>

    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
</pre></table></code></div></div><p>除了位置，还要插值法线、切线和所有 UV 坐标。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">tangent</span><span class="p">)</span>
    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">uv1</span><span class="p">)</span>
    <span class="nf">MY_DOMAIN_PROGRAM_INTERPOLATE</span><span class="p">(</span><span class="n">uv2</span><span class="p">)</span>
</pre></table></code></div></div><p>唯一不插值的是实例 ID。由于 Unity 不支持同时使用 GPU Instancing 和曲面细分，因此没有必要复制此 ID。要防止编译器错误，请从三个 Shader 通道中删除 multi-compile 指令。这也将从 Shader 的 GUI 中删除 Instancing 选项。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// #pragma multi_compile_instancing</span>
<span class="c1">// #pragma instancing_options lodfade force_same_maxcount_for_gl</span>
</pre></table></code></div></div><blockquote><p><strong>是否可以同时使用 Instancing 和曲面细分？</strong> 目前不行。请记住，GPU Instancing 在多次渲染相同对象时非常有用。由于曲面细分成本很高且是关于添加细节的，它们通常不是一个好的组合。如果你想让某些物体在近处使用曲面细分，你可以使用 LOD Group。让 LOD 0 使用非实例化的曲面细分材质，而所有其他 LOD 级别使用实例化的非曲面细分材质。</p></blockquote><p>我们现在有了一个新顶点，它将在这一阶段之后被发送到几何程序或插值器。但这些程序期望的是 <code class="language-plaintext highlighter-rouge">InterpolatorsVertex</code> 数据，而不是 <code class="language-plaintext highlighter-rouge">VertexData</code>。为了解决这个问题，我们让 Domain Shader 接管原始顶点程序的职责。这是通过在其中调用 <code class="language-plaintext highlighter-rouge">MyVertexProgram</code>——就像任何其他函数一样——并返回其结果来完成的。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="n">InterpolatorsVertex</span> <span class="nf">MyDomainProgram</span> <span class="p">(</span>
    <span class="n">TessellationFactors</span> <span class="n">factors</span><span class="p">,</span>
    <span class="n">OutputPatch</span><span class="p">&lt;</span><span class="n">VertexData</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">,</span>
    <span class="n">float3</span> <span class="n">barycentricCoordinates</span> <span class="p">:</span> <span class="n">SV_DomainLocation</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="k">return</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在我们可以将 Domain Shader 添加到我们的三个 Shader 通道中，但我们仍然会得到错误。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#pragma hull MyHullProgram
#pragma domain MyDomainProgram
</span></pre></table></code></div></div><h3 id="15-控制点control-points"><span class="me-2">1.5 控制点（Control Points）</span><a href="#15-控制点control-points" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">MyVertexProgram</code> 只需调用一次，只是我们改变了发生调用的位置。但我们仍然必须指定一个顶点程序在顶点着色器阶段调用，该阶段位于 Hull Shader 之前。此时我们不需要做任何事情，所以我们可以使用一个简单地原样传递顶点数据的函数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">VertexData</span> <span class="nf">MyTessellationVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让我们的三个 Shader 通道从现在起使用此函数作为其顶点程序。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma vertex MyTessellationVertexProgram
</span></pre></table></code></div></div><p>这将产生另一个编译器错误，抱怨位置语义的重复使用。为了使其工作，我们必须为顶点程序使用一个替代的输出结构，该结构使用 <code class="language-plaintext highlighter-rouge">INTERNALTESSPOS</code> 语义作为顶点位置。结构的其余部分与 <code class="language-plaintext highlighter-rouge">VertexData</code> 相同，只是它永远没有实例 ID。由于此顶点数据用作曲面细分过程的控制点，让我们将其命名为 <code class="language-plaintext highlighter-rouge">TessellationControlPoint</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">TessellationControlPoint</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">vertex</span> <span class="p">:</span> <span class="n">INTERNALTESSPOS</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normal</span> <span class="p">:</span> <span class="n">NORMAL</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">tangent</span> <span class="p">:</span> <span class="n">TANGENT</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">uv1</span> <span class="p">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">uv2</span> <span class="p">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>更改 <code class="language-plaintext highlighter-rouge">MyTessellationVertexProgram</code>，使其将顶点数据放入控制点结构并返回它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">TessellationControlPoint</span> <span class="nf">MyTessellationVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TessellationControlPoint</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">vertex</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">normal</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">tangent</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">uv</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">uv1</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">uv2</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接下来，<code class="language-plaintext highlighter-rouge">MyHullProgram</code> 也必须更改，以便它使用 <code class="language-plaintext highlighter-rouge">TessellationControlPoint</code> 而不是 <code class="language-plaintext highlighter-rouge">VertexData</code>。只有其参数类型需要更改。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">TessellationControlPoint</span> <span class="nf">MyHullProgram</span> <span class="p">(</span>
    <span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">TessellationControlPoint</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">,</span>
    <span class="kt">uint</span> <span class="n">id</span> <span class="p">:</span> <span class="n">SV_OutputControlPointID</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">patch</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Patch Constant 函数也是如此。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">TessellationFactors</span> <span class="nf">MyPatchConstantFunction</span> <span class="p">(</span>
    <span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">TessellationControlPoint</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Domain 程序的参数类型也必须更改。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">InterpolatorsVertex</span> <span class="nf">MyDomainProgram</span> <span class="p">(</span>
    <span class="n">TessellationFactors</span> <span class="n">factors</span><span class="p">,</span>
    <span class="n">OutputPatch</span><span class="p">&lt;</span><span class="n">TessellationControlPoint</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span><span class="p">,</span>
    <span class="n">float3</span> <span class="n">barycentricCoordinates</span> <span class="p">:</span> <span class="n">SV_DomainLocation</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
<span class="p">}</span>
</pre></table></code></div></div><p>此时我们终于有了一个正确的曲面细分 Shader。它应该可以编译并像以前一样渲染 Quad。它还没有被细分，因为曲面细分因子始终为 1。</p><h2 id="2-细分三角形"><span class="me-2">2 细分三角形</span><a href="#2-细分三角形" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>曲面细分设置的重点是我们可以细分 Patch。这允许我们将单个三角形替换为小三角形的集合。我们现在就来做这件事。</p><h3 id="21-曲面细分因子"><span class="me-2">2.1 曲面细分因子</span><a href="#21-曲面细分因子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>三角形 Patch 如何被细分由其曲面细分因子控制。我们在 <code class="language-plaintext highlighter-rouge">MyPatchConstantFunction</code> 中确定这些因子。目前，我们将它们都设置为 1，这不会产生视觉变化。Hull、曲面细分和 Domain Shader 阶段正在工作，但它们正在传递原始顶点数据并且不生成任何新内容。要更改此设置，请将所有因子设置为 2。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">TessellationFactors</span> <span class="nf">MyPatchConstantFunction</span> <span class="p">(</span>
    <span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">TessellationControlPoint</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">TessellationFactors</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/04-tessellation-factor-2.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/04-tessellation-factor-2.png" alt="Tessellation factors 2" width="100%" height="auto" loading="lazy"></a></div></div><p>三角形现在确实被细分了。它们的所有边都被分成了两个子边，导致每个三角形增加了三个新顶点。此外，在每个三角形的中心还添加了另一个顶点。这使得为每条原始边生成两个三角形成为可能，因此原始三角形已被六个较小的三角形替换。由于 Quad 由两个三角形组成，我们现在总共得到 12 个三角形。</p><p>如果你改为将所有因子设置为 3，每条边将被分成三个子边。在这种情况下，不会有中心顶点。相反，在原始三角形内部添加了三个顶点，形成一个较小的内部三角形。外边缘将通过三角形带（Triangle Strips）连接到这个内部三角形。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/05-tessellation-factor-3.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/05-tessellation-factor-3.png" alt="Tessellation factors 3" width="100%" height="auto" loading="lazy"></a></div></div><p>当曲面细分因子为偶数时，将有一个单一的中心顶点。当它们为奇数时，将有一个中心三角形。如果我们使用更大的曲面细分因子，我们最终会得到多个嵌套的三角形。向中心每迈进一阶，三角形被细分的数量就会减少二，直到我们最终得到一或零个子边。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/09-tessellation-factor-7.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/09-tessellation-factor-7.png" alt="Tessellation factors 4–7" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="22-不同的边和内部因子"><span class="me-2">2.2 不同的边和内部因子</span><a href="#22-不同的边和内部因子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>三角形如何被细分由内部曲面细分因子控制。边因子可用于覆盖其各自边被细分的数量。这仅影响原始 Patch 边缘，不影响生成的内部三角形。为了清楚地看到这一点，将内部因子设置为 7，同时保持边因子为 1。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="m">7</span><span class="p">;</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/10-factor-7-inside-1-outside.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/10-factor-7-inside-1-outside.png" alt="Factor 7 inside, but 1 outside" width="100%" height="auto" loading="lazy"></a></div></div><p>实际上，三角形使用因子 7 进行细分，之后最外圈的三角形被丢弃。然后每条边使用其自己的因子进行细分，之后生成一个三角形带以将边和内部三角形缝合在一起。</p><p>边因子也有可能大于内部因子。例如，将边因子设置为 7，同时将内部因子保持为 1。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">7</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">7</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="m">7</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/11-factor-1-inside-7-outside.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/11-factor-1-inside-7-outside.png" alt="Factor 1 inside, but 7 outside" width="100%" height="auto" loading="lazy"></a></div></div><p>在这种情况下，内部因子被迫表现得像 2，因为否则无法生成新的三角形。</p><h3 id="23-可变因子"><span class="me-2">2.3 可变因子</span><a href="#23-可变因子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>硬编码的曲面细分因子不是很有用。所以让我们把它变成可配置的，从一个单一的统一（Uniform）因子开始。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
<span class="err">…</span>
<span class="n">TessellationFactors</span> <span class="nf">MyPatchConstantFunction</span> <span class="p">(</span>
    <span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">TessellationControlPoint</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">TessellationFactors</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>为我们的 Shader 添加一个属性。将其范围设置为 1–64。无论我们想使用多高的因子，硬件在每个 Patch 上的细分限制都是 64。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">_TessellationUniform</span> <span class="p">(</span><span class="s">"Tessellation Uniform"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">64</span><span class="p">))</span> <span class="p">=</span> <span class="m">1</span>
</pre></table></code></div></div><p>为了能够编辑此因子，请在 <code class="language-plaintext highlighter-rouge">MyLightingShaderGUI</code> 中添加一个 <code class="language-plaintext highlighter-rouge">DoTessellation</code> 方法，将其显示在自己的部分中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">DoTessellation</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">GUILayout</span><span class="p">.</span><span class="nf">Label</span><span class="p">(</span><span class="s">"Tessellation"</span><span class="p">,</span> <span class="n">EditorStyles</span><span class="p">.</span><span class="n">boldLabel</span><span class="p">);</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="n">indentLevel</span> <span class="p">+=</span> <span class="m">2</span><span class="p">;</span>
    <span class="n">editor</span><span class="p">.</span><span class="nf">ShaderProperty</span><span class="p">(</span>
        <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_TessellationUniform"</span><span class="p">),</span>
        <span class="nf">MakeLabel</span><span class="p">(</span><span class="s">"Uniform"</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="n">indentLevel</span> <span class="p">-=</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">OnGUI</code> 内部，在渲染模式和线框（Wireframe）部分之间调用此方法。仅在所需属性存在时才执行此操作。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnGUI</span> <span class="p">(</span>
    <span class="n">MaterialEditor</span> <span class="n">editor</span><span class="p">,</span> <span class="n">MaterialProperty</span><span class="p">[]</span> <span class="n">properties</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="nf">DoRenderingMode</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="nf">HasProperty</span><span class="p">(</span><span class="s">"_TessellationUniform"</span><span class="p">))</span> <span class="p">{</span>
        <span class="nf">DoTessellation</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="nf">HasProperty</span><span class="p">(</span><span class="s">"_WireframeColor"</span><span class="p">))</span> <span class="p">{</span>
        <span class="nf">DoWireframe</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="err">…</span>
<span class="p">}</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/12-configurable-uniform-tessellation.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/12-configurable-uniform-tessellation.png" alt="Configurable uniform tessellation" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="24-分数因子fractional-factors"><span class="me-2">2.4 分数因子（Fractional Factors）</span><a href="#24-分数因子fractional-factors" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>即使我们使用 float 来设置曲面细分因子，我们最终总是在每条边上得到整数等效的细分。这是因为我们正在使用 <code class="language-plaintext highlighter-rouge">integer</code> 划分模式。虽然它是查看曲面细分如何工作的好模式，但它阻止了我们在细分级别之间平滑过渡。幸运的是，还有分数划分模式。让我们将模式更改为 <code class="language-plaintext highlighter-rouge">fractional_odd</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">UNITY_domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_outputcontrolpoints</span><span class="p">(</span><span class="m">3</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_outputtopology</span><span class="p">(</span><span class="s">"triangle_cw"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_partitioning</span><span class="p">(</span><span class="s">"fractional_odd"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">UNITY_patchconstantfunc</span><span class="p">(</span><span class="s">"MyPatchConstantFunction"</span><span class="p">)]</span>
<span class="n">TessellationControlPoint</span> <span class="n">MyHullProgram</span> <span class="err">…</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/13-fractional-odd-partitioning.jpg" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/13-fractional-odd-partitioning.jpg" alt="Fractional odd partitioning" width="100%" height="auto" loading="lazy"></a></div></div><p>当使用完整的奇数因子时，<code class="language-plaintext highlighter-rouge">fractional_odd</code> 划分模式产生与 <code class="language-plaintext highlighter-rouge">integer</code> 模式相同的结果。但在奇数因子之间转换时，额外的边细分将分离开来并增长，或者缩小并合并。这意味着边不再总是被分成等长的段。这种方法的优点是细分级别之间的过渡现在是平滑的。</p><p>也可以使用 <code class="language-plaintext highlighter-rouge">fractional_even</code> 模式。它的工作方式相同，只是它基于偶数因子。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/14-fractional-even-partitioning.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/14-fractional-even-partitioning.png" alt="Fractional even partitioning" width="100%" height="auto" loading="lazy"></a></div></div><p>通常使用 <code class="language-plaintext highlighter-rouge">fractional_odd</code> 模式，因为它处理因子 1，而 <code class="language-plaintext highlighter-rouge">fractional_even</code> 模式被迫使用最低级别 2。</p><h2 id="3-曲面细分启发式tessellation-heuristics"><span class="me-2">3 曲面细分启发式（Tessellation Heuristics）</span><a href="#3-曲面细分启发式tessellation-heuristics" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>什么是最好的曲面细分因子？这是在使用曲面细分时你必须问自己的主要问题。这个问题没有唯一的客观答案。通常，你能做的最好的事情就是提出一些度量标准，作为一个能够产生良好结果的启发式方法。在本教程中，我们将支持两种简单的方法。</p><h3 id="31-边因子"><span class="me-2">3.1 边因子</span><a href="#31-边因子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然必须按边提供曲面细分因子，但你不必直接根据边来确定因子。例如，你可以针对每个顶点确定因子，然后对每条边求平均值。也许因子存储在纹理中。无论如何，有一个单独的函数来确定给定一条边的两个控制点的因子是很方便的。创建这样一个函数，目前只是返回统一值。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="nf">TessellationEdgeFactor</span> <span class="p">(</span>
    <span class="n">TessellationControlPoint</span> <span class="n">cp0</span><span class="p">,</span> <span class="n">TessellationControlPoint</span> <span class="n">cp1</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">MyPatchConstantFunction</code> 内部使用此函数处理边因子。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">TessellationFactors</span> <span class="nf">MyPatchConstantFunction</span> <span class="p">(</span>
    <span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">TessellationControlPoint</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">TessellationFactors</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="n">patch</span><span class="p">[</span><span class="m">2</span><span class="p">]);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="m">2</span><span class="p">],</span> <span class="n">patch</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">patch</span><span class="p">[</span><span class="m">1</span><span class="p">]);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>对于内部因子，我们将简单地使用边因子的平均值。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">+</span> <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">+</span> <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">])</span> <span class="p">*</span> <span class="p">(</span><span class="m">1</span> <span class="p">/</span> <span class="m">3.0</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="32-边长edge-length"><span class="me-2">3.2 边长（Edge Length）</span><a href="#32-边长edge-length" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>由于边曲面细分因子控制我们对原始三角形边的细分程度，因此根据这些边的长度来确定此因子是有意义的。例如，我们可以指定一个理想的三角形边长。如果我们最终得到的三角形边长超过该长度，我们就应该按理想长度对其进行细分。为此添加一个变量。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_TessellationEdgeLength</span><span class="p">;</span>
</pre></table></code></div></div><p>还要添加一个属性。让我们使用 0.1 到 1 的范围，默认值为 0.5。这是世界空间单位。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nf">_TessellationUniform</span> <span class="p">(</span><span class="s">"Tessellation Uniform"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">64</span><span class="p">))</span> <span class="p">=</span> <span class="m">1</span>
<span class="nf">_TessellationEdgeLength</span> <span class="p">(</span><span class="s">"Tessellation Edge Length"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0.1</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.5</span>
</pre></table></code></div></div><p>我们需要一个 Shader Feature 来实现在统一和基于边的曲面细分之间切换。在我们的三个通道中都添加所需的指令，使用 <code class="language-plaintext highlighter-rouge">_TESSELLATION_EDGE</code> 关键字。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _TESSELLATION_EDGE
</span></pre></table></code></div></div><p>接下来，在 <code class="language-plaintext highlighter-rouge">MyLightingShaderGUI</code> 中添加一个枚举类型来表示曲面细分模式。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">TessellationMode</span> <span class="p">{</span>
    <span class="n">Uniform</span><span class="p">,</span> <span class="n">Edge</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后调整 <code class="language-plaintext highlighter-rouge">DoTessellation</code>，使其可以使用枚举弹出框在两种模式之间切换。它的工作方式类似于 <code class="language-plaintext highlighter-rouge">DoSmoothness</code> 控制光滑度模式的方式。在这种情况下，统一是默认模式，不需要关键字。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">DoTessellation</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">GUILayout</span><span class="p">.</span><span class="nf">Label</span><span class="p">(</span><span class="s">"Tessellation"</span><span class="p">,</span> <span class="n">EditorStyles</span><span class="p">.</span><span class="n">boldLabel</span><span class="p">);</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="n">indentLevel</span> <span class="p">+=</span> <span class="m">2</span><span class="p">;</span>
    <span class="n">TessellationMode</span> <span class="n">mode</span> <span class="p">=</span> <span class="n">TessellationMode</span><span class="p">.</span><span class="n">Uniform</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nf">IsKeywordEnabled</span><span class="p">(</span><span class="s">"_TESSELLATION_EDGE"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">mode</span> <span class="p">=</span> <span class="n">TessellationMode</span><span class="p">.</span><span class="n">Edge</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="nf">BeginChangeCheck</span><span class="p">();</span>
    <span class="n">mode</span> <span class="p">=</span> <span class="p">(</span><span class="n">TessellationMode</span><span class="p">)</span><span class="n">EditorGUILayout</span><span class="p">.</span><span class="nf">EnumPopup</span><span class="p">(</span>
        <span class="nf">MakeLabel</span><span class="p">(</span><span class="s">"Mode"</span><span class="p">),</span> <span class="n">mode</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="nf">EndChangeCheck</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">RecordAction</span><span class="p">(</span><span class="s">"Tessellation Mode"</span><span class="p">);</span>
        <span class="nf">SetKeyword</span><span class="p">(</span><span class="s">"_TESSELLATION_EDGE"</span><span class="p">,</span> <span class="n">mode</span> <span class="p">==</span> <span class="n">TessellationMode</span><span class="p">.</span><span class="n">Edge</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="p">==</span> <span class="n">TessellationMode</span><span class="p">.</span><span class="n">Uniform</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">editor</span><span class="p">.</span><span class="nf">ShaderProperty</span><span class="p">(</span>
            <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_TessellationUniform"</span><span class="p">),</span>
            <span class="nf">MakeLabel</span><span class="p">(</span><span class="s">"Uniform"</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">editor</span><span class="p">.</span><span class="nf">ShaderProperty</span><span class="p">(</span>
            <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_TessellationEdgeLength"</span><span class="p">),</span>
            <span class="nf">MakeLabel</span><span class="p">(</span><span class="s">"Edge Length"</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="n">indentLevel</span> <span class="p">-=</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/15-using-edge-mode.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/15-using-edge-mode.png" alt="Using edge mode" width="100%" height="auto" loading="lazy"></a></div></div><p>现在我们必须调整 <code class="language-plaintext highlighter-rouge">TessellationEdgeFactor</code>。当定义了 <code class="language-plaintext highlighter-rouge">_TESSELLATION_EDGE</code> 时，确定两个点的世界位置，然后计算它们之间的距离。这是世界空间中的边长。边因子等于此长度除以理想长度。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="nf">TessellationEdgeFactor</span> <span class="p">(</span>
    <span class="n">TessellationControlPoint</span> <span class="n">cp0</span><span class="p">,</span> <span class="n">TessellationControlPoint</span> <span class="n">cp1</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="err">#</span><span class="k">if</span> <span class="nf">defined</span><span class="p">(</span><span class="n">_TESSELLATION_EDGE</span><span class="p">)</span>
        <span class="n">float3</span> <span class="n">p0</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="nf">float4</span><span class="p">(</span><span class="n">cp0</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="m">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
        <span class="n">float3</span> <span class="n">p1</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="nf">float4</span><span class="p">(</span><span class="n">cp1</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="m">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">edgeLength</span> <span class="p">=</span> <span class="nf">distance</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">edgeLength</span> <span class="p">/</span> <span class="n">_TessellationEdgeLength</span><span class="p">;</span>
    <span class="err">#</span><span class="k">else</span>
        <span class="k">return</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
<span class="p">}</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/16-different-quad-scales.jpg" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/16-different-quad-scales.jpg" alt="Different quad scales, same desired edge length" width="100%" height="auto" loading="lazy"></a></div></div><p>因为我们现在使用边长来确定边的曲面细分因子，我们最终可能会为每条边得到不同的因子。你可以看到 Quad 发生了这种情况，因为对角线边缘比其他边缘长。当使用 Quad 的非均匀缩放，将其在一个维度上拉伸时，这一点也变得显而易见。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/17-stretched-quad.jpg" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/17-stretched-quad.jpg" alt="Stretched quad" width="100%" height="auto" loading="lazy"></a></div></div><p>为了使其工作，必不可少的是共享一条边的 Patch 最终都为该边使用相同的曲面细分因子。否则，生成的顶点将无法沿该边匹配，这可能会在网格中产生可见的间隙。在我们的案例中，我们对所有边都使用相同的逻辑。唯一的区别可能是控制点参数的顺序。由于浮点限制，这在技术上可能会产生不同的因子，但差异微小到无法察觉。</p><h3 id="33-屏幕空间中的边长"><span class="me-2">3.3 屏幕空间中的边长</span><a href="#33-屏幕空间中的边长" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然我们现在可以在世界空间中控制三角形边长，但这并不对应于它们在屏幕空间中的表现。曲面细分的重点是在需要时添加更多三角形。因此，我们不想细分那些看起来已经很小的三角形。所以让我们改用屏幕空间边长。</p><p>首先，更改我们的边长属性的范围。我们将使用像素而不是世界单位，因此 5–100 这样的范围更有意义。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">_TessellationEdgeLength</span> <span class="p">(</span><span class="s">"Tessellation Edge Length"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">100</span><span class="p">))</span> <span class="p">=</span> <span class="m">50</span>
</pre></table></code></div></div><p>将世界空间计算替换为它们的屏幕空间等效项。为此，点必须转换为裁剪空间（Clip Space）而不是世界空间。然后在 2D 中确定它们的距离，使用它们的 X 和 Y 坐标，除以它们的 W 坐标以将它们投影到屏幕上。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">float4</span> <span class="n">p0</span> <span class="p">=</span> <span class="nf">UnityObjectToClipPos</span><span class="p">(</span><span class="n">cp0</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">float4</span> <span class="n">p1</span> <span class="p">=</span> <span class="nf">UnityObjectToClipPos</span><span class="p">(</span><span class="n">cp1</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">edgeLength</span> <span class="p">=</span> <span class="nf">distance</span><span class="p">(</span><span class="n">p0</span><span class="p">.</span><span class="n">xy</span> <span class="p">/</span> <span class="n">p0</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">p1</span><span class="p">.</span><span class="n">xy</span> <span class="p">/</span> <span class="n">p1</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">edgeLength</span> <span class="p">/</span> <span class="n">_TessellationEdgeLength</span><span class="p">;</span>
</pre></table></code></div></div><p>现在我们在裁剪空间中得到了一个结果，裁剪空间是一个尺寸为 2 的统一立方体，正好适合显示。要转换为像素，我们必须按以像素为单位的显示尺寸进行缩放。实际上，由于显示器很少是正方形的，为了获得最准确的结果，我们应该在确定距离之前分别缩放 X 和 Y 坐标。但让我们仅通过缩放屏幕高度来满足要求，看看它看起来如何。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="k">return</span> <span class="n">edgeLength</span> <span class="p">*</span> <span class="n">_ScreenParams</span><span class="p">.</span><span class="n">y</span> <span class="p">/</span> <span class="n">_TessellationEdgeLength</span><span class="p">;</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/18-same-world-different-screen.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/18-same-world-different-screen.png" alt="Same world size, different screen size" width="100%" height="auto" loading="lazy"></a></div></div><p>我们的三角形边现在根据它们渲染的大小进行细分。位置、旋转和缩放都会相对于摄像机影响这一点。因此，当物体处于运动状态时，曲面细分的数量会发生变化。</p><blockquote><p><strong>我们不应该使用屏幕高度的一半吗？</strong> 由于裁剪空间立方体的范围是 -1 到 1，两个单位对应于显示的完整高度（和宽度）。这意味着我们最终得到了实际尺寸的两倍，高估了我们的边缘有多大。结果是我们实际上瞄准了预期的边长的一半。至少，对于完全垂直的边缘是这种情况，因为我们无论如何都没有使用确切的屏幕维度。使用屏幕高度的主要目的是使曲面细分依赖于显示分辨率。边长是否与我们的滑块的确切值匹配其实并不重要。</p></blockquote><h3 id="34-使用视图距离"><span class="me-2">3.4 使用视图距离</span><a href="#34-使用视图距离" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>纯粹依赖边缘的视觉长度的一个缺点是，世界空间中较长的边缘在屏幕空间中最终可能会变得非常小。这可能会导致这些边缘根本不被细分，而其他边缘被大量细分。当曲面细分用于近距离添加细节或生成复杂的轮廓时，这是不可取的。</p><p>另一种方法是回到使用世界空间边长，但根据视图距离调整因子。物体距离越远，它在视觉上看起来就越小，因此需要的曲面细分就越少。因此，将边长除以边缘与摄像机之间的距离。我们可以使用边缘的中点来确定这个距离。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="n">float3</span> <span class="n">p0</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="nf">float4</span><span class="p">(</span><span class="n">cp0</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="m">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">p1</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="nf">float4</span><span class="p">(</span><span class="n">cp1</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="m">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">edgeLength</span> <span class="p">=</span> <span class="nf">distance</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">);</span>

    <span class="n">float3</span> <span class="n">edgeCenter</span> <span class="p">=</span> <span class="p">(</span><span class="n">p0</span> <span class="p">+</span> <span class="n">p1</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">viewDistance</span> <span class="p">=</span> <span class="nf">distance</span><span class="p">(</span><span class="n">edgeCenter</span><span class="p">,</span> <span class="n">_WorldSpaceCameraPos</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">edgeLength</span> <span class="p">/</span> <span class="p">(</span><span class="n">_TessellationEdgeLength</span> <span class="p">*</span> <span class="n">viewDistance</span><span class="p">);</span>
</pre></table></code></div></div><p>我们仍然可以通过简单地将屏幕高度计入其中并保持我们的 5–100 滑块范围，使曲面细分依赖于显示尺寸。请注意，这些值不再直接对应于显示像素。当你改变摄像机的视野（Field of View）时，这一点非常明显，这根本不会影响曲面细分。因此，这种简单的方法不适用于使用可变视野的游戏，例如放大和缩小。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="k">return</span> <span class="n">edgeLength</span> <span class="p">*</span> <span class="n">_ScreenParams</span><span class="p">.</span><span class="n">y</span> <span class="p">/</span>
        <span class="p">(</span><span class="n">_TessellationEdgeLength</span> <span class="p">*</span> <span class="n">viewDistance</span><span class="p">);</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/19-edge-length-view-distance.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/19-edge-length-view-distance.png" alt="Based on edge length and view distance" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="35-使用正确的内部因子"><span class="me-2">3.5 使用正确的内部因子</span><a href="#35-使用正确的内部因子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然此时曲面细分看起来运行良好，但内部曲面细分因子似乎有些奇怪。至少，在使用 OpenGL Core 时是这种情况。在使用统一的 Quad 时并不那么明显，但在使用变形的立方体时，它变得显而易见。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/20-cube-incorrect-inner-factors.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/20-cube-incorrect-inner-factors.png" alt="Cube with incorrect inner factors" width="100%" height="auto" loading="lazy"></a></div></div><p>在立方体的情况下，组成面的两个三角形各自得到了截然不同的内部曲面细分因子。Quad 和立方体面之间的唯一区别是三角形顶点的定义顺序。Unity 的默认立方体不使用对称的三角形布局，而 Quad 则是。这表明边的顺序显然影响了内部曲面细分因子。然而，我们只是取边因子的平均值，所以它们的顺序不应该有影响。一定是其他地方出了问题。</p><p>让我们做一些看起来毫无意义的事情，在计算内部因子时再次明确调用 <code class="language-plaintext highlighter-rouge">TessellationEdgeFactors</code> 函数。从逻辑上讲，这不应该产生差异，因为我们最终只是执行了两次完全相同的计算。Shader 编译器肯定会优化掉它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// f.inside = (f.edge[0] + f.edge[1] + f.edge[2]) * (1 / 3.0);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span>
        <span class="p">(</span><span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="n">patch</span><span class="p">[</span><span class="m">2</span><span class="p">])</span> <span class="p">+</span>
        <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="m">2</span><span class="p">],</span> <span class="n">patch</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="p">+</span>
        <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">patch</span><span class="p">[</span><span class="m">1</span><span class="p">]))</span> <span class="p">*</span> <span class="p">(</span><span class="m">1</span> <span class="p">/</span> <span class="m">3.0</span><span class="p">);</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender22/21-cube-correct-inner-factors.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender22/21-cube-correct-inner-factors.png" alt="Cube with correct inner factors" width="100%" height="auto" loading="lazy"></a></div></div><p>显然，它确实产生了差异，因为两个面三角形现在最终使用了几乎相同的内部因子。这是怎么回事？</p><p>Patch Constant 函数与 Hull Shader 的其余部分并行调用。但实际上它可能比这更复杂。Shader 编译器也能够并行化边因子的计算。<code class="language-plaintext highlighter-rouge">MyPatchConstantFunction</code> 内部的代码被拆开并部分重复，取而代之的是一个并行计算三个边因子的分叉进程。一旦所有三个进程完成，它们的结果就会合并并用于计算内部因子。</p><p>编译器是否决定分叉进程不应影响我们的 Shader 的结果，只影响其性能。不幸的是，在为 OpenGL Core 生成的代码中存在一个 Bug。在计算内部因子时，只使用了第三个边因子，而不是使用三个边因子。数据就在那里，只是它访问了三次索引 2，而不是索引 0、1 和 2。所以我们总是最终得到一个等于第三个边因子的内部因子。</p><p>在 Patch Constant 函数的情况下，Shader 编译器优先考虑并行化。它尽可能早地拆分进程，之后它无法再优化掉对 <code class="language-plaintext highlighter-rouge">TessellationEdgeFactor</code> 的重复调用。我们最终得到三个进程，每个进程都计算两个点的世界位置、距离和最终因子。然后还有一个计算内部因子的进程，它现在也必须计算三个顶点的世界位置，以及所涉及的所有距离和因子。由于我们现在为内部因子做了所有这些工作，那么为边因子分别执行部分相同的工作就没有意义了。</p><p>事实证明，如果我们先计算顶点的世界位置，然后分别为边因子和内部因子调用 <code class="language-plaintext highlighter-rouge">TessellationEdgeFactor</code>，Shader 编译器会决定不为每个边因子分叉单独的进程。我们最终得到一个计算所有内容的单一进程。在这种情况下，Shader 编译器确实优化掉了对 <code class="language-plaintext highlighter-rouge">TessellationEdgeFactor</code> 的重复调用。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="nf">TessellationEdgeFactor</span> <span class="p">(</span><span class="n">float3</span> <span class="n">p0</span><span class="p">,</span> <span class="n">float3</span> <span class="n">p1</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">#</span><span class="k">if</span> <span class="nf">defined</span><span class="p">(</span><span class="n">_TESSELLATION_EDGE</span><span class="p">)</span>
        <span class="err">…</span>
    <span class="err">#</span><span class="k">else</span>
        <span class="k">return</span> <span class="n">_TessellationUniform</span><span class="p">;</span>
    <span class="err">#</span><span class="n">endif</span>
<span class="p">}</span>

<span class="n">TessellationFactors</span> <span class="nf">MyPatchConstantFunction</span> <span class="p">(</span>
    <span class="n">InputPatch</span><span class="p">&lt;</span><span class="n">TessellationControlPoint</span><span class="p">,</span> <span class="m">3</span><span class="p">&gt;</span> <span class="n">patch</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">p0</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">p1</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">p2</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>

    <span class="n">TessellationFactors</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p0</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inside</span> <span class="p">=</span>
        <span class="p">(</span><span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="p">+</span>
        <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span> <span class="p">+</span>
        <span class="nf">TessellationEdgeFactor</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">))</span> <span class="p">*</span> <span class="p">(</span><span class="m">1</span> <span class="p">/</span> <span class="m">3.0</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>此时我们可以细分三角形，但我们还没有利用这种能力做任何事情。<a href="../unity-surface-displacement">曲面细分</a> 演示了如何使用曲面细分来使表面变形。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/shader/">Shader</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86(%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%8D%81%E4%BA%8C)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Funity-tessellation%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86(%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%8D%81%E4%BA%8C)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Funity-tessellation%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Funity-tessellation%2F&text=%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86(%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%8D%81%E4%BA%8C)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/flat-and-wireframe-shading/">平面着色与线框着色(翻译二十一)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-tessellation/">曲面细分(翻译二十二)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-surface-displacement/">曲面细分表面置换(翻译二十三)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-bloom/">Bloom模糊光照(翻译二十四)</a><li class="text-truncate lh-lg"> <a href="/posts/claude-code-guide/">Claude Code学习总结：目录导航</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a> <a class="post-tag btn btn-outline-primary" href="/tags/context-engine/">Context Engine</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_2/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515333600" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展二(翻译十)</h4><div class="text-muted"><p>本篇摘要: 把自身阴影烘焙进材质 增加细节纹理部分 支持更丰富的shader变体 一次编辑多个材质球 遮挡区域的Self-Shading 美术能够创作非常复杂丰富的表面纹理，它只是一个视错觉。为了增强表面纹理视觉真实感，引入Self-Shading。 如何增强呢？通常我们使用了法线来增强模型表面的凹凸层次感，法线带来的视觉增强是第一步，但是法线只适用于采样直接光...</p></div></div></a></article><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515326400" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展一(翻译九)</h4><div class="text-muted"><p>选中当前材质后，若材质使用的Shader调用了GUI拓展，则会自动读取该Shader的所有属性。通过重实现OnGUI函数后，获取其参数地址就能读取。</p></div></div></a></article><article class="col"> <a href="/posts/Unity_Reflection/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515240000" data-df="ll" > Jan 6, 2018 </time><h4 class="pt-0 my-2">Unity Reflection 反射(翻译八)</h4><div class="text-muted"><p>一块完美的镜子是不会发生漫反射，但现在我们自己的Shader包含的光照：环境光、漫反射、高光反射、纹理、阴影，结果看起来蛮好。但是当把Metallic设为1，Smoothness设位0.95，看起来很亮就很不自然了。从下图看尽管颜色是白色但整个表面都是黑色，只有一个很小的高亮点。这个亮点形成1是光源的入射，2朝向观察者的反射。</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/flat-and-wireframe-shading/" class="btn btn-outline-primary" aria-label="Older" ><p>平面着色与线框着色(翻译二十一)</p></a> <a href="/posts/unity-surface-displacement/" class="btn btn-outline-primary" aria-label="Newer" ><p>曲面细分表面置换(翻译二十三)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a> <a class="post-tag btn btn-outline-primary" href="/tags/context-engine/">Context Engine</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
