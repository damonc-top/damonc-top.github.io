<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="自定义管线:烘焙光照 (翻译五)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="烘焙静态全局光照 创建Meta pass 支持自发光" /><meta property="og:description" content="烘焙静态全局光照 创建Meta pass 支持自发光" /><link rel="canonical" href="www.damonc.top/posts/baked-light/" /><meta property="og:url" content="www.damonc.top/posts/baked-light/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/SRP/srp5/01-cover.jpeg" /><meta property="og:image:alt" content="烘焙光照" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-01-31T00:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/SRP/srp5/01-cover.jpeg" /><meta name="twitter:image:alt" content="烘焙光照" /><meta property="twitter:title" content="自定义管线:烘焙光照 (翻译五)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2026-02-19T23:25:40+08:00","datePublished":"2020-01-31T00:00:00+08:00","description":"烘焙静态全局光照 创建Meta pass 支持自发光","headline":"自定义管线:烘焙光照 (翻译五)","image":{"lqip":"data:image/webp;base64,UklGRloAAABXRUJQVlA4IE4AAAAwAwCdASoUAAoAP3Ggxlk0q6ejsAgCkC4JZgCdAAMV8AxYAPEh/9FE23MTiqJL5og4fxmrDQJ9ugaOsFnxQRYVC23bKDqU8uqzBFaeAAA=","alt":"烘焙光照","url":"https://img.damonc.top/posts/SRP/srp5/01-cover.jpeg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/baked-light/"},"url":"www.damonc.top/posts/baked-light/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>自定义管线:烘焙光照 (翻译五) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>自定义管线:烘焙光照 (翻译五)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>自定义管线:烘焙光照 (翻译五)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1580400000" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jan 31, 2020 </time> </span> <span> Updated <time data-ts="1771514740" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 19, 2026 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/SRP/srp5/01-cover.jpeg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/SRP/srp5/01-cover.jpeg" alt="烘焙光照" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRloAAABXRUJQVlA4IE4AAAAwAwCdASoUAAoAP3Ggxlk0q6ejsAgCkC4JZgCdAAMV8AxYAPEh/9FE23MTiqJL5og4fxmrDQJ9ugaOsFnxQRYVC23bKDqU8uqzBFaeAAA="></a><figcaption class="text-center pt-2 pb-2">烘焙光照</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/baked-light/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="8829 words" > <em>49 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">自定义管线:烘焙光照 (翻译五)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">自定义管线:烘焙光照 (翻译五)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>烘焙静态全局光照<li>创建Meta pass<li>支持自发光</ul><hr /><h2 id="烘焙静态光照"><span class="me-2">烘焙静态光照</span><a href="#烘焙静态光照" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>到目前为止，我们都是在渲染时计算所有光照，但这并不是唯一的选择。光照也可以预先计算并存储在光照贴图和探针中。这样做有两个主要原因：减少实时计算量，以及添加在运行时无法计算间接光照。后者就是所谓全局光照（Global Illumination）的一部分：光照不是直接从光源发出，而是通过反射、环境或自发光表面间接到达。</p><p>烘焙光照的缺点是它是静态的，无法在运行时改变。它还需要存储，这会增加构建大小和内存使用。</p><h3 id="场景光照设置"><span class="me-2">场景光照设置</span><a href="#场景光照设置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>全局光照是通过场景的 Lighting 窗口的 Scene 选项卡进行配置的。烘焙光照通过 Mixed Lighting 下的 Baked Global Illumination 开关启用。也有一个 Lighting Mode 选项，我们将其设置为 Baked Indirect，这意味着我们烘焙所有静态间接光照。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/02-baked-indirect.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/02-baked-indirect.png" alt="Baked indirect lighting only" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Baked indirect lighting only</figcaption></figure><p>如果你的项目是在 Unity 2019.2 或更早版本创建的，你还会看到一个启用实时光照的选项，应该禁用它。如果你的项目是在 Unity 2019.3 或更高版本创建的，该选项不会显示。</p><p>再往下是 Lightmapping Settings 部分，用于控制光照贴图的处理过程。我将使用默认设置，但 LightMap Resolution 降低到 20，Compress Lightmaps 禁用，Directional Mode 设置为 Non-Directional。我还使用 Progressive GPU 光照贴图器。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/03-lightmapping-settings.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/03-lightmapping-settings.png" alt="Lightmapping settings" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Lightmapping settings</figcaption></figure><aside class="collapsible-aside"><h3>Directional 模式是做什么的？</h3><div><p>它还烘焙方向性数据，这使得法线贴图可以影响传入的烘焙光照。由于我们目前不支持法线贴图，没有理由启用它。</p></div></aside><h3 id="静态对象"><span class="me-2">静态对象</span><a href="#静态对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了演示烘焙光照，我创建了一个场景，地面是一个绿色平面，几个立方体和球体，以及中间的一个结构，只有一面开放，这样内部是完全阴影的。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/04-scene-dark-interior.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/04-scene-dark-interior.png" alt="Scene with dark interior" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Scene with dark interior</figcaption></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/05-scene-without-ceiling.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/05-scene-without-ceiling.png" alt="Same scene without ceiling" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Same scene without ceiling</figcaption></figure><p>场景有一个单一方向光，Mode 设置为 Mixed。这告诉 Unity 应该为这个光源烘焙间接光照。除此之外，这个光源仍然像常规实时光源一样工作。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/06-mixed-mode-light.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/06-mixed-mode-light.png" alt="Mixed-mode light" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Mixed-mode light</figcaption></figure><p>我还把地面平面和所有立方体（包括构成结构的那些）包含在烘焙过程中。它们将是光线反弹的物体，从而成为间接光。这是通过启用它们 MeshRenderer 组件的 Contribute Global Illumination 开关来完成的。启用这还会自动将它们的 Receive Global Illumination 模式切换为 Lightmaps，这意味着到达它们表面的间接光会被烘焙到光照贴图中。你也可以通过从对象的 Static 下拉列表中启用 Contribute GI，或者使其完全静态来启用此模式。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/07-contribute-gi.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/07-contribute-gi.png" alt="Contribute global illumination enabled" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Contribute global illumination enabled</figcaption></figure><p>一旦启用，场景的光照将被重新烘焙，假设 Lighting 窗口中启用了 Auto Generate，否则你必须按 Generate Lighting 按钮。Lightmapping 设置也会显示在 MeshRenderer 组件中，包括包含该对象的光照贴图的视图。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/08-baked-indirect-map.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/08-baked-indirect-map.png" alt="Map of baked received indirect light" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Map of baked received indirect light</figcaption></figure><p>球体没有出现在光照贴图中，因为它们不对全局光照做出贡献，因此被视为动态的。它们将不得不依赖光照探针，我们稍后会介绍。静态对象也可以通过将 Receive Global Illumination 模式切换回 Light Probes 从贴图中排除。它们仍然会影响烘焙结果，但不会占用光照贴图中的空间。</p><h3 id="全烘焙光照"><span class="me-2">全烘焙光照</span><a href="#全烘焙光照" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>烘焙光照主要是蓝色的，因为它由代表环境天空间接光照的天空盒主导。中心建筑周围较亮的区域是由光线从地面和墙壁反弹的间接光照引起的。</p><p>我们也可以将所有光照烘焙到贴图中，包括直接光和间接光。这是通过将光源的 Mode 设置为 Baked 来完成的。它不再提供实时光照。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/09-no-realtime-lighting.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/09-no-realtime-lighting.png" alt="No realtime lighting" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">No realtime lighting</figcaption></figure><p>实际上，烘焙光源的直接光也被视为间接光，因此最终进入贴图，使其变得更亮。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/10-fully-baked-map.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/10-fully-baked-map.png" alt="Map of fully baked light" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Map of fully baked light</figcaption></figure><h2 id="采样烘焙光照"><span class="me-2">采样烘焙光照</span><a href="#采样烘焙光照" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>目前所有东西都被渲染为纯黑色，因为没有实时光照，而且我们的着色器还不知道全局光照。我们必须对光照贴图进行采样才能使其工作。</p><h3 id="全局光照"><span class="me-2">全局光照</span><a href="#全局光照" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>创建一个新的 <code class="language-plaintext highlighter-rouge">ShaderLibrary/GI.hlsl</code> 文件来包含所有与全局光照相关的代码。在其中定义一个 GI 结构和一个 GetGI 函数，给定一些光照贴图 UV 坐标来检索它。间接光来自所有方向，因此只能用于漫反射照明，不能用于高光。所以给 GI 结构一个漫反射颜色字段。最初用光照贴图 UV 填充它用于调试。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_GI_INCLUDED
#define CUSTOM_GI_INCLUDED
</span>
<span class="k">struct</span> <span class="n">GI</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">diffuse</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">GI</span> <span class="nf">GetGI</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GI</span> <span class="n">gi</span><span class="p">;</span>
    <span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="kt">float3</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">gi</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>在 GetLighting 中添加一个 GI 参数，并使用它在累积实时光照之前初始化颜色值。此时我们不将它乘以表面的漫反射率，这样我们可以看到未修改的接收光照。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">GI</span> <span class="n">gi</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ShadowData</span> <span class="n">shadowData</span> <span class="o">=</span> <span class="n">GetShadowData</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
    <span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 LitPass 中，在 Lighting 之前 Include GI。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/GI.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Lighting.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><p>在 LitPassFragment 中获取全局光照数据，最初使用零 UV 坐标，并将其传递给 GetLighting。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">GI</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">GetGI</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">gi</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="光照贴图坐标"><span class="me-2">光照贴图坐标</span><a href="#光照贴图坐标" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了获取光照贴图坐标，Unity 必须将它们发送到着色器。我们必须指示管线为每个被光照贴图化的对象执行此操作。这是通过将绘图设置的 perObjectData 属性设置为 <code class="language-plaintext highlighter-rouge">PerObjectData.Lightmaps</code> 来完成的。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">drawingSettings</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DrawingSettings</span><span class="p">(</span>
    <span class="n">unlitShaderTagId</span><span class="p">,</span> <span class="n">sortingSettings</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">enableDynamicBatching</span> <span class="p">=</span> <span class="n">useDynamicBatching</span><span class="p">,</span>
    <span class="n">enableInstancing</span> <span class="p">=</span> <span class="n">useGPUInstancing</span><span class="p">,</span>
    <span class="n">perObjectData</span> <span class="p">=</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">Lightmaps</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Unity 现在将使用具有 <code class="language-plaintext highlighter-rouge">LIGHTMAP_ON</code> 关键字的着色器变体来渲染被光照贴图化的对象。在我们 Lit 着色器的 CustomLit pass 中添加一个 multi-compile 指令。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#pragma multi_compile _ LIGHTMAP_ON
#pragma multi_compile_instancing
</span></pre></table></code></div></div><p>光照贴图坐标是 Attributes 顶点数据的一部分。我们必须将它们传输到 Varyings 以便在 LitPassFragment 中使用。但我们只应在需要时执行此操作。我们可以使用类似于传输实例化标识符的方法，依赖 <code class="language-plaintext highlighter-rouge">GI_ATTRIBUTE_DATA</code>、<code class="language-plaintext highlighter-rouge">GI_VARYINGS_DATA</code> 和 <code class="language-plaintext highlighter-rouge">TRANSFER_GI_DATA</code> 宏。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">GI_ATTRIBUTE_DATA</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">GI_VARYINGS_DATA</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="n">Varyings</span> <span class="nf">LitPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Varyings</span> <span class="n">output</span><span class="p">;</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
    <span class="n">TRANSFER_GI_DATA</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>再加上另一个 <code class="language-plaintext highlighter-rouge">GI_FRAGMENT_DATA</code> 宏来检索 GetGI 所需的参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">GI</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">GetGI</span><span class="p">(</span><span class="n">GI_FRAGMENT_DATA</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
</pre></table></code></div></div><p>我们必须自己定义这些宏，最初将它们定义为空，除了 <code class="language-plaintext highlighter-rouge">GI_FRAGMENT_DATA</code> 简单地返回零。宏的参数列表就像函数的一样，只是没有类型，并且宏名称和参数列表之间不允许有空格，否则该列表会被解释为宏定义的内容。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#define GI_ATTRIBUTE_DATA
#define GI_VARYINGS_DATA
#define TRANSFER_GI_DATA(input, output)
#define GI_FRAGMENT_DATA(input) 0.0
</span></pre></table></code></div></div><p>当 <code class="language-plaintext highlighter-rouge">LIGHTMAP_ON</code> 被定义时，宏应该改为定义代码，向结构添加另一个 UV 集，复制它，并检索它。光照贴图 UV 通过第二个纹理坐标通道提供，所以我们需要在 Attributes 中使用 <code class="language-plaintext highlighter-rouge">TEXCOORD1</code> 语义。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#if defined(LIGHTMAP_ON)
#define GI_ATTRIBUTE_DATA float2 lightMapUV : TEXCOORD1;
#define GI_VARYINGS_DATA float2 lightMapUV : VAR_LIGHT_MAP_UV;
#define TRANSFER_GI_DATA(input, output) output.lightMapUV = input.lightMapUV;
#define GI_FRAGMENT_DATA(input) input.lightMapUV
#else
#define GI_ATTRIBUTE_DATA
#define GI_VARYINGS_DATA
#define TRANSFER_GI_DATA(input, output)
#define GI_FRAGMENT_DATA(input) 0.0
#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/11-lightmap-uv.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/11-lightmap-uv.png" alt="Light map coordinates" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Light map coordinates</figcaption></figure><p>所有静态烘焙对象现在都显示它们的 UV，而所有动态对象保持黑色。</p><h3 id="变换后的光照贴图坐标"><span class="me-2">变换后的光照贴图坐标</span><a href="#变换后的光照贴图坐标" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>光照贴图坐标通常由 Unity 自动为每个网格生成，或者是导入网格数据的一部分。它们定义了一个纹理展开，将网格展平以便映射到纹理坐标。展开在光照贴图中按对象进行缩放和定位，因此每个实例获得自己的空间。这就像应用于基础 UV 的缩放和变换一样。我们必须对光照贴图 UV 应用相同的变换。</p><p>光照贴图 UV 变换作为 <code class="language-plaintext highlighter-rouge">UnityPerDraw</code> buffer 的一部分传递给 GPU，所以在那里添加它。它被称为 <code class="language-plaintext highlighter-rouge">unity_LightmapST</code>。尽管它已被弃用，在它之后还要添加 <code class="language-plaintext highlighter-rouge">unityDynamicLightmapST</code>，否则 SRP batcher 兼容性可能会破坏。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityPerDraw</span><span class="p">)</span>
    <span class="kt">float4x4</span> <span class="n">unity_ObjectToWorld</span><span class="p">;</span>
    <span class="kt">float4x4</span> <span class="n">unity_WorldToObject</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_LODFade</span><span class="p">;</span>
    <span class="n">real4</span> <span class="n">unity_WorldTransformParams</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_LightmapST</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unityDynamicLightmapST</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><p><strong>光照贴图与 GPU 实例化一起工作吗？</strong> 是的。所有 UnityPerDraw 数据在需要时都会被实例化。</p></blockquote><p>然后调整 <code class="language-plaintext highlighter-rouge">TRANSFER_GI_DATA</code> 宏以应用变换。宏定义可以分成多行，只要每行最后一行除外都有反斜杠。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#define TRANSFER_GI_DATA(input, output) \
    output.lightMapUV = input.lightMapUV * \
    unity_LightmapST.xy + unity_LightmapST.zw;
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/12-transformed-lightmap-uv.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/12-transformed-lightmap-uv.png" alt="Transformed light map coordinates" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Transformed light map coordinates</figcaption></figure><h3 id="采样光照贴图"><span class="me-2">采样光照贴图</span><a href="#采样光照贴图" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>采样光照贴图是 GI 的职责。光照贴图纹理被称为 <code class="language-plaintext highlighter-rouge">unity_Lightmap</code>，带有相应的采样器状态。同时引入 Core RP Library 的 <code class="language-plaintext highlighter-rouge">EntityLighting.hlsl</code>，因为我们将使用它来检索光照数据。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"</span><span class="cp">
</span>
<span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">samplerunity_Lightmap</span><span class="p">);</span>
</pre></table></code></div></div><p>创建一个 <code class="language-plaintext highlighter-rouge">SampleLightMap</code> 函数，当有光照贴图时调用 <code class="language-plaintext highlighter-rouge">SampleSingleLightmap</code>，否则返回零。在 GetGI 中使用它来设置漫反射光。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">SampleLightMap</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="k">return</span> <span class="n">SampleSingleLightmap</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">);</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>

<span class="n">GI</span> <span class="nf">GetGI</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GI</span> <span class="n">gi</span><span class="p">;</span>
    <span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SampleLightMap</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">gi</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">SampleSingleLightmap</code> 函数需要几个更多参数。首先，我们必须将纹理和采样器状态作为前两个参数传递，我们可以使用 <code class="language-plaintext highlighter-rouge">TEXTURE2D_ARGS</code> 宏。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="nf">SampleSingleLightmap</span><span class="p">(</span>
    <span class="n">TEXTURE2D_ARGS</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">samplerunity_Lightmap</span><span class="p">),</span> <span class="n">lightMapUV</span>
<span class="p">);</span>
</pre></table></code></div></div><p>然后是要应用的缩放和变换。因为我们之前已经做了，我们将在这里使用恒等变换。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="nf">SampleSingleLightmap</span><span class="p">(</span>
    <span class="n">TEXTURE2D_ARGS</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">samplerunity_Lightmap</span><span class="p">),</span> <span class="n">lightMapUV</span><span class="p">,</span>
    <span class="kt">float4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
<span class="p">);</span>
</pre></table></code></div></div><p>然后是一个布尔值，指示光照贴图是否压缩，这在 <code class="language-plaintext highlighter-rouge">UNITY_LIGHTMAP_FULL_HDR</code> 未定义时为 true。最后一个参数是一个包含解码指令的 float4。使用 <code class="language-plaintext highlighter-rouge">LIGHTMAP_HDR_MULTIPLIER</code> 作为其第一个分量，<code class="language-plaintext highlighter-rouge">LIGHTMAP_HDR_EXPONENT</code> 作为第二个。其他分量不使用。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="nf">SampleSingleLightmap</span><span class="p">(</span>
    <span class="n">TEXTURE2D_ARGS</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">samplerunity_Lightmap</span><span class="p">),</span> <span class="n">lightMapUV</span><span class="p">,</span>
    <span class="kt">float4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span>
    <span class="cp">#if defined(UNITY_LIGHTMAP_FULL_HDR)
</span>        <span class="nb">false</span><span class="p">,</span>
    <span class="cp">#else
</span>        <span class="nb">true</span><span class="p">,</span>
    <span class="cp">#endif
</span>    <span class="kt">float4</span><span class="p">(</span><span class="n">LIGHTMAP_HDR_MULTIPLIER</span><span class="p">,</span> <span class="n">LIGHTMAP_HDR_EXPONENT</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
<span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/13-sampled-baked-light.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/13-sampled-baked-light.png" alt="Sampled baked light" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Sampled baked light</figcaption></figure><h3 id="禁用环境光照"><span class="me-2">禁用环境光照</span><a href="#禁用环境光照" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>烘焙光照相当明亮，因为它还包括来自天空的间接光照。我们可以通过将 Intensity Multiplier 设为零来禁用它。这允许我们聚焦于单个方向光。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/14-environment-intensity.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/14-environment-intensity.png" alt="Environment intensity set to zero" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Environment intensity set to zero</figcaption></figure><p>注意，结构内部现在被间接照亮，主要是通过地面。</p><blockquote class="prompt-info"><p><strong>我们也可以烘焙其他类型的光源吗？</strong> 是的，尽管我们目前只关注方向光。其他光源类型会烘焙，但需要一些额外的工作才能正确烘焙。</p></blockquote><h2 id="光照探针"><span class="me-2">光照探针</span><a href="#光照探针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>动态对象不影响烘焙的全局光照，但可以通过光照探针受到影响。光照探针是场景中的一个点，通过用三阶多项式（具体来说是 L2 球谐函数）近似，烘焙了所有传入的光照。光照探针放置在场景中，Unity 在每个对象上在它们之间进行插值，以到达其位置的最终光照近似值。</p><h3 id="光照探针组"><span class="me-2">光照探针组</span><a href="#光照探针组" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>通过创建光照探针组（GameObject / Light / Light Probe Group）将光照探针添加到场景中。这会创建一个具有 LightProbeGroup 组件的游戏对象，默认情况下该组件包含六个探针，形成立方体形状。当启用 Edit Light Probes 时，你可以移动、复制和删除单个探针，就像它们是游戏对象一样。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/15-probes-editing-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/15-probes-editing-scene.png" alt="Editing light probe group inside structure" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Editing light probe group inside structure</figcaption></figure><p>场景中可以有多个探针组。Unity 组合所有探针，然后创建一个连接它们的四面体体积网格。每个动态对象最终位于一个四面体内。顶点处的四个探针被插值以到达应用于对象的最终光照。如果对象最终位于探针覆盖的区域之外，则使用最近的三角形，因此光照可能会显得奇怪。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/16-probes-selected-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/16-probes-selected-scene.png" alt="Light probes used by selected objects" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Light probes used by selected objects</figcaption></figure><p><strong>你把光照探针放在哪里取决于场景。首先，它们只需要在动态对象会出现的地方。其次，把它们放在光照变化的地方。每个探针都是插值的端点，所以把它们放在光照过渡的地方。第三，不要把探针放在烘焙几何体内部，因为它们最终会变黑。最后，插值会穿过物体，所以如果墙的两侧光照不同，把探针放在墙的两侧附近。这样就没有物体会插值到两侧。除此之外，你必须自己实验。</strong></p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/17-probes-all.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/17-probes-all.png" alt="Showing all light probes" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Showing all light probes</figcaption></figure><h3 id="采样探针"><span class="me-2">采样探针</span><a href="#采样探针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>插值的光照探针数据必须通过每个对象传递给 GPU。我们必须告诉 Unity 这样做，这次通过 <code class="language-plaintext highlighter-rouge">PerObjectData.LightProbe</code> 而不是 <code class="language-plaintext highlighter-rouge">PerObjectData.Lightmaps</code>。我们需要启用两个特性标志，所以用布尔 OR 运算符组合它们。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">perObjectData</span> <span class="p">=</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">Lightmaps</span> <span class="p">|</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbe</span>
</pre></table></code></div></div><p>所需的 UnityPerDraw 数据由七个 float4 向量组成，代表红、绿、蓝光的多项式分量。它们名为 <code class="language-plaintext highlighter-rouge">unity_SH*</code>，其中 * 是 A、B 或 C。前两个有三个带 r、g 和 b 后缀的版本。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityPerDraw</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="kt">float4</span> <span class="n">unity_SHAr</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_SHAg</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_SHAb</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_SHBr</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_SHBg</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_SHBb</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_SHC</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>我们在 GI 中通过一个新的 <code class="language-plaintext highlighter-rouge">SampleLightProbe</code> 函数采样光照探针。我们需要一个方向，所以给它一个世界空间表面参数。</p><p>如果此对象使用了光照贴图，则返回零。否则返回 <code class="language-plaintext highlighter-rouge">max(0.0, SampleSH9)</code>。该函数需要探针数据和法线向量作为参数。探针数据必须作为系数数组提供。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">SampleLightProbe</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHAr</span><span class="p">;</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHAg</span><span class="p">;</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHAb</span><span class="p">;</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHBr</span><span class="p">;</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHBg</span><span class="p">;</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHBb</span><span class="p">;</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHC</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">SampleSH9</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span><span class="p">));</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p>在 GetGI 中添加一个表面参数，并让它将光照探针样本添加到漫反射光。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">GI</span> <span class="nf">GetGI</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GI</span> <span class="n">gi</span><span class="p">;</span>
    <span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SampleLightMap</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">)</span> <span class="o">+</span> <span class="n">SampleLightProbe</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">gi</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，在 LitPassFragment 中将表面传递给它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">GI</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">GetGI</span><span class="p">(</span><span class="n">GI_FRAGMENT_DATA</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">surface</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/18-sampling-probes.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/18-sampling-probes.png" alt="Sampling light probes" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Sampling light probes</figcaption></figure><h3 id="光照探针代理体"><span class="me-2">光照探针代理体</span><a href="#光照探针代理体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>光照探针适用于相当小的动态对象，但由于光照基于单个点，它对较大的对象效果不佳。举例来说，我在场景中添加了两个拉伸的立方体。由于它们的位置在黑暗区域，立方体是均匀的黑暗，即使显然这与光照不匹配。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/19-large-objects-single-probe.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/19-large-objects-single-probe.png" alt="Large objects sampling from one position" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Large objects sampling from one position</figcaption></figure><p>我们可以通过使用光照探针代理体（LPPV）来克服这个限制。最简单的方法是向每个立方体添加一个 LightProbeProxyVolume 组件，然后将它们的 Light Probes 模式设置为 Use Proxy Volume。</p><p>这些体积可以通过多种方式配置。在这种情况下，我使用自定义分辨率模式沿立方体的边缘放置子探针，这样它们是可见的。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/20-lppv-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/20-lppv-scene.png" alt="Using LPPVs" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Using LPPVs</figcaption></figure><p><strong>为什么我在场景视图中看不到探针？</strong></p><p>当 LPPV 的 Refresh Mode 设置为 Automatic 时，它们可能不会显示。在这种情况下，你可以暂时将其设置为 Every Frame。</p><h3 id="采样-lppv"><span class="me-2">采样 LPPV</span><a href="#采样-lppv" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>LPPV 还需要通过每个对象将数据发送到 GPU。在这种情况下，我们必须启用 <code class="language-plaintext highlighter-rouge">PerObjectData.LightProbeProxyVolume</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">perObjectData</span> <span class="p">=</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">Lightmaps</span> <span class="p">|</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbe</span> <span class="p">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbeProxyVolume</span>
</pre></table></code></div></div><p>必须向 UnityPerDraw 添加四个额外值：<code class="language-plaintext highlighter-rouge">unity_ProbeVolumeParams</code>、<code class="language-plaintext highlighter-rouge">unity_ProbeVolumeWorldToObject</code>、<code class="language-plaintext highlighter-rouge">unity_ProbeVolumeSizeInv</code> 和 <code class="language-plaintext highlighter-rouge">unity_ProbeVolumeMin</code>。第二个是矩阵，其他是 4D 向量。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityPerDraw</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="kt">float4</span> <span class="n">unity_ProbeVolumeParams</span><span class="p">;</span>
    <span class="kt">float4x4</span> <span class="n">unity_ProbeVolumeWorldToObject</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_ProbeVolumeSizeInv</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">unity_ProbeVolumeMin</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>体积数据存储在 3D 浮点纹理中，称为 <code class="language-plaintext highlighter-rouge">unity_ProbeVolumeSH</code>。通过 <code class="language-plaintext highlighter-rouge">TEXTURE3D_FLOAT</code> 宏将其添加到 GI，以及它的采样器状态。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">TEXTURE3D_FLOAT</span><span class="p">(</span><span class="n">unity_ProbeVolumeSH</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">samplerunity_ProbeVolumeSH</span><span class="p">);</span>
</pre></table></code></div></div><p>是使用 LPPV 还是插值光照探针通过 <code class="language-plaintext highlighter-rouge">unity_ProbeVolumeParams</code> 的第一个分量进行通信。如果已设置，我们必须通过 <code class="language-plaintext highlighter-rouge">SampleProbeVolumeSH4</code> 函数采样体积。我们必须传递纹理和采样器，然后是世界位置和法线。之后是矩阵，分别传递 <code class="language-plaintext highlighter-rouge">unity_ProbeVolumeParams</code> 的 Y 和 Z 分量，然后是 min 和 size-inv 数据的 XYZ 部分。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">SampleProbeVolumeSH4</span><span class="p">(</span>
        <span class="n">TEXTURE3D_ARGS</span><span class="p">(</span><span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">samplerunity_ProbeVolumeSH</span><span class="p">),</span>
        <span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span>
        <span class="n">unity_ProbeVolumeWorldToObject</span><span class="p">,</span>
        <span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">z</span><span class="p">,</span>
        <span class="n">unity_ProbeVolumeMin</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSizeInv</span><span class="p">.</span><span class="n">xyz</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
    <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHAr</span><span class="p">;</span>
    <span class="n">coefficients</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHAg</span><span class="p">;</span>
    <span class="n">coefficients</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHAb</span><span class="p">;</span>
    <span class="n">coefficients</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHBr</span><span class="p">;</span>
    <span class="n">coefficients</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHBg</span><span class="p">;</span>
    <span class="n">coefficients</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHBb</span><span class="p">;</span>
    <span class="n">coefficients</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">unity_SHC</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">SampleSH9</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/21-sampling-lppvs-1.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/21-sampling-lppvs-1.png" alt="Sampling LPPVs" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Sampling LPPVs</figcaption></figure><p>采样 LPPV 需要变换到体积的空间，以及一些其他计算、体积纹理采样和球谐函数的应用。在这种情况下只应用 L1 球谐函数，所以结果不太精确，但可以在单个对象的表面上变化。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/22-sampling-lppvs-2.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/22-sampling-lppvs-2.png" alt="Sampling LPPVs" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Sampling LPPVs</figcaption></figure><h2 id="meta-pass"><span class="me-2">Meta Pass</span><a href="#meta-pass" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>由于间接漫反射光从表面反弹，它应该受到这些表面漫反射率的影响。目前这种情况没有发生。Unity 将我们的表面视为均匀白色。Unity 在烘焙时使用特殊的 meta pass 来确定反射光。由于我们没有定义这样的 pass，Unity 使用默认的，最终是白色的。</p><h3 id="统一输入"><span class="me-2">统一输入</span><a href="#统一输入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>添加另一个 pass 意味着我们必须再次定义着色器属性。让我们从 LitPass 中提取基础纹理和 UnityPerMaterial buffer，并将它们放在一个新的 <code class="language-plaintext highlighter-rouge">Shaders/LitInput.hlsl</code> 文件中。我们还通过引入 <code class="language-plaintext highlighter-rouge">TransformBaseUV</code>、<code class="language-plaintext highlighter-rouge">GetBase</code>、<code class="language-plaintext highlighter-rouge">GetCutoff</code>、<code class="language-plaintext highlighter-rouge">GetMetallic</code> 和 <code class="language-plaintext highlighter-rouge">GetSmoothness</code> 函数来隐藏实例化代码。给它们全部一个基础 UV 参数，即使未使用。这样可以隐藏值是否从贴图中检索。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_LIT_INPUT_INCLUDED
#define CUSTOM_LIT_INPUT_INCLUDED
</span>
<span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">sampler_BaseMap</span><span class="p">);</span>

<span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseMap_ST</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Metallic</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Smoothness</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>

<span class="kt">float2</span> <span class="nf">TransformBaseUV</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">baseST</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_BaseMap_ST</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">baseUV</span> <span class="o">*</span> <span class="n">baseST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">baseST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float4</span> <span class="nf">GetBase</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">map</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">baseUV</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">map</span> <span class="o">*</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetCutoff</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetMetallic</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Metallic</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetSmoothness</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Smoothness</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>要在 Lit 的所有 pass 中包含此文件，在其 SubShader 块的顶部添加一个 HLSLINCLUDE 块，在 pass 之前。在其中包含 Common，然后是 LitInput。这段代码将被插入到所有 pass 的开始处。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">SubShader</span> <span class="p">{</span>
    <span class="n">HLSLINCLUDE</span>
        <span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Common.hlsl"</span><span class="cp">
</span>        <span class="cp">#include</span> <span class="cpf">"LitInput.hlsl"</span><span class="cp">
</span>    <span class="n">ENDHLSL</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>从 LitPass 中删除现在重复的 include 语句和声明。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">//#include "../ShaderLibrary/Common.hlsl"</span>
<span class="p">...</span>
<span class="c1">//TEXTURE2D(_BaseMap);</span>
<span class="c1">//SAMPLER(sampler_BaseMap);</span>
<span class="c1">//UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)</span>
<span class="c1">//...</span>
<span class="c1">//UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</span>
</pre></table></code></div></div><p>在 LitPassVertex 中使用 TransformBaseUV。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">//float4 baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseMap_ST);</span>
<span class="n">output</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">=</span> <span class="n">TransformBaseUV</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
</pre></table></code></div></div><p>并在 LitPassFragment 中使用相关函数检索着色器属性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">//float4 baseMap = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.baseUV);</span>
<span class="c1">//float4 baseColor = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);</span>
<span class="kt">float4</span> <span class="n">base</span> <span class="o">=</span> <span class="n">GetBase</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>

<span class="cp">#if defined(_CLIPPING)
</span>    <span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">GetCutoff</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">));</span>
<span class="cp">#endif
</span><span class="p">...</span>
<span class="n">surface</span><span class="p">.</span><span class="n">metallic</span> <span class="o">=</span> <span class="n">GetMetallic</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
<span class="n">surface</span><span class="p">.</span><span class="n">smoothness</span> <span class="o">=</span> <span class="n">GetSmoothness</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
</pre></table></code></div></div><p>给 ShadowCasterPass 同样的处理。</p><h3 id="unlit"><span class="me-2">Unlit</span><a href="#unlit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们也为 Unlit 着色器做同样的事情。复制 LitInput.hlsl 并重命名为 UnlitInput.hlsl。然后从其 UnityPerMaterial 版本中删除 _Metallic 和 _Smoothness。保留 GetMetallic 和 GetSmoothness 函数，让它们返回 0.0，代表一个非常暗淡的漫反射表面。之后，给着色器一个 HLSLINCLUDE 块。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">HLSLINCLUDE</span>
    <span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Common.hlsl"</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">"UnlitInput.hlsl"</span><span class="cp">
</span><span class="n">ENDHLSL</span>
</pre></table></code></div></div><p>像对 LitPass 一样转换 UnlitPass。注意，ShadowCasterPass 对两个着色器都适用，即使它最终具有不同的输入定义。</p><h3 id="meta-light-mode"><span class="me-2">Meta Light Mode</span><a href="#meta-light-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>向 Lit 和 Unlit 着色器添加一个新 pass，将 LightMode 设置为 Meta。这个 pass 需要将剔除始终关闭，可以通过添加 Cull Off 选项来配置。它将使用在新的 MetaPass.hlsl 文件中定义的 MetaPassVertex 和 MetaPassFragment 函数。它不需要 multi-compile 指令。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Tags</span> <span class="p">{</span>
        <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"Meta"</span>
    <span class="p">}</span>
    <span class="n">Cull</span> <span class="n">Off</span>
    <span class="n">HLSLPROGRAM</span>
        <span class="cp">#pragma target 3.5
</span>        <span class="cp">#pragma vertex MetaPassVertex
</span>        <span class="cp">#pragma fragment MetaPassFragment
</span>        <span class="cp">#include</span> <span class="cpf">"MetaPass.hlsl"</span><span class="cp">
</span>    <span class="n">ENDHLSL</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们需要知道表面的漫反射率，所以我们必须在 MetaPassFragment 中获取它的 BRDF 数据。因此我们必须包含 BRDF，加上它依赖的 Surface、Shadows 和 Light。我们只需要知道对象空间位置和基础 UV，最初将裁剪空间位置设置为零。表面可以通过 <code class="language-plaintext highlighter-rouge">ZERO_INITIALIZE(Surface, surface)</code> 初始化为 zero，之后我们只需要设置它的颜色、金属度和平滑度值。这足以获取 BRDF 数据，但我们将从返回零开始。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_META_PASS_INCLUDED
#define CUSTOM_META_PASS_INCLUDED
</span>
<span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Surface.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Shadows.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Light.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/BRDF.hlsl"</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">positionCS</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="n">VAR_BASE_UV</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Varyings</span> <span class="nf">MetaPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Varyings</span> <span class="n">output</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">=</span> <span class="n">TransformBaseUV</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float4</span> <span class="nf">MetaPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">base</span> <span class="o">=</span> <span class="n">GetBase</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="n">Surface</span> <span class="n">surface</span><span class="p">;</span>
    <span class="n">ZERO_INITIALIZE</span><span class="p">(</span><span class="n">Surface</span><span class="p">,</span> <span class="n">surface</span><span class="p">);</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">base</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">metallic</span> <span class="o">=</span> <span class="n">GetMetallic</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">smoothness</span> <span class="o">=</span> <span class="n">GetSmoothness</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="n">BRDF</span> <span class="n">brdf</span> <span class="o">=</span> <span class="n">GetBRDF</span><span class="p">(</span><span class="n">surface</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">meta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">meta</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>一旦 Unity 使用我们自己的 meta pass 重新烘焙场景，所有间接光照都会消失，因为黑色表面不反射任何东西。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/23-no-indirect-light.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/23-no-indirect-light.png" alt="No more indirect light" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">No more indirect light</figcaption></figure><h3 id="光照贴图坐标-1"><span class="me-2">光照贴图坐标</span><a href="#光照贴图坐标-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>就像采样光照贴图一样，我们需要使用光照贴图坐标。不同之处在于这次我们朝相反方向前进，使用它们作为 XY 对象空间位置。之后我们必须将其提供给 <code class="language-plaintext highlighter-rouge">TransformWorldToHClip</code>，尽管在这种情况下该函数执行与其名称建议的不同类型的变换。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">lightMapUV</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>

<span class="n">Varyings</span> <span class="nf">MetaPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Varyings</span> <span class="n">output</span><span class="p">;</span>
    <span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span>
        <span class="n">input</span><span class="p">.</span><span class="n">lightMapUV</span> <span class="o">*</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span> <span class="o">=</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">=</span> <span class="n">TransformBaseUV</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们仍然需要对象空间顶点属性作为输入，因为着色器期望它存在。实际上，OpenGL 似乎除非明确使用 Z 坐标否则不能工作。我们将使用与 Unity 自己的 meta pass 相同的虚拟赋值，即 <code class="language-plaintext highlighter-rouge">input.positionOS.z &gt; 0.0 ? FLT_MIN : 0.0</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span>
    <span class="n">input</span><span class="p">.</span><span class="n">lightMapUV</span> <span class="o">*</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="o">?</span> <span class="n">FLT_MIN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="漫反射率"><span class="me-2">漫反射率</span><a href="#漫反射率" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>meta pass 可用于生成不同的数据。请求的内容通过 bool4 向量 <code class="language-plaintext highlighter-rouge">unity_MetaFragmentControl</code> 标志传达。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">bool4</span> <span class="n">unity_MetaFragmentControl</span><span class="p">;</span>
</pre></table></code></div></div><p>如果设置了 X 标志，则请求漫反射率，所以使其成为 RGB 结果。A 分量应设为一。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="n">meta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaFragmentControl</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span><span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">meta</span><span class="p">;</span>
</pre></table></code></div></div><p>这足以给反射光着色，但 Unity 的 meta pass 也会通过添加一半按粗糙度缩放的高光反射率来增强结果。高度高光但粗糙的材质也会传递一些间接光的想法。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">meta</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span><span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="n">meta</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="n">brdf</span><span class="p">.</span><span class="n">specular</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">roughness</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
</pre></table></code></div></div><p>之后，通过使用 <code class="language-plaintext highlighter-rouge">PositivePow</code> 方法将结果提升到通过 <code class="language-plaintext highlighter-rouge">unity_OneOverOutputBoost</code> 提供的幂，然后将其限制为 <code class="language-plaintext highlighter-rouge">unity_MaxOutputValue</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">meta</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="n">brdf</span><span class="p">.</span><span class="n">specular</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">roughness</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">meta</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
    <span class="n">PositivePow</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">unity_OneOverOutputBoost</span><span class="p">),</span> <span class="n">unity_MaxOutputValue</span>
<span class="p">);</span>
</pre></table></code></div></div><p>这些值作为浮点数提供。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">unity_OneOverOutputBoost</span><span class="p">;</span>
<span class="n">float</span> <span class="n">unity_MaxOutputValue</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/24-colored-indirect-light.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/24-colored-indirect-light.png" alt="Colored indirect light, mostly green from the ground" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Colored indirect light, mostly green from the ground</figcaption></figure><p>现在我们得到了正确颜色的间接光照，同时在 GetLighting 中也将其应用于接收表面的漫反射率。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/25-proper-lighting.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/25-proper-lighting.png" alt="Properly colored baked lighting" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Properly colored baked lighting</figcaption></figure><p>我们还通过将环境光照强度设置回一来重新打开环境光照。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/26-environment-lighting.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/26-environment-lighting.png" alt="With environment lighting" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">With environment lighting</figcaption></figure><p>最后，将光源的模式设置回 Mixed。它再次成为实时光源，所有间接漫反射光照都被烘焙。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/27-mixed-lighting.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/27-mixed-lighting.png" alt="Mixed lighting" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Mixed lighting</figcaption></figure><h2 id="自发光表面"><span class="me-2">自发光表面</span><a href="#自发光表面" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>有些表面本身发出光，因此在没有其他照明的情况下也能看到。这可以通过在 LitPassFragment 末尾简单添加一些颜色来实现。这不是一个真正的光源，所以它不会影响其他表面。但是，效果可以贡献给烘焙光照。</p><h3 id="发出光"><span class="me-2">发出光</span><a href="#发出光" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在 Lit 着色器中添加两个新属性：一个自发光贴图和颜色，就像基础贴图和颜色一样。然而，我们将对两者使用相同的坐标变换，所以我们不需要为自发光贴图显示单独的控制。可以通过给它 NoScaleOffset 属性来隐藏它。为了支持非常亮的自发光，为颜色添加 HDR 属性。这使得可以通过检查器配置亮度大于一的颜色，显示 HDR 颜色弹出窗口而不是常规颜色。</p><p>作为示例，我制作了一个使用 Default-Particle 纹理的不透明自发光材质，它包含一个圆形渐变，从而产生一个亮点。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_EmissionMap</span><span class="p">(</span><span class="s">"Emission"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
<span class="p">[</span><span class="n">HDR</span><span class="p">]</span> <span class="n">_EmissionColor</span><span class="p">(</span><span class="s">"Emission"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/28-emissive-material.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/28-emissive-material.png" alt="Material with emission set to white dots" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Material with emission set to white dots</figcaption></figure><p>将贴图添加到 LitInput，将自发光颜色添加到 UnityPerMaterial。然后添加一个 GetEmission 函数，其工作方式与 GetBase 一样，只是使用另一个纹理和颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">);</span>
<span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_EmissionMap</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">sampler_BaseMap</span><span class="p">);</span>

<span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseMap_ST</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_EmissionColor</span><span class="p">)</span>
    <span class="p">...</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
<span class="p">...</span>

<span class="kt">float3</span> <span class="nf">GetEmission</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">map</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_EmissionMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">baseUV</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_EmissionColor</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 LitPassFragment 末尾将自发光添加到最终颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">gi</span><span class="p">);</span>
<span class="n">color</span> <span class="o">+=</span> <span class="n">GetEmission</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="n">alpha</span><span class="p">);</span>
</pre></table></code></div></div><p>还要在 UnlitInput 中添加 GetEmission 函数。在这种情况下，我们只需让它成为 GetBase 的代理。因此，如果你烘焙一个无光照对象，它最终会发出其全部颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetEmission</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetBase</span><span class="p">(</span><span class="n">baseUV</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>为了使无光照材质能够发出非常亮的光，我们可以在 Unlit 的基础颜色属性中添加 HDR 属性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">HDR</span><span class="p">]</span> <span class="n">_BaseColor</span><span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
</pre></table></code></div></div><p>最后，让我们将自发光颜色添加到 PerObjectMaterialProperties。在这种情况下，我们可以通过为配置字段提供 ColorUsage 属性来允许 HDR 输入。我们必须传递两个布尔值。第一个指示是否必须显示 alpha 通道，我们不需要。第二个指示是否允许 HDR 值。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="n">baseColorId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_BaseColor"</span><span class="p">),</span>
    <span class="n">cutoffId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_Cutoff"</span><span class="p">),</span>
    <span class="n">metallicId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_Metallic"</span><span class="p">),</span>
    <span class="n">smoothnessId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_Smoothness"</span><span class="p">),</span>
    <span class="n">emissionColorId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_EmissionColor"</span><span class="p">);</span>
<span class="p">...</span>

<span class="p">[</span><span class="n">SerializeField</span><span class="p">,</span> <span class="nf">ColorUsage</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">)]</span>
<span class="n">Color</span> <span class="n">emissionColor</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">black</span><span class="p">;</span>
<span class="p">...</span>

<span class="k">void</span> <span class="nf">OnValidate</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="n">emissionColorId</span><span class="p">,</span> <span class="n">emissionColor</span><span class="p">);</span>
    <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Renderer</span><span class="p">&gt;().</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/29-per-object-emission.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/29-per-object-emission.png" alt="Per-object emission set to HDR yellow" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Per-object emission set to HDR yellow</figcaption></figure><p>我在场景中添加了几个小的自发光立方体。我让它们对全局光照做出贡献，并将它们在 Lightmap 中的 Scale 翻倍以避免关于重叠 UV 坐标的警告。当顶点最终在光照贴图中太靠近而不得不共享同一个纹理像素时，就会发生这种情况。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/30-emissive-objects.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/30-emissive-objects.png" alt="Emissive cubes; no environment lighting" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Emissive cubes; no environment lighting</figcaption></figure><h3 id="烘焙自发光"><span class="me-2">烘焙自发光</span><a href="#烘焙自发光" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>自发光通过单独的 pass 烘焙。当 <code class="language-plaintext highlighter-rouge">unity_MetaFragmentControl</code> 的 Y 标志设置时，MetaPassFragment 应该返回发出的光，同样将 A 分量设为一。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">unity_MetaFragmentControl</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">unity_MetaFragmentControl</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span><span class="n">GetEmission</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">),</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但这不会自动发生。我们必须为每个材质启用自发光烘焙。我们可以通过在 PerObjectMaterialProperties.OnGUI 中调用编辑器上的 <code class="language-plaintext highlighter-rouge">LightmapEmissionProperty</code> 来显示此配置选项。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnGUI</span> <span class="p">(</span>
    <span class="n">MaterialEditor</span> <span class="n">materialEditor</span><span class="p">,</span> <span class="n">MaterialProperty</span><span class="p">[]</span> <span class="n">properties</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="nf">BeginChangeCheck</span><span class="p">();</span>
    <span class="k">base</span><span class="p">.</span><span class="nf">OnGUI</span><span class="p">(</span><span class="n">materialEditor</span><span class="p">,</span> <span class="n">properties</span><span class="p">);</span>
    <span class="n">editor</span> <span class="p">=</span> <span class="n">materialEditor</span><span class="p">;</span>
    <span class="n">materials</span> <span class="p">=</span> <span class="n">materialEditor</span><span class="p">.</span><span class="n">targets</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">properties</span> <span class="p">=</span> <span class="n">properties</span><span class="p">;</span>
    <span class="nf">BakedEmission</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">BakedEmission</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">editor</span><span class="p">.</span><span class="nf">LightmapEmissionProperty</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这会使一个 Global Illumination 下拉菜单显示出来，最初设置为 None。尽管它的名字，它只影响烘焙的自发光。将其更改为 Baked 告诉光照贴图器为发出的光运行一个单独的 pass。还有一个 Realtime 选项，但它已被弃用。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/31-emission-set-to-baked.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/31-emission-set-to-baked.png" alt="Emission set to baked" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Emission set to baked</figcaption></figure><p>这仍然不工作，因为 Unity 在烘焙时会积极尝试避免单独的发出光 pass。如果材质的自发光设置为零，它会被忽略。但是，这不会考虑每个对象的材质属性。我们可以通过在更改自发光模式时禁用所有选定材质的 globalIlluminationFlags 属性的默认 <code class="language-plaintext highlighter-rouge">MaterialGlobalIlluminationFlags.EmissiveIsBlack</code> 标志来覆盖此行为。这意味着你只应在需要时启用 Baked 选项。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">BakedEmission</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">EditorGUI</span><span class="p">.</span><span class="n">BeginChangeCheck</span><span class="p">();</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">LightmapEmissionProperty</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="n">EndChangeCheck</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">editor</span><span class="p">.</span><span class="n">targets</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">globalIlluminationFlags</span> <span class="o">&amp;=</span>
                <span class="o">~</span><span class="n">MaterialGlobalIlluminationFlags</span><span class="p">.</span><span class="n">EmissiveIsBlack</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/32-baked-emission-comparison.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/32-baked-emission-comparison.png" alt="Baked emission, with and without directional light" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Baked emission, with and without directional light</figcaption></figure><h2 id="烘焙透明度"><span class="me-2">烘焙透明度</span><a href="#烘焙透明度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>也可以烘焙透明对象，但这需要一点额外的努力。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/33-semitransparent-ceiling.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/33-semitransparent-ceiling.png" alt="Semitransparent ceiling treated as opaque" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Semitransparent ceiling treated as opaque</figcaption></figure><h3 id="硬编码属性"><span class="me-2">硬编码属性</span><a href="#硬编码属性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>不幸的是，Unity 的光照贴图器对透明度采用硬编码方法。它查看材质的队列以确定它是 opaque、clipped 还是透明的。然后通过将 _MainTex 和 _Color 属性的 alpha 分量相乘来确定透明度，使用 _Cuto! 属性进行 alpha 裁剪。我们的着色器有第三个但缺少前两个。目前使这工作的唯一方法是将预期属性添加到我们的着色器，给它们 HideInInspector 属性以使它们不会出现在检查器中。Unity 的 SRP 着色器必须处理同样的问题。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">HideInInspector</span><span class="p">]</span> <span class="n">_MainTex</span><span class="p">(</span><span class="s">"Texture for Lightmap"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
<span class="p">[</span><span class="n">HideInInspector</span><span class="p">]</span> <span class="n">_Color</span><span class="p">(</span><span class="s">"Color for Lightmap"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="复制属性"><span class="me-2">复制属性</span><a href="#复制属性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们必须确保 _MainTex 属性指向与 _BaseMap 相同的纹理并使用相同的 UV 变换。两种颜色属性也必须相同。我们可以在新的 CopyLightMappingProperties 方法中执行此操作，如果进行了更改，我们会在 CustomShaderGUI.OnGUI 结束时调用它。如果相关属性存在，则复制它们的值。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnGUI</span> <span class="p">(</span>
    <span class="n">MaterialEditor</span> <span class="n">materialEditor</span><span class="p">,</span> <span class="n">MaterialProperty</span><span class="p">[]</span> <span class="n">properties</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EditorGUI</span><span class="p">.</span><span class="nf">EndChangeCheck</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">SetShadowCasterPass</span><span class="p">();</span>
        <span class="nf">CopyLightMappingProperties</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">CopyLightMappingProperties</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialProperty</span> <span class="n">mainTex</span> <span class="p">=</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_MainTex"</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="n">MaterialProperty</span> <span class="n">baseMap</span> <span class="p">=</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_BaseMap"</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mainTex</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">baseMap</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mainTex</span><span class="p">.</span><span class="n">textureValue</span> <span class="p">=</span> <span class="n">baseMap</span><span class="p">.</span><span class="n">textureValue</span><span class="p">;</span>
        <span class="n">mainTex</span><span class="p">.</span><span class="n">textureScaleAndOffset</span> <span class="p">=</span> <span class="n">baseMap</span><span class="p">.</span><span class="n">textureScaleAndOffset</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">MaterialProperty</span> <span class="n">color</span> <span class="p">=</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_Color"</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="n">MaterialProperty</span> <span class="n">baseColor</span> <span class="p">=</span>
        <span class="nf">FindProperty</span><span class="p">(</span><span class="s">"_BaseColor"</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">color</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">baseColor</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">color</span><span class="p">.</span><span class="n">colorValue</span> <span class="p">=</span> <span class="n">baseColor</span><span class="p">.</span><span class="n">colorValue</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/34-transparent-baked.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/34-transparent-baked.png" alt="Transparency correctly baked" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Transparency correctly baked</figcaption></figure><p>这也对裁剪材质有效。虽然可能不需要在 MetaPassFragment 中裁剪片段，因为透明度是单独处理的。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/35-cutout-baked.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/35-cutout-baked.png" alt="Baked clipping" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Baked clipping</figcaption></figure><p>不幸的是，这意味着烘焙透明度只能依赖于单个纹理、颜色和裁剪属性。此外，光照贴图器只考虑材质的属性。每个实例的属性会被忽略。</p><h2 id="mesh-ball"><span class="me-2">Mesh Ball</span><a href="#mesh-ball" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们通过为 Mesh Ball 生成的实例添加全局光照支持来结束。由于它们的实例是在播放模式中生成的，它们不能被烘焙，但通过一点努力，它们可以通过光照探针接收烘焙的光照。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/36-mesh-ball-baked.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/36-mesh-ball-baked.png" alt="Mesh ball with fully-baked lighting" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Mesh ball with fully-baked lighting</figcaption></figure><h3 id="光照探针-1"><span class="me-2">光照探针</span><a href="#光照探针-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们通过调用需要五个额外参数的 DrawMeshInstanced 方法变体来指示应该使用光照探针。首先是阴影投射模式，我们希望开启。之后是实例是否应该投射阴影，我们希望。接下来是层，我们只使用默认的零。然后我们必须提供一个实例应该可见的相机。传递 null 意味着它们应该为所有相机呈现。最后，我们可以设置光照探针模式。我们必须使用 <code class="language-plaintext highlighter-rouge">LightProbeUsage.CustomProvided</code>，因为没有单一位置可以用于混合探针。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.Rendering</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MeshBall</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">block</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
            <span class="n">block</span><span class="p">.</span><span class="nf">SetVectorArray</span><span class="p">(</span><span class="n">baseColorId</span><span class="p">,</span> <span class="n">baseColors</span><span class="p">);</span>
            <span class="n">block</span><span class="p">.</span><span class="nf">SetFloatArray</span><span class="p">(</span><span class="n">metallicId</span><span class="p">,</span> <span class="n">metallic</span><span class="p">);</span>
            <span class="n">block</span><span class="p">.</span><span class="nf">SetFloatArray</span><span class="p">(</span><span class="n">smoothnessId</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Graphics</span><span class="p">.</span><span class="nf">DrawMeshInstanced</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">matrices</span><span class="p">,</span> <span class="m">1023</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
            <span class="n">ShadowCastingMode</span><span class="p">.</span><span class="n">On</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">LightProbeUsage</span><span class="p">.</span><span class="n">CustomProvided</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们必须为所有实例手动生成插值光照探针并将它们添加到材质属性块中。这意味着我们在配置块时需要访问实例位置。我们可以通过获取它们的变换矩阵的最后一列来检索它们并将它们存储在临时数组中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">block</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">SetVectorArray</span><span class="p">(</span><span class="n">baseColorId</span><span class="p">,</span> <span class="n">baseColors</span><span class="p">);</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">SetFloatArray</span><span class="p">(</span><span class="n">metallicId</span><span class="p">,</span> <span class="n">metallic</span><span class="p">);</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">SetFloatArray</span><span class="p">(</span><span class="n">smoothnessId</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">positions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector3</span><span class="p">[</span><span class="m">1023</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">matrices</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">GetColumn</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>光照探针必须通过 SphericalHarmonicsL2 数组提供。通过使用位置和光照探针数组作为参数调用 <code class="language-plaintext highlighter-rouge">LightProbes.CalculateInterpolatedLightAndOcclusionProbes</code> 来填充它。还有一个用于遮挡的第三个参数，我们将使用 null。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">matrices</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">GetColumn</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">var</span> <span class="n">lightProbes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SphericalHarmonicsL2</span><span class="p">[</span><span class="m">1023</span><span class="p">];</span>
<span class="n">LightProbes</span><span class="p">.</span><span class="nf">CalculateInterpolatedLightAndOcclusionProbes</span><span class="p">(</span>
    <span class="n">positions</span><span class="p">,</span> <span class="n">lightProbes</span><span class="p">,</span> <span class="k">null</span>
<span class="p">);</span>
</pre></table></code></div></div><p><strong>我们不能在这里使用列表吗？</strong></p><p>是的，有一个用于此的 <code class="language-plaintext highlighter-rouge">CalculateInterpolatedLightAndOcclusionProbes</code> 变体。但我们只需要数据一次，所以列表在这种情况下对我们没有好处。</p><p>之后我们可以通过 <code class="language-plaintext highlighter-rouge">CopySHCoefficientArraysFrom</code> 将光照探针复制到块中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">LightProbes</span><span class="p">.</span><span class="nf">CalculateInterpolatedLightAndOcclusionProbes</span><span class="p">(</span>
    <span class="n">positions</span><span class="p">,</span> <span class="n">lightProbes</span><span class="p">,</span> <span class="k">null</span>
<span class="p">);</span>
<span class="n">block</span><span class="p">.</span><span class="nf">CopySHCoefficientArraysFrom</span><span class="p">(</span><span class="n">lightProbes</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/37-using-probes.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/37-using-probes.png" alt="Using light probes" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Using light probes</figcaption></figure><h3 id="lppv"><span class="me-2">LPPV</span><a href="#lppv" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>另一种方法是使用 LPPV。这是合理的，因为所有实例都存在于一个紧凑的空间中。这使我们不必计算和存储插值的光照探针。此外，它使得可以动画化实例位置，而不必每帧提供新的光照探针数据，只要它们保持在体积内。</p><p>添加一个 LightProbeProxyVolume 配置字段。如果它正在使用中，则不要将光照探针数据添加到块中。然后将 <code class="language-plaintext highlighter-rouge">LightProbeUsage.UseProxyVolume</code> 传递给 DrawMeshInstanced 而不是 <code class="language-plaintext highlighter-rouge">LightProbeUsage.CustomProvided</code>。我们可以始终将体积作为额外参数传递，即使它是 null 且未使用。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
<span class="n">LightProbeProxyVolume</span> <span class="n">lightProbeVolume</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="p">...</span>

<span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">lightProbeVolume</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">var</span> <span class="n">positions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector3</span><span class="p">[</span><span class="m">1023</span><span class="p">];</span>
            <span class="p">...</span>
            <span class="n">block</span><span class="p">.</span><span class="nf">CopySHCoefficientArraysFrom</span><span class="p">(</span><span class="n">lightProbes</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="nf">DrawMeshInstanced</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">matrices</span><span class="p">,</span> <span class="m">1023</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
        <span class="n">ShadowCastingMode</span><span class="p">.</span><span class="n">On</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span>
        <span class="n">lightProbeVolume</span> <span class="p">?</span>
            <span class="n">LightProbeUsage</span><span class="p">.</span><span class="n">UseProxyVolume</span> <span class="p">:</span> <span class="n">LightProbeUsage</span><span class="p">.</span><span class="n">CustomProvided</span><span class="p">,</span>
        <span class="n">lightProbeVolume</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>你可以将 LPPV 组件添加到 mesh ball 或将其放在其他地方。custom bounding mode 可用于定义体积占据的世界空间区域。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp5/38-using-lppv.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp5/38-using-lppv.png" alt="Using an LPPV" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Using an LPPV</figcaption></figure><hr /><p>下一教程是 <a href="../shadow-masks">Shadow Masks</a>。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/scriptrenderpipeline/">ScriptRenderPipeline</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/srp/" class="post-tag no-text-decoration" >SRP</a> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a> <a href="/tags/gi/" class="post-tag no-text-decoration" >GI</a> <a href="/tags/lightmaps/" class="post-tag no-text-decoration" >Lightmaps</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:%E7%83%98%E7%84%99%E5%85%89%E7%85%A7%20(%E7%BF%BB%E8%AF%91%E4%BA%94)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Fbaked-light%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:%E7%83%98%E7%84%99%E5%85%89%E7%85%A7%20(%E7%BF%BB%E8%AF%91%E4%BA%94)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Fbaked-light%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Fbaked-light%2F&text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:%E7%83%98%E7%84%99%E5%85%89%E7%85%A7%20(%E7%BF%BB%E8%AF%91%E4%BA%94)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/particles/">粒子系统：颜色和深度纹理</a><li class="text-truncate lh-lg"> <a href="/posts/color-grading/">Unity自定义渲染管线13：色彩分级</a><li class="text-truncate lh-lg"> <a href="/posts/post-processing/">自定义渲染管线:后处理 (翻译十一)</a><li class="text-truncate lh-lg"> <a href="/posts/hdr/">自定义渲染管线:HDR (翻译十二)</a><li class="text-truncate lh-lg"> <a href="/posts/point-spot-light-shadow/">自定义渲染管线:点光源与聚光灯阴影 (翻译十)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/complex-maps/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1588240800" data-df="ll" > Apr 30, 2020 </time><h4 class="pt-0 my-2">自定义管线:遮罩、细节与法线贴图 (翻译八)</h4><div class="text-muted"><p>创建一个电路板般的材质。 添加对 MODS 蒙版贴图的支持。 引入一个辅助细节贴图。 执行切线空间法线贴图。 背景 到目前为止，我们一直使用非常简单的材质来测试渲染管线。但它也应该支持复杂的材质，这样我们可以表现更有趣的表面。在本教程中，我们将借助几张纹理创建一个艺术风格的电路材质。 漫反射贴图 我们材质的核心是漫反射贴图（Albedo Map）。它由几层不同深浅的...</p></div></div></a></article><article class="col"> <a href="/posts/directional-shadows/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1576598400" data-df="ll" > Dec 18, 2019 </time><h4 class="pt-0 my-2">自定义管线:方向阴影 (翻译四)</h4><div class="text-muted"><p>渲染阴影 当绘制物体时，表面和光照信息就足以计算光照了。但是两者之间可能有东西阻挡光线，在我们正在绘制的表面上投下阴影。为了使阴影成为可能，我们必须以某种方式让着色器知道阴影投射物体。有多种技术可以做到这一点。最常见的方法是生成一个阴影贴图，存储光线从光源出发在击中表面之前可以传播多远。同一方向上更远的任何东西都不能被同一个光源照亮。Unity 的渲染管线使用这种方法，我们也一样。 ...</p></div></div></a></article><article class="col"> <a href="/posts/directional-lights/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1575043200" data-df="ll" > Nov 30, 2019 </time><h4 class="pt-0 my-2">自定义管线:方向光 (翻译三)</h4><div class="text-muted"><p>增加对多个方向光着色（shading）的支持。 已升级至 2022.3.62f2 1 光照 (Lighting) 如果我们想创建一个更真实的场景，那么我们就必须模拟光如何与表面相互作用。这需要一个比我们目前拥有的不发光（unlit）着色器更复杂的着色器。 1.1 受光着色器 (Lit Shader) 复制 UnlitPass.hlsl 文件并将其重命名为 LitPass.h...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/directional-shadows/" class="btn btn-outline-primary" aria-label="Older" ><p>自定义管线:方向阴影 (翻译四)</p></a> <a href="/posts/shadow-masks/" class="btn btn-outline-primary" aria-label="Newer" ><p>自定义管线:Shadow Masks (翻译六)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
