<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="自定义管线:FXAA抗锯齿 (翻译十七)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="深入探索快速近似抗锯齿（FXAA）算法的实现，包括亮度计算、边缘检测、混合策略和性能优化。" /><meta property="og:description" content="深入探索快速近似抗锯齿（FXAA）算法的实现，包括亮度计算、边缘检测、混合策略和性能优化。" /><link rel="canonical" href="www.damonc.top/posts/fxaa/" /><meta property="og:url" content="www.damonc.top/posts/fxaa/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/SRP/srp17fxaa/tutorial-image.jpg" /><meta property="og:image:alt" content="使用和不使用FXAA的图像对比，放大显示" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-02-28T00:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/SRP/srp17fxaa/tutorial-image.jpg" /><meta name="twitter:image:alt" content="使用和不使用FXAA的图像对比，放大显示" /><meta property="twitter:title" content="自定义管线:FXAA抗锯齿 (翻译十七)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2021-02-28T00:00:00+08:00","datePublished":"2021-02-28T00:00:00+08:00","description":"深入探索快速近似抗锯齿（FXAA）算法的实现，包括亮度计算、边缘检测、混合策略和性能优化。","headline":"自定义管线:FXAA抗锯齿 (翻译十七)","image":{"lqip":"data:image/webp;base64,UklGRnAAAABXRUJQVlA4IGQAAADwAwCdASoUAAoAP3Ggxli0q6ejsAgCkC4JZgCdACFyCM96V9fNHVcgAP53XQ5lUZk6G4D8KY0ffUzWUjqOsmZinKbfBFtM9+Dnly15kS7r9JpEm+1RCUiLjqAy+SO4DL9MAAAA","alt":"使用和不使用FXAA的图像对比，放大显示","url":"https://img.damonc.top/posts/SRP/srp17fxaa/tutorial-image.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/fxaa/"},"url":"www.damonc.top/posts/fxaa/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>自定义管线:FXAA抗锯齿 (翻译十七) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>自定义管线:FXAA抗锯齿 (翻译十七)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>自定义管线:FXAA抗锯齿 (翻译十七)</h1><p class="post-desc fw-light mb-4">深入探索快速近似抗锯齿（FXAA）算法的实现，包括亮度计算、边缘检测、混合策略和性能优化。</p><div class="post-meta text-muted"> <span> Posted <time data-ts="1614441600" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 28, 2021 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/tutorial-image.jpg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/SRP/srp17fxaa/tutorial-image.jpg" alt="使用和不使用FXAA的图像对比，放大显示" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRnAAAABXRUJQVlA4IGQAAADwAwCdASoUAAoAP3Ggxli0q6ejsAgCkC4JZgCdACFyCM96V9fNHVcgAP53XQ5lUZk6G4D8KY0ffUzWUjqOsmZinKbfBFtM9+Dnly15kS7r9JpEm+1RCUiLjqAy+SO4DL9MAAAA"></a><figcaption class="text-center pt-2 pb-2">使用和不使用FXAA的图像对比，放大显示</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/fxaa/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="12215 words" > <em>67 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">自定义管线:FXAA抗锯齿 (翻译十七)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">自定义管线:FXAA抗锯齿 (翻译十七)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>计算并存储像素亮度，或回退到绿色通道。<li>查找并混合高对比度像素。<li>检测并平滑长边缘。<li>结合FXAA和渲染缩放。</ul><hr /><h2 id="fxaa后处理效果"><span class="me-2">FXAA后处理效果</span><a href="#fxaa后处理效果" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>帧缓冲区的有限分辨率会在最终图像中引入视觉锯齿伪影。这些通常被称为锯齿或阶梯效应，在与像素网格不对齐的线条上可见。除此之外，小于像素的特征要么出现要么不出现，这会在它们移动时产生时间闪烁伪影。</p><p>在上一个教程中，我添加了通过最多将渲染缩放加倍然后下采样来应用SSAA的能力。这在一定程度上平滑了锯齿，并将分辨率加倍用于检测然后平滑微小特征。虽然加倍渲染缩放可以提高视觉质量，但它也要求GPU处理四倍的片段，因此非常昂贵，通常不适合实时使用。可以使用小于2的渲染缩放，但单独使用它并不能大幅提高质量。</p><p>增加分辨率的替代方案是对原始图像应用后处理效果，平滑所有锯齿伪影。已经开发了各种此类算法，它们以总是以AA结尾的缩写词而闻名，例如FXAA、MLAA、SMAA和TAA。在本教程中，我将实现FXAA，这是最简单和最快的方法。</p><p>第一个后处理抗锯齿解决方案是形态抗锯齿，缩写为MLAA。它分析图像以检测视觉特征的边缘，然后选择性地模糊这些边缘。FXAA是受MLAA启发的一种更简单的方法。它代表快速近似抗锯齿。它由NVIDIA的Timothy Lottes开发。与MLAA相比，它牺牲质量换取速度。虽然对FXAA的一个常见抱怨是它模糊得太多，但这取决于使用哪个变体以及如何调整它。我将创建最新版本——FXAA 3.11——特别是还会调查长边缘的高质量变体。</p><aside class="collapsible-aside"><h3>那MSAA呢？</h3><div><p>与SSAA类似，MSAA渲染到更高的分辨率并随后下采样，但改变了片段的渲染方式。它不是渲染更高分辨率正方形的所有片段，而是每个覆盖该块的三角形仅渲染一个片段，实际上将结果复制到更高分辨率的像素。这保持了填充率的可管理性。这也意味着只有三角形的边缘受到影响，其他一切保持不变。这就是为什么MSAA不会平滑裁剪表面的边缘，也不会减轻着色器锯齿。</p></div></aside><h3 id="启用fxaa"><span class="me-2">启用FXAA</span><a href="#启用fxaa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然FXAA是后处理效果，但它会像渲染缩放一样全局影响图像质量，所以我将把它的配置添加到<code class="language-plaintext highlighter-rouge">CameraBufferSettings</code>。最初我只需要一个切换来启用它，但之后会添加一些更多的配置选项。因此，我将把所有FXAA设置分组到一个新的<code class="language-plaintext highlighter-rouge">CameraBufferSettings.FXAA</code>结构中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="p">[</span><span class="n">Serializable</span><span class="p">]</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">CameraBufferSettings</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">[</span><span class="n">Serializable</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">struct</span> <span class="nc">FXAA</span> <span class="p">{</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">enabled</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">FXAA</span> <span class="n">fxaa</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/fxaa-camera-buffer-settings.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/fxaa-camera-buffer-settings.png" alt="为渲染管线启用FXAA" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">为渲染管线启用FXAA</figcaption></figure><p>同样，就像我对渲染缩放所做的那样，我将使每个相机可以控制是否使用FXAA，方法是向<code class="language-plaintext highlighter-rouge">CameraSettings</code>添加一个切换来控制是否允许FXAA。默认情况下应该不允许。这确保FXAA不会应用于场景窗口、材质预览或反射探头。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="kt">bool</span> <span class="n">allowFXAA</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/fxaa-camera-settings.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/fxaa-camera-settings.png" alt="为相机启用FXAA" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">为相机启用FXAA</figcaption></figure><p>由于FXAA是后处理效果，应用它是<code class="language-plaintext highlighter-rouge">PostFXStack</code>的责任。这意味着FXAA只有在使用后处理效果时才会工作。此外，FXAA配置必须传递给栈，所以向<code class="language-plaintext highlighter-rouge">PostFXStack.Setup</code>添加一个参数并将其复制到字段。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">CameraBufferSettings</span><span class="p">.</span><span class="n">FXAA</span> <span class="n">fxaa</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(</span>
    <span class="p">...</span>
    <span class="n">CameraBufferSettings</span><span class="p">.</span><span class="n">BicubicRescalingMode</span> <span class="n">bicubicRescaling</span><span class="p">,</span>
    <span class="n">CameraBufferSettings</span><span class="p">.</span><span class="n">FXAA</span> <span class="n">fxaa</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">fxaa</span> <span class="p">=</span> <span class="n">fxaa</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">CameraRenderer.Render</code>中将FXAA配置传递给它，在应用相机的切换到全局切换之后。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">bufferSettings</span><span class="p">.</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span> <span class="p">&amp;=</span> <span class="n">cameraSettings</span><span class="p">.</span><span class="n">allowFXAA</span><span class="p">;</span>
<span class="n">postFXStack</span><span class="p">.</span><span class="nf">Setup</span><span class="p">(</span>
    <span class="n">context</span><span class="p">,</span> <span class="n">camera</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">,</span> <span class="n">postFXSettings</span><span class="p">,</span> <span class="n">useHDR</span><span class="p">,</span> <span class="n">colorLUTResolution</span><span class="p">,</span>
    <span class="n">cameraSettings</span><span class="p">.</span><span class="n">finalBlendMode</span><span class="p">,</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">bicubicRescaling</span><span class="p">,</span>
    <span class="n">bufferSettings</span><span class="p">.</span><span class="n">fxaa</span>
<span class="p">);</span>
</pre></table></code></div></div><p>请注意，我可以直接修改缓冲区设置结构字段，因为它包含RP设置结构的副本，而不是对原始结构的引用。</p><h3 id="fxaa-pass"><span class="me-2">FXAA Pass</span><a href="#fxaa-pass" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我需要一个pass来应用FXAA，所以将它添加到<code class="language-plaintext highlighter-rouge">PostFXStack</code>着色器，以及在<code class="language-plaintext highlighter-rouge">PostFXStack.Pass</code>枚举中添加相应的条目。该pass是<code class="language-plaintext highlighter-rouge">Final Rescale</code>的副本，重命名为FXAA并将其片段函数设置为<code class="language-plaintext highlighter-rouge">FXAAPassFragment</code>。除此之外，我将把FXAA着色器代码放在一个单独的<code class="language-plaintext highlighter-rouge">FXAAPass</code> HLSL文件中，并仅在pass本身中包含它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Name</span> <span class="s">"FXAA"</span>

    <span class="n">Blend</span> <span class="p">[</span><span class="n">_FinalSrcBlend</span><span class="p">]</span> <span class="p">[</span><span class="n">_FinalDstBlend</span><span class="p">]</span>

    <span class="n">HLSLPROGRAM</span>
        <span class="cp">#pragma target 3.5
</span>        <span class="cp">#pragma vertex DefaultPassVertex
</span>        <span class="cp">#pragma fragment FXAAPassFragment
</span>        <span class="cp">#include</span> <span class="cpf">"FXAAPass.hlsl"</span><span class="cp">
</span>    <span class="n">ENDHLSL</span>
<span class="p">}</span>
</pre></table></code></div></div><p>创建新的<code class="language-plaintext highlighter-rouge">FXAAPass.hlsl</code>文件，最初仅包含<code class="language-plaintext highlighter-rouge">FXAAPassFragment</code>函数，它返回源像素而不修改。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_FXAA_PASS_INCLUDED
#define CUSTOM_FXAA_PASS_INCLUDED
</span>
<span class="kt">float4</span> <span class="nf">FXAAPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetSource</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>我必须在颜色分级之后应用FXAA，原因与必须在颜色分级之后进行最终重新缩放相同。由于我现在有多种情况，其中Final pass不再是真正的最终pass，让我们将其重命名为Apply Color Grading，因为这就是它实际做的事情。在着色器和Pass枚举中都这样做。将其片段函数重命名为<code class="language-plaintext highlighter-rouge">ApplyColorGradingPassFragment</code>。</p><p>让我们也将<code class="language-plaintext highlighter-rouge">PostFXStack.DoColorGradingAndToneMapping</code>方法重命名为<code class="language-plaintext highlighter-rouge">DoFinal</code>，因为它现在做的远不止是颜色分级和色调映射。</p><p>当启用FXAA时，我必须首先执行颜色分级，然后在其上应用FXAA。因此，我必须将颜色分级结果存储在临时渲染纹理中。向<code class="language-plaintext highlighter-rouge">PostFXStack</code>添加一个着色器属性标识符。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">colorGradingResultId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_ColorGradingResult"</span><span class="p">),</span>
<span class="n">finalResultId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_FinalResult"</span><span class="p">),</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">DoFinal</code>中，在我继续进行最终绘制阶段之前，立即检查是否启用了FXAA。如果启用了FXAA，立即执行颜色分级并将结果存储在新的临时LDR纹理中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span><span class="n">colorGradingLUTParametersId</span><span class="p">,</span>
    <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="m">1f</span> <span class="p">/</span> <span class="n">lutWidth</span><span class="p">,</span> <span class="m">1f</span> <span class="p">/</span> <span class="n">lutHeight</span><span class="p">,</span> <span class="n">lutHeight</span> <span class="p">-</span> <span class="m">1f</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
        <span class="n">colorGradingResultId</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
        <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span>
    <span class="p">);</span>
    <span class="nf">Draw</span><span class="p">(</span><span class="n">sourceId</span><span class="p">,</span> <span class="n">colorGradingResultId</span><span class="p">,</span> <span class="n">Pass</span><span class="p">.</span><span class="n">ApplyColorGrading</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bufferSize</span><span class="p">.</span><span class="n">x</span> <span class="p">==</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">DrawFinal</span><span class="p">(</span><span class="n">sourceId</span><span class="p">,</span> <span class="n">Pass</span><span class="p">.</span><span class="n">ApplyColorGrading</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>就像我对调整后的渲染缩放所做的那样，我必须确保颜色分级的最终混合模式设置为One Zero。由于这现在可能发生在两个地方，让我们简单地在开始绘制之前始终重置它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">finalSrcBlendId</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">finalDstBlendId</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bufferSize</span><span class="p">.</span><span class="n">x</span> <span class="p">==</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">DrawFinal</span><span class="p">(</span><span class="n">sourceId</span><span class="p">,</span> <span class="n">Pass</span><span class="p">.</span><span class="n">ApplyColorGrading</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
        <span class="n">finalResultId</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
        <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span>
    <span class="p">);</span>
    <span class="c1">//buffer.SetGlobalFloat(finalSrcBlendId, 1f);</span>
    <span class="c1">//buffer.SetGlobalFloat(finalDstBlendId, 0f);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接下来，如果缓冲区没有缩放，我再次必须检查是否启用了FXAA。如果是，则最终绘制使用FXAA pass和颜色分级结果，之后必须释放颜色分级结果。否则，颜色分级就是最终pass，就像以前一样。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">bufferSize</span><span class="p">.</span><span class="n">x</span> <span class="p">==</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">DrawFinal</span><span class="p">(</span><span class="n">colorGradingResultId</span><span class="p">,</span> <span class="n">Pass</span><span class="p">.</span><span class="n">FXAA</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">colorGradingResultId</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nf">DrawFinal</span><span class="p">(</span><span class="n">sourceId</span><span class="p">,</span> <span class="n">Pass</span><span class="p">.</span><span class="n">ApplyColorGrading</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在调整渲染缩放的情况下，我仍然必须首先渲染到中间最终结果纹理。如果启用了FXAA，我用FXAA pass对颜色分级结果进行常规绘制来完成此操作，之后释放颜色分级结果。否则，就是对原始源应用颜色分级的常规绘制。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">else</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
        <span class="n">finalResultId</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
        <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Draw</span><span class="p">(</span><span class="n">colorGradingResultId</span><span class="p">,</span> <span class="n">finalResultId</span><span class="p">,</span> <span class="n">Pass</span><span class="p">.</span><span class="n">FXAA</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">colorGradingResultId</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nf">Draw</span><span class="p">(</span><span class="n">sourceId</span><span class="p">,</span> <span class="n">finalResultId</span><span class="p">,</span> <span class="n">Pass</span><span class="p">.</span><span class="n">ApplyColorGrading</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>此时，我的RP仍然产生与以前相同的结果，但是当启用FXAA时，帧调试器将显示一个额外的FXAA pass绘制步骤。</p><h3 id="亮度"><span class="me-2">亮度</span><a href="#亮度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>FXAA通过选择性地降低图像的对比度来工作，平滑视觉上明显的锯齿和孤立像素。对比度是通过比较像素的感知强度来确定的。由于目标是减少我感知到的伪影，FXAA只关心感知亮度，即经过伽马调整的亮度，称为luma（亮度）。像素的确切颜色并不重要，重要的是它们的luma。因此，FXAA分析灰度图像。这意味着当不同颜色之间的luma相似时，它们之间的硬过渡不会被大幅平滑。只有视觉上明显的过渡才会受到强烈影响。</p><p>向<code class="language-plaintext highlighter-rouge">FXAAPass</code>添加一个<code class="language-plaintext highlighter-rouge">GetLuma</code>函数，它返回某些UV坐标的luma值。最初让它返回源的线性亮度。然后让FXAA pass返回它。请注意，FXAA在颜色分级和色调映射之后处理LDR数据，所以这代表最终图像的luma。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetLuma</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Luminance</span><span class="p">(</span><span class="n">GetSource</span><span class="p">(</span><span class="n">uv</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">float4</span> <span class="nf">FXAAPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/color.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/color.png" alt="原始颜色和线性亮度" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/luma-linear.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/luma-linear.png" alt="原始颜色和线性亮度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">原始颜色和线性亮度</figcaption></figure><p>因为我对暗色变化的感知比亮色更敏感，所以我必须对亮度应用伽马调整以获得适当的luma值。伽马值2足够准确，我通过取线性亮度的平方根来获得它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetLuma</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">Luminance</span><span class="p">(</span><span class="n">GetSource</span><span class="p">(</span><span class="n">uv</span><span class="p">)));</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/luma-gamma-2.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/luma-gamma-2.png" alt="伽马2.0 luma" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">伽马2.0 luma</figcaption></figure><h3 id="使用绿色作为亮度"><span class="me-2">使用绿色作为亮度</span><a href="#使用绿色作为亮度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>FXAA通过检测对比度和边缘来工作，这需要每个片段进行多次采样。为每个样本计算luma会使其过于昂贵。因为我在视觉上对绿色最敏感，所以计算luma的一个常见替代方案是直接使用绿色通道。这会降低质量，但避免了点积和平方根运算。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetLuma</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetSource</span><span class="p">(</span><span class="n">uv</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/luma-green.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/luma-green.png" alt="绿色作为luma" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">绿色作为luma</figcaption></figure><h3 id="在alpha通道中存储亮度"><span class="me-2">在Alpha通道中存储亮度</span><a href="#在alpha通道中存储亮度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>计算luma产生的结果比仅依赖绿色通道要好得多，但我不想在每次采样源时都计算它。一个解决方案是在应用颜色分级时计算一次。我必须将luma存储在某个地方，为此我可以使用颜色分级结果纹理的alpha通道。但是，如果之后需要存储在alpha通道中的透明度，例如在分层相机时，这是不可能的。</p><p>由于alpha通道通常未使用，我将向<code class="language-plaintext highlighter-rouge">PostFXStack</code>添加另一个pass，既应用颜色分级又计算luma，同时保留原始pass。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Name</span> <span class="s">"Apply Color Grading With Luma"</span>

    <span class="n">HLSLPROGRAM</span>
        <span class="cp">#pragma target 3.5
</span>        <span class="cp">#pragma vertex DefaultPassVertex
</span>        <span class="cp">#pragma fragment ApplyColorGradingWithLumaPassFragment
</span>    <span class="n">ENDHLSL</span>
<span class="p">}</span>
</pre></table></code></div></div><p>新的片段函数是<code class="language-plaintext highlighter-rouge">ApplyColorGradingPassFragment</code>的副本，还计算luma并将其存储在alpha通道中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">ApplyColorGradingWithLumaPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">GetSource</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
    <span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">ApplyColorGradingLUT</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
    <span class="n">color</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">Luminance</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我现在需要两个版本的FXAA pass，一个用于alpha通道包含luma的情况，一个用于luma不可用的情况。我将保留当前的FXAA pass，并在luma可用时添加另一个FXAA With Luma pass。在这种情况下，我将定义<code class="language-plaintext highlighter-rouge">FXAA_ALPHA_CONTAINS_LUMA</code>，而不是为它创建单独的片段函数。这是可行的，因为我在pass块本身中包含了<code class="language-plaintext highlighter-rouge">FXAAPass</code>，所以我在包含文件之前添加定义。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Name</span> <span class="s">"FXAA With Luma"</span>

    <span class="n">Blend</span> <span class="p">[</span><span class="n">_FinalSrcBlend</span><span class="p">]</span> <span class="p">[</span><span class="n">_FinalDstBlend</span><span class="p">]</span>

    <span class="n">HLSLPROGRAM</span>
        <span class="cp">#pragma target 3.5
</span>        <span class="cp">#pragma vertex DefaultPassVertex
</span>        <span class="cp">#pragma fragment FXAAPassFragment
</span>        <span class="cp">#define FXAA_ALPHA_CONTAINS_LUMA
</span>        <span class="cp">#include</span> <span class="cpf">"FXAAPass.hlsl"</span><span class="cp">
</span>    <span class="n">ENDHLSL</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在我可以使用条件编译使<code class="language-plaintext highlighter-rouge">GetLuma</code>返回适当的颜色通道：当luma存储在其中时返回alpha，否则返回绿色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetLuma</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined(FXAA_ALPHA_CONTAINS_LUMA)
</span>    <span class="k">return</span> <span class="n">GetSource</span><span class="p">(</span><span class="n">uv</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="cp">#else
</span>    <span class="k">return</span> <span class="n">GetSource</span><span class="p">(</span><span class="n">uv</span><span class="p">).</span><span class="n">g</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><h3 id="保留alpha"><span class="me-2">保留Alpha</span><a href="#保留alpha" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我更喜欢计算luma，所以这将是默认值。我只有在必须保持alpha通道中的数据不变时才会切换到绿色，无论原因是什么。这取决于渲染图像的用途，因此必须为每个相机配置。为此向<code class="language-plaintext highlighter-rouge">CameraSettings</code>添加一个保留alpha的切换选项，默认情况下禁用。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="kt">bool</span> <span class="n">keepAlpha</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/keep-alpha.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/keep-alpha.png" alt="保留alpha切换" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">保留alpha切换</figcaption></figure><p>在<code class="language-plaintext highlighter-rouge">CameraRenderer.Render</code>中设置后处理效果栈时传递此切换。它与HDR切换相关，因为两个设置都处理纹理数据的性质，所以将其放在HDR切换参数之前。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">postFXStack</span><span class="p">.</span><span class="nf">Setup</span><span class="p">(</span>
    <span class="n">context</span><span class="p">,</span> <span class="n">camera</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">,</span> <span class="n">postFXSettings</span><span class="p">,</span> <span class="n">cameraSettings</span><span class="p">.</span><span class="n">keepAlpha</span><span class="p">,</span> <span class="n">useHDR</span><span class="p">,</span>
    <span class="n">colorLUTResolution</span><span class="p">,</span> <span class="n">cameraSettings</span><span class="p">.</span><span class="n">finalBlendMode</span><span class="p">,</span>
    <span class="n">bufferSettings</span><span class="p">.</span><span class="n">bicubicRescaling</span><span class="p">,</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">fxaa</span>
<span class="p">);</span>
</pre></table></code></div></div><p>然后在<code class="language-plaintext highlighter-rouge">PostFXStack</code>中跟踪切换。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">keepAlpha</span><span class="p">,</span> <span class="n">useHDR</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(</span>
    <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">Camera</span> <span class="n">camera</span><span class="p">,</span> <span class="n">Vector2Int</span> <span class="n">bufferSize</span><span class="p">,</span>
    <span class="n">PostFXSettings</span> <span class="n">settings</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepAlpha</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useHDR</span><span class="p">,</span> <span class="kt">int</span> <span class="n">colorLUTResolution</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">this</span><span class="p">.</span><span class="n">keepAlpha</span> <span class="p">=</span> <span class="n">keepAlpha</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">useHDR</span> <span class="p">=</span> <span class="n">useHDR</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在当启用FXAA时，<code class="language-plaintext highlighter-rouge">DoFinal</code>必须使用适当的pass。如果我必须保留alpha，那么我坚持使用当前的pass，否则我可以切换到在alpha通道中包含luma的颜色分级和FXAA pass。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nf">Draw</span><span class="p">(</span>
        <span class="n">sourceId</span><span class="p">,</span> <span class="n">colorGradingResultId</span><span class="p">,</span>
        <span class="n">keepAlpha</span> <span class="p">?</span> <span class="n">Pass</span><span class="p">.</span><span class="n">ApplyColorGrading</span> <span class="p">:</span> <span class="n">Pass</span><span class="p">.</span><span class="n">ApplyColorGradingWithLuma</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bufferSize</span><span class="p">.</span><span class="n">x</span> <span class="p">==</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">DrawFinal</span><span class="p">(</span>
            <span class="n">colorGradingResultId</span><span class="p">,</span> <span class="n">keepAlpha</span> <span class="p">?</span> <span class="n">Pass</span><span class="p">.</span><span class="n">FXAA</span> <span class="p">:</span> <span class="n">Pass</span><span class="p">.</span><span class="n">FXAAWithLuma</span>
        <span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">colorGradingResultId</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Draw</span><span class="p">(</span>
            <span class="n">colorGradingResultId</span><span class="p">,</span> <span class="n">finalResultId</span><span class="p">,</span>
            <span class="n">keepAlpha</span> <span class="p">?</span> <span class="n">Pass</span><span class="p">.</span><span class="n">FXAA</span> <span class="p">:</span> <span class="n">Pass</span><span class="p">.</span><span class="n">FXAAWithLuma</span>
        <span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">colorGradingResultId</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>你可以通过切换相机的Keep Alpha设置来检查这是否有效。当必须保留alpha时，我的RP被迫回退到依赖绿色而不是luma，这将产生更暗的灰度图像。目前保留alpha的唯一原因是当多个相机以透明方式堆叠时。</p><h2 id="子像素混合"><span class="me-2">子像素混合</span><a href="#子像素混合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>FXAA通过混合具有高对比度的相邻像素来工作。所以这不是图像的简单均匀模糊。首先，必须计算源像素周围的局部对比度——从最低到最高luma的范围。其次——如果有足够的对比度——必须根据对比度选择混合因子。第三，必须调查局部对比度梯度以确定混合方向。最后，在原始像素与其适当邻居之间执行混合。</p><h3 id="亮度邻域"><span class="me-2">亮度邻域</span><a href="#亮度邻域" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>局部对比度是通过采样源像素邻域中像素的luma来找到的。为了使这变得容易，向<code class="language-plaintext highlighter-rouge">GetLuma</code>添加两个可选的偏移参数，这样它可以沿U和V维度以像素为单位偏移。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetLuma</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="n">float</span> <span class="n">uOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">float</span> <span class="n">vOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uv</span> <span class="o">+=</span> <span class="kt">float2</span><span class="p">(</span><span class="n">uOffset</span><span class="p">,</span> <span class="n">vOffset</span><span class="p">)</span> <span class="o">*</span> <span class="n">GetSourceTexelSize</span><span class="p">().</span><span class="n">xy</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>除了源像素，我还必须采样其直接相邻的邻居，我将用罗盘方向来识别它们。所以我最终得到五个luma值：中间源像素加上北、东、南和西。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/neighborhood.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/neighborhood.png" alt="邻域采样" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">邻域采样</figcaption></figure><p>定义一个<code class="language-plaintext highlighter-rouge">LumaNeighborhood</code>结构来跟踪所有这些，并添加一个<code class="language-plaintext highlighter-rouge">GetLumaNeighborhood</code>函数来返回该邻域。在片段pass中调用它，最初仍然只返回中间luma值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">LumaNeighborhood</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">LumaNeighborhood</span> <span class="nf">GetLumaNeighborhood</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">;</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">e</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">luma</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float4</span> <span class="nf">FXAAPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">LumaNeighborhood</span> <span class="n">luma</span> <span class="o">=</span> <span class="n">GetLumaNeighborhood</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>要确定此邻域中的luma范围，我需要知道其最高和最低luma值是什么。计算它们并将它们也存储在邻域结构中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">LumaNeighborhood</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">highest</span><span class="p">,</span> <span class="n">lowest</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">LumaNeighborhood</span> <span class="nf">GetLumaNeighborhood</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">highest</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">luma</span><span class="p">.</span><span class="n">n</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">e</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">lowest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">luma</span><span class="p">.</span><span class="n">n</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">e</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">luma</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>你可以通过将它们用于片段函数的结果来观察这些值和其他值，但我不显示为此所需的临时代码更改。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/luma-middle.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/luma-middle.png" alt="Image" width="100%" height="auto" loading="lazy"></a></div></div></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/luma-highest.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/luma-highest.png" alt="邻域中的中间、最高和最低luma；放大显示" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/luma-lowest.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/luma-lowest.png" alt="邻域中的中间、最高和最低luma；放大显示" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">邻域中的中间、最高和最低luma；放大显示</figcaption></figure><p>现在还向邻域添加luma范围，它是最高luma减去最低luma。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">LumaNeighborhood</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">highest</span><span class="p">,</span> <span class="n">lowest</span><span class="p">,</span> <span class="n">range</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">LumaNeighborhood</span> <span class="nf">GetLumaNeighborhood</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">highest</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">luma</span><span class="p">.</span><span class="n">n</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">e</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">lowest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">luma</span><span class="p">.</span><span class="n">n</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">e</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span><span class="p">),</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">luma</span><span class="p">.</span><span class="n">highest</span> <span class="o">-</span> <span class="n">luma</span><span class="p">.</span><span class="n">lowest</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">luma</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/luma-range.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/luma-range.png" alt="邻域中的luma范围" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">邻域中的luma范围</figcaption></figure><p>请注意，luma范围在视觉上将图像中的边缘显示为线条。线条有两个像素宽，因为每个边缘的两侧都有一个像素。边缘的luma对比度越高，它显得越亮。</p><h3 id="固定阈值"><span class="me-2">固定阈值</span><a href="#固定阈值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我不需要混合每个像素，只需要混合那些邻域具有足够高对比度的像素。做出这种区分的最简单方法是引入对比度阈值。如果邻域luma范围没有达到此阈值，则像素不需要混合。我将其命名为固定阈值，因为还有一个相对阈值。</p><p>向我的<code class="language-plaintext highlighter-rouge">CameraBufferSettings.FXAA</code>结构添加一个滑块来配置固定阈值。原始FXAA算法也有此阈值，具有以下代码文档：</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// 修剪算法不处理暗区域。</span>
<span class="c1">//   0.0833 - 上限（默认，可见未过滤边缘的开始）</span>
<span class="c1">//   0.0625 - 高质量（更快）</span>
<span class="c1">//   0.0312 - 可见极限（更慢）</span>
</pre></table></code></div></div><p>虽然文档提到它修剪暗区域，但它基于对比度修剪，所以无论是亮还是暗。我将使用原始FXAA文档指示的相同范围。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">struct</span> <span class="nc">FXAA</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">enabled</span><span class="p">;</span>

    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.0312f</span><span class="p">,</span> <span class="m">0.0833f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">fixedThreshold</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让我们也使用与原始相同的默认值，我在<code class="language-plaintext highlighter-rouge">CustomRenderPipelineAsset</code>中设置它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">CameraBufferSettings</span> <span class="n">cameraBuffer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CameraBufferSettings</span> <span class="p">{</span>
    <span class="n">allowHDR</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>
    <span class="n">renderScale</span> <span class="p">=</span> <span class="m">1f</span><span class="p">,</span>
    <span class="n">fxaa</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CameraBufferSettings</span><span class="p">.</span><span class="n">FXAA</span> <span class="p">{</span>
        <span class="n">fixedThreshold</span> <span class="p">=</span> <span class="m">0.0833f</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/fixed-threshold-slider.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/fixed-threshold-slider.png" alt="固定阈值滑块" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">固定阈值滑块</figcaption></figure><p>接下来，向<code class="language-plaintext highlighter-rouge">PostFXStack</code>添加一个<code class="language-plaintext highlighter-rouge">_FXAAConfig</code>着色器属性标识符。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">fxaaConfigId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_FXAAConfig"</span><span class="p">);</span>
</pre></table></code></div></div><p>我将FXAA配置作为向量发送到GPU，最初只在其第一个分量中包含固定阈值。如果启用了FXAA，则在<code class="language-plaintext highlighter-rouge">DoFinal</code>中执行此操作。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span><span class="n">fxaaConfigId</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">fixedThreshold</span><span class="p">,</span> <span class="m">0f</span><span class="p">));</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
        <span class="n">colorGradingResultId</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
        <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span>
    <span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>向<code class="language-plaintext highlighter-rouge">FXAAPass</code>添加<code class="language-plaintext highlighter-rouge">_FXAAConfig</code>向量，以及一个<code class="language-plaintext highlighter-rouge">CanSkipFXAA</code>函数，它接受<code class="language-plaintext highlighter-rouge">LumaNeighborhood</code>并返回其范围是否小于固定阈值。然后如果我可以跳过FXAA，则在<code class="language-plaintext highlighter-rouge">FXAAPassFragment</code>中返回零。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="n">_FXAAConfig</span><span class="p">;</span>
<span class="p">...</span>

<span class="n">bool</span> <span class="nf">CanSkipFXAA</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">luma</span><span class="p">.</span><span class="n">range</span> <span class="o">&lt;</span> <span class="n">_FXAAConfig</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float4</span> <span class="nf">FXAAPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">LumaNeighborhood</span> <span class="n">luma</span> <span class="o">=</span> <span class="n">GetLumaNeighborhood</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CanSkipFXAA</span><span class="p">(</span><span class="n">luma</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">luma</span><span class="p">.</span><span class="n">range</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/fixed-threshold-min.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/fixed-threshold-min.png" alt="固定阈值设置为最小和最大" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/fixed-threshold-max.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/fixed-threshold-max.png" alt="固定阈值设置为最小和最大" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">固定阈值设置为最小和最大</figcaption></figure><p>FXAA跳过的像素现在是纯黑色。低对比度区域现在在视觉上被消除了。保留多少取决于阈值。</p><h3 id="相对阈值"><span class="me-2">相对阈值</span><a href="#相对阈值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>FXAA还有第二个阈值，它相对于每个邻域的最亮luma。邻域越亮，对比度必须越高才重要。原始FXAA代码对其值有以下文档：</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// 应用算法所需的最小局部对比度量。</span>
<span class="c1">//   0.333 - 太少（更快）</span>
<span class="c1">//   0.250 - 低质量</span>
<span class="c1">//   0.166 - 默认</span>
<span class="c1">//   0.125 - 高质量</span>
<span class="c1">//   0.063 - 过度（更慢）</span>
</pre></table></code></div></div><p>也向<code class="language-plaintext highlighter-rouge">CameraBufferSettings.FXAA</code>添加一个此相对阈值的滑块。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.063f</span><span class="p">,</span> <span class="m">0.333f</span><span class="p">)]</span>
<span class="k">public</span> <span class="kt">float</span> <span class="n">relativeThreshold</span><span class="p">;</span>
</pre></table></code></div></div><p>再次在<code class="language-plaintext highlighter-rouge">CustomRenderPipelineAsset</code>中使用与原始相同的默认值。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">fxaa</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CameraBufferSettings</span><span class="p">.</span><span class="n">FXAA</span> <span class="p">{</span>
    <span class="n">fixedThreshold</span> <span class="p">=</span> <span class="m">0.0833f</span><span class="p">,</span>
    <span class="n">relativeThreshold</span> <span class="p">=</span> <span class="m">0.166f</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在<code class="language-plaintext highlighter-rouge">PostFXStack.DoFinal</code>中将其放入FXAA配置向量的第二个分量中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span><span class="n">fxaaConfigId</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
    <span class="n">fxaa</span><span class="p">.</span><span class="n">fixedThreshold</span><span class="p">,</span> <span class="n">fxaa</span><span class="p">.</span><span class="n">relativeThreshold</span>
<span class="p">));</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/relative-threshold-slider.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/relative-threshold-slider.png" alt="两个阈值滑块" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">两个阈值滑块</figcaption></figure><p>要应用相对阈值而不是固定阈值，更改<code class="language-plaintext highlighter-rouge">FXAAPass</code>中的<code class="language-plaintext highlighter-rouge">CanSkipFXAA</code>，使其检查luma范围是否小于由最高luma缩放的第二个阈值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="nf">CanSkipFXAA</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">luma</span><span class="p">.</span><span class="n">range</span> <span class="o">&lt;</span> <span class="n">_FXAAConfig</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">highest</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/relative-threshold-min.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/relative-threshold-min.png" alt="相对阈值设置为最小和最大" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/relative-threshold-max.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/relative-threshold-max.png" alt="相对阈值设置为最小和最大" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">相对阈值设置为最小和最大</figcaption></figure><p>要应用两个阈值，比较最大的一个。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="nf">CanSkipFXAA</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">luma</span><span class="p">.</span><span class="n">range</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">_FXAAConfig</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">_FXAAConfig</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">highest</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/both-thresholds-min.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/both-thresholds-min.png" alt="两个阈值都设置为最小和最大" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/both-thresholds-max.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/both-thresholds-max.png" alt="两个阈值都设置为最小和最大" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">两个阈值都设置为最小和最大</figcaption></figure><p>从现在开始，我将始终使用最低阈值，以便影响最多的像素。</p><h3 id="混合因子"><span class="me-2">混合因子</span><a href="#混合因子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>提高边缘视觉质量的唯一正确方法是提高图像的分辨率。但是，FXAA只能使用原始图像数据。它能做的最好的事情是猜测缺失的子像素数据。它通过混合中间像素与其邻居之一来实现这一点。在最极端的情况下，这将是两个像素的简单平均值，但确切的混合因子是依赖于像素对比度及其邻居平均值的滤波器的结果。我将分步骤可视化这一点。</p><p>首先创建一个<code class="language-plaintext highlighter-rouge">GetSubpixelBlendFactor</code>函数，它返回邻域中四个邻居的平均值。将其用于<code class="language-plaintext highlighter-rouge">FXAAPassFragment</code>的结果。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetSubpixelBlendFactor</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">luma</span><span class="p">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">e</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">filter</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">filter</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float4</span> <span class="nf">FXAAPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">GetSubpixelBlendFactor</span><span class="p">(</span><span class="n">luma</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/filter-low-pass.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/filter-low-pass.png" alt="低通滤波器" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">低通滤波器</figcaption></figure><p>结果是应用于未跳过像素周围luma的低通滤波器。下一步是通过取邻居平均值与中间值之间的绝对差将其转换为高通滤波器。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">filter</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">filter</span> <span class="o">-</span> <span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
<span class="k">return</span> <span class="n">filter</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/filter-high-pass.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/filter-high-pass.png" alt="高通滤波器" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">高通滤波器</figcaption></figure><p>之后，我通过将滤波器除以luma范围来归一化它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">filter</span> <span class="o">=</span> <span class="n">filter</span> <span class="o">/</span> <span class="n">luma</span><span class="p">.</span><span class="n">range</span><span class="p">;</span>
<span class="k">return</span> <span class="n">filter</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/filter-normalized.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/filter-normalized.png" alt="归一化滤波器" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">归一化滤波器</figcaption></figure><p>此时，结果太强，无法用作混合因子。FXAA通过对其应用平方的smoothstep函数来修改滤波器。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/squared-smoothstep.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/squared-smoothstep.png" alt="线性和平方smoothstep" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">线性和平方smoothstep</figcaption></figure><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">filter</span> <span class="o">=</span> <span class="nb">smoothstep</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
<span class="k">return</span> <span class="n">filter</span> <span class="o">*</span> <span class="n">filter</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/filter-smoothed.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/filter-smoothed.png" alt="平滑滤波器" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">平滑滤波器</figcaption></figure><p>滤波器的质量可以通过将对角邻居也纳入其中来提高，所以将它们的luma值添加到邻域中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">LumaNeighborhood</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">ne</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">nw</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">highest</span><span class="p">,</span> <span class="n">lowest</span><span class="p">,</span> <span class="n">range</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">LumaNeighborhood</span> <span class="nf">GetLumaNeighborhood</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">;</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">e</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">ne</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">se</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">sw</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">luma</span><span class="p">.</span><span class="n">nw</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>因为对角邻居在空间上离中间更远，所以它们应该比直接邻居更不重要。我通过将直接邻居的权重加倍来将这一点纳入平均值。这就像一个3×3帐篷滤波器，没有中间。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/neighbor-weights.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/neighbor-weights.png" alt="邻居权重" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">邻居权重</figcaption></figure><p>我现在还必须饱和归一化滤波器，因为我存储的最高值没有考虑对角样本，因此在除法后我仍然可能有一个超过1的值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetSubpixelBlendFactor</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">filter</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">e</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="n">filter</span> <span class="o">+=</span> <span class="n">luma</span><span class="p">.</span><span class="n">ne</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">nw</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">se</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">sw</span><span class="p">;</span>
    <span class="n">filter</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">12</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">filter</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">filter</span> <span class="o">-</span> <span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
    <span class="n">filter</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">filter</span> <span class="o">/</span> <span class="n">luma</span><span class="p">.</span><span class="n">range</span><span class="p">);</span>
    <span class="n">filter</span> <span class="o">=</span> <span class="nb">smoothstep</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">filter</span> <span class="o">*</span> <span class="n">filter</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/filter-expanded.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/filter-expanded.png" alt="扩展滤波器和两个滤波器之间的绝对差" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/filter-difference.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/filter-difference.png" alt="扩展滤波器和两个滤波器之间的绝对差" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">扩展滤波器和两个滤波器之间的绝对差</figcaption></figure><h3 id="混合方向"><span class="me-2">混合方向</span><a href="#混合方向" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在确定混合因子之后，下一步是决定混合哪两个像素。FXAA将中间像素与其直接邻居之一混合，所以是北、东、南或西邻居。选择这四个像素中的哪一个取决于对比度梯度的方向。在最简单的情况下，中间像素接触两个对比区域之间的水平或垂直边缘。在水平边缘的情况下，它应该是北或南邻居，具体取决于中间是在边缘下方还是上方。否则，它应该是东或西邻居，具体取决于中间是在边缘的左侧还是右侧。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/blend-directions.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/blend-directions.png" alt="四个可能的混合方向" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">四个可能的混合方向</figcaption></figure><p>边缘通常不是完全水平或垂直的，但我通过比较邻域中的水平和垂直对比度来选择最佳近似值。如果有水平边缘，那么中间上方或下方将有强烈的垂直对比度。我通过将北和南相加，减去中间的两倍，并取其绝对值来衡量这一点。相同的逻辑适用于垂直边缘，但使用东和西。如果水平结果大于垂直结果，那么我将其声明为水平边缘。创建一个函数来指示这一点，给定一个邻域。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="nf">IsHorizontalEdge</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">horizontal</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span> <span class="o">-</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">vertical</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">e</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span> <span class="o">-</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">horizontal</span> <span class="o">&gt;=</span> <span class="n">vertical</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我可以通过包含对角邻居来提高边缘方向检测的质量。对于水平边缘，我对向东一步的三个像素和向西一步的三个像素执行相同的计算，对结果求和。同样，这些附加值离中间更远，所以我通过将中间对比度的权重加倍来将它们的相对重要性减半。相同的逻辑适用于垂直边缘对比度，但使用北和南偏移。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="nf">IsHorizontalEdge</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">horizontal</span> <span class="o">=</span>
        <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span> <span class="o">-</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">ne</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">se</span> <span class="o">-</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">nw</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">sw</span> <span class="o">-</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">vertical</span> <span class="o">=</span>
        <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">e</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span> <span class="o">-</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">ne</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">nw</span> <span class="o">-</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">se</span> <span class="o">+</span> <span class="n">luma</span><span class="p">.</span><span class="n">sw</span> <span class="o">-</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">horizontal</span> <span class="o">&gt;=</span> <span class="n">vertical</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在引入一个<code class="language-plaintext highlighter-rouge">FXAAEdge</code>结构来包含有关检测到的边缘的信息。此时只是它是否为水平的。创建一个<code class="language-plaintext highlighter-rouge">GetFXAAEdge</code>方法，给定一个邻域返回该信息。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">FXAAEdge</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">isHorizontal</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">FXAAEdge</span> <span class="nf">GetFXAAEdge</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">FXAAEdge</span> <span class="n">edge</span><span class="p">;</span>
    <span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span> <span class="o">=</span> <span class="n">IsHorizontalEdge</span><span class="p">(</span><span class="n">luma</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">edge</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">FXAAPassFragment</code>中获取边缘数据，然后使用它来可视化边缘的方向，例如使水平边缘为红色，垂直边缘为白色。此时我不关心混合因子。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">FXAAPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">LumaNeighborhood</span> <span class="n">luma</span> <span class="o">=</span> <span class="n">GetLumaNeighborhood</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CanSkipFXAA</span><span class="p">(</span><span class="n">luma</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">FXAAEdge</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">GetFXAAEdge</span><span class="p">(</span><span class="n">luma</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span> <span class="o">?</span> <span class="kt">float4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/edge-direction.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/edge-direction.png" alt="水平边缘为红色，垂直边缘为白色" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">水平边缘为红色，垂直边缘为白色</figcaption></figure><p>知道边缘方向告诉我在哪个维度中必须混合。如果是水平的，那么我将垂直跨越边缘混合，否则它是垂直的，我将水平跨越边缘混合。在UV空间中到下一个像素的距离取决于像素大小，这取决于混合方向。所以让我们向<code class="language-plaintext highlighter-rouge">FXAAEdge</code>添加像素步长的大小，并在<code class="language-plaintext highlighter-rouge">GetFXAAEdge</code>中初始化它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">FXAAEdge</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">isHorizontal</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">pixelStep</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">FXAAEdge</span> <span class="nf">GetFXAAEdge</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">FXAAEdge</span> <span class="n">edge</span><span class="p">;</span>
    <span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span> <span class="o">=</span> <span class="n">IsHorizontalEdge</span><span class="p">(</span><span class="n">luma</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span> <span class="o">=</span> <span class="n">GetSourceTexelSize</span><span class="p">().</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span> <span class="o">=</span> <span class="n">GetSourceTexelSize</span><span class="p">().</span><span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">edge</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接下来，我必须确定是否应该在正方向或负方向混合。我通过比较中间适当方向的每一侧的对比度——luma梯度——来做到这一点。如果我有水平边缘，那么北是正邻居，南是负邻居。如果我有垂直边缘，那么东是正邻居，西是负邻居。</p><p>如果正梯度小于负梯度，那么中间在边缘的右侧，我必须在负方向混合，我通过否定步长来做到这一点。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">lumaP</span><span class="p">,</span> <span class="n">lumaN</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span> <span class="o">=</span> <span class="n">GetSourceTexelSize</span><span class="p">().</span><span class="n">y</span><span class="p">;</span>
    <span class="n">lumaP</span> <span class="o">=</span> <span class="n">luma</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>
    <span class="n">lumaN</span> <span class="o">=</span> <span class="n">luma</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span> <span class="o">=</span> <span class="n">GetSourceTexelSize</span><span class="p">().</span><span class="n">x</span><span class="p">;</span>
    <span class="n">lumaP</span> <span class="o">=</span> <span class="n">luma</span><span class="p">.</span><span class="n">e</span><span class="p">;</span>
    <span class="n">lumaN</span> <span class="o">=</span> <span class="n">luma</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">float</span> <span class="n">gradientP</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lumaP</span> <span class="o">-</span> <span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
<span class="n">float</span> <span class="n">gradientN</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lumaN</span> <span class="o">-</span> <span class="n">luma</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">gradientP</span> <span class="o">&lt;</span> <span class="n">gradientN</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span> <span class="o">=</span> <span class="o">-</span><span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在我可以可视化混合方向，例如使正边缘为红色，负边缘为白色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="o">?</span> <span class="kt">float4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/edge-sign.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/edge-sign.png" alt="正边缘（左侧和底侧）为红色，负边缘为白色" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">正边缘（左侧和底侧）为红色，负边缘为白色</figcaption></figure><h3 id="最终混合"><span class="me-2">最终混合</span><a href="#最终混合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>此时我可以获得混合因子并知道向哪个方向混合。最终结果是通过使用混合因子在中间像素与其适当方向的邻居之间线性插值获得的。我可以通过简单地使用等于像素步长乘以混合因子的偏移来采样图像来做到这一点。此外，如果我跳过它，我必须返回原始像素。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">FXAAPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">LumaNeighborhood</span> <span class="n">luma</span> <span class="o">=</span> <span class="n">GetLumaNeighborhood</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CanSkipFXAA</span><span class="p">(</span><span class="n">luma</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">GetSource</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">FXAAEdge</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">GetFXAAEdge</span><span class="p">(</span><span class="n">luma</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">blendFactor</span> <span class="o">=</span> <span class="n">GetSubpixelBlendFactor</span><span class="p">(</span><span class="n">luma</span><span class="p">);</span>
    <span class="kt">float2</span> <span class="n">blendUV</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">blendUV</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">blendFactor</span> <span class="o">*</span> <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">blendUV</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">blendFactor</span> <span class="o">*</span> <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">GetSource</span><span class="p">(</span><span class="n">blendUV</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/blending-with.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/blending-with.png" alt="有无混合对比" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/blending-without.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/blending-without.png" alt="有无混合对比" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">有无混合对比</figcaption></figure><h3 id="混合强度"><span class="me-2">混合强度</span><a href="#混合强度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>FXAA不仅影响明显的高对比度边缘，它混合任何具有足够高对比度的东西，包括孤立像素。虽然这有助于减轻萤火虫，但它也会激进地模糊小细节，这通常是对FXAA的最大抱怨。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/circuitry-with.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/circuitry-with.png" alt="具有小细节的电路材料，有无子像素混合对比" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/circuitry-without.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/circuitry-without.png" alt="具有小细节的电路材料，有无子像素混合对比" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">具有小细节的电路材料，有无子像素混合对比</figcaption></figure><p>FXAA可以通过简单地缩小其混合因子来控制子像素混合的强度。以下是其原始文档：</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// 选择子像素锯齿消除的量。</span>
<span class="c1">// 这会影响锐度。</span>
<span class="c1">//   1.00 - 上限（更柔和）</span>
<span class="c1">//   0.75 - 默认过滤量</span>
<span class="c1">//   0.50 - 下限（更锐利，更少的子像素锯齿消除）</span>
<span class="c1">//   0.25 - 几乎关闭</span>
<span class="c1">//   0.00 - 完全关闭</span>
</pre></table></code></div></div><p>我也使其可配置，通过向<code class="language-plaintext highlighter-rouge">CameraSettings.FXAA</code>添加一个0-1滑块用于子像素混合。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">)]</span>
<span class="k">public</span> <span class="kt">float</span> <span class="n">subpixelBlending</span><span class="p">;</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">CustomRenderPipelineAsset</code>中给它与原始相同的75%强度默认值。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">fxaa</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CameraBufferSettings</span><span class="p">.</span><span class="n">FXAA</span> <span class="p">{</span>
    <span class="n">fixedThreshold</span> <span class="p">=</span> <span class="m">0.0833f</span><span class="p">,</span>
    <span class="n">relativeThreshold</span> <span class="p">=</span> <span class="m">0.166f</span><span class="p">,</span>
    <span class="n">subpixelBlending</span> <span class="p">=</span> <span class="m">0.75f</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在<code class="language-plaintext highlighter-rouge">PostFXStack.DoFinal</code>中将其添加到FXAA配置向量。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span><span class="n">fxaaConfigId</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
    <span class="n">fxaa</span><span class="p">.</span><span class="n">fixedThreshold</span><span class="p">,</span> <span class="n">fxaa</span><span class="p">.</span><span class="n">relativeThreshold</span><span class="p">,</span> <span class="n">fxaa</span><span class="p">.</span><span class="n">subpixelBlending</span>
<span class="p">));</span>
</pre></table></code></div></div><p>并在<code class="language-plaintext highlighter-rouge">GetSubpixelBlendFactor</code>的末尾将其应用于混合因子。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetSubpixelBlendFactor</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">filter</span> <span class="o">*</span> <span class="n">filter</span> <span class="o">*</span> <span class="n">_FXAAConfig</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/blending-slider.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/blending-slider.png" alt="Image" width="100%" height="auto" loading="lazy"></a></div></div></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/blending-075.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/blending-075.png" alt="子像素混合降低到75%" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">子像素混合降低到75%</figcaption></figure><h2 id="沿边缘混合"><span class="me-2">沿边缘混合</span><a href="#沿边缘混合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>因为像素混合因子是在3×3块内确定的，所以它只能平滑该尺度的特征。但边缘可以比这更长。像素可能最终位于倾斜边缘阶梯的长阶梯上的某个位置。虽然局部边缘是水平或垂直的，但真正的边缘通常处于另一个角度。如果我知道这个真实边缘，那么我可以更好地匹配相邻像素的混合因子，在整个长度上平滑边缘。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-subpixel-blending.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-subpixel-blending.png" alt="针垫几何体，全强度下有无子像素混合对比" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-without-blending.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-without-blending.png" alt="针垫几何体，全强度下有无子像素混合对比" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">针垫几何体，全强度下有无子像素混合对比</figcaption></figure><p>相比之下，在渲染缩放2时，我获得了更好的边缘，因为更高的分辨率可以在整个长度上稍微平滑阶梯。也可以在增加的渲染缩放之上应用FXAA以获得更平滑的结果，但目前这对边缘质量没有太大影响。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-render-scale-2.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-render-scale-2.png" alt="渲染缩放2，不使用FXAA" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">渲染缩放2，不使用FXAA</figcaption></figure><h3 id="边缘亮度"><span class="me-2">边缘亮度</span><a href="#边缘亮度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要弄清楚我正在处理什么类型的边缘，我必须跟踪更多信息。我知道3×3块的中间像素位于边缘的一侧，而至少一个其他像素位于相对侧。为了进一步识别边缘，我需要知道它的luma梯度。我已经在<code class="language-plaintext highlighter-rouge">GetFXAAEdge</code>中计算过了。我现在需要跟踪这个梯度和边缘另一侧的luma，所以将它们添加到边缘数据中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">FXAAEdge</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">isHorizontal</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">pixelStep</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">lumaGradient</span><span class="p">,</span> <span class="n">otherLuma</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">FXAAEdge</span> <span class="nf">GetFXAAEdge</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gradientP</span> <span class="o">&lt;</span> <span class="n">gradientN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span> <span class="o">=</span> <span class="o">-</span><span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span><span class="p">;</span>
        <span class="n">edge</span><span class="p">.</span><span class="n">lumaGradient</span> <span class="o">=</span> <span class="n">gradientN</span><span class="p">;</span>
        <span class="n">edge</span><span class="p">.</span><span class="n">otherLuma</span> <span class="o">=</span> <span class="n">lumaN</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">edge</span><span class="p">.</span><span class="n">lumaGradient</span> <span class="o">=</span> <span class="n">gradientP</span><span class="p">;</span>
        <span class="n">edge</span><span class="p">.</span><span class="n">otherLuma</span> <span class="o">=</span> <span class="n">lumaP</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">edge</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>引入一个<code class="language-plaintext highlighter-rouge">GetEdgeBlendFactor</code>函数，它返回边缘的单独混合因子。它需要luma邻域、边缘数据和像素UV坐标来做到这一点，所以为这些添加参数。我将从返回边缘的luma梯度开始。调整<code class="language-plaintext highlighter-rouge">FXAAPassFragment</code>，使其仅可视化新的边缘混合因子。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetEdgeBlendFactor</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">,</span> <span class="n">FXAAEdge</span> <span class="n">edge</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">edge</span><span class="p">.</span><span class="n">lumaGradient</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float4</span> <span class="nf">FXAAPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">LumaNeighborhood</span> <span class="n">luma</span> <span class="o">=</span> <span class="n">GetLumaNeighborhood</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CanSkipFXAA</span><span class="p">(</span><span class="n">luma</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">FXAAEdge</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">GetFXAAEdge</span><span class="p">(</span><span class="n">luma</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">blendFactor</span> <span class="o">=</span> <span class="n">GetEdgeBlendFactor</span> <span class="p">(</span><span class="n">luma</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">blendFactor</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">blendUV</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/edge-gradients.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/edge-gradients.png" alt="边缘梯度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">边缘梯度</figcaption></figure><h3 id="追踪边缘"><span class="me-2">追踪边缘</span><a href="#追踪边缘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我必须弄清楚像素沿水平或垂直边缘段的相对位置。唯一的方法是沿边缘在两个方向上走，直到我找到端点。这可以通过沿边缘采样像素对并检查它们是否仍然类似于我最初检测到的边缘来完成。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/searching.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/searching.png" alt="搜索端点" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">搜索端点</figcaption></figure><p>但我不需要每一步采样两个像素。我可以在它们之间采样一个样本，这给我它们luma的平均值。这将足以确定边缘的结束。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/search-sampling.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/search-sampling.png" alt="搜索（黄色）和邻域（黑色）样本" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">搜索（黄色）和邻域（黑色）样本</figcaption></figure><p>要执行此搜索，我在<code class="language-plaintext highlighter-rouge">GetEdgeBlendFactor</code>中必须做的第一件事是确定在边缘上采样的UV坐标。我必须将原始UV坐标向边缘偏移半个像素步长。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetEdgeBlendFactor</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">,</span> <span class="n">FXAAEdge</span> <span class="n">edge</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">edgeUV</span> <span class="o">=</span> <span class="n">uv</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">edgeUV</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">edgeUV</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">edge</span><span class="p">.</span><span class="n">lumaGradient</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>之后，沿边缘单步的UV偏移取决于其方向。它要么是水平的，要么是垂直的。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">float2</span> <span class="n">edgeUV</span> <span class="o">=</span> <span class="n">uv</span><span class="p">;</span>
<span class="kt">float2</span> <span class="n">uvStep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">edgeUV</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span><span class="p">;</span>
    <span class="n">uvStep</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">GetSourceTexelSize</span><span class="p">().</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">edgeUV</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">edge</span><span class="p">.</span><span class="n">pixelStep</span><span class="p">;</span>
    <span class="n">uvStep</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">GetSourceTexelSize</span><span class="p">().</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我要做的是确定采样的luma值与最初检测到的边缘上的luma平均值之间的对比度。如果这种对比度变得太大，那么我已经离开了边缘。FXAA使用边缘的luma梯度的四分之一作为此检查的阈值。所以我必须跟踪这个阈值和初始边缘luma平均值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">edgeLuma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">m</span> <span class="o">+</span> <span class="n">edge</span><span class="p">.</span><span class="n">otherLuma</span><span class="p">);</span>
<span class="n">float</span> <span class="n">gradientThreshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span> <span class="o">*</span> <span class="n">edge</span><span class="p">.</span><span class="n">lumaGradient</span><span class="p">;</span>
<span class="k">return</span> <span class="n">edge</span><span class="p">.</span><span class="n">lumaGradient</span><span class="p">;</span>
</pre></table></code></div></div><p>我从在正方向上走一步开始。确定正向偏移UV坐标，计算该偏移与原始边缘之间的luma梯度，并检查它是否等于或超过阈值。这告诉我是否在正方向的边缘末端。如果我直接可视化这个检查，那么我将只看到直接位于边缘端点旁边的那些像素。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">edgeLuma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">m</span> <span class="o">+</span> <span class="n">edge</span><span class="p">.</span><span class="n">otherLuma</span><span class="p">);</span>
<span class="n">float</span> <span class="n">gradientThreshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span> <span class="o">*</span> <span class="n">edge</span><span class="p">.</span><span class="n">lumaGradient</span><span class="p">;</span>

<span class="kt">float2</span> <span class="n">uvP</span> <span class="o">=</span> <span class="n">edgeUV</span> <span class="o">+</span> <span class="n">uvStep</span><span class="p">;</span>
<span class="n">float</span> <span class="n">lumaGradientP</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">GetLuma</span><span class="p">(</span><span class="n">uvP</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">atEndP</span> <span class="o">=</span> <span class="n">lumaGradientP</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>

<span class="k">return</span> <span class="n">atEndP</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/positive-end-one-step.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/positive-end-one-step.png" alt="正方向上到端点的一步" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">正方向上到端点的一步</figcaption></figure><p>要走完整条边缘，我必须在循环中重复此过程，只要我还没有到达末端。我还必须在某个点终止此过程，这样它就不会永远继续下去，比如在最多100步后，所以循环应该允许再进行99步。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">float2</span> <span class="n">uvP</span> <span class="o">=</span> <span class="n">edgeUV</span> <span class="o">+</span> <span class="n">uvStep</span><span class="p">;</span>
<span class="n">float</span> <span class="n">lumaGradientP</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">GetLuma</span><span class="p">(</span><span class="n">uvP</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">atEndP</span> <span class="o">=</span> <span class="n">lumaGradientP</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">99</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvP</span> <span class="o">+=</span> <span class="n">uvStep</span><span class="p">;</span>
    <span class="n">lumaGradientP</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">GetLuma</span><span class="p">(</span><span class="n">uvP</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">);</span>
    <span class="n">atEndP</span> <span class="o">=</span> <span class="n">lumaGradientP</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/positive-end-100-steps.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/positive-end-100-steps.png" alt="正方向上最多100步" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">正方向上最多100步</figcaption></figure><p>一旦我完成搜索，我可以通过从最终偏移分量中减去适当的原始UV坐标分量来找到UV空间中到正端的距离。然后我可以可视化距离，将其放大以使其更容易看到。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">distanceToEndP</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">distanceToEndP</span> <span class="o">=</span> <span class="n">uvP</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">uv</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">distanceToEndP</span> <span class="o">=</span> <span class="n">uvP</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">uv</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">distanceToEndP</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/positive-end-uv-distance.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/positive-end-uv-distance.png" alt="UV空间中到正端的距离，×10" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">UV空间中到正端的距离，×10</figcaption></figure><h3 id="负方向"><span class="me-2">负方向</span><a href="#负方向" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我还必须在负方向上做同样的事情，所以复制相关代码并适当调整它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">float2</span> <span class="n">uvP</span> <span class="o">=</span> <span class="n">edgeUV</span> <span class="o">+</span> <span class="n">uvStep</span><span class="p">;</span>
<span class="n">float</span> <span class="n">lumaGradientP</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">GetLuma</span><span class="p">(</span><span class="n">uvP</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">atEndP</span> <span class="o">=</span> <span class="n">lumaGradientP</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
<span class="n">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">99</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvP</span> <span class="o">+=</span> <span class="n">uvStep</span><span class="p">;</span>
    <span class="n">lumaGradientP</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">GetLuma</span><span class="p">(</span><span class="n">uvP</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">);</span>
    <span class="n">atEndP</span> <span class="o">=</span> <span class="n">lumaGradientP</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="n">uvN</span> <span class="o">=</span> <span class="n">edgeUV</span> <span class="o">-</span> <span class="n">uvStep</span><span class="p">;</span>
<span class="n">float</span> <span class="n">lumaGradientN</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">GetLuma</span><span class="p">(</span><span class="n">uvN</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">atEndN</span> <span class="o">=</span> <span class="n">lumaGradientN</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">99</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvN</span> <span class="o">-=</span> <span class="n">uvStep</span><span class="p">;</span>
    <span class="n">lumaGradientN</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">GetLuma</span><span class="p">(</span><span class="n">uvN</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">);</span>
    <span class="n">atEndN</span> <span class="o">=</span> <span class="n">lumaGradientN</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后确定到负端的距离，它的工作方式与到正端的相同，但取反。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">distanceToEndP</span><span class="p">,</span> <span class="n">distanceToEndN</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">isHorizontal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">distanceToEndP</span> <span class="o">=</span> <span class="n">uvP</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">uv</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">distanceToEndN</span> <span class="o">=</span> <span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">uvN</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">distanceToEndP</span> <span class="o">=</span> <span class="n">uvP</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">uv</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="n">distanceToEndN</span> <span class="o">=</span> <span class="n">uv</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">uvN</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我现在可以找到到边缘最近端的距离并可视化它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">distanceToNearestEnd</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">distanceToEndP</span> <span class="o">&lt;=</span> <span class="n">distanceToEndN</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">distanceToNearestEnd</span> <span class="o">=</span> <span class="n">distanceToEndP</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">distanceToNearestEnd</span> <span class="o">=</span> <span class="n">distanceToEndN</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">distanceToNearestEnd</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/distance-to-nearest-end.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/distance-to-nearest-end.png" alt="到最近端的距离" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">到最近端的距离</figcaption></figure><p>请注意，找到的距离在大多数情况下似乎是有意义的，但并非总是如此。因为FXAA是一个近似值，所以它有时会错误地猜测或错过边缘的末端。</p><h3 id="单侧混合"><span class="me-2">单侧混合</span><a href="#单侧混合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>此时我知道到边缘最近端点的距离，我可以用它来确定混合因子。但我只会在边缘向包含中间像素的区域倾斜的方向上这样做。这确保我只在边缘的一侧混合像素。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/searching-sign.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/searching-sign.png" alt="选择混合哪一侧" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">选择混合哪一侧</figcaption></figure><p>要确定方向，我需要知道搜索时获得的最后一个梯度的方向。为了使这成为可能，我将更改代码以跟踪luma增量而不是绝对梯度。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">float2</span> <span class="n">uvP</span> <span class="o">=</span> <span class="n">edgeUV</span> <span class="o">+</span> <span class="n">uvStep</span><span class="p">;</span>
<span class="n">float</span> <span class="n">lumaDeltaP</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uvP</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">;</span>
<span class="n">bool</span> <span class="n">atEndP</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lumaDeltaP</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
<span class="n">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">99</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvP</span> <span class="o">+=</span> <span class="n">uvStep</span><span class="p">;</span>
    <span class="n">lumaDeltaP</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uvP</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">;</span>
    <span class="n">atEndP</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lumaDeltaP</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float2</span> <span class="n">uvN</span> <span class="o">=</span> <span class="n">edgeUV</span> <span class="o">-</span> <span class="n">uvStep</span><span class="p">;</span>
<span class="n">float</span> <span class="n">lumaDeltaN</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uvN</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">;</span>
<span class="n">bool</span> <span class="n">atEndN</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lumaDeltaN</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">99</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvN</span> <span class="o">-=</span> <span class="n">uvStep</span><span class="p">;</span>
    <span class="n">lumaDeltaN</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uvN</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">;</span>
    <span class="n">atEndN</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lumaDeltaN</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在我可以确定最终增量的符号。我可以通过检查它是否大于或等于零来做到这一点。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">distanceToNearestEnd</span><span class="p">;</span>
<span class="n">bool</span> <span class="n">deltaSign</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">distanceToEndP</span> <span class="o">&lt;=</span> <span class="n">distanceToEndN</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">distanceToNearestEnd</span> <span class="o">=</span> <span class="n">distanceToEndP</span><span class="p">;</span>
    <span class="n">deltaSign</span> <span class="o">=</span> <span class="n">lumaDeltaP</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">distanceToNearestEnd</span> <span class="o">=</span> <span class="n">distanceToEndN</span><span class="p">;</span>
    <span class="n">deltaSign</span> <span class="o">=</span> <span class="n">lumaDeltaN</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果最终符号与原始边缘的符号匹配，那么我正在远离边缘，应该跳过混合，返回零。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">deltaSign</span> <span class="o">==</span> <span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">m</span> <span class="o">-</span> <span class="n">edgeLuma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">distanceToNearestEnd</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/single-side-only.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/single-side-only.png" alt="仅单侧的距离" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">仅单侧的距离</figcaption></figure><h3 id="最终混合因子"><span class="me-2">最终混合因子</span><a href="#最终混合因子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果我在边缘的正确一侧，那么我以0.5减去到边缘最近端点的相对距离的因子混合。这意味着我越接近端点混合越多，在边缘中间根本不会混合。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">deltaSign</span> <span class="o">==</span> <span class="p">(</span><span class="n">luma</span><span class="p">.</span><span class="n">m</span> <span class="o">-</span> <span class="n">edgeLuma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">-</span> <span class="n">distanceToNearestEnd</span> <span class="o">/</span> <span class="p">(</span><span class="n">distanceToEndP</span> <span class="o">+</span> <span class="n">distanceToEndN</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/edge-blend-factors.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/edge-blend-factors.png" alt="边缘混合因子" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">边缘混合因子</figcaption></figure><p>现在调整<code class="language-plaintext highlighter-rouge">FXAAPassFragment</code>，这样我可以看到边缘混合的结果。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">CanSkipFXAA</span><span class="p">(</span><span class="n">luma</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetSource</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">FXAAEdge</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">GetFXAAEdge</span><span class="p">(</span><span class="n">luma</span><span class="p">);</span>
<span class="n">float</span> <span class="n">blendFactor</span> <span class="o">=</span> <span class="n">GetEdgeBlendFactor</span> <span class="p">(</span><span class="n">luma</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">);</span>
<span class="c1">//return blendFactor;</span>
<span class="kt">float2</span> <span class="n">blendUV</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-edge-blending.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-edge-blending.png" alt="仅边缘混合和仅子像素混合，全强度" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-subpixel-blending.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-subpixel-blending.png" alt="仅边缘混合和仅子像素混合，全强度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">仅边缘混合和仅子像素混合，全强度</figcaption></figure><p>要应用边缘和子像素混合，我使用两者中最大的混合因子。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">blendFactor</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
    <span class="n">GetSubpixelBlendFactor</span><span class="p">(</span><span class="n">luma</span><span class="p">),</span> <span class="n">GetEdgeBlendFactor</span> <span class="p">(</span><span class="n">luma</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">)</span>
<span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/strongest-blend.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/strongest-blend.png" alt="边缘混合与0.75的子像素混合结合" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">边缘混合与0.75的子像素混合结合</figcaption></figure><h3 id="有限边缘搜索"><span class="me-2">有限边缘搜索</span><a href="#有限边缘搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果边缘几乎是水平或垂直的，搜索边缘的端点可能需要很长时间。在任一方向上最多100个样本太多，无法保证可接受的性能。所以我必须更早地终止搜索，但这将使FXAA无法检测更长的边缘。为了清楚地说明这一点，将<code class="language-plaintext highlighter-rouge">GetEdgeBlendFactor</code>中的搜索减少到任一方向上最多四个像素，所以在三步后终止循环。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">...</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/strongest-blend.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/strongest-blend.png" alt="最多100步和仅最多四步" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/up-to-four-steps.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/up-to-four-steps.png" alt="最多100步和仅最多四步" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">最多100步和仅最多四步</figcaption></figure><p>结果是所有距离超过四个像素的端点都被视为距离四个像素，这降低了FXAA的质量。如果循环在找到边缘之前终止，那么我低估了距离，因为末端至少还有一步的距离。因此，如果我没有找到它，我可以通过添加另一步来猜测真实距离来稍微改善结果。如果我在四步后没有找到它，那么我猜测真实距离是五。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atEndP</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvP</span> <span class="o">+=</span> <span class="n">uvStep</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atEndN</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvN</span> <span class="o">-=</span> <span class="n">uvStep</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/up-to-four-steps-plus-guess.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/up-to-four-steps-plus-guess.png" alt="最多四步带额外猜测" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">最多四步带额外猜测</figcaption></figure><h3 id="边缘质量"><span class="me-2">边缘质量</span><a href="#边缘质量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我允许边缘搜索走多远限制了结果的质量和所需时间。所以这是质量和性能之间的权衡，这意味着没有单一的最佳选择。为了使我的方法可配置，我将为额外边缘步数引入定义语句、额外步数的偏移列表，以及当我必须停止搜索时使用的最后边缘步数猜测的偏移。使用这些来创建边缘步长大小的静态常量数组，然后在<code class="language-plaintext highlighter-rouge">GetEdgeBlendFactor</code>中使用它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cp">#define EXTRA_EDGE_STEPS 3
#define EDGE_STEP_SIZES 1.0, 1.0, 1.0
#define LAST_EDGE_STEP_GUESS 1.0
</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">float</span> <span class="n">edgeStepSizes</span><span class="p">[</span><span class="n">EXTRA_EDGE_STEPS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">EDGE_STEP_SIZES</span> <span class="p">};</span>

<span class="n">float</span> <span class="nf">GetEdgeBlendFactor</span> <span class="p">(</span><span class="n">LumaNeighborhood</span> <span class="n">luma</span><span class="p">,</span> <span class="n">FXAAEdge</span> <span class="n">edge</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EXTRA_EDGE_STEPS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uvP</span> <span class="o">+=</span> <span class="n">uvStep</span> <span class="o">*</span> <span class="n">edgeStepSizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">lumaDeltaP</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uvP</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">;</span>
        <span class="n">atEndP</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lumaDeltaP</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atEndP</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uvP</span> <span class="o">+=</span> <span class="n">uvStep</span> <span class="o">*</span> <span class="n">LAST_EDGE_STEP_GUESS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EXTRA_EDGE_STEPS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uvN</span> <span class="o">-=</span> <span class="n">uvStep</span> <span class="o">*</span> <span class="n">edgeStepSizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">lumaDeltaN</span> <span class="o">=</span> <span class="n">GetLuma</span><span class="p">(</span><span class="n">uvN</span><span class="p">)</span> <span class="o">-</span> <span class="n">edgeLuma</span><span class="p">;</span>
        <span class="n">atEndN</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lumaDeltaN</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">gradientThreshold</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atEndN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uvN</span> <span class="o">-=</span> <span class="n">uvStep</span> <span class="o">*</span> <span class="n">LAST_EDGE_STEP_GUESS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我明确地为步长大小创建一个数组，这样我就可以改变它们。例如，原始FXAA算法包含多个质量预设，它们在步数和步长大小上都有所不同。质量预设22是一个快速低质量预设，有三个额外步骤。第一个额外步骤——在单个像素的初始偏移之后——偏移为1.5。这个额外的半像素偏移意味着我最终沿边缘采样四个像素的正方形的平均值，而不是单对。之后的两个步骤大小为2，每个再次采样四个像素的正方形而不是对。因此，它仅用四个样本覆盖最多七个像素的距离。如果它未能检测到末端，它猜测它至少还有八步远。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#define EXTRA_EDGE_STEPS 3
#define EDGE_STEP_SIZES 1.5, 2.0, 2.0
#define LAST_EDGE_STEP_GUESS 8.0
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/quality-low.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/quality-low.png" alt="低质量FXAA" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">低质量FXAA</figcaption></figure><p>使用这些设置，我获得低质量结果，但它们比我将额外步长大小固定为1时更能处理更长的边缘。缺点是边缘可能看起来有点抖动。这是由产生不太准确结果的更大步长引起的。</p><p>让我们使用当前配置用于低质量FXAA，仅在定义了<code class="language-plaintext highlighter-rouge">FXAA_QUALITY_LOW</code>时使用它，目前还没有定义。否则，我将使用对应于质量预设26的设置。它使用与预设22相同的方法，但有八个额外样本，除了最后一个步长为4以跳过一步以向前看得更远外，其他都是步长2。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#if defined(FXAA_QUALITY_LOW)
</span>    <span class="cp">#define EXTRA_EDGE_STEPS 3
</span>    <span class="cp">#define EDGE_STEP_SIZES 1.5, 2.0, 2.0
</span>    <span class="cp">#define LAST_EDGE_STEP_GUESS 8.0
#else
</span>    <span class="cp">#define EXTRA_EDGE_STEPS 8
</span>    <span class="cp">#define EDGE_STEP_SIZES 1.5, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 4.0
</span>    <span class="cp">#define LAST_EDGE_STEP_GUESS 8.0
#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/quality-medium.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/quality-medium.png" alt="中等质量FXAA" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">中等质量FXAA</figcaption></figure><p>让我们将此配置用于中等质量——当定义了<code class="language-plaintext highlighter-rouge">FXAA_QUALITY_MEDIUM</code>时——并添加与预设39匹配的最终默认配置。这是一个高质量配置，有十个额外步骤，仅在四个额外对采样后才切换到正方形块采样，再次为最后一步跳过并猜测为8。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#if defined(FXAA_QUALITY_LOW)
</span>    <span class="cp">#define EXTRA_EDGE_STEPS 3
</span>    <span class="cp">#define EDGE_STEP_SIZES 1.5, 2.0, 2.0
</span>    <span class="cp">#define LAST_EDGE_STEP_GUESS 8.0
#elif defined(FXAA_QUALITY_MEDIUM)
</span>    <span class="cp">#define EXTRA_EDGE_STEPS 8
</span>    <span class="cp">#define EDGE_STEP_SIZES 1.5, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 4.0
</span>    <span class="cp">#define LAST_EDGE_STEP_GUESS 8.0
#else
</span>    <span class="cp">#define EXTRA_EDGE_STEPS 10
</span>    <span class="cp">#define EDGE_STEP_SIZES 1.0, 1.0, 1.0, 1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 4.0
</span>    <span class="cp">#define LAST_EDGE_STEP_GUESS 8.0
#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/quality-high.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/quality-high.png" alt="高质量FXAA" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">高质量FXAA</figcaption></figure><p>要允许选择质量级别，向<code class="language-plaintext highlighter-rouge">PostFXStack</code>着色器的两个FXAA pass添加multi-compile指令。我只需要低质量和中等质量版本的关键字，对高质量版本使用没有关键字的默认值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#pragma fragment FXAAPassFragment
#pragma multi_compile _ FXAA_QUALITY_MEDIUM FXAA_QUALITY_LOW
</span></pre></table></code></div></div><p>向<code class="language-plaintext highlighter-rouge">CameraBufferSettings.FXAA</code>添加相应的质量配置选项。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">enum</span> <span class="n">Quality</span> <span class="p">{</span> <span class="n">Low</span><span class="p">,</span> <span class="n">Medium</span><span class="p">,</span> <span class="n">High</span> <span class="p">}</span>

<span class="k">public</span> <span class="n">Quality</span> <span class="n">quality</span><span class="p">;</span>
</pre></table></code></div></div><p>然后在<code class="language-plaintext highlighter-rouge">PostFXStack</code>中启用或禁用适当的关键字。在新的<code class="language-plaintext highlighter-rouge">ConfigureFXAA</code>方法中执行此操作，并将设置配置向量的代码也移到那里。然后在<code class="language-plaintext highlighter-rouge">DoFinal</code>中的适当时刻调用它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">string</span>
    <span class="n">fxaaQualityLowKeyword</span> <span class="p">=</span> <span class="s">"FXAA_QUALITY_LOW"</span><span class="p">,</span>
    <span class="n">fxaaQualityMediumKeyword</span> <span class="p">=</span> <span class="s">"FXAA_QUALITY_MEDIUM"</span><span class="p">;</span>
<span class="p">...</span>

<span class="k">void</span> <span class="nf">ConfigureFXAA</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">quality</span> <span class="p">==</span> <span class="n">CameraBufferSettings</span><span class="p">.</span><span class="n">FXAA</span><span class="p">.</span><span class="n">Quality</span><span class="p">.</span><span class="n">Low</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">EnableShaderKeyword</span><span class="p">(</span><span class="n">fxaaQualityLowKeyword</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">DisableShaderKeyword</span><span class="p">(</span><span class="n">fxaaQualityMediumKeyword</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">quality</span> <span class="p">==</span> <span class="n">CameraBufferSettings</span><span class="p">.</span><span class="n">FXAA</span><span class="p">.</span><span class="n">Quality</span><span class="p">.</span><span class="n">Medium</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">DisableShaderKeyword</span><span class="p">(</span><span class="n">fxaaQualityLowKeyword</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">EnableShaderKeyword</span><span class="p">(</span><span class="n">fxaaQualityMediumKeyword</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">DisableShaderKeyword</span><span class="p">(</span><span class="n">fxaaQualityLowKeyword</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">DisableShaderKeyword</span><span class="p">(</span><span class="n">fxaaQualityMediumKeyword</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span><span class="n">fxaaConfigId</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
        <span class="n">fxaa</span><span class="p">.</span><span class="n">fixedThreshold</span><span class="p">,</span> <span class="n">fxaa</span><span class="p">.</span><span class="n">relativeThreshold</span><span class="p">,</span> <span class="n">fxaa</span><span class="p">.</span><span class="n">subpixelBlending</span>
    <span class="p">));</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">DoFinal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sourceId</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fxaa</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">ConfigureFXAA</span><span class="p">();</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
            <span class="n">colorGradingResultId</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
            <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span>
        <span class="p">);</span>
        <span class="nf">Draw</span><span class="p">(</span>
            <span class="n">sourceId</span><span class="p">,</span> <span class="n">colorGradingResultId</span><span class="p">,</span>
            <span class="n">keepAlpha</span> <span class="p">?</span> <span class="n">Pass</span><span class="p">.</span><span class="n">ApplyColorGrading</span> <span class="p">:</span> <span class="n">Pass</span><span class="p">.</span><span class="n">ApplyColorGradingWithLuma</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/fxaa-quality-setting.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/fxaa-quality-setting.png" alt="FXAA设置为高质量" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">FXAA设置为高质量</figcaption></figure><p>这些质量预设只是示例，你可以根据自己的喜好配置它们。也可以将FXAA与渲染缩放加倍结合以获得更好的结果。请记住，FXAA在调整后的渲染缩放下运行，所以这相当昂贵。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-2-with-fxaa.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-2-with-fxaa.png" alt="渲染缩放2，有无高质量FXAA对比" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-render-scale-2.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/pincushion-render-scale-2.png" alt="渲染缩放2，有无高质量FXAA对比" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">渲染缩放2，有无高质量FXAA对比</figcaption></figure><p>你不需要一路加倍。例如，你可以将FXAA与渲染缩放4/3结合。这将使像素数量增加1.78倍而不是四倍。这是Timothy Lottes在他的SIGGRAPH2011演讲《实时抗锯齿的过滤方法》中建议的。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-4-3-with-fxaa.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-4-3-with-fxaa.png" alt="双线性渲染缩放1.333333，有无高质量FXAA对比" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-4-3.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-4-3.png" alt="双线性渲染缩放1.333333，有无高质量FXAA对比" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">双线性渲染缩放1.333333，有无高质量FXAA对比</figcaption></figure><p>这可以通过使用双三次重新缩放进一步平滑。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-4-3-with-fxaa-bicubic.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-4-3-with-fxaa-bicubic.png" alt="双三次渲染缩放1.333333，有无高质量FXAA对比" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-4-3-bicubic.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-4-3-bicubic.png" alt="双三次渲染缩放1.333333，有无高质量FXAA对比" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">双三次渲染缩放1.333333，有无高质量FXAA对比</figcaption></figure><p>也可以使用FXAA来改善降低渲染缩放的结果。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-05-with-fxaa.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-05-with-fxaa.png" alt="双三次渲染缩放0.5，有无高质量FXAA对比" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-05-without-fxaa.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp17fxaa/render-scale-05-without-fxaa.png" alt="双三次渲染缩放0.5，有无高质量FXAA对比" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">双三次渲染缩放0.5，有无高质量FXAA对比</figcaption></figure><h3 id="展开循环"><span class="me-2">展开循环</span><a href="#展开循环" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为我的循环有保证的最大迭代次数，所以可以展开它们，这意味着我用一系列条件代码块替换它们。我不必显式这样做，我可以让着色器编译器通过在循环之前放置<code class="language-plaintext highlighter-rouge">UNITY_UNROLL</code>来做到这一点。这为它们添加了展开属性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">UNITY_UNROLL</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EXTRA_EDGE_STEPS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">...</span>
<span class="n">UNITY_UNROLL</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EXTRA_EDGE_STEPS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atEndN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></table></code></div></div><p>结果证明这始终稍微提高了性能，预计不会超过1 FPS的增益。虽然这不多，但它是免费的。</p><p>原始FXAA算法还组合了两个循环，在锁步中在两个方向上搜索。每次迭代，只有尚未完成的方向才会前进并再次采样。这在某些情况下可能更快，但在我的情况下，两个单独的循环比单个循环表现稍好。一如既往，如果你想要绝对最佳性能，请自己测试，每个项目、每个目标平台。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">自定义渲染管线</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/srp/" class="post-tag no-text-decoration" >SRP</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:FXAA%E6%8A%97%E9%94%AF%E9%BD%BF%20(%E7%BF%BB%E8%AF%91%E5%8D%81%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Ffxaa%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:FXAA%E6%8A%97%E9%94%AF%E9%BD%BF%20(%E7%BF%BB%E8%AF%91%E5%8D%81%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Ffxaa%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Ffxaa%2F&text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:FXAA%E6%8A%97%E9%94%AF%E9%BD%BF%20(%E7%BF%BB%E8%AF%91%E5%8D%81%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/particles/">粒子系统：颜色和深度纹理</a><li class="text-truncate lh-lg"> <a href="/posts/color-grading/">Unity自定义渲染管线13：色彩分级</a><li class="text-truncate lh-lg"> <a href="/posts/post-processing/">自定义渲染管线:后处理 (翻译十一)</a><li class="text-truncate lh-lg"> <a href="/posts/hdr/">自定义渲染管线:HDR (翻译十二)</a><li class="text-truncate lh-lg"> <a href="/posts/point-spot-light-shadow/">自定义渲染管线:点光源与聚光灯阴影 (翻译十)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/rendering-scale/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1609257600" data-df="ll" > Dec 30, 2020 </time><h4 class="pt-0 my-2">自定义管线:渲染缩放 (翻译十六)</h4><div class="text-muted"><p>探索Unity渲染管线中的分辨率缩放技术，包括动态调整渲染分辨率、超采样抗锯齿和性能优化策略。</p></div></div></a></article><article class="col"> <a href="/posts/particles/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1606406400" data-df="ll" > Nov 27, 2020 </time><h4 class="pt-0 my-2">粒子系统：颜色和深度纹理</h4><div class="text-muted"><p>深入探索Unity粒子系统的渲染技术，包括翻书动画、近距离淡入淡出、软粒子和扭曲效果的实现原理与实践。</p></div></div></a></article><article class="col"> <a href="/posts/multiple-camera/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1603641600" data-df="ll" > Oct 26, 2020 </time><h4 class="pt-0 my-2">自定义渲染管线:多摄像机渲染 (翻译十四)</h4><div class="text-muted"><p>深入探讨Unity自定义渲染管线中的多摄像机渲染技术，包括分屏渲染、摄像机混合以及渲染层遮罩的实现。</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/rendering-scale/" class="btn btn-outline-primary" aria-label="Older" ><p>自定义管线:渲染缩放 (翻译十六)</p></a> <a href="/posts/claude-code-guide/" class="btn btn-outline-primary" aria-label="Newer" ><p>Claude Code学习总结：目录导航</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
