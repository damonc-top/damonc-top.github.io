<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="自定义管线:方向光 (翻译三)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="增加对多个方向光着色（shading）的支持。 已升级至 2022.3.62f2" /><meta property="og:description" content="增加对多个方向光着色（shading）的支持。 已升级至 2022.3.62f2" /><link rel="canonical" href="www.damonc.top/posts/directional-lights/" /><meta property="og:url" content="www.damonc.top/posts/directional-lights/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/SRP/srp3/tutorial-image.jpg" /><meta property="og:image:alt" content="由四个灯光照明的各种球体" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-11-30T00:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/SRP/srp3/tutorial-image.jpg" /><meta name="twitter:image:alt" content="由四个灯光照明的各种球体" /><meta property="twitter:title" content="自定义管线:方向光 (翻译三)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2019-11-30T00:00:00+08:00","datePublished":"2019-11-30T00:00:00+08:00","description":"增加对多个方向光着色（shading）的支持。 已升级至 2022.3.62f2","headline":"自定义管线:方向光 (翻译三)","image":{"lqip":"data:image/webp;base64,UklGRmQAAABXRUJQVlA4IFgAAADQAwCdASoUAAoAP3Ggx1k0q6gjsAgCkC4JYwAATLX8J+PVSH6kc5AA/txuJyqnw1daoXahg+8iOYDpiOrEFmy+c6lfCKIm4ZnP6f7v22fU/H1KYCUOQAAA","alt":"由四个灯光照明的各种球体","url":"https://img.damonc.top/posts/SRP/srp3/tutorial-image.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/directional-lights/"},"url":"www.damonc.top/posts/directional-lights/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>自定义管线:方向光 (翻译三) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘摊手</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>自定义管线:方向光 (翻译三)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>自定义管线:方向光 (翻译三)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1575043200" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Nov 30, 2019 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/SRP/srp3/tutorial-image.jpg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/SRP/srp3/tutorial-image.jpg" alt="由四个灯光照明的各种球体" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRmQAAABXRUJQVlA4IFgAAADQAwCdASoUAAoAP3Ggx1k0q6gjsAgCkC4JYwAATLX8J+PVSH6kc5AA/txuJyqnw1daoXahg+8iOYDpiOrEFmy+c6lfCKIm4ZnP6f7v22fU/H1KYCUOQAAA"></a><figcaption class="text-center pt-2 pb-2">由四个灯光照明的各种球体</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/directional-lights/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="12332 words" > <em>68 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">自定义管线:方向光 (翻译三)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">自定义管线:方向光 (翻译三)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>增加对多个方向光着色（shading）的支持。<li>已升级至 2022.3.62f2</ul><hr /><h2 id="1-光照-lighting"><span class="me-2">1 光照 (Lighting)</span><a href="#1-光照-lighting" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>如果我们想创建一个更真实的场景，那么我们就必须模拟光如何与表面相互作用。这需要一个比我们目前拥有的不发光（unlit）着色器更复杂的着色器。</p><h3 id="11-受光着色器-lit-shader"><span class="me-2">1.1 受光着色器 (Lit Shader)</span><a href="#11-受光着色器-lit-shader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>复制 <code class="language-plaintext highlighter-rouge">UnlitPass.hlsl</code> 文件并将其重命名为 <code class="language-plaintext highlighter-rouge">LitPass.hlsl</code>。调整重命名（include guard define）以及顶点和片元函数名称以匹配。我们稍后会添加光照计算。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_LIT_PASS_INCLUDED
#define CUSTOM_LIT_PASS_INCLUDED
</span>
<span class="err">…</span>

<span class="n">Varyings</span> <span class="nf">LitPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>

<span class="kt">float4</span> <span class="nf">LitPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>同时复制 <code class="language-plaintext highlighter-rouge">Unlit</code> 着色器并将其重命名为 <code class="language-plaintext highlighter-rouge">Lit</code>。更改其菜单名称、它包含的文件以及它使用的函数。让我们也将默认颜色更改为灰色，因为在光照充足的场景中，全白表面可能会显得非常亮。通用管线（URP）默认也使用灰色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Custom RP/Lit"</span> <span class="p">{</span>
    <span class="n">Properties</span> <span class="p">{</span>
        <span class="n">_BaseMap</span><span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
        <span class="n">_BaseColor</span><span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
        <span class="err">…</span>
    <span class="p">}</span>
    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="n">Pass</span> <span class="p">{</span>
            <span class="err">…</span>
            <span class="cp">#pragma vertex LitPassVertex
</span>            <span class="cp">#pragma fragment LitPassFragment
</span>            <span class="cp">#include</span> <span class="cpf">"LitPass.hlsl"</span><span class="cp">
</span>            <span class="n">ENDHLSL</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们将使用自定义光照方法，我们将通过将着色器的 LightMode 设置为 <code class="language-plaintext highlighter-rouge">CustomLit</code> 来指示这一点。在 Pass 中添加一个 <code class="language-plaintext highlighter-rouge">Tags</code> 块，包含 <code class="language-plaintext highlighter-rouge">"LightMode" = "CustomLit"</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>        <span class="n">Pass</span> <span class="p">{</span>
            <span class="n">Tags</span> <span class="p">{</span>
                <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"CustomLit"</span>
            <span class="p">}</span>
            <span class="err">…</span>
        <span class="p">}</span>
</pre></table></code></div></div><p>为了渲染使用此 Pass 的对象，我们必须在 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 中包含它。首先为其添加一个着色器标签标识符。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="k">static</span> <span class="n">ShaderTagId</span>
        <span class="n">unlitShaderTagId</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ShaderTagId</span><span class="p">(</span><span class="s">"SRPDefaultUnlit"</span><span class="p">),</span>
        <span class="n">litShaderTagId</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ShaderTagId</span><span class="p">(</span><span class="s">"CustomLit"</span><span class="p">);</span>
</pre></table></code></div></div><p>然后将其添加到 <code class="language-plaintext highlighter-rouge">DrawVisibleGeometry</code> 中要渲染的 Pass 中，就像我们在 <code class="language-plaintext highlighter-rouge">DrawUnsupportedShaders</code> 中所做的一样。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>        <span class="kt">var</span> <span class="n">drawingSettings</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DrawingSettings</span><span class="p">(</span>
            <span class="n">unlitShaderTagId</span><span class="p">,</span> <span class="n">sortingSettings</span>
        <span class="p">)</span> <span class="p">{</span>
            <span class="n">enableDynamicBatching</span> <span class="p">=</span> <span class="n">useDynamicBatching</span><span class="p">,</span>
            <span class="n">enableInstancing</span> <span class="p">=</span> <span class="n">useGPUInstancing</span>
        <span class="p">};</span>
        <span class="n">drawingSettings</span><span class="p">.</span><span class="nf">SetShaderPassName</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">litShaderTagId</span><span class="p">);</span>
</pre></table></code></div></div><p>现在我们可以创建一个新的不透明材质，尽管此时它的结果与不发光材质相同。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/opaque-material.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/opaque-material.png" alt="默认不透明材质" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">默认不透明材质</figcaption></figure><h3 id="12-法线向量-normal-vectors"><span class="me-2">1.2 法线向量 (Normal Vectors)</span><a href="#12-法线向量-normal-vectors" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>物体的受光程度取决于多种因素，包括光线与表面之间的相对角度。为了了解表面的朝向，我们需要访问表面法线（surface normal），这是一个垂直于表面的单位长度向量。该向量是顶点数据的一部分，在对象空间中定义，就像位置一样。因此，在 <code class="language-plaintext highlighter-rouge">LitPass</code> 的 <code class="language-plaintext highlighter-rouge">Attributes</code> 中添加它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">normalOS</span> <span class="o">:</span> <span class="nb">NORMAL</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</pre></table></code></div></div><p>由于需要逐像素级计算的，所以我们也必须在 <code class="language-plaintext highlighter-rouge">Varyings</code> 中添加法线向量。我们将在世界空间中执行计算，因此将其命名为 <code class="language-plaintext highlighter-rouge">normalWS</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">positionCS</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">normalWS</span> <span class="o">:</span> <span class="n">VAR_NORMAL</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="n">VAR_BASE_UV</span><span class="p">;</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</pre></table></code></div></div><p>我们可以使用 <code class="language-plaintext highlighter-rouge">SpaceTransforms</code> 中的 <code class="language-plaintext highlighter-rouge">TransformObjectToWorldNormal</code> 在 <code class="language-plaintext highlighter-rouge">LitPassVertex</code> 中将法线转换为世界空间。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="n">output</span><span class="p">.</span><span class="n">positionWS</span> <span class="o">=</span> <span class="n">TransformObjectToWorld</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span> <span class="o">=</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">positionWS</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">normalWS</span> <span class="o">=</span> <span class="n">TransformObjectToWorldNormal</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">normalOS</span><span class="p">);</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>TransformObjectToWorldNormal 是如何工作的？</h3><div><p>当你检查代码时，你会看到它根据是否定义了 <code class="language-plaintext highlighter-rouge">UNITY_ASSUME_UNIFORM_SCALING</code> 宏的分支代码。 1.当定义了 <code class="language-plaintext highlighter-rouge">UNITY_ASSUME_UNIFORM_SCALING</code> 时，它会调用 <code class="language-plaintext highlighter-rouge">TransformObjectToWorldDir</code>，它的作用与 <code class="language-plaintext highlighter-rouge">TransformObjectToWorld</code> 相同，只是它忽略了平移部分，因为我们处理的是方向向量而不是位置。但向量也会被均匀缩放，因此稍后应该对其进行归一化。 2.在另一种情况下，不假设均匀缩放。这更复杂，因为当对象受到非均匀缩放变形时，法线向量必须反向缩放以匹配新的表面朝向。这需要乘以转置的 <code class="language-plaintext highlighter-rouge">UNITY_MATRIX_I_M</code> 矩阵，再加上归一化。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/scaling-incorrect.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/scaling-incorrect.png" alt="不正确和正确的法线转换" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/scaling-correct.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/scaling-correct.png" alt="不正确和正确的法线转换" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">不正确和正确的法线转换</figcaption></figure><blockquote class="prompt-info"><p>使用 <code class="language-plaintext highlighter-rouge">UNITY_ASSUME_UNIFORM_SCALING</code> 是一种微小的优化，你可以通过自己定义它来启用。但是，当使用 GPU 实例化时，它会产生更大的差异，因为那样就不必将 <code class="language-plaintext highlighter-rouge">UNITY_MATRIX_I_M</code> 矩阵数组发送到 GPU。在不需要时避免这样做是值得的。你可以通过在着色器中添加 <code class="language-plaintext highlighter-rouge">#pragma instancing_options assumeuniformscaling</code> 指令来启用它，但只有在你专门渲染具有均匀缩放的对象时才这样做。</p></blockquote></div></aside><p>为了验证我们是否在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 中获得了正确的法线向量，我们可以将其用作颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">base</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">normalWS</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">base</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/world-normals.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/world-normals.png" alt="世界空间法线向量" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">世界空间法线向量</figcaption></figure><p>负值无法可视化，因此它们被约束到0。</p><h3 id="13-插值法线-interpolated-normals"><span class="me-2">1.3 插值法线 (Interpolated Normals)</span><a href="#13-插值法线-interpolated-normals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然法线向量在顶点程序中是单位长度的，但跨三角形的线性插值会影响它们的长度。我们可以通过渲染 1 与向量长度之间的差异（放大十倍使其更明显）来可视化误差。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="n">base</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">normalWS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/interpolated-normal-error.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/interpolated-normal-error.png" alt="插值法线误差，夸张处理" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">插值法线误差，夸张处理</figcaption></figure><p>我们可以通过在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 中归一化法线向量来平滑插值畸变。在只看法线向量时，差异并不明显，但在用于光照时会更加明显。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="n">base</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">normalWS</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/normalization-after-interpolation.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/normalization-after-interpolation.png" alt="插值后的归一化" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">插值后的归一化</figcaption></figure><h3 id="14-表面属性-surface-properties"><span class="me-2">1.4 表面属性 (Surface Properties)</span><a href="#14-表面属性-surface-properties" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>着色器中的光照是关于模拟光线照射到表面的相互作用，这意味着我们必须跟踪表面的属性。现在我们有一个法线向量和一个基础颜色。我们可以将后者分为两部分：RGB 颜色和 alpha 值。我们将在几个地方使用这些数据，所以让我们定义一个方便的 <code class="language-plaintext highlighter-rouge">Surface</code> 结构体来包含所有相关数据。将其放在 <code class="language-plaintext highlighter-rouge">ShaderLibrary</code> 文件夹中一个单独的 <code class="language-plaintext highlighter-rouge">Surface.hlsl</code> 文件中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_SURFACE_INCLUDED
#define CUSTOM_SURFACE_INCLUDED
</span>
<span class="k">struct</span> <span class="n">Surface</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">normal</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">alpha</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif
</span></pre></table></code></div></div><aside class="collapsible-aside"><h3>我们不应该将法线定义为 normalWS 吗？</h3><div><p>可以，但表面并不关心法线是在什么空间定义的。光照计算可以在任何适当的 3D 空间中执行。所以我们让空间未定义。在填充数据时，我们只需要在任何地方使用相同的空间即可。我们将使用世界空间，但稍后我们可以切换到另一个空间，一切仍然可以正常工作。</p></div></aside><p>将它包含在 <code class="language-plaintext highlighter-rouge">LitPass</code> 中，位于 <code class="language-plaintext highlighter-rouge">Common</code> 之后。这样我们可以保持 <code class="language-plaintext highlighter-rouge">LitPass</code> 简洁。从现在开始，我们将把专业代码放在它自己的 HLSL 文件中，以便更容易找到相关功能。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Common.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Surface.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 中定义一个 <code class="language-plaintext highlighter-rouge">surface</code> 变量并填充它。然后最终结果变成表面的颜色和 alpha。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>    <span class="n">Surface</span> <span class="n">surface</span><span class="p">;</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">normalWS</span><span class="p">);</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">base</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">base</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>

    <span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">color</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="n">alpha</span><span class="p">);</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>这不是低效的代码吗？</h3><div><p>没关系，因为着色器编译器会生成高度优化的程序，完全重写我们的代码。结构体纯粹是为了我们的方便。你可以通过着色器检查器中的 Compile and show code 按钮检查编译器的工作。</p></div></aside><h3 id="15-计算光照-calculating-lighting"><span class="me-2">1.5 计算光照 (Calculating Lighting)</span><a href="#15-计算光照-calculating-lighting" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了计算实际光照，我们将创建一个具有 <code class="language-plaintext highlighter-rouge">Surface</code> 参数的 <code class="language-plaintext highlighter-rouge">GetLighting</code> 函数。最初让它返回表面法线的 Y 分量。由于这是光照功能，我们将把它放在 <code class="language-plaintext highlighter-rouge">ShaderLibrary</code> 文件夹中一个单独的 <code class="language-plaintext highlighter-rouge">Lighting.hlsl</code> 文件中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_LIGHTING_INCLUDED
#define CUSTOM_LIGHTING_INCLUDED
</span>
<span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">surface</span><span class="p">.</span><span class="n">normal</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>将它包含在 <code class="language-plaintext highlighter-rouge">LitPass</code> 中，在包含 <code class="language-plaintext highlighter-rouge">Surface</code> 之后，因为 <code class="language-plaintext highlighter-rouge">Lighting</code> 依赖于它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Surface.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Lighting.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><aside class="collapsible-aside"><h3>为什么不在 Lighting 中包含 Surface？</h3><div><p>我们可以这样做，但最终会导致多个文件依赖于多个其他文件。我选择将所有包含语句放在一个地方，这使依赖关系清晰。这也使得用另一个文件替换一个文件变得容易，以更改着色器的工作方式，只要新文件定义了其他文件所依赖的相同功能即可。</p></div></aside><p>现在我们可以在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 中获取光照，并将其用于片元的 RGB 部分。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surface</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="n">alpha</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/diffuse-lighting-from-above.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/diffuse-lighting-from-above.png" alt="来自上方的漫反射光照" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">来自上方的漫反射光照</figcaption></figure><p>此时，结果是表面法线的 Y 分量，因此它在球体顶部为 1，在侧面下降到 0。再往下，结果变为负值，在底部达到 -1，但我们看不见负值。它匹配法线和向上向量之间夹角的余弦值。忽略负数部分，这在视觉上匹配指向正下方的方向光的漫反射光照（diffuse lighting）。最后的修饰是在 <code class="language-plaintext highlighter-rouge">GetLighting</code> 中将表面颜色计入结果，将其解释为表面反照率（albedo）。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">surface</span><span class="p">.</span><span class="n">normal</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">surface</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/albedo.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/albedo.png" alt="应用反照率" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">应用反照率</figcaption></figure><blockquote class="prompt-info"><p>反照率（albedo）是什么意思？ Albedo 在拉丁语中意为“白度”。它是衡量表面散射反射多少光的一个指标。如果反照率不是全白，那么部分光能就会被吸收而不是反射。</p></blockquote><h2 id="2-灯光-lights"><span class="me-2">2 灯光 (Lights)</span><a href="#2-灯光-lights" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>为了执行正确的光照，我们还需要知道灯光的属性。在本教程中，我们将仅限制在方向光上。方向光代表一个距离非常远的光源，以至于其位置无关紧要，只有其方向重要。这是一个简化，但足以模拟地球上的太阳光以及入射光或多或少是单向的其他情况。</p><h3 id="21-灯光结构-light-structure"><span class="me-2">2.1 灯光结构 (Light Structure)</span><a href="#21-灯光结构-light-structure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们将使用一个结构体来存储灯光数据。目前，颜色和方向就足够了。将其放在一个单独的 <code class="language-plaintext highlighter-rouge">Light.hlsl</code> 文件中。同时定义一个 <code class="language-plaintext highlighter-rouge">GetDirectionalLight</code> 函数，返回一个配置好的方向光。最初使用白色和向上向量，匹配我们当前使用的灯光数据。请注意，灯光的方向被定义为光线来自的方向，而不是它去的方向。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_LIGHT_INCLUDED
#define CUSTOM_LIGHT_INCLUDED
</span>
<span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">color</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">direction</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Light</span> <span class="nf">GetDirectionalLight</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">Light</span> <span class="n">light</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="kt">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">Lighting</code> 之前将文件包含在 <code class="language-plaintext highlighter-rouge">LitPass</code> 中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Light.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Lighting.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><h3 id="22-光照函数-lighting-functions"><span class="me-2">2.2 光照函数 (Lighting Functions)</span><a href="#22-光照函数-lighting-functions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在 <code class="language-plaintext highlighter-rouge">Lighting</code> 中添加一个 <code class="language-plaintext highlighter-rouge">IncomingLight</code> 函数，用于计算给定表面和光源的入射光量。对于任意光照方向，我们必须计算表面法线和方向的点积。我们可以使用 <code class="language-plaintext highlighter-rouge">dot</code> 函数。结果应该由灯光的颜色调制。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">IncomingLight</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">dot</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">)</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>什么是点积（dot product）</h3><div><p><strong>什么是点积（dot product）？</strong> 两个向量之间的点积在几何上定义为 $A \cdot B = ||A|| ||B|| \cos{\theta}$。这意味着它是向量之间夹角的余弦值，再乘以它们的长度。所以在两个单位长度向量的情况下，$A \cdot B = \cos{\theta}$。 在代数上，它被定义为 $A \cdot B = \sum_{i=1}^{n} A_i B_i = A_1 B_1 + A_2 B_2 + \dots + A_n B_n$。这意味着你可以通过将所有分量相乘并求和来计算它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">dotProduct</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/dot-product.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/dot-product.png" alt="点积" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">点积</figcaption></figure><p>在视觉上，此操作将一个向量直接投影到另一个向量上，就像在其上投射阴影一样。这样做，你最终会得到一个直角三角形，其底边的长度就是点积的结果。如果两个向量都是单位长度，那就是它们夹角的余弦值。</p></div></aside><p>但这只有在表面朝向灯光时才正确。当点积为负时，我们必须将其约束为零，我们可以通过 <code class="language-plaintext highlighter-rouge">saturate</code> 函数来实现。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">IncomingLight</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">))</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote class="prompt-info"><p><strong>saturate 的作用是什么？</strong> 它将值约束在 0 和 1 之间（含 0 和 1）。我们只需要指定最小值，因为点积永远不应该大于 1，但饱和（saturation）是着色器的一种常见操作，通常是免费的操作修饰符。</p></blockquote><p>添加另一个 <code class="language-plaintext highlighter-rouge">GetLighting</code> 函数，它返回表面和灯光的最终光照。目前，它是入射光乘以表面颜色。在另一个函数上方定义它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">IncomingLight</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="o">*</span> <span class="n">surface</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，调整只有一个 <code class="language-plaintext highlighter-rouge">Surface</code> 参数的 <code class="language-plaintext highlighter-rouge">GetLighting</code> 函数，使其调用另一个函数，使用 <code class="language-plaintext highlighter-rouge">GetDirectionalLight</code> 提供灯光数据。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">GetDirectionalLight</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="23-发送灯光数据到-gpu-sending-light-data-to-the-gpu"><span class="me-2">2.3 发送灯光数据到 GPU (Sending Light Data to the GPU)</span><a href="#23-发送灯光数据到-gpu-sending-light-data-to-the-gpu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们不应该总是使用来自上方的白光，而应该使用当前场景的灯光。默认场景自带一个代表太阳的方向光，颜色略带黄色——十六进制 FFF4D6——并且绕 X 轴旋转 50°，绕 Y 轴旋转 -30°。如果这种灯光不存在，请创建一个。</p><p>为了使灯光的数据在着色器中可访问，我们必须为其创建统一值（uniform values），就像着色器属性一样。在这种情况下，我们将定义两个 <code class="language-plaintext highlighter-rouge">float3</code> 向量：<code class="language-plaintext highlighter-rouge">_DirectionalLightColor</code> 和 <code class="language-plaintext highlighter-rouge">_DirectionalLightDirection</code>。将它们放在 <code class="language-plaintext highlighter-rouge">Light</code> 顶部定义的 <code class="language-plaintext highlighter-rouge">_CustomLight</code> 缓冲区中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomLight</span><span class="p">)</span>
    <span class="kt">float3</span> <span class="n">_DirectionalLightColor</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">_DirectionalLightDirection</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">GetDirectionalLight</code> 中使用这些值而不是常量。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">Light</span> <span class="nf">GetDirectionalLight</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">Light</span> <span class="n">light</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_DirectionalLightColor</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">_DirectionalLightDirection</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在我们的 RP 必须将灯光数据发送到 GPU。我们将为此创建一个新的 <code class="language-plaintext highlighter-rouge">Lighting</code> 类。它的工作方式类似于 <code class="language-plaintext highlighter-rouge">CameraRenderer</code>，但用于灯光。给它一个带有 context 参数的公共 <code class="language-plaintext highlighter-rouge">Setup</code> 方法，在其中调用一个单独的 <code class="language-plaintext highlighter-rouge">SetupDirectionalLight</code> 方法。虽然不是严格必要，但我们也给它一个专门的命令缓冲区，我们在完成后执行它，这对于调试很方便。另一种选择是添加一个缓冲区参数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.Rendering</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Lighting</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">string</span> <span class="n">bufferName</span> <span class="p">=</span> <span class="s">"Lighting"</span><span class="p">;</span>
    <span class="n">CommandBuffer</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CommandBuffer</span> <span class="p">{</span>
        <span class="n">name</span> <span class="p">=</span> <span class="n">bufferName</span>
    <span class="p">};</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(</span><span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
        <span class="nf">SetupDirectionalLight</span><span class="p">();</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
        <span class="n">context</span><span class="p">.</span><span class="nf">ExecuteCommandBuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">Clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">SetupDirectionalLight</span> <span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>跟踪这两个着色器属性的标识符。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="k">static</span> <span class="kt">int</span>
        <span class="n">dirLightColorId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalLightColor"</span><span class="p">),</span>
        <span class="n">dirLightDirectionId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalLightDirection"</span><span class="p">);</span>
</pre></table></code></div></div><p>我们可以通过 <code class="language-plaintext highlighter-rouge">RenderSettings.sun</code> 访问场景的主光源。默认情况下，这会得到最重要的方向光，也可以在 Window / Rendering / Lighting Settings 中显式配置。使用 <code class="language-plaintext highlighter-rouge">CommandBuffer.SetGlobalVector</code> 将灯光数据发送到 GPU。颜色是灯光在线性空间中的颜色，而方向是灯光变换的前向向量取反。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">SetupDirectionalLight</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">Light</span> <span class="n">light</span> <span class="p">=</span> <span class="n">RenderSettings</span><span class="p">.</span><span class="n">sun</span><span class="p">;</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span><span class="n">dirLightColorId</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">linear</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span><span class="n">dirLightDirectionId</span><span class="p">,</span> <span class="p">-</span><span class="n">light</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">forward</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><p>SetGlobalVector 不需要 Vector4 吗？ 是的，发送到 GPU 的向量始终有四个分量，即使我们定义的分量较少。额外的分量在着色器中被隐式掩码。同样，存在从 <code class="language-plaintext highlighter-rouge">Vector3</code> 到 <code class="language-plaintext highlighter-rouge">Vector4</code> 的隐式转换，尽管反向不行。</p></blockquote><p>灯光的颜色属性是其配置的颜色，但灯光也有一个单独的强度因子。最终颜色是两者相乘的结果。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVector</span><span class="p">(</span>
    <span class="n">dirLightColorId</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">linear</span> <span class="p">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensity</span>
<span class="p">);</span>
</pre></table></code></div></div><p>为 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 提供一个 <code class="language-plaintext highlighter-rouge">Lighting</code> 实例，并在绘制可见几何体之前使用它来设置光照。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>    <span class="n">Lighting</span> <span class="n">lighting</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Lighting</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(</span>
        <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">Camera</span> <span class="n">camera</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="err">…</span>
        <span class="nf">Setup</span><span class="p">();</span>
        <span class="n">lighting</span><span class="p">.</span><span class="nf">Setup</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
        <span class="nf">DrawVisibleGeometry</span><span class="p">(</span><span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">);</span>
        <span class="nf">DrawUnsupportedShaders</span><span class="p">();</span>
        <span class="nf">DrawGizmos</span><span class="p">();</span>
        <span class="nf">Submit</span><span class="p">();</span>
    <span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/lit-by-sun.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/lit-by-sun.png" alt="被照亮" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">被照亮</figcaption></figure><h3 id="24-可见光-visible-lights"><span class="me-2">2.4 可见光 (Visible Lights)</span><a href="#24-可见光-visible-lights" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在剔除时，Unity 还会确定哪些灯光影响摄像机可见的空间。我们可以依靠这些信息而不是全局太阳。为此，<code class="language-plaintext highlighter-rouge">Lighting</code> 需要访问剔除结果，因此为 <code class="language-plaintext highlighter-rouge">Setup</code> 添加一个参数并在字段中存储它以便于使用。然后我们可以支持多个灯光，因此将 <code class="language-plaintext highlighter-rouge">SetupDirectionalLight</code> 的调用替换为新的 <code class="language-plaintext highlighter-rouge">SetupLights</code> 方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>    <span class="n">CullingResults</span> <span class="n">cullingResults</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(</span>
        <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">CullingResults</span> <span class="n">cullingResults</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">cullingResults</span> <span class="p">=</span> <span class="n">cullingResults</span><span class="p">;</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
        <span class="c1">//SetupDirectionalLight();</span>
        <span class="nf">SetupLights</span><span class="p">();</span>
        <span class="err">…</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">SetupLights</span> <span class="p">()</span> <span class="p">{}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">CameraRenderer.Render</code> 中调用 <code class="language-plaintext highlighter-rouge">Setup</code> 时添加剔除结果作为参数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>        <span class="n">lighting</span><span class="p">.</span><span class="nf">Setup</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">cullingResults</span><span class="p">);</span>
</pre></table></code></div></div><p>现在 <code class="language-plaintext highlighter-rouge">Lighting.SetupLights</code> 可以通过剔除结果的 <code class="language-plaintext highlighter-rouge">visibleLights</code> 属性检索所需数据。它是以 <code class="language-plaintext highlighter-rouge">Unity.Collections.NativeArray</code> 形式提供的，元素类型为 <code class="language-plaintext highlighter-rouge">VisibleLight</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">Unity.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.Rendering</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Lighting</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="k">void</span> <span class="nf">SetupLights</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">NativeArray</span><span class="p">&lt;</span><span class="n">VisibleLight</span><span class="p">&gt;</span> <span class="n">visibleLights</span> <span class="p">=</span> <span class="n">cullingResults</span><span class="p">.</span><span class="n">visibleLights</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="err">…</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><p><strong>什么是 NativeArray？</strong> 它是一个行为类似于数组的结构体，但提供了与本机内存缓冲区的连接。它使得在托管 C# 代码和本机 Unity 引擎代码之间高效共享数据成为可能。</p></blockquote><h3 id="25-多个方向光-multiple-directional-lights"><span class="me-2">2.5 多个方向光 (Multiple Directional Lights)</span><a href="#25-多个方向光-multiple-directional-lights" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>使用可见光数据使得支持多个方向光成为可能，但我们必须将所有这些灯光的数据发送到 GPU。因此，我们将使用两个 <code class="language-plaintext highlighter-rouge">Vector4</code> 数组加上一个用于灯光数量的整数，而不是一对向量。我们还将定义方向光的最大数量，我们可以使用它来初始化两个数组字段以缓冲数据。让我们将最大值设置为 4，这对于大多数场景应该足够了。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxDirLightCount</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">int</span>
        <span class="c1">//dirLightColorId = Shader.PropertyToID("_DirectionalLightColor"),</span>
        <span class="c1">//dirLightDirectionId = Shader.PropertyToID("_DirectionalLightDirection");</span>
        <span class="n">dirLightCountId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalLightCount"</span><span class="p">),</span>
        <span class="n">dirLightColorsId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalLightColors"</span><span class="p">),</span>
        <span class="n">dirLightDirectionsId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_DirectionalLightDirections"</span><span class="p">);</span>

    <span class="k">static</span> <span class="n">Vector4</span><span class="p">[]</span>
        <span class="n">dirLightColors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxDirLightCount</span><span class="p">],</span>
        <span class="n">dirLightDirections</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="n">maxDirLightCount</span><span class="p">];</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>为什么不使用结构化缓冲区（structured buffers）？</h3><div><p>这是可能的，但我不会使用，因为着色器对结构化缓冲区的支持还不够好。要么根本不支持，要么仅在片元程序中支持，或者性能比常规数组差。好消息是，数据在 CPU 和 GPU 之间传递方式的细节仅在少数地方起作用，因此很容易更改。这是使用 <code class="language-plaintext highlighter-rouge">Light</code> 结构体的另一个好处。</p></div></aside><p>为 <code class="language-plaintext highlighter-rouge">SetupDirectionalLight</code> 添加一个索引和一个 <code class="language-plaintext highlighter-rouge">VisibleLight</code> 参数。让它使用提供的索引设置颜色和方向元素。在这种情况下，最终颜色通过 <code class="language-plaintext highlighter-rouge">visibleLight.finalColor</code> 属性提供。前向向量可以通过 <code class="language-plaintext highlighter-rouge">visibleLight.localToWorldMatrix</code> 属性找到。它是矩阵的第三列，并且再次需要取反。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">SetupDirectionalLight</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">VisibleLight</span> <span class="n">visibleLight</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dirLightColors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">visibleLight</span><span class="p">.</span><span class="n">finalColor</span><span class="p">;</span>
        <span class="n">dirLightDirections</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="p">-</span><span class="n">visibleLight</span><span class="p">.</span><span class="n">localToWorldMatrix</span><span class="p">.</span><span class="nf">GetColumn</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>最终颜色已经应用了灯光的强度，但默认情况下 Unity 不会将其转换为线性空间。我们必须将 <code class="language-plaintext highlighter-rouge">GraphicsSettings.lightsUseLinearIntensity</code> 设置为 <code class="language-plaintext highlighter-rouge">true</code>，我们可以在 <code class="language-plaintext highlighter-rouge">CustomRenderPipeline</code> 的构造函数中执行此操作。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="k">public</span> <span class="nf">CustomRenderPipeline</span> <span class="p">(</span>
        <span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useSRPBatcher</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">useDynamicBatching</span> <span class="p">=</span> <span class="n">useDynamicBatching</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">useGPUInstancing</span> <span class="p">=</span> <span class="n">useGPUInstancing</span><span class="p">;</span>
        <span class="n">GraphicsSettings</span><span class="p">.</span><span class="n">useScriptableRenderPipelineBatching</span> <span class="p">=</span> <span class="n">useSRPBatcher</span><span class="p">;</span>
        <span class="n">GraphicsSettings</span><span class="p">.</span><span class="n">lightsUseLinearIntensity</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>接下来，循环遍历 <code class="language-plaintext highlighter-rouge">Lighting.SetupLights</code> 中的所有可见光并为每个元素调用 <code class="language-plaintext highlighter-rouge">SetupDirectionalLight</code>。然后在缓冲区上调用 <code class="language-plaintext highlighter-rouge">SetGlobalInt</code> 和 <code class="language-plaintext highlighter-rouge">SetGlobalVectorArray</code> 以将数据发送到 GPU。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>        <span class="n">NativeArray</span><span class="p">&lt;</span><span class="n">VisibleLight</span><span class="p">&gt;</span> <span class="n">visibleLights</span> <span class="p">=</span> <span class="n">cullingResults</span><span class="p">.</span><span class="n">visibleLights</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">visibleLights</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="n">VisibleLight</span> <span class="n">visibleLight</span> <span class="p">=</span> <span class="n">visibleLights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="nf">SetupDirectionalLight</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">visibleLight</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalInt</span><span class="p">(</span><span class="n">dirLightCountId</span><span class="p">,</span> <span class="n">visibleLights</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVectorArray</span><span class="p">(</span><span class="n">dirLightColorsId</span><span class="p">,</span> <span class="n">dirLightColors</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalVectorArray</span><span class="p">(</span><span class="n">dirLightDirectionsId</span><span class="p">,</span> <span class="n">dirLightDirections</span><span class="p">);</span>
</pre></table></code></div></div><p>但我们只支持最多四个方向光，所以当我们达到该最大值时应该中止循环。让我们保持方向光索引与循环迭代器分开。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>        <span class="kt">int</span> <span class="n">dirLightCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">visibleLights</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="n">VisibleLight</span> <span class="n">visibleLight</span> <span class="p">=</span> <span class="n">visibleLights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="nf">SetupDirectionalLight</span><span class="p">(</span><span class="n">dirLightCount</span><span class="p">++,</span> <span class="n">visibleLight</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dirLightCount</span> <span class="p">&gt;=</span> <span class="n">maxDirLightCount</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalInt</span><span class="p">(</span><span class="n">dirLightCountId</span><span class="p">,</span> <span class="n">dirLightCount</span><span class="p">);</span>
</pre></table></code></div></div><p>因为我们只支持方向光，所以我们应该忽略其他类型的灯光。我们可以通过检查可见光的 <code class="language-plaintext highlighter-rouge">lightType</code> 属性是否等于 <code class="language-plaintext highlighter-rouge">LightType.Directional</code> 来实现这一点。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">VisibleLight</span> <span class="n">visibleLight</span> <span class="p">=</span> <span class="n">visibleLights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">visibleLight</span><span class="p">.</span><span class="n">lightType</span> <span class="p">==</span> <span class="n">LightType</span><span class="p">.</span><span class="n">Directional</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">SetupDirectionalLight</span><span class="p">(</span><span class="n">dirLightCount</span><span class="p">++,</span> <span class="n">visibleLight</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dirLightCount</span> <span class="p">&gt;=</span> <span class="n">maxDirLightCount</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这可行，但 <code class="language-plaintext highlighter-rouge">VisibleLight</code> 结构体相当大。理想情况下，我们只从原生数组中检索它一次，而且不要将其作为常规参数传递给 <code class="language-plaintext highlighter-rouge">SetupDirectionalLight</code>，因为这会复制它。我们可以使用 Unity 对 <code class="language-plaintext highlighter-rouge">ScriptableRenderContext.DrawRenderers</code> 方法使用的相同技巧，即通过引用传递参数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">SetupDirectionalLight</span><span class="p">(</span><span class="n">dirLightCount</span><span class="p">++,</span> <span class="k">ref</span> <span class="n">visibleLight</span><span class="p">);</span>
</pre></table></code></div></div><p>这要求我们也将会参数定义为引用。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">SetupDirectionalLight</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">ref</span> <span class="n">VisibleLight</span> <span class="n">visibleLight</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</pre></table></code></div></div><h3 id="26-着色器循环-shader-loop"><span class="me-2">2.6 着色器循环 (Shader Loop)</span><a href="#26-着色器循环-shader-loop" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>调整 <code class="language-plaintext highlighter-rouge">Light</code> 中的 <code class="language-plaintext highlighter-rouge">_CustomLight</code> 缓冲区以使其匹配我们的新数据格式。在这种情况下，我们将明确地为数组类型使用 <code class="language-plaintext highlighter-rouge">float4</code>。数组在着色器中具有固定大小，无法调整大小。确保使用我们在 <code class="language-plaintext highlighter-rouge">Lighting</code> 中定义的相同最大值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#define MAX_DIRECTIONAL_LIGHT_COUNT 4
</span>
<span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">_CustomLight</span><span class="p">)</span>
    <span class="n">int</span> <span class="n">_DirectionalLightCount</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">_DirectionalLightColors</span><span class="p">[</span><span class="n">MAX_DIRECTIONAL_LIGHT_COUNT</span><span class="p">];</span>
    <span class="kt">float4</span> <span class="n">_DirectionalLightDirections</span><span class="p">[</span><span class="n">MAX_DIRECTIONAL_LIGHT_COUNT</span><span class="p">];</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>添加一个获取方向光数量的函数，并调整 <code class="language-plaintext highlighter-rouge">GetDirectionalLight</code> 以使其检索特定灯光索引的数据。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">int</span> <span class="nf">GetDirectionalLightCount</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_DirectionalLightCount</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Light</span> <span class="nf">GetDirectionalLight</span> <span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Light</span> <span class="n">light</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">_DirectionalLightColors</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">_DirectionalLightDirections</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">xyz</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><p><strong>rgb 和 xyz 之间有区别吗？</strong> 它们是语义别名。使用 <code class="language-plaintext highlighter-rouge">rgba</code> 和 <code class="language-plaintext highlighter-rouge">xyzw</code> 进行混写（Swizzling）是等效的。</p></blockquote><p>然后调整表面的 <code class="language-plaintext highlighter-rouge">GetLighting</code>，使其使用 <code class="language-plaintext highlighter-rouge">for</code> 循环来累加所有方向光的贡献。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GetDirectionalLightCount</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">color</span> <span class="o">+=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">GetDirectionalLight</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/four-directional-lights.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/four-directional-lights.png" alt="四个方向光" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">四个方向光</figcaption></figure><p>现在我们的着色器支持最多四个方向光。通常只需要一个方向光来代表太阳或月亮，但也许在拥有多个太阳的行星上有一个场景。方向光也可以用来近似多个大型灯光装置，例如大型体育场的灯光。</p><p>如果你的游戏始终只有一个方向光，那么你可以去掉循环，或者制作多个着色器变体。但在本教程中，我们将保持简单，坚持使用一个通用的循环。最好的性能始终是通过剥离所有你不需要的东西来实现的，尽管它并不总是产生显著差异。</p><h3 id="27-着色器目标级别-shader-target-level"><span class="me-2">2.7 着色器目标级别 (Shader Target Level)</span><a href="#27-着色器目标级别-shader-target-level" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>使用变量长度的循环过去对着色器来说是个问题，但现代 GPU 可以毫无问题地处理它们，特别是当绘制调用的所有片元都以相同的方式迭代相同的数据时。但是，OpenGL ES 2.0 和 WebGL 1.0 图形 API 默认无法处理此类循环。我们可以通过合并硬编码的最大值来使其工作，例如让 <code class="language-plaintext highlighter-rouge">GetDirectionalLight</code> 返回 <code class="language-plaintext highlighter-rouge">min(_DirectionalLightCount, MAX_DIRECTIONAL_LIGHT_COUNT)</code>。这使得展开（unroll）循环成为可能，将其转换为一系列条件代码块。不幸的是，生成的着色器代码一团糟，性能会迅速下降。在非常陈旧的硬件上，所有代码块将始终执行，它们的贡献通过条件分配来控制。虽然我们可以使其工作，但它会使代码变得更复杂，因为我们也必须做出其他调整。所以我选择忽略这些限制，为了简单起见在构建中关闭 WebGL 1.0 和 OpenGL ES 2.0 支持。它们无论如何都不支持线性光照。我们还可以通过 <code class="language-plaintext highlighter-rouge">#pragma target 3.5</code> 指令将着色器 Pass 的目标级别提高到 3.5 来避免为它们编译 OpenGL ES 2.0 着色器变体。让我们保持一致，对两个着色器都这样做。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">HLSLPROGRAM</span>
<span class="cp">#pragma target 3.5
</span><span class="err">…</span>
<span class="n">ENDHLSL</span>
</pre></table></code></div></div><h2 id="3-brdf"><span class="me-2">3 BRDF</span><a href="#3-brdf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们目前使用一个非常简单的光照模型，仅适用于完全漫反射表面。我们可以通过应用<code class="language-plaintext highlighter-rouge">双向反射分布函数</code>（BRDF）来实现更多样化、更真实的光照。此类函数有很多。我们将使用通用管线（URP）所使用的那一个，它权衡了一些真实感以换取性能。</p><h3 id="31-入射光-incoming-light"><span class="me-2">3.1 入射光 (Incoming Light)</span><a href="#31-入射光-incoming-light" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当光束正面照射到表面片元时，其所有能量都将影响该片元。为简单起见，我们将假设光束的宽度与片元的宽度匹配。这就是光线方向 $L$ 和表面法线 $N$ 对齐的情况，因此 $N \cdot L = 1$。当它们不对齐时，光束的至少一部分会错过表面片元，因此影响片元的能量较少。影响片元的能量部分是 $N \cdot L$。负值结果意味着表面背离光源，因此不受其影响。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/incoming-light.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/incoming-light.png" alt="入射光部分" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">入射光部分</figcaption></figure><h3 id="32-出射光-outgoing-light"><span class="me-2">3.2 出射光 (Outgoing Light)</span><a href="#32-出射光-outgoing-light" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们不会直接看到到达表面的光。我们只看到从表面反弹并到达摄像机或我们眼睛的那部分。如果表面是一个完全平坦的镜子，那么光线会反射出去，出射角等于入射角。只有当摄像机与该光线对齐时，我们才能看到此光线。这被称为高光反射（specular reflection）。这是光交互的简化，但对于我们的目的来说已经足够了。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/specular-reflection.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/specular-reflection.png" alt="完全高光反射" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">完全高光反射</figcaption></figure><p>但如果表面不是完全平坦的，那么光线就会被散射，因为该片元实际上由许多具有不同方向的更小片元组成。这会将光束分解成走向不同方向的小光束，从而有效地模糊了高光反射。即使没有与完美反射方向对齐，我们最终也可能会看到一些散射光。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/scattered-reflection.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/scattered-reflection.png" alt="散射高光反射" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">散射高光反射</figcaption></figure><p>除此之外，光线还会穿透表面，到处反弹，并以不同的角度射出，以及其他我们不需要考虑的事情。取极端情况，我们最终会得到一个完美的漫反射表面，它向所有可能的方向均匀散射光。这就是我们目前在着色器中计算的光照。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/diffuse-reflection.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/diffuse-reflection.png" alt="完美漫反射反射" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">完美漫反射反射</figcaption></figure><p>无论摄像机位于何处，从表面接收到的漫反射光量都是相同的。但这意味着我们观察到的光能远小于到达表面 fragment 的光能。这表明我们应该用某个系数来缩放进入的光线。然而，由于该系数始终保持不变，我们可以将其直接合并到光的颜色和强度中。因此，我们使用的最终光色代表了在正面照射下，从一个完美的白色漫反射表面 fragment 反射时观察到的光量。这只是实际发射的总光量的一小部分。还有其他配置灯光的方法，例如通过指定流明（lumen）或（lux），这使得配置现实的光源更加容易，但我们将坚持目前的方法。</p><h3 id="33-表面属性-surface-properties"><span class="me-2">3.3 表面属性 (Surface Properties)</span><a href="#33-表面属性-surface-properties" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>表面可以是完全漫反射、完美镜面反射或介于两者之间的任何状态。我们可以通过多种方式控制这一点。我们将使用金属度工作流（metallic workflow），这要求我们在 <code class="language-plaintext highlighter-rouge">Lit</code> 着色器中添加两个表面属性。</p><ol><li>第一个属性是表面是金属还是非金属，也称为电介质（dielectric）。由于表面可以包含两者的混合，我们将为其添加一个 $0-1$ 范围的滑块，1 表示完全金属。默认值为完全电介质。<li>第二个属性控制表面的平滑程度。我们也将为此使用 $0-1$ 范围的滑块，0 表示完全粗糙，1 表示完全平滑。我们将使用 0.5 作为默认值。</ol><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">_Metallic</span> <span class="p">(</span><span class="s">"Metallic"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_Smoothness</span> <span class="p">(</span><span class="s">"Smoothness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/metallic-smoothness.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/metallic-smoothness.png" alt="带有金属度和光滑度滑块的材质" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">带有金属度和光滑度滑块的材质</figcaption></figure><p>将这些属性添加到 <code class="language-plaintext highlighter-rouge">UnityPerMaterial</code> 缓冲区中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseMap_ST</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Metallic</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Smoothness</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
</pre></table></code></div></div><p>同时也添加到 <code class="language-plaintext highlighter-rouge">Surface</code> 结构体中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Surface</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">normal</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">alpha</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">metallic</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">smoothness</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 中将它们复制到表面。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="n">Surface</span> <span class="n">surface</span><span class="p">;</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">normalWS</span><span class="p">);</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">base</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">base</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">metallic</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Metallic</span><span class="p">);</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">smoothness</span> <span class="o">=</span>
        <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Smoothness</span><span class="p">);</span>
</pre></table></code></div></div><p>并为 <code class="language-plaintext highlighter-rouge">PerObjectMaterialProperties</code> 添加对它们的支持。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>    <span class="k">static</span> <span class="kt">int</span>
        <span class="n">baseColorId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_BaseColor"</span><span class="p">),</span>
        <span class="n">cutoffId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_Cutoff"</span><span class="p">),</span>
        <span class="n">metallicId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_Metallic"</span><span class="p">),</span>
        <span class="n">smoothnessId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_Smoothness"</span><span class="p">);</span>
    <span class="err">…</span>
    <span class="p">[</span><span class="n">SerializeField</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">)]</span>
    <span class="kt">float</span> <span class="n">alphaCutoff</span> <span class="p">=</span> <span class="m">0.5f</span><span class="p">,</span> <span class="n">metallic</span> <span class="p">=</span> <span class="m">0f</span><span class="p">,</span> <span class="n">smoothness</span> <span class="p">=</span> <span class="m">0.5f</span><span class="p">;</span>
    <span class="err">…</span>
    <span class="k">void</span> <span class="nf">OnValidate</span> <span class="p">()</span> <span class="p">{</span>
        <span class="err">…</span>
        <span class="n">block</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="n">metallicId</span><span class="p">,</span> <span class="n">metallic</span><span class="p">);</span>
        <span class="n">block</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="n">smoothnessId</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">);</span>
        <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Renderer</span><span class="p">&gt;().</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><h3 id="34-brdf-属性-brdf-properties"><span class="me-2">3.4 BRDF 属性 (BRDF Properties)</span><a href="#34-brdf-属性-brdf-properties" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们将使用表面属性来计算 BRDF 方程。它告诉我们最终看到的从表面反射了多少光，这是漫反射和高光反射的组合。我们需要将表面颜色分为漫反射部分和高光部分，我们还需要知道表面的粗糙程度。让我们在 <code class="language-plaintext highlighter-rouge">ShaderLibrary</code> 文件夹中一个单独的 <code class="language-plaintext highlighter-rouge">BRDF.hlsl</code> 文件中跟踪这三个值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_BRDF_INCLUDED
#define CUSTOM_BRDF_INCLUDED
</span>
<span class="k">struct</span> <span class="n">BRDF</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">diffuse</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">specular</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">roughness</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>添加一个获取给定表面的 BRDF 数据的函数。从完美的漫反射表面开始，因此漫反射部分等于表面颜色，而高光部分为黑色，粗糙度为 1。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">BRDF</span> <span class="nf">GetBRDF</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">;</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">surface</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">specular</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">roughness</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">brdf</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">Light</code> 之后、<code class="language-plaintext highlighter-rouge">Lighting</code> 之前包含 <code class="language-plaintext highlighter-rouge">BRDF</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Common.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Surface.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Light.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/BRDF.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"../ShaderLibrary/Lighting.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><p>为两个 <code class="language-plaintext highlighter-rouge">GetLighting</code> 函数添加一个 <code class="language-plaintext highlighter-rouge">BRDF</code> 参数，然后将入射光乘以漫反射部分而不是整个表面颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">IncomingLight</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GetDirectionalLightCount</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">color</span> <span class="o">+=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">GetDirectionalLight</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 中获取 BRDF 数据并将其传递给 <code class="language-plaintext highlighter-rouge">GetLighting</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">BRDF</span> <span class="n">brdf</span> <span class="o">=</span> <span class="n">GetBRDF</span><span class="p">(</span><span class="n">surface</span><span class="p">);</span>
    <span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">brdf</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="35-反射率-reflectivity"><span class="me-2">3.5 反射率 (Reflectivity)</span><a href="#35-反射率-reflectivity" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>表面的反射程度各不相同，但一般金属通过高光反射反射所有光线，漫反射反射为零。所以我们将声明反射率等于金属度表面属性。被反射的光不会被漫反射，所以我们应该在 <code class="language-plaintext highlighter-rouge">GetBRDF</code> 中通过 1 减去反射率来缩放漫反射颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">float</span> <span class="n">oneMinusReflectivity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">surface</span><span class="p">.</span><span class="n">metallic</span><span class="p">;</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">surface</span><span class="p">.</span><span class="n">color</span> <span class="o">*</span> <span class="n">oneMinusReflectivity</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/reflectivity.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/reflectivity.png" alt="金属度为 0、0.25、0.5、0.75 和 1 的白色球体" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">金属度为 0、0.25、0.5、0.75 和 1 的白色球体</figcaption></figure><p>实际上，一些光也会从电介质表面反弹，这给它们带来了亮点。非金属的反射率各不相同，但平均约为 0.04。让我们将其定义为最小反射率，并添加一个 <code class="language-plaintext highlighter-rouge">OneMinusReflectivity</code> 函数，将范围从 0-1 调整为 0-0.96。此范围调整与通用管线（URP）的方法匹配。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#define MIN_REFLECTIVITY 0.04
</span>
<span class="n">float</span> <span class="nf">OneMinusReflectivity</span> <span class="p">(</span><span class="n">float</span> <span class="n">metallic</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">MIN_REFLECTIVITY</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">range</span> <span class="o">-</span> <span class="n">metallic</span> <span class="o">*</span> <span class="n">range</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">GetBRDF</code> 中使用该函数来强制执行最小值。在仅渲染漫反射反射时差异几乎察觉不到，但在我们添加高光反射时会很重要。没有它，非金属将不会获得高光。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="n">float</span> <span class="n">oneMinusReflectivity</span> <span class="o">=</span> <span class="n">OneMinusReflectivity</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">metallic</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="36-高光颜色-specular-color"><span class="me-2">3.6 高光颜色 (Specular Color)</span><a href="#36-高光颜色-specular-color" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>被反射走的光线不能再以另一种方式被反射。这被称为能量守恒，这意味着出射光量不能超过入射光量。这表明高光颜色应该等于表面颜色减去漫反射颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">surface</span><span class="p">.</span><span class="n">color</span> <span class="o">*</span> <span class="n">oneMinusReflectivity</span><span class="p">;</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">specular</span> <span class="o">=</span> <span class="n">surface</span><span class="p">.</span><span class="n">color</span> <span class="o">-</span> <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span><span class="p">;</span>
</pre></table></code></div></div><p>但是，这忽略了金属影响高光反射颜色而非金属不影响这一事实。电介质表面的高光颜色应该是白色的，我们可以通过使用金属度属性在最小反射率和表面颜色之间进行插值来实现。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="n">brdf</span><span class="p">.</span><span class="n">specular</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">MIN_REFLECTIVITY</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="n">color</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="n">metallic</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="37-粗糙度-roughness"><span class="me-2">3.7 粗糙度 (Roughness)</span><a href="#37-粗糙度-roughness" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>粗糙度是平滑度的相反面，所以我们可以简单地用 1 减去平滑度。Core RP 库有一个执行此操作的函数，名为 <code class="language-plaintext highlighter-rouge">PerceptualSmoothnessToPerceptualRoughness</code>。我们将使用此函数，以明确平滑度以及粗糙度都被定义为感知的。我们可以通过 <code class="language-plaintext highlighter-rouge">PerceptualRoughnessToRoughness</code> 函数转换为实际的粗糙度值，该函数对感知值进行平方。这匹配 Disney 光照模型。之所以这样做，是因为在编辑材质时调整感知版本更直观。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="n">float</span> <span class="n">perceptualRoughness</span> <span class="o">=</span>
        <span class="n">PerceptualSmoothnessToPerceptualRoughness</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">smoothness</span><span class="p">);</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">roughness</span> <span class="o">=</span> <span class="n">PerceptualRoughnessToRoughness</span><span class="p">(</span><span class="n">perceptualRoughness</span><span class="p">);</span>
</pre></table></code></div></div><p>这些函数在 Core RP 库的 <code class="language-plaintext highlighter-rouge">CommonMaterial.hlsl</code> 文件中定义。在包含核心的 <code class="language-plaintext highlighter-rouge">Common</code> 之后将其包含在我们的 <code class="language-plaintext highlighter-rouge">Common</code> 文件中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"UnityInput.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><h3 id="38-视角方向-view-direction"><span class="me-2">3.8 视角方向 (View Direction)</span><a href="#38-视角方向-view-direction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了确定摄像机与完美反射方向的对齐程度，我们需要知道摄像机的位置。Unity 通过 <code class="language-plaintext highlighter-rouge">float3 _WorldSpaceCameraPos</code> 提供此数据，所以将其添加到 <code class="language-plaintext highlighter-rouge">UnityInput</code> 中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">_WorldSpaceCameraPos</span><span class="p">;</span>
</pre></table></code></div></div><p>为了获得视角方向——从表面到摄像机的方向——在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 中，我们需要在 <code class="language-plaintext highlighter-rouge">Varyings</code> 中添加世界空间表面位置。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">positionCS</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">positionWS</span> <span class="o">:</span> <span class="n">VAR_POSITION</span><span class="p">;</span>
    <span class="err">…</span>
<span class="p">};</span>

<span class="n">Varyings</span> <span class="nf">LitPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="n">output</span><span class="p">.</span><span class="n">positionWS</span> <span class="o">=</span> <span class="n">TransformObjectToWorld</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">positionCS</span> <span class="o">=</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">positionWS</span><span class="p">);</span>
    <span class="err">…</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们将视角方向视为表面数据的一部分，因此将其添加到 <code class="language-plaintext highlighter-rouge">Surface</code> 中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Surface</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">normal</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">viewDirection</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">alpha</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">metallic</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">smoothness</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 中分配它。它等于摄像机位置减去片元位置，再归一化。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">surface</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">normalWS</span><span class="p">);</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">viewDirection</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">input</span><span class="p">.</span><span class="n">positionWS</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="39-高光强度-specular-strength"><span class="me-2">3.9 高光强度 (Specular Strength)</span><a href="#39-高光强度-specular-strength" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们观察到的高光反射强度取决于我们的视角方向与完美反射方向的匹配程度。我们将使用与通用管线（URP）相同的公式，它是 Minimalist CookTorrance BRDF 的变体。该公式包含一些平方，所以让我们首先为 <code class="language-plaintext highlighter-rouge">Common</code> 添加一个方便的 <code class="language-plaintext highlighter-rouge">Square</code> 函数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">Square</span> <span class="p">(</span><span class="n">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">v</span> <span class="o">*</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后为 <code class="language-plaintext highlighter-rouge">BRDF</code> 添加一个以表面、BRDF 数据和灯光为参数的 <code class="language-plaintext highlighter-rouge">SpecularStrength</code> 函数。它应该计算 $\frac{r^2}{d^2 \max (0.1, (L \cdot H)^2) n}$，其中 $r$ 是粗糙度，所有点积都应该饱和。此外，$d = (N \cdot H)^2(r^2 - 1) + 1.0001$，$N$ 是表面法线，$L$ 是灯光方向，$H = L + V$ 归一化，它是灯光和视角方向之间的半程向量（halfway vector）。使用 <code class="language-plaintext highlighter-rouge">SafeNormalize</code> 函数来归一化该向量，以避免在向量相反的情况下除以零。最后，$n = 4r + 2$ 且是一个归一化项。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">SpecularStrength</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">h</span> <span class="o">=</span> <span class="n">SafeNormalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">direction</span> <span class="o">+</span> <span class="n">surface</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">nh2</span> <span class="o">=</span> <span class="n">Square</span><span class="p">(</span><span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">h</span><span class="p">)));</span>
    <span class="n">float</span> <span class="n">lh2</span> <span class="o">=</span> <span class="n">Square</span><span class="p">(</span><span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">h</span><span class="p">)));</span>
    <span class="n">float</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">brdf</span><span class="p">.</span><span class="n">roughness</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">nh2</span> <span class="o">*</span> <span class="p">(</span><span class="n">r2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">.</span><span class="mo">0001</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">normalization</span> <span class="o">=</span> <span class="n">brdf</span><span class="p">.</span><span class="n">roughness</span> <span class="o">*</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r2</span> <span class="o">/</span> <span class="p">(</span><span class="n">d2</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">lh2</span><span class="p">)</span> <span class="o">*</span> <span class="n">normalization</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote class="promtp-tip"><p><strong>那个函数是如何工作的？</strong> BRDF 理论太复杂，无法简短地完全解释，而且也不是本教程的重点。你可以查看 URP 的 <code class="language-plaintext highlighter-rouge">Lighting.hlsl</code> 文件以获取一些代码文档和参考。</p></blockquote><p>接下来，添加一个 <code class="language-plaintext highlighter-rouge">DirectBRDF</code>，它返回通过直接光照获得颜色，给定表面、BRDF 和灯光。结果是高光颜色由高光强度调制，加上漫反射颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">DirectBRDF</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">SpecularStrength</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="o">*</span> <span class="n">brdf</span><span class="p">.</span><span class="n">specular</span> <span class="o">+</span> <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">GetLighting</code> 然后必须将入射光乘以该函数的结果。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">IncomingLight</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">light</span><span class="p">)</span> <span class="o">*</span> <span class="n">DirectBRDF</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">light</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/smoothness.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/smoothness.png" alt="平滑度从上到下分别为 0、0.25、0.5、0.75 和 0.95" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">平滑度从上到下分别为 0、0.25、0.5、0.75 和 0.95</figcaption></figure><p>我们现在获得了高光反射，这为我们的表面增加了亮点。对于完全粗糙的表面，亮点模拟漫反射反射。平滑的表面获得更集中的亮点。完全平滑的表面获得极其微小的亮点，我们看不见。需要一些散射才能使其可见。</p><p>由于能量守恒，平滑表面的亮点可能会变得非常亮，因为到达表面片元的大部分光都变得集中了。因此，我们最终看到的光比漫反射反射可能看到的光要多得多。你可以通过将最终渲染颜色大幅缩小来验证这一点。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/colors-001.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/colors-001.png" alt="最终颜色除以 100" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">最终颜色除以 100</figcaption></figure><p>你也可以通过使用白色以外的基础颜色来验证金属会影响高光反射的颜色而非金属不影响。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/blue.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/blue.png" alt="蓝色基础颜色" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">蓝色基础颜色</figcaption></figure><p>我们现在有了功能性的、可信的直接光照，尽管目前结果太暗了——特别是对于金属——因为我们还不支持环境反射。此时均匀的黑色环境会比默认的天空盒更真实，但这会使我们的对象更难看到。添加更多灯光也有效。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/four-lights.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/four-lights.png" alt="四个灯光" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">四个灯光</figcaption></figure><h3 id="310-网格球-mesh-ball"><span class="me-2">3.10 网格球 (Mesh Ball)</span><a href="#310-网格球-mesh-ball" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>让我们也为 <code class="language-plaintext highlighter-rouge">MeshBall</code> 添加对变化的金属度和光滑度属性的支持。这需要添加两个 float 数组。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>    <span class="k">static</span> <span class="kt">int</span>
        <span class="n">baseColorId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_BaseColor"</span><span class="p">),</span>
        <span class="n">metallicId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_Metallic"</span><span class="p">),</span>
        <span class="n">smoothnessId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_Smoothness"</span><span class="p">);</span>
    <span class="err">…</span>
    <span class="kt">float</span><span class="p">[]</span>
        <span class="n">metallic</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="m">1023</span><span class="p">],</span>
        <span class="n">smoothness</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="m">1023</span><span class="p">];</span>
    <span class="err">…</span>
    <span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">block</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
            <span class="n">block</span><span class="p">.</span><span class="nf">SetVectorArray</span><span class="p">(</span><span class="n">baseColorId</span><span class="p">,</span> <span class="n">baseColors</span><span class="p">);</span>
            <span class="n">block</span><span class="p">.</span><span class="nf">SetFloatArray</span><span class="p">(</span><span class="n">metallicId</span><span class="p">,</span> <span class="n">metallic</span><span class="p">);</span>
            <span class="n">block</span><span class="p">.</span><span class="nf">SetFloatArray</span><span class="p">(</span><span class="n">smoothnessId</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Graphics</span><span class="p">.</span><span class="nf">DrawMeshInstanced</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">matrices</span><span class="p">,</span> <span class="m">1023</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>让我们在 <code class="language-plaintext highlighter-rouge">Awake</code> 中让 25% 的实例具有金属感，并让平滑度从 0.05 变化到 0.95。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="n">baseColors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span>
        <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
            <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span>
            <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">1f</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="n">metallic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span> <span class="p">&lt;</span> <span class="m">0.25f</span> <span class="p">?</span> <span class="m">1f</span> <span class="p">:</span> <span class="m">0f</span><span class="p">;</span>
    <span class="n">smoothness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.05f</span><span class="p">,</span> <span class="m">0.95f</span><span class="p">);</span>
</pre></table></code></div></div><p>然后让网格球使用受光材质。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/mesh-ball.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/mesh-ball.png" alt="受光网格球" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">受光网格球</figcaption></figure><h2 id="4-透明度-transparency"><span class="me-2">4 透明度 (Transparency)</span><a href="#4-透明度-transparency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>让我们再次考虑透明度。对象仍然基于其 alpha 值淡出，但现在是反射光淡出。这对于漫反射反射是有意义的，因为只有一部分光被反射，而其余光穿过表面。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/fading.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/fading.png" alt="淡出球体" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">淡出球体</figcaption></figure><p>但是，高光反射也会淡出。在完全透明的玻璃的情况下，光线要么穿过要么被反射。高光反射不会淡出。我们目前的做法无法表示这一点。</p><h3 id="41-预乘-alpha-premultiplied-alpha"><span class="me-2">4.1 预乘 Alpha (Premultiplied Alpha)</span><a href="#41-预乘-alpha-premultiplied-alpha" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>解决方案是只淡出漫反射光，同时保持高光反射为全强度。由于源混合模式应用于所有内容，我们无法使用它，所以让我们将其设置为 1，同时仍然为目标混合模式使用 one-minus-source-alpha。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/src-blend-one-inspector.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/src-blend-one-inspector.png" alt="源混合模式设置为 one" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/src-blend-one-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/src-blend-one-scene.png" alt="源混合模式设置为 one" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">源混合模式设置为 one</figcaption></figure><p>这恢复了高光反射，但漫反射反射不再淡出。我们通过将表面 alpha 因子计入漫反射颜色来解决这个问题。因此，我们对漫反射进行预乘 alpha 处理，而不是稍后依赖 GPU 混合。这种方法被称为预乘 alpha 混合（premultiplied alpha blending）。在 <code class="language-plaintext highlighter-rouge">GetBRDF</code> 中执行此操作。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">surface</span><span class="p">.</span><span class="n">color</span> <span class="o">*</span> <span class="n">oneMinusReflectivity</span><span class="p">;</span>
    <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">*=</span> <span class="n">surface</span><span class="p">.</span><span class="n">alpha</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/premultiplied-diffuse.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/premultiplied-diffuse.png" alt="预乘漫反射" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">预乘漫反射</figcaption></figure><h3 id="42-预乘切换-premultiplication-toggle"><span class="me-2">4.2 预乘切换 (Premultiplication Toggle)</span><a href="#42-预乘切换-premultiplication-toggle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>将 alpha 与漫反射预乘有效地将对象变成了玻璃，而常规 alpha 混合使对象有效地仅部分存在。让我们通过为 <code class="language-plaintext highlighter-rouge">GetBRDF</code> 添加一个布尔参数来支持两者，以控制我们是否预乘 alpha，默认设置为 <code class="language-plaintext highlighter-rouge">false</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">BRDF</span> <span class="nf">GetBRDF</span> <span class="p">(</span><span class="k">inout</span> <span class="n">Surface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">bool</span> <span class="n">applyAlphaToDiffuse</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">applyAlphaToDiffuse</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">brdf</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">*=</span> <span class="n">surface</span><span class="p">.</span><span class="n">alpha</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="err">…</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们可以在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 中使用 <code class="language-plaintext highlighter-rouge">_PREMULTIPLY_ALPHA</code> 关键字来决定使用哪种方法，类似于我们控制 alpha 裁剪的方式。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_PREMULTIPLY_ALPHA)
</span>    <span class="n">BRDF</span> <span class="n">brdf</span> <span class="o">=</span> <span class="n">GetBRDF</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="cp">#else
</span>    <span class="n">BRDF</span> <span class="n">brdf</span> <span class="o">=</span> <span class="n">GetBRDF</span><span class="p">(</span><span class="n">surface</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="kt">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">GetLighting</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">brdf</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="n">alpha</span><span class="p">);</span>
</pre></table></code></div></div><p>为 <code class="language-plaintext highlighter-rouge">Lit</code> 的 Pass 添加关键字的着色器特征（shader feature）。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _CLIPPING
#pragma shader_feature _PREMULTIPLY_ALPHA
</span></pre></table></code></div></div><p>并为着色器也添加一个切换属性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">Toggle</span><span class="p">(</span><span class="n">_PREMULTIPLY_ALPHA</span><span class="p">)]</span> <span class="n">_PremulAlpha</span> <span class="p">(</span><span class="s">"Premultiply Alpha"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/premultiply-alpha-toggle.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/premultiply-alpha-toggle.png" alt="预乘 alpha 切换" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">预乘 alpha 切换</figcaption></figure><h2 id="5-着色器-gui-shader-gui"><span class="me-2">5 着色器 GUI (Shader GUI)</span><a href="#5-着色器-gui-shader-gui" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们现在支持多种渲染模式，每种模式都需要特定设置。为了更轻松地在模式之间切换，让我们为材质检查器添加一些按钮以应用预设配置。</p><h3 id="51-自定义着色器-gui-custom-shader-gui"><span class="me-2">5.1 自定义着色器 GUI (Custom Shader GUI)</span><a href="#51-自定义着色器-gui-custom-shader-gui" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在 <code class="language-plaintext highlighter-rouge">Lit</code> 着色器的主块底部添加一个 <code class="language-plaintext highlighter-rouge">CustomEditor "CustomShaderGUI"</code> 语句。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Custom RP/Lit"</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="n">CustomEditor</span> <span class="s">"CustomShaderGUI"</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这指示 Unity 编辑器使用 <code class="language-plaintext highlighter-rouge">CustomShaderGUI</code> 类的实例来绘制使用 <code class="language-plaintext highlighter-rouge">Lit</code> 着色器的材质的检查器。创建一个该类的脚本资产并将其放在一个新的 <code class="language-plaintext highlighter-rouge">Custom RP / Editor</code> 文件夹中。</p><p>我们需要使用 <code class="language-plaintext highlighter-rouge">UnityEditor</code>、<code class="language-plaintext highlighter-rouge">UnityEngine</code> 和 <code class="language-plaintext highlighter-rouge">UnityEngine.Rendering</code> 命名空间。该类必须继承 <code class="language-plaintext highlighter-rouge">ShaderGUI</code> 并重写公共 <code class="language-plaintext highlighter-rouge">OnGUI</code> 方法，该方法具有 <code class="language-plaintext highlighter-rouge">MaterialEditor</code> 和 <code class="language-plaintext highlighter-rouge">MaterialProperty</code> 数组参数。让它调用基类方法，这样我们最终得到默认的检查器。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">UnityEditor</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.Rendering</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CustomShaderGUI</span> <span class="p">:</span> <span class="n">ShaderGUI</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnGUI</span> <span class="p">(</span>
        <span class="n">MaterialEditor</span> <span class="n">materialEditor</span><span class="p">,</span> <span class="n">MaterialProperty</span><span class="p">[]</span> <span class="n">properties</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">base</span><span class="p">.</span><span class="nf">OnGUI</span><span class="p">(</span><span class="n">materialEditor</span><span class="p">,</span> <span class="n">properties</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="52-设置属性和关键字-setting-properties-and-keywords"><span class="me-2">5.2 设置属性和关键字 (Setting Properties and Keywords)</span><a href="#52-设置属性和关键字-setting-properties-and-keywords" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了完成我们的工作，我们需要访问三样东西，我们将它们存储在字段中。首先是材质编辑器，它是负责显示和编辑材质的基础编辑器对象。其次是对正在编辑的材质的引用，我们可以通过编辑器的 <code class="language-plaintext highlighter-rouge">targets</code> 属性检索它。它被定义为 <code class="language-plaintext highlighter-rouge">Object</code> 数组，因为 <code class="language-plaintext highlighter-rouge">targets</code> 是通用 <code class="language-plaintext highlighter-rouge">Editor</code> 类的属性。第三是可以编辑的属性数组。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>    <span class="n">MaterialEditor</span> <span class="n">editor</span><span class="p">;</span>
    <span class="n">Object</span><span class="p">[]</span> <span class="n">materials</span><span class="p">;</span>
    <span class="n">MaterialProperty</span><span class="p">[]</span> <span class="n">properties</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnGUI</span> <span class="p">(</span>
        <span class="n">MaterialEditor</span> <span class="n">materialEditor</span><span class="p">,</span> <span class="n">MaterialProperty</span><span class="p">[]</span> <span class="n">properties</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">base</span><span class="p">.</span><span class="nf">OnGUI</span><span class="p">(</span><span class="n">materialEditor</span><span class="p">,</span> <span class="n">properties</span><span class="p">);</span>
        <span class="n">editor</span> <span class="p">=</span> <span class="n">materialEditor</span><span class="p">;</span>
        <span class="n">materials</span> <span class="p">=</span> <span class="n">materialEditor</span><span class="p">.</span><span class="n">targets</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">properties</span> <span class="p">=</span> <span class="n">properties</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><p><strong>为什么有多个材质？</strong> 可以同时编辑使用相同着色器的多个材质，就像你可以选择并编辑多个游戏对象一样。</p></blockquote><p>要设置属性，我们首先必须在数组中找到它，为此我们可以使用 <code class="language-plaintext highlighter-rouge">ShaderGUI.FindProperty</code> 方法，传递名称和属性数组。然后我们可以通过给其 <code class="language-plaintext highlighter-rouge">floatValue</code> 属性赋值来调整其值。将其封装在一个方便的、带有名称和值参数的 <code class="language-plaintext highlighter-rouge">SetProperty</code> 方法中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">SetProperty</span> <span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">float</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">FindProperty</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">properties</span><span class="p">).</span><span class="n">floatValue</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>设置关键字稍微复杂一些。我们将为此创建一个 <code class="language-plaintext highlighter-rouge">SetKeyword</code> 方法，它带有一个名称和一个布尔参数，指示是启用还是禁用该关键字。我们必须在所有材质上调用 <code class="language-plaintext highlighter-rouge">EnableKeyword</code> 或 <code class="language-plaintext highlighter-rouge">DisableKeyword</code>，并向它们传递关键字名称。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">SetKeyword</span> <span class="p">(</span><span class="kt">string</span> <span class="n">keyword</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">materials</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">m</span><span class="p">.</span><span class="nf">EnableKeyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">materials</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">m</span><span class="p">.</span><span class="nf">DisableKeyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>让我们还创建一个 <code class="language-plaintext highlighter-rouge">SetProperty</code> 变体，用于切换属性-关键字组合。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">SetProperty</span> <span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span> <span class="n">keyword</span><span class="p">,</span> <span class="kt">bool</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">SetProperty</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">value</span> <span class="p">?</span> <span class="m">1f</span> <span class="p">:</span> <span class="m">0f</span><span class="p">);</span>
        <span class="nf">SetKeyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>现在我们可以定义简单的 <code class="language-plaintext highlighter-rouge">Clipping</code>、<code class="language-plaintext highlighter-rouge">PremultiplyAlpha</code>、<code class="language-plaintext highlighter-rouge">SrcBlend</code>、<code class="language-plaintext highlighter-rouge">DstBlend</code> 和 <code class="language-plaintext highlighter-rouge">ZWrite</code> 设置器属性。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>    <span class="kt">bool</span> <span class="n">Clipping</span> <span class="p">{</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetProperty</span><span class="p">(</span><span class="s">"_Clipping"</span><span class="p">,</span> <span class="s">"_CLIPPING"</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">PremultiplyAlpha</span> <span class="p">{</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetProperty</span><span class="p">(</span><span class="s">"_PremulAlpha"</span><span class="p">,</span> <span class="s">"_PREMULTIPLY_ALPHA"</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">BlendMode</span> <span class="n">SrcBlend</span> <span class="p">{</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetProperty</span><span class="p">(</span><span class="s">"_SrcBlend"</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">BlendMode</span> <span class="n">DstBlend</span> <span class="p">{</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetProperty</span><span class="p">(</span><span class="s">"_DstBlend"</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">ZWrite</span> <span class="p">{</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetProperty</span><span class="p">(</span><span class="s">"_ZWrite"</span><span class="p">,</span> <span class="k">value</span> <span class="p">?</span> <span class="m">1f</span> <span class="p">:</span> <span class="m">0f</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>最后，渲染队列通过分配给所有材质的 <code class="language-plaintext highlighter-rouge">renderQueue</code> 属性来设置。我们可以为此使用 <code class="language-plaintext highlighter-rouge">RenderQueue</code> 枚举。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="n">RenderQueue</span> <span class="n">RenderQueue</span> <span class="p">{</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Material</span> <span class="n">m</span> <span class="k">in</span> <span class="n">materials</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">m</span><span class="p">.</span><span class="n">renderQueue</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><h3 id="53-预设按钮-preset-buttons"><span class="me-2">5.3 预设按钮 (Preset Buttons)</span><a href="#53-预设按钮-preset-buttons" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>可以通过 <code class="language-plaintext highlighter-rouge">GUILayout.Button</code> 方法创建一个按钮，并向其传递一个标签，该标签将是预设的名称。如果该方法返回 <code class="language-plaintext highlighter-rouge">true</code>，则表示它被按下了。在应用预设之前，我们应该向编辑器注册一个撤消步骤，这可以通过调用 <code class="language-plaintext highlighter-rouge">RegisterPropertyChangeUndo</code> 并向其传递名称来完成。由于此代码对于所有预设都是相同的，因此将其放在一个 <code class="language-plaintext highlighter-rouge">PresetButton</code> 方法中，该方法返回是否应应用预设。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="kt">bool</span> <span class="nf">PresetButton</span> <span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">GUILayout</span><span class="p">.</span><span class="nf">Button</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">editor</span><span class="p">.</span><span class="nf">RegisterPropertyChangeUndo</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>我们将为每个预设创建一个单独的方法，从默认的 <code class="language-plaintext highlighter-rouge">Opaque</code> 模式开始。让它在激活时适当地设置属性。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">OpaquePreset</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">PresetButton</span><span class="p">(</span><span class="s">"Opaque"</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Clipping</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">PremultiplyAlpha</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">SrcBlend</span> <span class="p">=</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">One</span><span class="p">;</span>
            <span class="n">DstBlend</span> <span class="p">=</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">Zero</span><span class="p">;</span>
            <span class="n">ZWrite</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">RenderQueue</span> <span class="p">=</span> <span class="n">RenderQueue</span><span class="p">.</span><span class="n">Geometry</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>第二个预设是 <code class="language-plaintext highlighter-rouge">Clip</code>，它是 <code class="language-plaintext highlighter-rouge">Opaque</code> 的副本，打开了裁剪并将队列设置为 <code class="language-plaintext highlighter-rouge">AlphaTest</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">ClipPreset</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">PresetButton</span><span class="p">(</span><span class="s">"Clip"</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Clipping</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">PremultiplyAlpha</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">SrcBlend</span> <span class="p">=</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">One</span><span class="p">;</span>
            <span class="n">DstBlend</span> <span class="p">=</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">Zero</span><span class="p">;</span>
            <span class="n">ZWrite</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">RenderQueue</span> <span class="p">=</span> <span class="n">RenderQueue</span><span class="p">.</span><span class="n">AlphaTest</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>第三个预设是标准透明度，它会淡出对象，所以我们将它命名为 <code class="language-plaintext highlighter-rouge">Fade</code>。它是 <code class="language-plaintext highlighter-rouge">Opaque</code> 的另一个副本，调整了混合模式和队列，另外没有深度写入。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">FadePreset</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">PresetButton</span><span class="p">(</span><span class="s">"Fade"</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Clipping</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">PremultiplyAlpha</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">SrcBlend</span> <span class="p">=</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">SrcAlpha</span><span class="p">;</span>
            <span class="n">DstBlend</span> <span class="p">=</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">OneMinusSrcAlpha</span><span class="p">;</span>
            <span class="n">ZWrite</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">RenderQueue</span> <span class="p">=</span> <span class="n">RenderQueue</span><span class="p">.</span><span class="n">Transparent</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>第四个预设是 <code class="language-plaintext highlighter-rouge">Fade</code> 的变体，它应用预乘 alpha 混合。我们将它命名为 <code class="language-plaintext highlighter-rouge">Transparent</code>，因为它适用于具有正确光照的半透明表面。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">TransparentPreset</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">PresetButton</span><span class="p">(</span><span class="s">"Transparent"</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Clipping</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">PremultiplyAlpha</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">SrcBlend</span> <span class="p">=</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">One</span><span class="p">;</span>
            <span class="n">DstBlend</span> <span class="p">=</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">OneMinusSrcAlpha</span><span class="p">;</span>
            <span class="n">ZWrite</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">RenderQueue</span> <span class="p">=</span> <span class="n">RenderQueue</span><span class="p">.</span><span class="n">Transparent</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">OnGUI</code> 末尾调用预设方法，这样它们就会显示在默认检查器下方。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnGUI</span> <span class="p">(</span>
        <span class="n">MaterialEditor</span> <span class="n">materialEditor</span><span class="p">,</span> <span class="n">MaterialProperty</span><span class="p">[]</span> <span class="n">properties</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="err">…</span>
        <span class="nf">OpaquePreset</span><span class="p">();</span>
        <span class="nf">ClipPreset</span><span class="p">();</span>
        <span class="nf">FadePreset</span><span class="p">();</span>
        <span class="nf">TransparentPreset</span><span class="p">();</span>
    <span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/preset-buttons.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/preset-buttons.png" alt="预设按钮" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">预设按钮</figcaption></figure><h3 id="54-预设折叠-preset-foldout"><span class="me-2">5.4 预设折叠 (Preset Foldout)</span><a href="#54-预设折叠-preset-foldout" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>预设按钮不会经常使用，所以让我们把它们放在一个默认折叠的折叠栏（foldout）里。这通过调用 <code class="language-plaintext highlighter-rouge">EditorGUILayout.Foldout</code> 来完成，传入当前的折叠状态、标签和 <code class="language-plaintext highlighter-rouge">true</code> 以指示点击它应该切换其状态。它返回新的折叠状态，我们应该将其存储在一个字段中。仅当折叠栏打开时才绘制按钮。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>    <span class="kt">bool</span> <span class="n">showPresets</span><span class="p">;</span>
    <span class="err">…</span>
    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnGUI</span> <span class="p">(</span>
        <span class="n">MaterialEditor</span> <span class="n">materialEditor</span><span class="p">,</span> <span class="n">MaterialProperty</span><span class="p">[]</span> <span class="n">properties</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="err">…</span>
        <span class="n">EditorGUILayout</span><span class="p">.</span><span class="nf">Space</span><span class="p">();</span>
        <span class="n">showPresets</span> <span class="p">=</span> <span class="n">EditorGUILayout</span><span class="p">.</span><span class="nf">Foldout</span><span class="p">(</span><span class="n">showPresets</span><span class="p">,</span> <span class="s">"Presets"</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">showPresets</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">OpaquePreset</span><span class="p">();</span>
            <span class="nf">ClipPreset</span><span class="p">();</span>
            <span class="nf">FadePreset</span><span class="p">();</span>
            <span class="nf">TransparentPreset</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/foldout.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/foldout.png" alt="预设折叠" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">预设折叠</figcaption></figure><h3 id="55-不发光预设-presets-for-unlit"><span class="me-2">5.5 不发光预设 (Presets for Unlit)</span><a href="#55-不发光预设-presets-for-unlit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们也可以为我们的 <code class="language-plaintext highlighter-rouge">Unlit</code> 着色器使用自定义着色器 GUI。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Custom RP/Unlit"</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="n">CustomEditor</span> <span class="s">"CustomShaderGUI"</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但是，激活预设将导致错误，因为我们正试图设置着色器没有的属性。我们可以通过调整 <code class="language-plaintext highlighter-rouge">SetProperty</code> 来防范这种情况。让它通过 <code class="language-plaintext highlighter-rouge">false</code> 作为额外参数调用 <code class="language-plaintext highlighter-rouge">FindProperty</code>，指示如果找不到属性，则不应记录错误。结果将为 <code class="language-plaintext highlighter-rouge">null</code>，所以只有在这种情况下才设置值。同时返回属性是否存在。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="kt">bool</span> <span class="nf">SetProperty</span> <span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">float</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MaterialProperty</span> <span class="n">property</span> <span class="p">=</span> <span class="nf">FindProperty</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">property</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">property</span><span class="p">.</span><span class="n">floatValue</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>然后调整 <code class="language-plaintext highlighter-rouge">SetProperty</code> 的关键字版本，使其仅在相关属性存在时才设置关键字。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="k">void</span> <span class="nf">SetProperty</span> <span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span> <span class="n">keyword</span><span class="p">,</span> <span class="kt">bool</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">SetProperty</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">value</span> <span class="p">?</span> <span class="m">1f</span> <span class="p">:</span> <span class="m">0f</span><span class="p">))</span> <span class="p">{</span>
            <span class="nf">SetKeyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><h3 id="56-无透明度-no-transparency"><span class="me-2">5.6 无透明度 (No Transparency)</span><a href="#56-无透明度-no-transparency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>现在预设也适用于使用 <code class="language-plaintext highlighter-rouge">Unlit</code> 着色器的材质，尽管在这种情况下 <code class="language-plaintext highlighter-rouge">Transparent</code> 模式没有太大意义，因为相关属性不存在。让我们在不相关时隐藏此预设。</p><p>首先，添加一个返回属性是否存在的 <code class="language-plaintext highlighter-rouge">HasProperty</code> 方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="kt">bool</span> <span class="nf">HasProperty</span> <span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="nf">FindProperty</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="p">!=</span> <span class="k">null</span><span class="p">;</span>
</pre></table></code></div></div><p>其次，创建一个方便的属性来检查 <code class="language-plaintext highlighter-rouge">_PremultiplyAlpha</code> 是否存在。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="kt">bool</span> <span class="n">HasPremultiplyAlpha</span> <span class="p">=&gt;</span> <span class="nf">HasProperty</span><span class="p">(</span><span class="s">"_PremulAlpha"</span><span class="p">);</span>
</pre></table></code></div></div><p>最后，通过在 <code class="language-plaintext highlighter-rouge">TransparentPreset</code> 中首先检查该属性，使 <code class="language-plaintext highlighter-rouge">Transparent</code> 预设的所有内容都以该属性为条件。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">HasPremultiplyAlpha</span> <span class="p">&amp;&amp;</span> <span class="nf">PresetButton</span><span class="p">(</span><span class="s">"Transparent"</span><span class="p">))</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp3/no-transparent-preset.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp3/no-transparent-preset.png" alt="不发光材质缺少透明预设" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">不发光材质缺少透明预设</figcaption></figure><p>下一篇<a href="../">方向阴影 (Directional Shadows)</a>。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/scriptrenderpipeline/">ScriptRenderPipeline</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/srp/" class="post-tag no-text-decoration" >SRP</a> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:%E6%96%B9%E5%90%91%E5%85%89%20(%E7%BF%BB%E8%AF%91%E4%B8%89)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Fdirectional-lights%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:%E6%96%B9%E5%90%91%E5%85%89%20(%E7%BF%BB%E8%AF%91%E4%B8%89)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Fdirectional-lights%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Fdirectional-lights%2F&text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:%E6%96%B9%E5%90%91%E5%85%89%20(%E7%BF%BB%E8%AF%91%E4%B8%89)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/rustom-render-pipeline/">自定义渲染管线:掌控渲染流程 (翻译一)</a><li class="text-truncate lh-lg"> <a href="/posts/drawcalls-shaders-batches/">自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</a><li class="text-truncate lh-lg"> <a href="/posts/flat-and-wireframe-shading/">平面着色与线框着色(翻译二十一)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-tessellation/">曲面细分(翻译二十二)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-surface-displacement/">曲面细分表面置换(翻译二十三)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/drawcalls-shaders-batches/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1572451200" data-df="ll" > Oct 31, 2019 </time><h4 class="pt-0 my-2">自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</h4><div class="text-muted"><p>编写一个 HLSL shader 支持 SRP batcher、GPU instancing 以及 dynamic batching 为每个对象配置材质属性，并随机绘制多个对象 创建透明（transparent）和镂空（cutout）材质 Shaders 为了绘制物体，CPU 必须告诉 GPU 绘制什么以及如何绘制。绘制的内容通常是一个 mesh。如何绘制则由 shad...</p></div></div></a></article><article class="col"> <a href="/posts/rustom-render-pipeline/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1569427200" data-df="ll" > Sep 26, 2019 </time><h4 class="pt-0 my-2">自定义渲染管线:掌控渲染流程 (翻译一)</h4><div class="text-muted"><p>这是关于创建自定义脚本化渲染管线（Scriptable Render Pipeline, SRP）的系列教程的第一部分。它涵盖了我们将要在未来扩展的准系统渲染管线的初始创建。 创建渲染管线资源和实例 渲染摄像机视图 执行剔除、过滤和排序 分离不透明、透明和无效阶段 处理多个摄像机。 1 Render Pipeline 为了渲染任何内容，Unity 必须确定需...</p></div></div></a></article><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_2/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515333600" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展二(翻译十)</h4><div class="text-muted"><p>本篇摘要: 把自身阴影烘焙进材质 增加细节纹理部分 支持更丰富的shader变体 一次编辑多个材质球 遮挡区域的Self-Shading 美术能够创作非常复杂丰富的表面纹理，它只是一个视错觉。为了增强表面纹理视觉真实感，引入Self-Shading。 如何增强呢？通常我们使用了法线来增强模型表面的凹凸层次感，法线带来的视觉增强是第一步，但是法线只适用于采样直接光...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/drawcalls-shaders-batches/" class="btn btn-outline-primary" aria-label="Older" ><p>自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</p></a> <a href="/posts/claude-code-guide/" class="btn btn-outline-primary" aria-label="Newer" ><p>Claude Code学习总结：目录导航</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
