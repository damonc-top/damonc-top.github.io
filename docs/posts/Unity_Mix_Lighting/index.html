<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Unity 混合光照(翻译十七)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="本篇摘要： 只烘焙间接光 混合烘焙阴影和实时阴影 处理代码的变化和问题 支持消减光照（subtractivelighting）" /><meta property="og:description" content="本篇摘要： 只烘焙间接光 混合烘焙阴影和实时阴影 处理代码的变化和问题 支持消减光照（subtractivelighting）" /><link rel="canonical" href="www.damonc.top/posts/Unity_Mix_Lighting/" /><meta property="og:url" content="www.damonc.top/posts/Unity_Mix_Lighting/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/2018/month1/catRender17/tutorial-image.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-01-21T20:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/2018/month1/catRender17/tutorial-image.png" /><meta property="twitter:title" content="Unity 混合光照(翻译十七)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2026-02-15T22:53:15+08:00","datePublished":"2018-01-21T20:00:00+08:00","description":"本篇摘要： 只烘焙间接光 混合烘焙阴影和实时阴影 处理代码的变化和问题 支持消减光照（subtractivelighting）","headline":"Unity 混合光照(翻译十七)","image":{"lqip":"data:image/webp;base64,UklGRlIAAABXRUJQVlA4IEYAAAAQAwCdASoUAAoAP3Ggxlk0q6ejsAgCkC4JQBdgBaDzS+AA/uSYgm5/IMnr9IlmSfSARhrRXMH9rzOSHzBlbXfEeEP6KAAA","url":"https://img.damonc.top/posts/2018/month1/catRender17/tutorial-image.png","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/Unity_Mix_Lighting/"},"url":"www.damonc.top/posts/Unity_Mix_Lighting/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>Unity 混合光照(翻译十七) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js,npm/mermaid@11.12.0/dist/mermaid.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘摊手</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Unity 混合光照(翻译十七)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>Unity 混合光照(翻译十七)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1516536000" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jan 21, 2018 </time> </span> <span> Updated <time data-ts="1771167195" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 15, 2026 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/tutorial-image.png" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/2018/month1/catRender17/tutorial-image.png" alt="Preview Image" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRlIAAABXRUJQVlA4IEYAAAAQAwCdASoUAAoAP3Ggxlk0q6ejsAgCkC4JQBdgBaDzS+AA/uSYgm5/IMnr9IlmSfSARhrRXMH9rzOSHzBlbXfEeEP6KAAA"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/Unity_Mix_Lighting/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="6682 words" > <em>37 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">Unity 混合光照(翻译十七)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">Unity 混合光照(翻译十七)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><p>本篇摘要：</p><ul><li>只烘焙间接光<li>混合烘焙阴影和实时阴影<li>处理代码的变化和问题<li>支持消减光照（subtractivelighting）</ul><hr /><h2 id="烘焙间接光"><span class="me-2">烘焙间接光</span><a href="#烘焙间接光" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>光照贴图可以提供预计算光照：以纹理内存为代价减少了GPU在实时中的工作量；还加入了间接光。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>烘焙光的限制
    1.高光不能被烘焙
    2.烘焙光只通过光照探头影响动态物体
    3.烘焙光不产生实时阴影
</pre></table></code></div></div><p>你可以在下面的截图中看到完全实时光照和完全烘焙光照之间的区别。<a href="https://www.damonc.top/2018/01/19/Unity_Static_Lightting/">前一篇</a>教程中的一个场景，唯一的不同是我将所有的球体都设置为动态并重新改变了一些球体的位置。其它一切都是静态的。这是使 用前向渲染的方法。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002309942-1932595350.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002309942-1932595350.png" alt="完全实时和完全烘焙光照" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002311276-1707091650.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002311276-1707091650.png" alt="完全实时和完全烘焙光照" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="混合模式"><span class="me-2">混合模式</span><a href="#混合模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>烘焙光照有间接光而没有实时光照，因为间接光需要光照贴图。由于间接光可以为场景加入很大的真实感，如果我们可以将它和实时光照融合在一起就再好不过了。这是可以的，但也意味着着色的开销会增加。我们需要将混合光（Mixed Lighting）的光照模式（Lighting Mode）设置为烘焙间接（Baked Indirect）。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002312394-324532807.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002312394-324532807.png" alt="混合光照，烘焙间接" width="100%" height="auto" loading="lazy"></a></div></div><p>我们已经在<a href="https://www.damonc.top/2018/01/19/Unity_Static_Lightting/">前一篇</a>教程中切换到这个模式了，但是之前 we 只使用了完全烘焙光照。虽然表现结果与完全烘焙光照相同，混合光照模式没有任何区别。为了使用混合光照，光源的模式必须要设置为混合。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002313374-471117722.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002313374-471117722.png" alt="混合模式的主光源" width="100%" height="auto" loading="lazy"></a></div></div><p>在将主定向光改为混合光后，两件事会发生：</p><p>第一，Unity会再次烘焙光照贴图。这一次光照贴图只会存储间接光，所以它会比之前的暗很多。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002314496-2053721233.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002314496-2053721233.png" alt="完全烘焙的光照贴图 vs 只有间接光的光照贴图" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002315595-1655913714.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002315595-1655913714.png" alt="完全烘焙的光照贴图 vs 只有间接光的光照贴图" width="100%" height="auto" loading="lazy"></a></div></div><p>第二，所有物体都会像主光源被设置为实时那样被照亮。只有一点不同：光照贴图被用来为静态物体添加间接光，而不是球谐光或探头。动态物体的间接光仍要使用光照探头。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002316908-68636833.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002316908-68636833.png" alt="混合光照，实时直接光照烘焙间接光" width="100%" height="auto" loading="lazy"></a></div></div><p>我们不需要改变我们的着色器来支持这点，因为前向基础通道（forward base pass）已经融合了光照贴图数据和主定向光源。和往常一样，额外的光照会得到附加通道（additive pass）。当使用延迟渲染通道时，主光源也会得到一个通道。</p><p><strong>混合光可以在运行时调整吗？</strong><br /> 是的，因为它们被用于实时光照。但是，它们的烘焙数据时静态的。所以在运行时你只能稍微调整光照，比如稍微调整它的强度。更大的变化会使人明显看出烘焙光照和实时光照之间的不同步。_</p><h3 id="更新着色器"><span class="me-2">更新着色器</span><a href="#更新着色器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>刚开始一切似乎正常运行。但是，定向光的阴影衰减发生了错误。我们通过极大降低阴影距离观察到阴影被剪掉了。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002318408-928334072.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002318408-928334072.png" alt="阴影衰减，标准着色器vs我们的着色器" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002319957-145579115.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002319957-145579115.png" alt="阴影衰减，标准着色器vs我们的着色器" width="100%" height="auto" loading="lazy"></a></div></div><p>虽然Unity很长一段时间都有混合光照模式，但实际上它在Unity5中就不起作用了。Unity5.6中新加入了一个混合光照模式，即我们现在使用的这个。当该新模式被加入时，_UNITY_LIGHT_ATTENUATION_宏下面的代码发生了变化。我们在使用完全烘焙光照或者实时光照时没有注意到这一点，但是我们必须更新我们的代码以适应混合光照的新方法。由于这是最近的一个巨大的变化，我们必须要注意它所带来的问题。</p><p>我们要改变的第一点是不再使用_SHADOW_COORDS_宏来定义阴影坐标的插值（interpolater）。我们必须使用新的_UNITY_SHADOW_COORDS_宏来代替它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Interpolators</span>
<span class="p">{</span>
    <span class="c1">//SHADOW_COORDS(5)</span>
    <span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">};</span>
</pre></table></code></div></div><p>同样，<em>TRANSFER_SHADOW_应该替换为_UNITY_TRANSFER_SHADOW</em></p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//TRANSFER_SHADOW(i);</span>
    <span class="n">UNITY_TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   
<span class="p">}</span>
</pre></table></code></div></div><p>然而，这会产生一个编译错误，因为该宏需要一个额外的参数。从Unity 5.6开始，只有定向阴影的屏幕空间坐标中被放入一个插值。点光源和聚光源的阴影坐标现在在片段程序（fragment program）中进行计算。有个新变化：在一些情况中光照贴图的坐标被用在阴影蒙版 （shadow mask）中，我们会在后面讲解这一点。为了该宏能正常工作，我们必须为它提供第二个UV通道中的数据，其中包含光照贴图的坐标。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">UNITY_TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">);</span>

</pre></table></code></div></div><p>这样会再次产生一个编译错误。这是因为在一些情况下_UNITY_SHADOW_COORDS_错误地创建了一个插值，尽管实际上并不需要。在这种情况下，_TRANSFER_SHADOW_不会初始化它，因而导致错误。这个问题出现在5.6.0中，一直到5.6.2和2017.1.0beta版本中都有。</p><p>人们通常不会注意到这个问题，因为Unity的标准着色器使用_UNITY_INITIALIZE_OUTPUT_宏来完全地初始化它的插值结构体。因为我们不使用这个宏，所以出现了问题。为了解决它，我们使用_UNITY_INITIALIZE_OUTPUT_宏来初始化我们的插值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>  
<span class="p">}</span>
</pre></table></code></div></div><p>_UNITY_INITIALIZE_OUTPUT_有什么作用？</p><p>它只是为变量分配数值0，将其转换为正确的类型。至少是当程序支持该宏时会这样，否则它不会做任何事。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// Initialize arbitrary structure with zero values.</span>
<span class="c1">// Not supported on some backends</span>
<span class="c1">// (e.g. Cg-based particularly with nested structs).</span>
<span class="c1">// hlsl2glsl would almost support it, except with structs that have</span>
<span class="n">arrays</span>
<span class="c1">// -- so treat as not supported there either :(</span>
<span class="cp">#if defined(UNITY_COMPILER_HLSL) || defined(SHADER_API_PSSL) || 
</span><span class="n">defined</span><span class="p">(</span><span class="n">UNITY_COMPILER_HLSLCC</span><span class="p">)</span>
    <span class="cp">#define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
#else
</span>    <span class="cp">#define UNITY_INITIALIZE_OUTPUT(type,name)
#endif
</span></pre></table></code></div></div><p><strong>通常我们倾向于只使用显式赋值，很少使用这个初始化插值宏。</strong></p><h3 id="手动衰减阴影"><span class="me-2">手动衰减阴影</span><a href="#手动衰减阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>现在我们正确地使用了新的宏定义，但是主光源的阴影仍然没有按照它们应该的那样衰减。结果我们发现当同时使用定向阴影和光照贴图时，<em>UNITY_LIGHT_ATTENUATION</em> 不会对光源进行衰减。使用混合模式的主定向光源就会产生这个问题。所以我们必须手动设置。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>为什么在这个例子中阴影没有衰减？

1、UNITY_LIGHT_ATTENUATION宏之前是独立使用的，但是自从Unity5. 6它开始和Unity的标准全局光照函数一同使用。我们没有采用同样的方法，因此它不能正常工作。  
2、至于为什么要做这个改动，唯一的线索就是AutoLight中的一段注释：“为了性能的原因以GI函数的深度处理阴影”。由于着色器编译器会随意地移动代码。
</pre></table></code></div></div><p>对于我们的延迟光照着色器，我们已经有了进行阴影衰减的代码。将相关代码片段从MyDeferredShading中复制到My Lighting中的一个新函数中。唯一实际的区别在于我们必须使用视图向量和视图矩阵构建viewZ。我们只需要Z分量，所以无需进行一次完整的矩阵乘法。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">viewZ</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">UNITY_MATRIX_V</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>该手动衰减必须在使用了_UNITY_LIGHT_ATTENUATION初始化完成_之后。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>只有当 <em>HANDLE_SHADOW_BLENDING_IN_GI</em> 在UnityShadowLibrary.cginc文件中有定义时，FadeShadows才会开始计算。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI
</span>        <span class="c1">// UNITY_LIGHT_ATTENUATION doesn't fade shadows for us.</span>
        <span class="n">float</span> <span class="n">viewZ</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">UNITY_MATRIX_V</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，我们的阴影如它们应该的那样正常衰减了。</p><h2 id="使用阴影蒙版"><span class="me-2">使用阴影蒙版</span><a href="#使用阴影蒙版" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>烘焙间接光的混合模式成本很高。它们需要实时光照外加间接光的光照贴图那么大的工作量。它和完全烘焙光照相比最重要的是加入了实时阴影。幸运的是，有一个方法仍可以将阴影烘焙到光照贴图中，将其和实时阴影综合起来。为了开启这个功能，我们将混合光照模式改为Shadowmask。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002321275-2134383138.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002321275-2134383138.png" alt="Shadowmask模式" width="100%" height="auto" loading="lazy"></a></div></div><p>在这个模式中，混合光照的间接光和阴影衰减都存储在了光照贴图中。阴影被存储在一张额外的贴图（即阴影蒙版）。当只有主定向光源时，红色的阴影蒙版决定是否过滤被照亮的物体。红色是因为阴影信息被存储在纹理的R通道中。事实上，贴图中至多可以储存四个光照 的阴影，因为它只有四个通道。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002322323-849349388.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002322323-849349388.png" alt="烘焙的强度以及阴影蒙版" width="100%" height="auto" loading="lazy"></a></div></div><p>在Unity创建了阴影蒙版后，静态物体的阴影投射会消失。只有光照探头仍会处理它们。动态物体的阴影不受影响。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002323536-1775535799.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002323536-1775535799.png" alt="没有烘焙阴影" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="对阴影蒙版采样"><span class="me-2">对阴影蒙版采样</span><a href="#对阴影蒙版采样" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了重新得到烘焙阴影，我们必须对阴影蒙版采样样。Unity的宏已经对点光源和聚光源进行了取样，不过我们必须也要将它包含在我们的FadeShadows函数中。为此我们可以使用UnityShadowLibrary中的UnitySampleBakedOcclusions函数。它需要光照贴图的UV坐标和世界位置作为输入参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI
</span>        
        <span class="n">float</span> <span class="n">bakedAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleBakedOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>UnitySampleBakedOcclusion是什么样子的？

它使用光照贴图坐标对阴影蒙版取样，然后选择适当的通道。unity_OcclusionMaskSelector变量是一个含有一个分量的向量，该分量被设置为1以匹配当前正在被着色的光源。
</pre></table></code></div></div><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">fixed</span> <span class="nf">UnitySampleBakedOcclusion</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightmapUV</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">fixed4</span> <span class="n">rawOcclusionMask</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
                <span class="n">unity_ShadowMask</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">lightmapUV</span><span class="p">.</span><span class="n">xy</span>
            <span class="p">);</span>
        <span class="cp">#else
</span>            <span class="n">fixed4</span> <span class="n">rawOcclusionMask</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_ShadowMask</span><span class="p">,</span> <span class="n">lightmapUV</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="cp">#endif
</span>        <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">rawOcclusionMask</span><span class="p">,</span> <span class="n">unity_OcclusionMaskSelector</span><span class="p">));</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p><em>该函数还处理了光照探头代理体积的衰减，但是我们还没有支持这点所以我去掉了那部分的代码。这就是为什么该函数有一个世界位置的参数。</em></p><p>当使用阴影蒙版时，_UnitySampleBakedOcclusions_提供给我们烘焙阴影衰减，在其他情况下它的值都为1。现在我们必须将它和我们已经有的衰减综合起来然后对阴影进行衰减。UnityMixRealtimeAndBakedShadows函数为我们实现了这些。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">bakedAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleBakedOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
<span class="c1">//attenuation = saturate(attenuation shadowFade);</span>
<span class="n">attenuation</span> <span class="o">=</span> <span class="n">UnityMixRealtimeAndBakedShadows</span>
<span class="p">(</span>
    <span class="n">attenuation</span><span class="p">,</span> <span class="n">bakedAttenuation</span><span class="p">,</span> <span class="n">shadowFade</span>
<span class="p">);</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>UnityMixRealtimeAndBakedShadows是如何工作的？

它也是UnityShadowLibrary中的一个函数。它还处理光照探头代理体积以及一些其他极端情况。那些情况和我们无关，所以我删除了一些内容。
</pre></table></code></div></div><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">inline</span> <span class="n">half</span> <span class="nf">UnityMixRealtimeAndBakedShadows</span> <span class="p">(</span>
    <span class="n">half</span> <span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">half</span> <span class="n">bakedShadowAttenuation</span><span class="p">,</span> <span class="n">half</span> <span class="n">fade</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if !defined(SHADOWS_DEPTH) &amp;&amp; !defined(SHADOWS_SCREEN) &amp;&amp; 
</span>        <span class="o">!</span><span class="n">defined</span><span class="p">(</span><span class="n">SHADOWS_CUBE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bakedShadowAttenuation</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="cp">#if defined (LIGHTMAP_SHADOW_MIXING)
</span>            <span class="n">realtimeShadowAttenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span> <span class="o">+</span> <span class="n">fade</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">bakedShadowAttenuation</span><span class="p">);</span>
        <span class="cp">#else
</span>            <span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span>
                <span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">bakedShadowAttenuation</span><span class="p">,</span> <span class="n">fade</span>
            <span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#else //no shadowmask
</span>        <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span> <span class="o">+</span> <span class="n">fade</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p><strong>如果没有动态阴影，那么结果将得到烘焙的衰减。这意味着动态物体没有阴影，以及被映射到光照贴图上的物体没有烘焙阴影。</strong></p><p>当没有使用阴影蒙版时，它会进行原来的衰减。否则，它会根据我们是否做了阴影混合进行表现，我们后面再讲。现在，它只是在实时衰减和烘焙衰减之间进行一个插值。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002325094-888038969.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002325094-888038969.png" alt="实时阴影和阴影蒙版阴影" width="100%" height="auto" loading="lazy"></a></div></div><p>现在静态物体有了实时阴影和烘焙阴影，且它们正确地混合。实时阴影的衰减仍然超过了阴影距离，但是烘焙阴影没有。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002326606-1972314102.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002326606-1972314102.png" alt="只有实时阴影衰减了" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="添加一个阴影蒙版g-buffer"><span class="me-2">添加一个阴影蒙版G-Buffer</span><a href="#添加一个阴影蒙版g-buffer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>现在阴影蒙版可用于前向渲染路径，但是我们需要使它也可用于延迟渲染：添加阴影蒙版信息作为一个额外的G-缓存。所以当_SHADOWS_SHADOWMASK_被定义时，在_FragmentOutput_结构体中添加一个缓存。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">FragmentOutput</span> <span class="p">{</span>
    <span class="cp">#if defined(DEFERRED_PASS)
</span>        <span class="kt">float4</span> <span class="n">gBuffer0</span> <span class="o">:</span> <span class="n">SV_Target0</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer1</span> <span class="o">:</span> <span class="n">SV_Target1</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer2</span> <span class="o">:</span> <span class="n">SV_Target2</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer3</span> <span class="o">:</span> <span class="n">SV_Target3</span><span class="p">;</span>

        <span class="cp">#if defined(SHADOWS_SHADOWMASK)
</span>            <span class="kt">float4</span> <span class="n">gBuffer4</span> <span class="o">:</span> <span class="n">SV_Target4</span><span class="p">;</span>
        <span class="cp">#endif
</span>    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">SV_Target</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</pre></table></code></div></div><p>添加的第五个G-缓存，会使显存增大，并不是所有的平台(mobile)都支持它。Unity只在有足够多的渲染目标可用时才支持阴影蒙版，因此我们也应该这样做。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>    <span class="kt">float4</span> <span class="n">gBuffer4</span> <span class="o">:</span> <span class="n">SV_Target4</span><span class="p">;</span>
<span class="cp">#endif
</span>
</pre></table></code></div></div><p>我们只需在G-缓存中存储采样得到的阴影蒙版数据，而且没有一个确切的光照，为此我们可以使用_UnityGetRawBakedOcclusions_函数，它与_UnitySampleBakedOcclusion_相似，唯一不同在于它没有选择某个纹理通道。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">FragmentOutput</span> <span class="n">output</span><span class="p">;</span>
<span class="cp">#if defined(DEFERRED_PASS)
</span>    <span class="cp">#if !defined(UNITY_HDR_ON)
</span>        <span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">exp2</span><span class="p">(</span><span class="o">-</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer0</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">albedo</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer0</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">GetOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer1</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">specularTint</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer1</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">GetSmoothness</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer2</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer3</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>        <span class="n">output</span><span class="p">.</span><span class="n">gBuffer4</span> <span class="o">=</span> <span class="n">UnityGetRawBakedOcclusions</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="cp">#endif
#else
</span>    <span class="n">output</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">ApplyFog</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>为了可以在没有光照贴图的时候也能成功编译，当光照贴图坐标不可用时我们使用0代替它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>    <span class="kt">float2</span> <span class="n">shadowUV</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="n">shadowUV</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer4</span> <span class="o">=</span> <span class="n">UnityGetRawBakedOcclusions</span><span class="p">(</span><span class="n">shadowUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="cp">#endif
</span>
</pre></table></code></div></div><h3 id="使用阴影蒙版g-缓存"><span class="me-2">使用阴影蒙版G-缓存</span><a href="#使用阴影蒙版g-缓存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>调整MyDeferredShading延迟渲染着色器。</p><p>第一步先添加额外的一个G-buffer变量。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture0</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture1</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture2</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture4</span><span class="p">;</span>
</pre></table></code></div></div><p>第二步，创建一个函数来得到适当的阴影衰减。如果有了阴影蒙版，可通过对纹理采样然后和_unity_OcclusionMaskSelector_进行一次颜色饱和点乘。这个变量是在_UnityShaderVariables.cginc_中定义的，包含了一个用于选择当前正在被渲染的光照通道的向量。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetShadowMaskAttenuation</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="kt">float4</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_CameraGBufferTexture4</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">unity_OcclusionMaskSelector</span><span class="p">));</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在CreateLight中，即使当前光照没有实时阴影，我们在有阴影蒙版时也要衰减阴影。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">,</span> <span class="n">float</span> <span class="n">viewZ</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(SHADOWS_SHADOWMASK)
</span>        <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> 
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>为了正确地包含烘焙阴影，再次使用UnityMixRealtimeAndBakedShadows代替之前的衰减计算。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
<span class="c1">//  shadowAttenuation = saturate(shadowAttenuation + shadowFade);</span>
    <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="n">UnityMixRealtimeAndBakedShadows</span><span class="p">(</span>
        <span class="n">shadowAttenuation</span><span class="p">,</span> <span class="n">GetShadowMaskAttenuation</span><span class="p">(</span><span class="n">uv</span><span class="p">),</span> <span class="n">shadowFade</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在也可以使用自定义的延迟光照着色器得到正确的烘焙阴影了。例外，即当我们的优化分支被使用时会跳过阴影混合。该捷径在阴影蒙版被使用时不可用。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="cp">#if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT)
</span>        <span class="cp">#if !defined(SHADOWS_SHADOWMASK)
</span>            <span class="n">UNITY_BRANCH</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">shadowFade</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><h3 id="阴影蒙版-距离模式-distance-shadowmask"><span class="me-2">阴影蒙版-距离模式 DIstance Shadowmask</span><a href="#阴影蒙版-距离模式-distance-shadowmask" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然使用阴影蒙版模式我们可以得到不错的静态物体的烘焙阴影，动态物体却不能从中获利。动态物体只能接收到实时阴影以及光照探头数据。如果我们希望得到动态物体的阴影，那么静态物体必须也要投射实时阴影。这里的混合光照模式我们要用到距离阴影蒙版（Distance Shadowmask）了。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002327719-433885054.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002327719-433885054.png" alt="距离阴影蒙版模式" width="100%" height="auto" loading="lazy"></a></div></div><p><em>在2017及以上，使用哪个阴影蒙版模式是通过质量设置进行控制。</em></p><p>当使用DistanceShadowmask模式时，所有物体都使用实时阴影。第一眼看去，好像和Baked Indirect模式完全一样。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002329008-1483902900.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002329008-1483902900.png" alt="所有物体都有实时阴影" width="100%" height="auto" loading="lazy"></a></div></div><p>不过这里仍有一个阴影蒙版。在这个模式中，烘焙阴影和光照探头的使用超出了阴影距离。因此该模式是成本最高的模式，在阴影距离范围内等价于烘焙间接模式，超出该范围则等价于阴影蒙版模式。</p><p>前面已经支持这个模式了，因为我们正在使用UnityMixRealtimeAndBakedShadows。为了正确地混合完全实时阴影和烘焙阴影，它像往常那样衰减实时阴影，然后取其和烘焙阴影的最小值。</p><h3 id="多重光照"><span class="me-2">多重光照</span><a href="#多重光照" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为阴影蒙版有四个通道，它可以最多同时支持4个光照体积重叠在一起</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002330331-1413395037.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002330331-1413395037.png" alt="四个光源，都是混合光" width="100%" height="auto" loading="lazy"></a></div></div><p><strong>主方向光源的阴影仍存储在R通道中</strong>。你还能够看到存储在G通道和B通道中的聚光源的阴影，最后一个聚光源的阴影存储在A通道中。</p><p>当光照体积不重叠时，它们使用相同的通道来存储它们的阴影数据。所以你可以有任意多个混合光照。但是你必须<strong>确保至多四个光照体积彼此重叠</strong>。如果有太多个混合光影响同一篇区域，那么一些就会改回到完全烘焙模式。为了说明这一点，下面这张截图显示的是在多加入一个聚光源以后的光照贴图。你可以在强度贴图中清楚地看到其中一个已经变成了烘焙光。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002332758-586177298.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002332758-586177298.png" alt="5个重叠的光照，其中一个为完全烘焙光" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002333778-925731185.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002333778-925731185.png" alt="5个重叠的光照，其中一个为完全烘焙光" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="支持多个有蒙版的定向光"><span class="me-2">支持多个有蒙版的定向光</span><a href="#支持多个有蒙版的定向光" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>不幸的是，阴影蒙版只有当包含至多一个混合模式的方向光源存在时才能正常工作。对于额外的方向光，阴影衰减会发生错误，至少是在使用前向渲染通道时。延迟渲染倒没有问题。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002335110-966052747.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002335110-966052747.png" alt="两个方向光源产生错误的衰减" width="100%" height="auto" loading="lazy"></a></div></div><p>这是使用UNITY_LIGHT_ATTENUATION的新方法中的一个漏洞：Unity使用通过UNITY_SHADOW_COORDS定义的阴影插值来存储方向阴影的屏幕空间坐标，或者其它拥有阴影蒙版的光源的光照贴图坐标。</p><p>使用阴影蒙版的方向光还需要光照贴图坐标。在forward-render中，这些坐标会被包含，因为LIGHTMAP_ON会在需要的时候被定义。然而，LIGHTMAP_ON在additional-pass中永远不会被定义。这意味着多余的方向光没有可用的光照贴图坐标。结果UNITY_LIGHT_ATTENUATION在这种情况下只会使用0，导致错误的光照贴图采样</p><p>所以我们不能依靠UNITY_LIGHT_ATTENUATION额外获得使用阴影蒙版的方向光源。用屏幕空间的方向阴影</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2)
</span>    
<span class="cp">#endif
#if !defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; !defined(UNITY_NO_SCREENSPACE_SHADOWS)
</span>        <span class="cp">#define ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS 1
</span>    <span class="cp">#endif
#endif
</span></pre></table></code></div></div><p>接下来，对那些额外有蒙版的定向阴影，我们也要包含光照贴图坐标。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="kt">float2</span> <span class="n">lightmapUV</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span>    
<span class="p">}</span>
</pre></table></code></div></div><p>当光照贴图坐标可用时，我们可以再次使用FadeShadows函数进行我们自己控制的衰减。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但是，这仍然不正确，因为我们为其输入了错误的衰减数据。我们必须绕开UNITY_LIGHT_ATTENUATION，只得到烘焙后的衰减，在这个情况中我们可以使用SHADOW_ATTENUATION宏。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="c1">//UNITY_LIGHT_ATTENUATION doesn't fade shadows for us.</span>
        <span class="cp">#if ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>            <span class="n">attenuation</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="cp">#endif
</span>        
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002336571-896877423.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002336571-896877423.png" alt="两个定向光源正确的衰减" width="100%" height="auto" loading="lazy"></a></div></div><h2 id="消减阴影-subtractive-shadows"><span class="me-2">消减阴影-Subtractive Shadows</span><a href="#消减阴影-subtractive-shadows" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>混合光照很好，但是它不像完全烘焙光照那样成本低廉。如果以低性能硬件为目标，那么混合光照不太可行。烘焙光照会管用，但是事实上你<strong>也许需要动态物体对静态物体投射阴影。那样的话，你可以使用消减混合光照模式</strong>。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002337701-173459592.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002337701-173459592.png" alt="消减模式" width="100%" height="auto" loading="lazy"></a></div></div><p>在切换到消减模式后，场景会亮很多。这是由于静态物体现在同时使用完全烘焙的光照贴图和方向光源。这是因为动态物体仍然会同时使用光照探头和方向光源。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002338965-1025220581.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002338965-1025220581.png" alt="静态物体受到两次光照" width="100%" height="auto" loading="lazy"></a></div></div><p><strong>消减模式只可用于前向渲染</strong>。当使用延迟渲染路径时，相关的物体会回到前向渲染路径，就像透明物体那样。</p><h3 id="消减光照"><span class="me-2">消减光照</span><a href="#消减光照" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在消减模式中，静态物体通过光照贴图被照亮，同时还将动态阴影考虑在内。这是通过降低光照贴图在阴影区域的强度来实现的。为此，着色器需要使用光照贴图和实时阴影。它还需要使用实时光照来计算出要将光照贴图调暗多少。这就是为什么我们在切换到这个模式后得到了双重光照。</p><p><strong>消减光照是一个近似，只在一个单一定向光下起作用，因此它只支持主方向光的阴影</strong>。另外，我们必须以某种方式了解在动态着色区域内间接光的环境是什么。由于我们使用的是一个完全烘焙的光照贴图，我们没有这个信息。Unity没有包含一个额外的只有间接光的光 照贴图，而是使用了一个统一的颜色对环境光取近似值。即实时阴影颜色（Realtime Shadow Color），你可以在混合光照选项中调整它。</p><p>在着色器中，我们知道_当LIGHTMAP_ON_，<em>SHADOWS_SCREEN</em>，和_LIGHTMAP_SHADOW_MIXING_关键词被定义而_SHADOWS_SHADOWMASK_没有被定义时我们应该使用消减光照。如果这样的话我们定义_SUBTRACTIVE_LIGHTING_，以便更容易使用它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; !defined(UNITY_NO_SCREENSPACE_SHADOWS)
</span>        <span class="cp">#define ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS 1
</span>    <span class="cp">#endif
#endif
</span>
<span class="cp">#if defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK)
</span>        <span class="cp">#define SUBTRACTIVE_LIGHTING 1
</span>    <span class="cp">#endif
#endif
</span></pre></table></code></div></div><p>在做其他事情之前，我们必须去除掉双重阴影。为此我们可以关闭动态光照，就像我们对延迟通道所做的那样。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>

    <span class="cp">#if defined(DEFERRED_PASS) || SUBTRACTIVE_LIGHTING
</span>        <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="kt">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cp">#else
</span>        
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002340399-1575340233.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002340399-1575340233.png" alt="静态物体只有烘焙光" width="100%" height="auto" loading="lazy"></a></div></div><h3 id="为烘焙光打阴影"><span class="me-2">为烘焙光打阴影</span><a href="#为烘焙光打阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了应用消减阴影，我们创建一个函数以在需要的时候调整间接光。通常它不会做任何事。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ApplySubtractiveLighting</span> <span class="p">(</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">UnityIndirect</span> <span class="n">indirectLight</span>
<span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</pre></table></code></div></div><p>我们在获取光照贴图数据后要调用该函数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">UnityIndirect</span> <span class="nf">CreateIndirectLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeLightmap</span><span class="p">(</span><span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">));</span>

            <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>                
            <span class="cp">#endif
</span>
            <span class="n">ApplySubtractiveLighting</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">);</span>
        <span class="cp">#else
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="cp">#endif
</span>        
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">indirectLight</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果有消减光照，那么我们必须获取阴影衰减。我们可以简单地从CreateLight中将代码复制过来。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ApplySubtractiveLighting</span> <span class="p">(</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">UnityIndirect</span> <span class="n">indirectLight</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if SUBTRACTIVE_LIGHTING
</span>        <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p>下一步，我们要计算出如果使用实时光照的话我们可以接收到多少光。我们假设该信息和烘焙在光照贴图中的信息相吻合。由于光照贴图只包含漫射光，我们只需计算定向光的Lambert。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#if SUBTRACTIVE_LIGHTING
</span>    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">ndotl</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>为了达到阴影光照的强度，我们必须将兰伯特项乘以衰减。但是我们已经有了完全不含阴影的烘焙光照。因此我们估算一下有多少光被阴影挡住了。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="n">ndotl</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
<span class="kt">float3</span> <span class="n">shadowedLightEstimate</span> <span class="o">=</span> <span class="n">ndotl</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">attenuation</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</pre></table></code></div></div><p>通过从烘焙光中减去该估值，我们最终得到了调整好的光照。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">shadowedLightEstimate</span> <span class="o">=</span> <span class="n">ndotl</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">attenuation</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">subtractedLight</span> <span class="o">=</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="err">–</span> <span class="n">shadowedLightEstimate</span><span class="p">;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002341952-1577870051.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002341952-1577870051.png" alt="减去后得到的光照" width="100%" height="auto" loading="lazy"></a></div></div><p>无论在什么环境光场景中，这总会产生纯黑色阴影。为了更好地符合场景的需要，我们可以使用我们的消减阴影颜色，可以通过unity_ShadowColor实现。阴影区域不应比这个颜色更暗，不过它们可以更亮些。所以我们取计算出的光照和阴影颜色的最大值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="n">subtractedLight</span> <span class="o">=</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">-</span> <span class="n">shadowedLightEstimate</span><span class="p">;</span>
<span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">unity_ShadowColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</pre></table></code></div></div><p>我们还要考虑到阴影强度被设置为小于1这个情况。为了应用阴影强度，在有阴影和无阴影光照之间基于_LightShadowData的X分量做插值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">unity_ShadowColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
<span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002343602-223725225.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002343602-223725225.png" alt="有颜色的阴影" width="100%" height="auto" loading="lazy"></a></div></div><p>因为我们的场景的环境强度（ambient intensity）被设置为0，所以默认的阴影颜色和场景不太搭配。但是可以很轻松地发现消减阴影，因此我没有调整它。还有一点非常明显，即阴影颜色现在覆盖了所有的烘焙阴影，而实际不应该这样。它应该只影响那些接收动态阴影的区域，不应该使烘焙阴影变亮。为此，使用消减光照和烘焙光照的最小值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">//indirectLight.diffuse = subtractedLight;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
</pre></table></code></div></div><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002345136-2052798411.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002345136-2052798411.png" alt="正确的消减阴影" width="100%" height="auto" loading="lazy"></a></div></div><p>现在只要我们使用适当的阴影颜色，我们就会得到正确的消减阴影。但是记住这只是一个近似，而且它不太适用于多重光照。例如，其它的烘焙光会产生错误的阴影。</p><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;margin:1rem 0;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002346714-785287043.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender17/1692664-20200603002346714-785287043.png" alt="多重光照错误的消减" width="100%" height="auto" loading="lazy"></a></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/shader/">Shader</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Unity%20%E6%B7%B7%E5%90%88%E5%85%89%E7%85%A7(%E7%BF%BB%E8%AF%91%E5%8D%81%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2FUnity_Mix_Lighting%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Unity%20%E6%B7%B7%E5%90%88%E5%85%89%E7%85%A7(%E7%BF%BB%E8%AF%91%E5%8D%81%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2FUnity_Mix_Lighting%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2FUnity_Mix_Lighting%2F&text=Unity%20%E6%B7%B7%E5%90%88%E5%85%89%E7%85%A7(%E7%BF%BB%E8%AF%91%E5%8D%81%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/flat-and-wireframe-shading/">平面着色与线框着色(翻译二十一)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-tessellation/">曲面细分(翻译二十二)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-surface-displacement/">曲面细分表面置换(翻译二十三)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-bloom/">Bloom模糊光照(翻译二十四)</a><li class="text-truncate lh-lg"> <a href="/posts/claude-code-guide/">Claude Code学习总结：目录导航</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a> <a class="post-tag btn btn-outline-primary" href="/tags/context-engine/">Context Engine</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_2/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515333600" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展二(翻译十)</h4><div class="text-muted"><p>本篇摘要: 把自身阴影烘焙进材质 增加细节纹理部分 支持更丰富的shader变体 一次编辑多个材质球 遮挡区域的Self-Shading 美术能够创作非常复杂丰富的表面纹理，它只是一个视错觉。为了增强表面纹理视觉真实感，引入Self-Shading。 如何增强呢？通常我们使用了法线来增强模型表面的凹凸层次感，法线带来的视觉增强是第一步，但是法线只适用于采样直接光...</p></div></div></a></article><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515326400" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展一(翻译九)</h4><div class="text-muted"><p>选中当前材质后，若材质使用的Shader调用了GUI拓展，则会自动读取该Shader的所有属性。通过重实现OnGUI函数后，获取其参数地址就能读取。</p></div></div></a></article><article class="col"> <a href="/posts/Unity_Reflection/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515240000" data-df="ll" > Jan 6, 2018 </time><h4 class="pt-0 my-2">Unity Reflection 反射(翻译八)</h4><div class="text-muted"><p>一块完美的镜子是不会发生漫反射，但现在我们自己的Shader包含的光照：环境光、漫反射、高光反射、纹理、阴影，结果看起来蛮好。但是当把Metallic设为1，Smoothness设位0.95，看起来很亮就很不自然了。从下图看尽管颜色是白色但整个表面都是黑色，只有一个很小的高亮点。这个亮点形成1是光源的入射，2朝向观察者的反射。</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/Unity_Static_Lightting/" class="btn btn-outline-primary" aria-label="Older" ><p>Unity 光照烘焙(翻译十六)</p></a> <a href="/posts/Unity_RealTime_GI_LOD/" class="btn btn-outline-primary" aria-label="Newer" ><p>Unity 实时 GI & LPPV & LOD(翻译十八)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a> <a class="post-tag btn btn-outline-primary" href="/tags/context-engine/">Context Engine</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
