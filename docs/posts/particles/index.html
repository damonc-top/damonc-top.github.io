<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="粒子系统：颜色和深度纹理" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="深入探索Unity粒子系统的渲染技术，包括翻书动画、近距离淡入淡出、软粒子和扭曲效果的实现原理与实践。" /><meta property="og:description" content="深入探索Unity粒子系统的渲染技术，包括翻书动画、近距离淡入淡出、软粒子和扭曲效果的实现原理与实践。" /><link rel="canonical" href="www.damonc.top/posts/particles/" /><meta property="og:url" content="www.damonc.top/posts/particles/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/SRP/srp15particles/tutorial-image.jpg" /><meta property="og:image:alt" content="使用粒子创建混乱的氛围" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-11-27T00:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/SRP/srp15particles/tutorial-image.jpg" /><meta name="twitter:image:alt" content="使用粒子创建混乱的氛围" /><meta property="twitter:title" content="粒子系统：颜色和深度纹理" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2026-02-20T23:28:22+08:00","datePublished":"2020-11-27T00:00:00+08:00","description":"深入探索Unity粒子系统的渲染技术，包括翻书动画、近距离淡入淡出、软粒子和扭曲效果的实现原理与实践。","headline":"粒子系统：颜色和深度纹理","image":{"lqip":"data:image/webp;base64,UklGRmoAAABXRUJQVlA4IF4AAADQAwCdASoUAAoAP3Ggxlk0q6gjsAgCkC4JaAC06BwX21mMfRZKXmAA8pHorhHlpVFBCio3KvrI/SzarM6repS/8KE8AjTrjngNHeBl2mALWNqp3wXAVxYA6nzcXoAA","alt":"使用粒子创建混乱的氛围","url":"https://img.damonc.top/posts/SRP/srp15particles/tutorial-image.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/particles/"},"url":"www.damonc.top/posts/particles/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>粒子系统：颜色和深度纹理 | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>粒子系统：颜色和深度纹理</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>粒子系统：颜色和深度纹理</h1><p class="post-desc fw-light mb-4">深入探索Unity粒子系统的渲染技术，包括翻书动画、近距离淡入淡出、软粒子和扭曲效果的实现原理与实践。</p><div class="post-meta text-muted"> <span> Posted <time data-ts="1606406400" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Nov 27, 2020 </time> </span> <span> Updated <time data-ts="1771601302" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 20, 2026 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/SRP/srp15particles/tutorial-image.jpg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/SRP/srp15particles/tutorial-image.jpg" alt="使用粒子创建混乱的氛围" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRmoAAABXRUJQVlA4IF4AAADQAwCdASoUAAoAP3Ggxlk0q6gjsAgCkC4JaAC06BwX21mMfRZKXmAA8pHorhHlpVFBCio3KvrI/SzarM6repS/8KE8AjTrjngNHeBl2mALWNqp3wXAVxYA6nzcXoAA"></a><figcaption class="text-center pt-2 pb-2">使用粒子创建混乱的氛围</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/particles/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="12773 words" > <em>70 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">粒子系统：颜色和深度纹理</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">粒子系统：颜色和深度纹理</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>支持翻页书、近景淡入淡出、柔和以及扭曲粒子效果。<li>确定片段深度，用于正交和透视投影。<li>复制并采样颜色和深度缓冲区。</ul><hr /><h2 id="无光照粒子"><span class="me-2">无光照粒子</span><a href="#无光照粒子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>粒子系统可以使用任何材质，所以我们的渲染管线已经可以渲染它们，但有一些限制。在本教程中，我们只考虑无光照粒子。有光照的粒子工作方式相同，只是有更多的着色器属性和光照计算。</p><p>我为粒子设置了一个新场景，它是已有测试场景的变体。场景中有几个长垂直立方体和一个明亮的黄色灯泡，作为粒子系统的背景。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/without-particles.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/without-particles.png" alt="没有粒子和后处理效果的场景" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">没有粒子和后处理效果的场景</figcaption></figure><h3 id="粒子系统"><span class="me-2">粒子系统</span><a href="#粒子系统" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>通过 <strong>GameObject / Effects / Particle System</strong> 创建一个粒子系统，并将其放置在地面平面下方一点。我假设你已经知道如何配置粒子系统，不会详细讨论这些内容。如果不熟悉，请查看 Unity 的文档来学习特定模块及其设置。</p><aside class="collapsible-aside"><h3>可视效果图（VFX Graph）呢？</h3><div><p>VFX Graph 是基于计算着色器的，目前与 URP 和 HDRP 紧密耦合。它不能轻松地与自定义 SRP 一起使用。</p><p>请注意，常规粒子系统并未被 VFX Graph 所取代。对于许多小型系统（每个系统最多约一千个粒子），常规粒子系统更好，而 VFX Graph 更适合大型粒子系统。</p></div></aside><p>默认系统使粒子向上移动并填充一个锥形区域。如果我们为它分配无光照材质，粒子将显示为与相机平面对齐的纯白色方块。它们会突然出现和消失，但因为它们从平面下方开始，所以看起来像是从地面升起。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/default-particle-system.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/default-particle-system.png" alt="使用无光照材质的默认粒子系统，位于地面下方" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">使用无光照材质的默认粒子系统，位于地面下方</figcaption></figure><h3 id="无光照粒子着色器"><span class="me-2">无光照粒子着色器</span><a href="#无光照粒子着色器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们可以使用无光照着色器来渲染粒子，但让我们为它们创建一个专用的着色器。它从无光照着色器的副本开始，将菜单项更改为 <strong>Custom RP/Particles/Unlit</strong>。此外，由于粒子总是动态的，所以不需要 meta pass。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Custom RP/Particles/Unlit"</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="p">....</span>
        <span class="c1">//Pass {</span>
        <span class="c1">//    Tags {</span>
        <span class="c1">//        "LightMode" = "Meta"</span>
        <span class="c1">//    }</span>
        <span class="c1">//    ....</span>
        <span class="c1">//}</span>
    <span class="p">}</span>
    <span class="n">CustomEditor</span> <span class="s">"CustomShaderGUI"</span>
<span class="p">}</span>
</pre></table></code></div></div><p>使用这个着色器创建一个专用的无光照粒子材质，然后让粒子系统使用它。目前它等同于之前的无光照材质。粒子系统也可以设置为渲染网格，如果材质和粒子系统都启用了阴影，甚至可以渲染阴影。然而，GPU 实例化不起作用，因为粒子系统为此使用程序化绘制，这在本教程中不会涉及。相反，所有粒子网格都会被合并成一个单一的网格，就像广告牌粒子一样。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/particles-sphere.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/particles-sphere.png" alt="球体网格粒子，带阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">球体网格粒子，带阴影</figcaption></figure><p>从现在开始，我们将只关注没有阴影的广告牌粒子。这是一个单个粒子的基础贴图，包含一个简单的平滑淡出的白色圆盘。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/particles-single.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/particles-single.png" alt="单个粒子的基础贴图，黑色背景" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">单个粒子的基础贴图，黑色背景</figcaption></figure><p>当使用这个纹理来渲染淡出粒子时，我们得到一个简单的效果，看起来像是白色烟雾从地面冒出。为了使其更令人信服，将发射速率增加到 100 左右。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/textured-particles.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/textured-particles.png" alt="纹理广告牌粒子，发射速率设置为 100" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">纹理广告牌粒子，发射速率设置为 100</figcaption></figure><h3 id="顶点颜色"><span class="me-2">顶点颜色</span><a href="#顶点颜色" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>可以为每个粒子使用不同的颜色。演示这一点的最简单方法是将起始颜色设置为随机选择黑色和白色。然而，这样做目前不会改变粒子的外观。为了使其工作，我们必须在着色器中添加对顶点颜色的支持。我们不会为粒子创建新的 HLSL 文件，而是将支持添加到 <strong>UnlitPass</strong> 中。</p><p>第一步是添加一个带有 <code class="language-plaintext highlighter-rouge">COLOR</code> 语义的 <code class="language-plaintext highlighter-rouge">float4</code> 顶点属性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="nb">COLOR</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</pre></table></code></div></div><p>也将其添加到 <code class="language-plaintext highlighter-rouge">Varyings</code> 中，并在 <code class="language-plaintext highlighter-rouge">UnlitPassVertex</code> 中传递它，但仅在定义了 <code class="language-plaintext highlighter-rouge">_VERTEX_COLORS</code> 时。这样我们可以根据需要启用和禁用顶点颜色支持。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">positionCS</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
    <span class="cp">#if defined(_VERTEX_COLORS)
</span>        <span class="kt">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">VAR_COLOR</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="n">VAR_BASE_UV</span><span class="p">;</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="n">Varyings</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="cp">#if defined(_VERTEX_COLORS)
</span>        <span class="n">output</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="n">output</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">=</span> <span class="n">TransformBaseUV</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接下来，在 <code class="language-plaintext highlighter-rouge">UnlitInput</code> 中为 <code class="language-plaintext highlighter-rouge">InputConfig</code> 添加一个颜色字段，默认设置为不透明白色，并将其纳入 <code class="language-plaintext highlighter-rouge">GetBase</code> 的结果中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">InputConfig</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">color</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">InputConfig</span> <span class="nf">GetInputConfig</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InputConfig</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">=</span> <span class="n">baseUV</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">....</span>
<span class="kt">float4</span> <span class="nf">GetBase</span> <span class="p">(</span><span class="n">InputConfig</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">baseMap</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="kt">float4</span> <span class="n">baseColor</span> <span class="o">=</span> <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_BaseColor</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">baseMap</span> <span class="o">*</span> <span class="n">baseColor</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>回到 <code class="language-plaintext highlighter-rouge">UnlitPass</code>，如果插值的顶点颜色存在，则在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中将其复制到配置中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">InputConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="n">GetInputConfig</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
<span class="cp">#if defined(_VERTEX_COLORS)
</span>    <span class="n">config</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>最后，为了将顶点颜色支持添加到 <code class="language-plaintext highlighter-rouge">UnlitParticles</code>，需要向其添加一个切换着色器属性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">HDR</span><span class="p">]</span> <span class="n">_BaseColor</span><span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
<span class="p">[</span><span class="n">Toggle</span><span class="p">(</span><span class="n">_VERTEX_COLORS</span><span class="p">)]</span> <span class="n">_VertexColors</span> <span class="p">(</span><span class="s">"Vertex Colors"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></table></code></div></div><p>以及相应的定义关键字的着色器特性。如果你也希望常规的 <code class="language-plaintext highlighter-rouge">Unlit</code> 着色器支持顶点颜色，也可以这样做。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _VERTEX_COLORS
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/vertex-colors-without-sorting.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/vertex-colors-without-sorting.png" alt="使用顶点颜色，不排序（左）和按距离排序（右）" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/vertex-colors-with-sorting.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/vertex-colors-with-sorting.png" alt="使用顶点颜色，不排序（左）和按距离排序（右）" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">使用顶点颜色，不排序（左）和按距离排序（右）</figcaption></figure><p>现在我们获得了彩色粒子。此时粒子排序成为一个问题。如果所有粒子颜色相同，它们的绘制顺序无关紧要，但如果它们不同，我们需要按距离排序以获得正确的结果。请注意，当基于距离排序时，由于视角位置的变化，粒子可能会突然交换绘制顺序，就像任何透明对象一样。</p><h3 id="翻书动画"><span class="me-2">翻书动画</span><a href="#翻书动画" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>广告牌粒子可以通过循环播放不同的基础贴图来实现动画效果。Unity 将这些称为翻书粒子。这是通过使用规则网格布局的纹理图集来完成的，比如这个包含 4×4 网格的循环噪声图案的纹理。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/particles-flipbook.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/particles-flipbook.png" alt="粒子翻书的基础贴图，黑色背景" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">粒子翻书的基础贴图，黑色背景</figcaption></figure><p>创建一个使用翻书贴图的新无光照粒子材质，然后复制我们的粒子系统并让它使用该翻书材质。停用单粒子版本，这样我们只看到翻书系统。由于每个粒子现在代表一小片云，将它们的大小增加到 2 左右。启用粒子系统的 <strong>Texture Sheet Animation</strong> 模块，将其配置为 4×4 翻书，使其从随机帧开始，并在粒子的生命周期内循环播放一次。</p><p>可以通过在 50% 的时间内沿 X 和 Y 随机翻转粒子、从任意旋转开始以及使粒子以随机速度旋转来增加额外的变化。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/particles-with-flipbook.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/particles-with-flipbook.png" alt="翻书粒子系统" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">翻书粒子系统</figcaption></figure><h3 id="翻书混合"><span class="me-2">翻书混合</span><a href="#翻书混合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当系统运动时，很明显粒子循环播放了几帧，因为翻书帧率非常低。对于生命周期为 5 秒的粒子，帧率是 3.2 帧每秒。这可以通过在连续帧之间进行混合来平滑过渡。这需要我们向着色器发送第二对 UV 坐标和一个动画混合因子。</p><p>我们通过在 <strong>Renderer</strong> 模块中启用自定义顶点流来实现。添加 <strong>UV2</strong> 和 <strong>AnimBlend</strong>。你也可以移除 normal 流，因为我们不需要它。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/custom-vertex-streams.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/custom-vertex-streams.png" alt="自定义顶点流" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">自定义顶点流</figcaption></figure><p>添加流后，会显示一个错误，指示粒子系统与当前使用的着色器之间不匹配。在我们在着色器中消耗这些流之后，此错误将消失。向 <code class="language-plaintext highlighter-rouge">UnlitParticle</code> 添加一个着色器关键字切换属性，以控制是否支持翻书混合。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">Toggle</span><span class="p">(</span><span class="n">_VERTEX_COLORS</span><span class="p">)]</span> <span class="n">_VertexColors</span> <span class="p">(</span><span class="s">"Vertex Colors"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">[</span><span class="n">Toggle</span><span class="p">(</span><span class="n">_FLIPBOOK_BLENDING</span><span class="p">)]</span> <span class="n">_FlipbookBlending</span> <span class="p">(</span><span class="s">"Flipbook Blending"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></table></code></div></div><p>以及相应的着色器特性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _FLIPBOOK_BLENDING
</span></pre></table></code></div></div><p>如果启用了翻书混合，则两对 UV 都通过 <code class="language-plaintext highlighter-rouge">TEXCOORD0</code> 提供，因此它必须是 <code class="language-plaintext highlighter-rouge">float4</code> 而不是 <code class="language-plaintext highlighter-rouge">float2</code>。混合因子作为单个 <code class="language-plaintext highlighter-rouge">float</code> 通过 <code class="language-plaintext highlighter-rouge">TEXCOORD1</code> 提供。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="nb">COLOR</span><span class="p">;</span>
    <span class="cp">#if defined(_FLIPBOOK_BLENDING)
</span>        <span class="kt">float4</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
        <span class="n">float</span> <span class="n">flipbookBlend</span> <span class="o">:</span> <span class="nb">TEXCOORD1</span><span class="p">;</span>
    <span class="cp">#else
</span>        <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</pre></table></code></div></div><p>如果需要，我们将新数据作为单个 <code class="language-plaintext highlighter-rouge">float3 flipbookUVB</code> 字段添加到 <code class="language-plaintext highlighter-rouge">Varyings</code> 中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="n">VAR_BASE_UV</span><span class="p">;</span>
    <span class="cp">#if defined(_FLIPBOOK_BLENDING)
</span>        <span class="kt">float3</span> <span class="n">flipbookUVB</span> <span class="o">:</span> <span class="n">VAR_FLIPBOOK</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</pre></table></code></div></div><p>调整 <code class="language-plaintext highlighter-rouge">UnlitPassVertex</code>，使其在适当时将所有相关数据复制到其中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">Varyings</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">output</span><span class="p">.</span><span class="n">baseUV</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TransformBaseUV</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="cp">#if defined(_FLIPBOOK_BLENDING)
</span>        <span class="n">output</span><span class="p">.</span><span class="n">flipbookUVB</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TransformBaseUV</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">.</span><span class="n">zw</span><span class="p">);</span>
        <span class="n">output</span><span class="p">.</span><span class="n">flipbookUVB</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">flipbookBlend</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>也将 <code class="language-plaintext highlighter-rouge">flipbookUVB</code> 添加到 <code class="language-plaintext highlighter-rouge">InputConfig</code>，以及一个布尔值来指示是否启用了翻书混合（默认情况下不启用）。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">InputConfig</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">color</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">baseUV</span><span class="p">;</span>
    <span class="kt">float3</span> <span class="n">flipbookUVB</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">flipbookBlending</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">InputConfig</span> <span class="nf">GetInputConfig</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">c</span><span class="p">.</span><span class="n">flipbookUVB</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">flipbookBlending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果启用了翻书混合，我们必须在 <code class="language-plaintext highlighter-rouge">GetBase</code> 中第二次采样基础贴图，使用翻书 UV，然后根据混合因子从第一个样本插值到第二个样本。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">GetBase</span> <span class="p">(</span><span class="n">InputConfig</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">baseMap</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">flipbookBlending</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">baseMap</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span>
            <span class="n">baseMap</span><span class="p">,</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">flipbookUVB</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span>
            <span class="n">c</span><span class="p">.</span><span class="n">flipbookUVB</span><span class="p">.</span><span class="n">z</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">float4</span> <span class="n">baseColor</span> <span class="o">=</span> <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_BaseColor</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">baseMap</span> <span class="o">*</span> <span class="n">baseColor</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中适当地覆盖默认配置以激活翻书混合。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_VERTEX_COLORS)
</span>    <span class="n">config</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="cp">#endif
#if defined(_FLIPBOOK_BLENDING)
</span>    <span class="n">config</span><span class="p">.</span><span class="n">flipbookUVB</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">flipbookUVB</span><span class="p">;</span>
    <span class="n">config</span><span class="p">.</span><span class="n">flipbookBlending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/particles-flipbook-distortion.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/particles-flipbook-distortion.png" alt="翻书混合" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">翻书混合</figcaption></figure><h2 id="相机近处淡出"><span class="me-2">相机近处淡出</span><a href="#相机近处淡出" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>当相机处于粒子系统内部时，粒子最终会非常接近相机的近平面，也会从一侧穿过到另一侧。粒子系统有一个 <strong>Renderer / Max Particle Size</strong> 属性，可以防止单个广告牌粒子覆盖窗口的太多区域。一旦它们达到最大可见大小，它们看起来会滑出视野，而不是随着接近近平面而变得更大。</p><p>处理接近近平面的粒子的另一种方法是根据它们的片段深度淡出它们。当穿过代表大气效果的粒子系统时，这看起来会更好。</p><h3 id="片段数据"><span class="me-2">片段数据</span><a href="#片段数据" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们已经在片段函数中拥有了片段深度。它通过带有 <code class="language-plaintext highlighter-rouge">SV_POSITION</code> 语义的 <code class="language-plaintext highlighter-rouge">float4</code> 提供。我们已经使用了它的 XY 分量进行抖动，但现在让我们正式声明我们正在使用片段数据。</p><p>在顶点函数中，<code class="language-plaintext highlighter-rouge">SV_POSITION</code> 表示顶点的裁剪空间位置，作为 4D 齐次坐标。但在片段函数中，<code class="language-plaintext highlighter-rouge">SV_POSITION</code> 表示片段的屏幕空间（也称为窗口空间）位置。空间转换由 GPU 执行。为了明确这一点，让我们在所有 <code class="language-plaintext highlighter-rouge">Varyings</code> 结构体中将 <code class="language-plaintext highlighter-rouge">positionCS</code> 重命名为 <code class="language-plaintext highlighter-rouge">positionCS_SS</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="n">positionCS_SS</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
</pre></table></code></div></div><p>在相应的顶点函数中也进行调整。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">output</span><span class="p">.</span><span class="n">positionCS_SS</span> <span class="o">=</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">positionWS</span><span class="p">);</span>
</pre></table></code></div></div><p>接下来，我们将引入一个新的 <code class="language-plaintext highlighter-rouge">Fragment</code> HLSL 包含文件，其中包含一个 <code class="language-plaintext highlighter-rouge">Fragment</code> 结构体和一个 <code class="language-plaintext highlighter-rouge">GetFragment</code> 函数，该函数在给定 <code class="language-plaintext highlighter-rouge">float4</code> 屏幕空间位置向量的情况下返回片段。最初，片段只有一个 2D 位置，它来自屏幕空间位置的 XY 分量。这些是带有 0.5 偏移的纹素坐标。屏幕左下角纹素的坐标是 (0.5, 0.5)，它右边的纹素是 (1.5, 0.5)，依此类推。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#ifndef FRAGMENT_INCLUDED
#define FRAGMENT_INCLUDED
</span>
<span class="k">struct</span> <span class="n">Fragment</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">positionSS</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Fragment</span> <span class="nf">GetFragment</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">positionSS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Fragment</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">positionSS</span> <span class="o">=</span> <span class="n">positionSS</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>在所有其他包含语句之后，在 <code class="language-plaintext highlighter-rouge">Common</code> 中包含此文件，然后调整 <code class="language-plaintext highlighter-rouge">ClipLOD</code>，使其第一个参数是 <code class="language-plaintext highlighter-rouge">Fragment</code> 而不是 <code class="language-plaintext highlighter-rouge">float4</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"Fragment.hlsl"</span><span class="cp">
</span><span class="p">....</span>
<span class="kt">void</span> <span class="nf">ClipLOD</span> <span class="p">(</span><span class="n">Fragment</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">float</span> <span class="n">fade</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(LOD_FADE_CROSSFADE)
</span>        <span class="n">float</span> <span class="n">dither</span> <span class="o">=</span> <span class="n">InterleavedGradientNoise</span><span class="p">(</span><span class="n">fragment</span><span class="p">.</span><span class="n">positionSS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nb">clip</span><span class="p">(</span><span class="n">fade</span> <span class="o">+</span> <span class="p">(</span><span class="n">fade</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="o">?</span> <span class="n">dither</span> <span class="o">:</span> <span class="o">-</span><span class="n">dither</span><span class="p">));</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p>此时，让我们也在 <code class="language-plaintext highlighter-rouge">Common</code> 中定义通用的线性和点钳位采样器状态，因为我们稍后会在多个地方使用它们。在包含 <code class="language-plaintext highlighter-rouge">Fragment</code> 之前这样做。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"</span><span class="cp">
</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">sampler_linear_clamp</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">sampler_point_clamp</span><span class="p">);</span>

<span class="cp">#include</span> <span class="cpf">"Fragment.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><p>然后从 <code class="language-plaintext highlighter-rouge">PostFXStackPasses</code> 中删除通用采样器定义，因为这现在是一个会导致编译器错误的重复定义。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_PostFXSource2</span><span class="p">);</span>
<span class="c1">//SAMPLER(sampler_linear_clamp);</span>
</pre></table></code></div></div><p>接下来，将片段添加到 <code class="language-plaintext highlighter-rouge">LitInput</code> 和 <code class="language-plaintext highlighter-rouge">UnlitInput</code> 的 <code class="language-plaintext highlighter-rouge">InputConfig</code> 结构体中。然后将屏幕空间位置向量作为第一个参数添加到 <code class="language-plaintext highlighter-rouge">GetInputConfig</code> 函数中，这样它们可以用它调用 <code class="language-plaintext highlighter-rouge">GetFragment</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">InputConfig</span> <span class="p">{</span>
    <span class="n">Fragment</span> <span class="n">fragment</span><span class="p">;</span>
    <span class="p">....</span>
<span class="p">};</span>

<span class="n">InputConfig</span> <span class="nf">GetInputConfig</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">positionSS</span><span class="p">,</span> <span class="p">....)</span> <span class="p">{</span>
    <span class="n">InputConfig</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">fragment</span> <span class="o">=</span> <span class="n">GetFragment</span><span class="p">(</span><span class="n">positionSS</span><span class="p">);</span>
    <span class="p">....</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在所有调用 <code class="language-plaintext highlighter-rouge">GetInputConfig</code> 的地方添加参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">InputConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="n">GetInputConfig</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS_SS</span><span class="p">,</span> <span class="p">....);</span>
</pre></table></code></div></div><p>然后调整 <code class="language-plaintext highlighter-rouge">LitPassFragment</code>，使其在获取配置后调用 <code class="language-plaintext highlighter-rouge">ClipLOD</code>，以便可以将片段传递给它。还将片段的位置传递给 <code class="language-plaintext highlighter-rouge">InterleavedGradientNoise</code>，而不是直接使用 <code class="language-plaintext highlighter-rouge">input.positionCS_SS</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">LitPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="c1">//ClipLOD(input.positionSS.xy, unity_LODFade.x);</span>

    <span class="n">InputConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="n">GetInputConfig</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS_SS</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="n">ClipLOD</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fragment</span><span class="p">,</span> <span class="n">unity_LODFade</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="p">....</span>
    <span class="n">surface</span><span class="p">.</span><span class="n">dither</span> <span class="o">=</span> <span class="n">InterleavedGradientNoise</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fragment</span><span class="p">.</span><span class="n">positionSS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">....</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">ShadowCasterPassFragment</code> 也必须更改，以便在获取配置后进行裁剪。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ShadowCasterPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="c1">//ClipLOD(input.positionCS.xy, unity_LODFade.x);</span>

    <span class="n">InputConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="n">GetInputConfig</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS_SS</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="n">ClipLOD</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fragment</span><span class="p">,</span> <span class="n">unity_LODFade</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>

    <span class="kt">float4</span> <span class="n">base</span> <span class="o">=</span> <span class="n">GetBase</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
    <span class="cp">#if defined(_SHADOWS_CLIP)
</span>        <span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">GetCutoff</span><span class="p">(</span><span class="n">config</span><span class="p">));</span>
    <span class="cp">#elif defined(_SHADOWS_DITHER)
</span>        <span class="n">float</span> <span class="n">dither</span> <span class="o">=</span> <span class="n">InterleavedGradientNoise</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionSS</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">dither</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><h3 id="片段深度"><span class="me-2">片段深度</span><a href="#片段深度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要在相机附近淡出粒子，我们需要知道片段的深度。所以向 <code class="language-plaintext highlighter-rouge">Fragment</code> 添加一个深度字段。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Fragment</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">positionSS</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>片段深度存储在屏幕空间位置向量的最后一个分量中。这是用于执行透视除法以将 3D 位置投影到屏幕上的值。这是视图空间深度，因此它是距相机 XY 平面的距离，而不是其近平面的距离。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">Fragment</span> <span class="nf">GetFragment</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">positionCS_SS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Fragment</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">positionSS</span> <span class="o">=</span> <span class="n">positionSS</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">positionSS</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>什么是视图空间？</h3><div><p>它是经过旋转和平移的世界空间，使相机最终位于原点且没有旋转。</p></div></aside><p>我们可以通过在 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 和 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中直接返回片段深度来验证这是正确的，将其缩小以便我们可以看到它作为灰度渐变。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">InputConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="n">GetInputConfig</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS_SS</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fragment</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">xxx</span> <span class="o">/</span> <span class="mi">20</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/fragment-depth.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/fragment-depth.png" alt="片段深度，除以 20" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">片段深度，除以 20</figcaption></figure><h3 id="正交深度"><span class="me-2">正交深度</span><a href="#正交深度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>上述方法仅在使用透视相机时有效。当使用正交相机时，不存在透视除法，因此屏幕空间位置向量的最后一个分量始终为 1。</p><p>我们可以通过向 <code class="language-plaintext highlighter-rouge">UnityInput</code> 添加一个 <code class="language-plaintext highlighter-rouge">float4 unity_OrthoParams</code> 字段来确定我们是否在处理正交相机，Unity 通过该字段将有关正交相机的信息传达给 GPU。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="n">unity_OrthoParams</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">_ProjectionParams</span><span class="p">;</span>
</pre></table></code></div></div><p>对于正交相机，其最后一个分量将为 1，否则将为 0。在 <code class="language-plaintext highlighter-rouge">Common</code> 中添加一个 <code class="language-plaintext highlighter-rouge">IsOrthographicCamera</code> 函数来使用这一事实，在包含 <code class="language-plaintext highlighter-rouge">Fragment</code> 之前定义它，以便我们可以在那里使用它。如果你永远不会使用正交相机，可以硬编码它返回 <code class="language-plaintext highlighter-rouge">false</code>，或者通过着色器关键字来控制。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="nf">IsOrthographicCamera</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">unity_OrthoParams</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include</span> <span class="cpf">"Fragment.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><p>对于正交相机，我们能做的最好的事情是依赖屏幕空间位置向量的 Z 分量，它包含片段的转换后的裁剪空间深度。这是用于深度比较的原始值，如果启用深度写入，则会写入深度缓冲区。它是 0-1 范围内的值，对于正交投影是线性的。要将其转换为视图空间深度，我们必须将其按相机的近远范围缩放，然后添加近平面距离。近距离和远距离存储在 <code class="language-plaintext highlighter-rouge">_ProjectionParams</code> 的 Y 和 Z 分量中。如果使用反转深度缓冲区，我们还需要反转原始深度。在一个新的 <code class="language-plaintext highlighter-rouge">OrthographicDepthBufferToLinear</code> 函数中执行此操作，也在包含 <code class="language-plaintext highlighter-rouge">Fragment</code> 之前在 <code class="language-plaintext highlighter-rouge">Common</code> 中定义。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">OrthographicDepthBufferToLinear</span> <span class="p">(</span><span class="n">float</span> <span class="n">rawDepth</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if UNITY_REVERSED_Z
</span>        <span class="n">rawDepth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">rawDepth</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">rawDepth</span> <span class="o">+</span> <span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include</span> <span class="cpf">"Fragment.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><p>现在 <code class="language-plaintext highlighter-rouge">GetFragment</code> 可以检查是否使用正交相机，如果是，则依赖 <code class="language-plaintext highlighter-rouge">OrthographicDepthBufferToLinear</code> 来确定片段深度。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">f</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">IsOrthographicCamera</span><span class="p">()</span> <span class="o">?</span>
    <span class="n">OrthographicDepthBufferToLinear</span><span class="p">(</span><span class="n">positionSS</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="o">:</span> <span class="n">positionSS</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/orthographic-depth.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/orthographic-depth.png" alt="正交相机的片段深度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">正交相机的片段深度</figcaption></figure><p>在验证两种相机类型的片段深度都正确后，从 <code class="language-plaintext highlighter-rouge">LitPassFragment</code> 和 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中删除调试可视化。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="c1">//return float4(config.fragment.depth.xxx / 20.0, 1.0);</span>
</pre></table></code></div></div><h3 id="基于距离的淡出"><span class="me-2">基于距离的淡出</span><a href="#基于距离的淡出" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>回到 <code class="language-plaintext highlighter-rouge">UnlitParticles</code> 着色器，添加一个 <strong>Near Fade</strong> 关键字切换属性，以及使其距离和范围可配置的属性。距离决定粒子应该完全消失时距离相机平面的距离。这是相机平面，而不是其近平面。因此应该使用至少近平面的值。1 是一个合理的默认值。范围控制过渡区域的长度，在该区域内粒子将线性淡出。同样，1 是一个合理的默认值，并且至少必须是一个小的正值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">Toggle</span><span class="p">(</span><span class="n">_NEAR_FADE</span><span class="p">)]</span> <span class="n">_NearFade</span> <span class="p">(</span><span class="s">"Near Fade"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_NearFadeDistance</span> <span class="p">(</span><span class="s">"Near Fade Distance"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_NearFadeRange</span> <span class="p">(</span><span class="s">"Near Fade Range"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mo">01</span><span class="p">,</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
</pre></table></code></div></div><p>添加一个着色器特性来启用近距离淡出。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _NEAR_FADE
</span></pre></table></code></div></div><p>然后在 <code class="language-plaintext highlighter-rouge">UnlitInput</code> 的 <code class="language-plaintext highlighter-rouge">UnityPerMaterial</code> 缓冲区中包含距离和范围。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseMap_ST</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_NearFadeDistance</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_NearFadeRange</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_ZWrite</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
</pre></table></code></div></div><p>接下来，向 <code class="language-plaintext highlighter-rouge">InputConfig</code> 添加一个布尔字段 <code class="language-plaintext highlighter-rouge">nearFade</code> 来控制是否激活近距离淡出（默认情况下不激活）。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">InputConfig</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">bool</span> <span class="n">nearFade</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">InputConfig</span> <span class="nf">GetInputConfig</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">positionCC_SS</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">c</span><span class="p">.</span><span class="n">nearFade</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在相机附近淡出是通过简单地降低片段的基础 alpha 来完成的。衰减因子等于片段深度减去淡出距离，然后除以淡出范围。由于结果可能为负，在将其纳入基础贴图的 alpha 之前，先对其进行饱和。在适当的时候在 <code class="language-plaintext highlighter-rouge">GetBase</code> 中执行此操作。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">flipbookBlending</span><span class="p">)</span> <span class="p">{</span> <span class="p">....</span> <span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">nearFade</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">nearAttenuation</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">fragment</span><span class="p">.</span><span class="n">depth</span> <span class="o">-</span> <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_NearFadeDistance</span><span class="p">))</span> <span class="o">/</span>
        <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_NearFadeRange</span><span class="p">);</span>
    <span class="n">baseMap</span><span class="p">.</span><span class="n">a</span> <span class="o">*=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">nearAttenuation</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，要激活该功能，如果定义了 <code class="language-plaintext highlighter-rouge">_NEAR_FADE</code> 关键字，则在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中将片段的 <code class="language-plaintext highlighter-rouge">nearFade</code> 字段设置为 <code class="language-plaintext highlighter-rouge">true</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_FLIPBOOK_BLENDING)
</span>    <span class="n">config</span><span class="p">.</span><span class="n">flipbookUVB</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">flipbookUVB</span><span class="p">;</span>
    <span class="n">config</span><span class="p">.</span><span class="n">flipbookBlending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif
#if defined(_NEAR_FADE)
</span>    <span class="n">config</span><span class="p">.</span><span class="n">nearFade</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/faded-distortion.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/faded-distortion.png" alt="调整近距离淡出距离" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">调整近距离淡出距离</figcaption></figure><h2 id="软粒子"><span class="me-2">软粒子</span><a href="#软粒子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>当广告牌粒子与几何体相交时，尖锐的过渡在视觉上很刺眼，并使它们的平面性质显而易见。解决方案是使用软粒子，当它们后面有靠近的不透明几何体时，软粒子会淡出。要使其工作，粒子的片段深度必须与之前绘制到相机缓冲区中相同位置的任何内容的深度进行比较。这意味着我们必须对深度缓冲区进行采样。</p><h3 id="分离深度缓冲区"><span class="me-2">分离深度缓冲区</span><a href="#分离深度缓冲区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>到目前为止，我们总是为相机使用单个帧缓冲区，它包含颜色和深度信息。这是典型的帧缓冲区配置，但颜色和深度数据始终存储在单独的缓冲区中，称为帧缓冲区附件。要访问深度缓冲区，我们需要分别定义这些附件。</p><p>第一步是将 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 中的 <code class="language-plaintext highlighter-rouge">_CameraFrameBuffer</code> 标识符替换为两个标识符，我们将它们命名为 <code class="language-plaintext highlighter-rouge">_CameraColorAttachment</code> 和 <code class="language-plaintext highlighter-rouge">_CameraDepthAttachment</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">//static int frameBufferId = Shader.PropertyToID("_CameraFrameBuffer");</span>
<span class="k">static</span> <span class="kt">int</span>
    <span class="n">colorAttachmentId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraColorAttachment"</span><span class="p">),</span>
    <span class="n">depthAttachmentId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraDepthAttachment"</span><span class="p">);</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">Render</code> 中，我们现在必须将颜色附件传递给 <code class="language-plaintext highlighter-rouge">PostFXStack.Render</code>，这在功能上等同于我们之前所做的。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">postFXStack</span><span class="p">.</span><span class="n">IsActive</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">postFXStack</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="n">colorAttachmentId</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">Setup</code> 中，我们现在必须获取两个缓冲区，而不是一个复合缓冲区。颜色缓冲区没有深度，而深度缓冲区的格式是 <code class="language-plaintext highlighter-rouge">RenderTextureFormat.Depth</code>，其过滤模式是 <code class="language-plaintext highlighter-rouge">FilterMode.Point</code>，因为混合深度数据没有意义。可以通过一次 <code class="language-plaintext highlighter-rouge">SetRenderTarget</code> 调用来设置两个附件，对每个附件使用相同的加载和存储操作。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">postFXStack</span><span class="p">.</span><span class="n">IsActive</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="p">&gt;</span> <span class="n">CameraClearFlags</span><span class="p">.</span><span class="n">Color</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flags</span> <span class="p">=</span> <span class="n">CameraClearFlags</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
        <span class="n">colorAttachmentId</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelHeight</span><span class="p">,</span>
        <span class="m">0</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">useHDR</span> <span class="p">?</span>
            <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">DefaultHDR</span> <span class="p">:</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
        <span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelHeight</span><span class="p">,</span>
        <span class="m">32</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Point</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Depth</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetRenderTarget</span><span class="p">(</span>
        <span class="n">colorAttachmentId</span><span class="p">,</span>
        <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">DontCare</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span><span class="p">,</span>
        <span class="n">depthAttachmentId</span><span class="p">,</span>
        <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">DontCare</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>两个缓冲区也必须被释放。完成后，我们的渲染管线仍然以与之前相同的方式工作，但现在使用可以单独访问的帧缓冲区附件。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">Cleanup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">lighting</span><span class="p">.</span><span class="nf">Cleanup</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">postFXStack</span><span class="p">.</span><span class="n">IsActive</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">colorAttachmentId</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="复制深度"><span class="me-2">复制深度</span><a href="#复制深度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们不能在深度缓冲区用于渲染的同时对其进行采样。我们必须制作它的副本。因此引入一个 <code class="language-plaintext highlighter-rouge">_CameraDepthTexture</code> 标识符，并添加一个布尔字段来指示我们是否正在使用深度纹理。我们应该只在需要时才费心复制深度，我们将在获取相机设置后在 <code class="language-plaintext highlighter-rouge">Render</code> 中确定这一点。但我们最初只是始终启用它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="n">colorAttachmentId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraColorAttachment"</span><span class="p">),</span>
    <span class="n">depthAttachmentId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraDepthAttachment"</span><span class="p">),</span>
    <span class="n">depthTextureId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraDepthTexture"</span><span class="p">);</span>
<span class="p">....</span>
<span class="kt">bool</span> <span class="n">useDepthTexture</span><span class="p">;</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(....)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">CameraSettings</span> <span class="n">cameraSettings</span> <span class="p">=</span>
        <span class="n">crpCamera</span> <span class="p">?</span> <span class="n">crpCamera</span><span class="p">.</span><span class="n">Settings</span> <span class="p">:</span> <span class="n">defaultCameraSettings</span><span class="p">;</span>
    <span class="n">useDepthTexture</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">....</span>
<span class="p">}</span>
</pre></table></code></div></div><p>创建一个新的 <code class="language-plaintext highlighter-rouge">CopyAttachments</code> 方法，如果需要，它会获取一个临时的深度纹理副本，并将深度附件数据复制到其中。这可以通过在命令缓冲区上调用 <code class="language-plaintext highlighter-rouge">CopyTexture</code> 并使用源和目标纹理来完成。这比通过全屏绘制调用来完成要高效得多。还要确保在 <code class="language-plaintext highlighter-rouge">Cleanup</code> 中释放额外的深度纹理。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">Cleanup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">useDepthTexture</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">depthTextureId</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">....</span>
<span class="k">void</span> <span class="nf">CopyAttachments</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">useDepthTexture</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
            <span class="n">depthTextureId</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelHeight</span><span class="p">,</span>
            <span class="m">32</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Point</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Depth</span>
        <span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">CopyTexture</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">depthTextureId</span><span class="p">);</span>
        <span class="nf">ExecuteBuffer</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们将在绘制完所有不透明几何体后只复制一次附件，因此在 <code class="language-plaintext highlighter-rouge">Render</code> 中的天空盒之后。这意味着深度纹理仅在渲染透明对象时可用。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">context</span><span class="p">.</span><span class="nf">DrawSkybox</span><span class="p">(</span><span class="n">camera</span><span class="p">);</span>
<span class="nf">CopyAttachments</span><span class="p">();</span>
</pre></table></code></div></div><h3 id="没有后处理时复制深度"><span class="me-2">没有后处理时复制深度</span><a href="#没有后处理时复制深度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>仅当我们有深度附件可以复制时，复制深度才有效，目前只有在启用后处理效果时才会出现这种情况。为了在没有后处理效果的情况下实现它，当使用深度纹理时，我们还需要使用中间帧缓冲区。引入一个 <code class="language-plaintext highlighter-rouge">useIntermediateBuffer</code> 布尔字段来跟踪这一点，在可能获取附件之前在 <code class="language-plaintext highlighter-rouge">Setup</code> 中初始化。现在应该在使用深度纹理或后处理效果激活时执行此操作。<code class="language-plaintext highlighter-rouge">Cleanup</code> 也以相同的方式受到影响。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">useDepthTexture</span><span class="p">,</span> <span class="n">useIntermediateBuffer</span><span class="p">;</span>
<span class="p">....</span>
<span class="k">void</span> <span class="nf">Setup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">context</span><span class="p">.</span><span class="nf">SetupCameraProperties</span><span class="p">(</span><span class="n">camera</span><span class="p">);</span>
    <span class="n">CameraClearFlags</span> <span class="n">flags</span> <span class="p">=</span> <span class="n">camera</span><span class="p">.</span><span class="n">clearFlags</span><span class="p">;</span>
    <span class="n">useIntermediateBuffer</span> <span class="p">=</span> <span class="n">useDepthTexture</span> <span class="p">||</span> <span class="n">postFXStack</span><span class="p">.</span><span class="n">IsActive</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">useIntermediateBuffer</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="p">&gt;</span> <span class="n">CameraClearFlags</span><span class="p">.</span><span class="n">Color</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">flags</span> <span class="p">=</span> <span class="n">CameraClearFlags</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">....</span>
    <span class="p">}</span>
    <span class="p">....</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Cleanup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">lighting</span><span class="p">.</span><span class="nf">Cleanup</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">useIntermediateBuffer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">colorAttachmentId</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">);</span>
        <span class="c1">//}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">useDepthTexture</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">depthTextureId</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但是现在，当没有激活后处理效果时，渲染失败，因为我们只是渲染到中间缓冲区。我们必须执行最终复制到相机的目标。不幸的是，我们只能使用 <code class="language-plaintext highlighter-rouge">CopyTexture</code> 复制到渲染纹理，而不能复制到最终帧缓冲区。我们可以使用后处理效果复制 pass 来完成它，但这一步特定于相机渲染器，因此我们将为其创建一个专用的 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 着色器。它的开始与 <code class="language-plaintext highlighter-rouge">PostFX</code> 着色器相同，但只有一个复制 pass，并且它包含自己的 HLSL 文件。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Hidden/Custom RP/Camera Renderer"</span> <span class="p">{</span>
    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="n">Cull</span> <span class="n">Off</span>
        <span class="n">ZTest</span> <span class="n">Always</span>
        <span class="n">ZWrite</span> <span class="n">Off</span>

        <span class="n">HLSLINCLUDE</span>
        <span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Common.hlsl"</span><span class="cp">
</span>        <span class="cp">#include</span> <span class="cpf">"CameraRendererPasses.hlsl"</span><span class="cp">
</span>        <span class="n">ENDHLSL</span>

        <span class="n">Pass</span> <span class="p">{</span>
            <span class="n">Name</span> <span class="s">"Copy"</span>

            <span class="n">HLSLPROGRAM</span>
                <span class="cp">#pragma target 3.5
</span>                <span class="cp">#pragma vertex DefaultPassVertex
</span>                <span class="cp">#pragma fragment CopyPassFragment
</span>            <span class="n">ENDHLSL</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>新的 <code class="language-plaintext highlighter-rouge">CameraRendererPasses</code> HLSL 文件具有与 <code class="language-plaintext highlighter-rouge">PostFXStackPasses</code> 相同的 <code class="language-plaintext highlighter-rouge">Varyings</code> 结构体和 <code class="language-plaintext highlighter-rouge">DefaultPassVertex</code> 函数。它还有一个 <code class="language-plaintext highlighter-rouge">_SourceTexture</code> 纹理和一个 <code class="language-plaintext highlighter-rouge">CopyPassFragment</code> 函数，该函数简单地返回采样的源纹理。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_CAMERA_RENDERER_PASSES_INCLUDED
#define CUSTOM_CAMERA_RENDERER_PASSES_INCLUDED
</span>
<span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_SourceTexture</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span> <span class="p">....</span> <span class="p">};</span>

<span class="n">Varyings</span> <span class="nf">DefaultPassVertex</span> <span class="p">(</span><span class="n">uint</span> <span class="n">vertexID</span> <span class="o">:</span> <span class="n">SV_VertexID</span><span class="p">)</span> <span class="p">{</span> <span class="p">....</span> <span class="p">}</span>

<span class="kt">float4</span> <span class="nf">CopyPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">SAMPLE_TEXTURE2D_LOD</span><span class="p">(</span><span class="n">_SourceTexture</span><span class="p">,</span> <span class="n">sampler_linear_clamp</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>接下来，向 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 添加一个材质字段。要初始化它，创建一个带有着色器参数的公共构造函数方法，并让它使用着色器作为参数调用 <code class="language-plaintext highlighter-rouge">CoreUtils.CreateEngineMaterial</code>。该方法创建一个新材质并将其设置为在编辑器中隐藏，确保它不会被保存为资产，因此我们不必显式地这样做。如果着色器丢失，它还会记录错误。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">Material</span> <span class="n">material</span><span class="p">;</span>

<span class="k">public</span> <span class="nf">CameraRenderer</span> <span class="p">(</span><span class="n">Shader</span> <span class="n">shader</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">material</span> <span class="p">=</span> <span class="n">CoreUtils</span><span class="p">.</span><span class="nf">CreateEngineMaterial</span><span class="p">(</span><span class="n">shader</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>还添加一个公共 <code class="language-plaintext highlighter-rouge">Dispose</code> 方法，通过将其传递给 <code class="language-plaintext highlighter-rouge">CoreUtils.Destroy</code> 来销毁材质。该方法会根据 Unity 是否处于播放模式来定期或立即销毁材质。我们需要这样做，因为每当修改渲染管线资产时都会创建新的渲染管线实例，从而创建渲染器，这可能导致在编辑器中创建许多材质。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">CoreUtils</span><span class="p">.</span><span class="nf">Destroy</span><span class="p">(</span><span class="n">material</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在 <code class="language-plaintext highlighter-rouge">CustomRenderPipeline</code> 必须在构造渲染器时提供一个着色器。所以我们将在它自己的构造函数方法中执行此操作，同时为其添加一个相机渲染器着色器的参数。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">CameraRenderer</span> <span class="n">renderer</span><span class="p">;</span> <span class="c1">// = new CameraRenderer();</span>
<span class="p">....</span>
<span class="k">public</span> <span class="nf">CustomRenderPipeline</span> <span class="p">(</span>
    <span class="kt">bool</span> <span class="n">allowHDR</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useSRPBatcher</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">useLightsPerObject</span><span class="p">,</span> <span class="n">ShadowSettings</span> <span class="n">shadowSettings</span><span class="p">,</span>
    <span class="n">PostFXSettings</span> <span class="n">postFXSettings</span><span class="p">,</span> <span class="kt">int</span> <span class="n">colorLUTResolution</span><span class="p">,</span> <span class="n">Shader</span> <span class="n">cameraRendererShader</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">renderer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CameraRenderer</span><span class="p">(</span><span class="n">cameraRendererShader</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>从现在开始，当它自身被释放时，它还必须在渲染器上调用 <code class="language-plaintext highlighter-rouge">Dispose</code>。我们已经为它创建了一个 <code class="language-plaintext highlighter-rouge">Dispose</code> 方法，但仅用于编辑器代码。将该版本重命名为 <code class="language-plaintext highlighter-rouge">DisposeForEditor</code>，并且只让它重置光照贴图委托。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">partial</span> <span class="k">void</span> <span class="nf">DisposeForEditor</span> <span class="p">();</span>

<span class="cp">#if UNITY_EDITOR
</span><span class="p">....</span>
<span class="k">partial</span> <span class="k">void</span> <span class="nf">DisposeForEditor</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">//base.Dispose(disposing);</span>
    <span class="n">Lightmapping</span><span class="p">.</span><span class="nf">ResetDelegate</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后添加一个新的非仅编辑器的 <code class="language-plaintext highlighter-rouge">Dispose</code> 方法，它调用其基础实现、编辑器版本，最后释放渲染器。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Dispose</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">disposing</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">base</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">(</span><span class="n">disposing</span><span class="p">);</span>
    <span class="nf">DisposeForEditor</span><span class="p">();</span>
    <span class="n">renderer</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在顶层，<code class="language-plaintext highlighter-rouge">CustomRenderPipelineAsset</code> 必须获取一个着色器配置属性并将其传递给管线构造函数。然后我们终于可以连接着色器了。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
<span class="n">Shader</span> <span class="n">cameraRendererShader</span> <span class="p">=</span> <span class="k">default</span><span class="p">;</span>

<span class="k">protected</span> <span class="k">override</span> <span class="n">RenderPipeline</span> <span class="nf">CreatePipeline</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">CustomRenderPipeline</span><span class="p">(</span>
        <span class="n">allowHDR</span><span class="p">,</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="n">useSRPBatcher</span><span class="p">,</span>
        <span class="n">useLightsPerObject</span><span class="p">,</span> <span class="n">shadows</span><span class="p">,</span> <span class="n">postFXSettings</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">colorLUTResolution</span><span class="p">,</span>
        <span class="n">cameraRendererShader</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/camera-renderer-shader.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/camera-renderer-shader.png" alt="分配的相机渲染器着色器" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">分配的相机渲染器着色器</figcaption></figure><p>此时，<code class="language-plaintext highlighter-rouge">CameraRenderer</code> 拥有一个可用的材质。还向其添加 <code class="language-plaintext highlighter-rouge">_SourceTexture</code> 标识符，并为其提供一个类似于 <code class="language-plaintext highlighter-rouge">PostFXStack</code> 中的 <code class="language-plaintext highlighter-rouge">Draw</code> 方法，但没有 pass 参数，因为我们目前只有一个 pass。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span>
    <span class="n">colorAttachmentId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraColorAttachment"</span><span class="p">),</span>
    <span class="n">depthAttachmentId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraDepthAttachment"</span><span class="p">),</span>
    <span class="n">depthTextureId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraDepthTexture"</span><span class="p">),</span>
    <span class="n">sourceTextureId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_SourceTexture"</span><span class="p">);</span>
<span class="p">....</span>
<span class="k">void</span> <span class="nf">Draw</span> <span class="p">(</span><span class="n">RenderTargetIdentifier</span> <span class="k">from</span><span class="p">,</span> <span class="n">RenderTargetIdentifier</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalTexture</span><span class="p">(</span><span class="n">sourceTextureId</span><span class="p">,</span> <span class="k">from</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetRenderTarget</span><span class="p">(</span>
        <span class="n">to</span><span class="p">,</span> <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">DontCare</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">DrawProcedural</span><span class="p">(</span>
        <span class="n">Matrix4x4</span><span class="p">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">MeshTopology</span><span class="p">.</span><span class="n">Triangles</span><span class="p">,</span> <span class="m">3</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>要最终修复我们的渲染器，如果后处理效果未激活但我们确实使用了中间缓冲区，则通过调用 <code class="language-plaintext highlighter-rouge">Draw</code> 将颜色附件复制到相机目标。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">postFXStack</span><span class="p">.</span><span class="n">IsActive</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">postFXStack</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="n">colorAttachmentId</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">useIntermediateBuffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Draw</span><span class="p">(</span><span class="n">colorAttachmentId</span><span class="p">,</span> <span class="n">BuiltinRenderTextureType</span><span class="p">.</span><span class="n">CameraTarget</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="重建视图空间深度"><span class="me-2">重建视图空间深度</span><a href="#重建视图空间深度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要采样深度纹理，我们需要片段的 UV 坐标，它们在屏幕空间中。我们可以通过将其位置除以屏幕像素尺寸来找到它们，Unity 通过 <code class="language-plaintext highlighter-rouge">float4 _ScreenParams</code> 的 XY 分量使其可用，因此将其添加到 <code class="language-plaintext highlighter-rouge">UnityInput</code> 中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="n">unity_OrthoParams</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">_ProjectionParams</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">_ScreenParams</span><span class="p">;</span>
</pre></table></code></div></div><p>然后我们可以将片段 UV 和缓冲区深度添加到 <code class="language-plaintext highlighter-rouge">Fragment</code>。通过使用点钳位采样器通过 <code class="language-plaintext highlighter-rouge">SAMPLE_DEPTH_TEXTURE_LOD</code> 宏采样相机深度纹理来检索缓冲区深度。此宏的功能与 <code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D_LOD</code> 相同，但仅返回 R 通道。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">Fragment</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">positionSS</span><span class="p">;</span>
    <span class="kt">float2</span> <span class="n">screenUV</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">depth</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">bufferDepth</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Fragment</span> <span class="nf">GetFragment</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">positionCS_SS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Fragment</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">positionSS</span> <span class="o">=</span> <span class="n">positionSS</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">screenUV</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">positionSS</span> <span class="o">/</span> <span class="n">_ScreenParams</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">IsOrthographicCamera</span><span class="p">()</span> <span class="o">?</span>
        <span class="n">OrthographicDepthBufferToLinear</span><span class="p">(</span><span class="n">positionSS</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="o">:</span> <span class="n">positionSS</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">bufferDepth</span> <span class="o">=</span>
        <span class="n">SAMPLE_DEPTH_TEXTURE_LOD</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">,</span> <span class="n">sampler_point_clamp</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">screenUV</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这为我们提供了原始深度缓冲区值。要将其转换为视图空间深度，在正交相机的情况下，我们可以再次调用 <code class="language-plaintext highlighter-rouge">OrthographicDepthBufferToLinear</code>，就像当前片段的深度一样。透视深度也必须转换，为此我们可以使用 <code class="language-plaintext highlighter-rouge">LinearEyeDepth</code>。它需要 <code class="language-plaintext highlighter-rouge">_ZBufferParams</code> 作为第二个参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">f</span><span class="p">.</span><span class="n">bufferDepth</span> <span class="o">=</span> <span class="n">LOAD_TEXTURE2D</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">positionSS</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">bufferDepth</span> <span class="o">=</span> <span class="n">IsOrthographicCamera</span><span class="p">()</span> <span class="o">?</span>
    <span class="n">OrthographicDepthBufferToLinear</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">bufferDepth</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">LinearEyeDepth</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">bufferDepth</span><span class="p">,</span> <span class="n">_ZBufferParams</span><span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">_ZBufferParams</code> 是 Unity 提供的另一个 <code class="language-plaintext highlighter-rouge">float4</code>，它包含从原始深度到线性深度的转换因子。将其添加到 <code class="language-plaintext highlighter-rouge">UnityInput</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="n">unity_OrthoParams</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">_ProjectionParams</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">_ScreenParams</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">_ZBufferParams</span><span class="p">;</span>
</pre></table></code></div></div><p>要检查我们是否正确采样了缓冲区深度，请在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中返回它的缩放版本，就像我们之前测试片段深度一样。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">InputConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="n">GetInputConfig</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS_SS</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fragment</span><span class="p">.</span><span class="n">bufferDepth</span><span class="p">.</span><span class="n">xxx</span> <span class="o">/</span> <span class="mi">20</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/buffered-depth-perspective.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/buffered-depth-perspective.png" alt="缓冲区深度，透视（左）和正交（右）投影" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/buffered-depth-orthographic.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/buffered-depth-orthographic.png" alt="缓冲区深度，透视（左）和正交（右）投影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">缓冲区深度，透视（左）和正交（右）投影</figcaption></figure><p>一旦明确采样的深度是正确的，就删除调试可视化。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="c1">//return float4(config.fragment.bufferDepth.xxx / 20.0, 1.0);</span>
</pre></table></code></div></div><h3 id="可选的深度纹理"><span class="me-2">可选的深度纹理</span><a href="#可选的深度纹理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>复制深度需要额外的工作，尤其是在不使用后处理效果时，因为这还需要中间缓冲区和对相机目标的额外复制。因此，让我们将渲染管线是否支持复制深度设置为可配置的。我们将为此创建一个新的 <code class="language-plaintext highlighter-rouge">CameraBufferSettings</code> 结构体，放在其自己的文件中，用于分组所有与相机缓冲区相关的设置。除了复制深度的切换外，还将允许 HDR 的切换放在其中。还引入一个单独的切换来控制渲染反射时是否复制深度。这很有用，因为反射是在没有后处理效果的情况下渲染的，粒子系统也不会出现在反射中，因此为反射复制深度既昂贵又可能无用。我们确实使其成为可能，因为深度也可以用于其他效果，这些效果可能在反射中可见。即便如此，请记住，深度缓冲区对于每个立方体贴图反射面都是不同的，因此沿着立方体贴图边缘会有深度接缝。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">System</span><span class="p">.</span><span class="n">Serializable</span><span class="p">]</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">CameraBufferSettings</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">allowHDR</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">copyDepth</span><span class="p">,</span> <span class="n">copyDepthReflections</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>将 <code class="language-plaintext highlighter-rouge">CustomRenderPipelineAsset</code> 的当前 HDR 切换替换为这些相机缓冲区设置。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">//[SerializeField]</span>
<span class="c1">//bool allowHDR = true;</span>

<span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
<span class="n">CameraBufferSettings</span> <span class="n">cameraBuffer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CameraBufferSettings</span> <span class="p">{</span>
    <span class="n">allowHDR</span> <span class="p">=</span> <span class="k">true</span>
<span class="p">};</span>

<span class="k">protected</span> <span class="k">override</span> <span class="n">RenderPipeline</span> <span class="nf">CreatePipeline</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">CustomRenderPipeline</span><span class="p">(</span>
        <span class="n">cameraBuffer</span><span class="p">,</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="n">useSRPBatcher</span><span class="p">,</span>
        <span class="n">useLightsPerObject</span><span class="p">,</span> <span class="n">shadows</span><span class="p">,</span> <span class="n">postFXSettings</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">colorLUTResolution</span><span class="p">,</span>
        <span class="n">cameraRendererShader</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>也将更改应用到 <code class="language-plaintext highlighter-rouge">CustomRenderPipeline</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">//bool allowHDR;</span>
<span class="n">CameraBufferSettings</span> <span class="n">cameraBufferSettings</span><span class="p">;</span>
<span class="p">....</span>
<span class="k">public</span> <span class="nf">CustomRenderPipeline</span> <span class="p">(</span>
    <span class="n">CameraBufferSettings</span> <span class="n">cameraBufferSettings</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useSRPBatcher</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">useLightsPerObject</span><span class="p">,</span> <span class="n">ShadowSettings</span> <span class="n">shadowSettings</span><span class="p">,</span>
    <span class="n">PostFXSettings</span> <span class="n">postFXSettings</span><span class="p">,</span> <span class="kt">int</span> <span class="n">colorLUTResolution</span><span class="p">,</span> <span class="n">Shader</span> <span class="n">cameraRendererShader</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">colorLUTResolution</span> <span class="p">=</span> <span class="n">colorLUTResolution</span><span class="p">;</span>
    <span class="c1">//this.allowHDR = allowHDR;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">cameraBufferSettings</span> <span class="p">=</span> <span class="n">cameraBufferSettings</span><span class="p">;</span>
    <span class="p">....</span>
<span class="p">}</span>
<span class="p">....</span>
<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(</span>
    <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Camera</span><span class="p">&gt;</span> <span class="n">cameras</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">cameras</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">renderer</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span>
            <span class="n">context</span><span class="p">,</span> <span class="n">cameras</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cameraBufferSettings</span><span class="p">,</span>
            <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="n">useLightsPerObject</span><span class="p">,</span>
            <span class="n">shadowSettings</span><span class="p">,</span> <span class="n">postFXSettings</span><span class="p">,</span> <span class="n">colorLUTResolution</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">CameraRenderer.Render</code> 现在必须根据是否正在渲染反射来使用适当的设置。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(</span>
    <span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">Camera</span> <span class="n">camera</span><span class="p">,</span>
    <span class="n">CameraBufferSettings</span> <span class="n">bufferSettings</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useLightsPerObject</span><span class="p">,</span>
    <span class="n">ShadowSettings</span> <span class="n">shadowSettings</span><span class="p">,</span> <span class="n">PostFXSettings</span> <span class="n">postFXSettings</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">colorLUTResolution</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="c1">//useDepthTexture = true;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">cameraType</span> <span class="p">==</span> <span class="n">CameraType</span><span class="p">.</span><span class="n">Reflection</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">useDepthTexture</span> <span class="p">=</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">copyDepthReflection</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">useDepthTexture</span> <span class="p">=</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">copyDepth</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">....</span>
    <span class="n">useHDR</span> <span class="p">=</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">allowHDR</span> <span class="p">&amp;&amp;</span> <span class="n">camera</span><span class="p">.</span><span class="n">allowHDR</span><span class="p">;</span>
    <span class="p">....</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/camera-buffer-settings.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/camera-buffer-settings.png" alt="相机缓冲区设置，启用 HDR 和非反射复制深度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">相机缓冲区设置，启用 HDR 和非反射复制深度</figcaption></figure><p>除了整个渲染管线的设置之外，我们还可以向 <code class="language-plaintext highlighter-rouge">CameraSettings</code> 添加一个复制深度切换，默认启用。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="kt">bool</span> <span class="n">copyDepth</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/camera-buffer-settings-color.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/camera-buffer-settings-color.png" alt="相机复制深度切换" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">相机复制深度切换</figcaption></figure><p>然后对于常规相机，仅当渲染管线和相机都启用了深度纹理时才使用深度纹理，类似于 HDR 的控制方式。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">cameraType</span> <span class="p">==</span> <span class="n">CameraType</span><span class="p">.</span><span class="n">Reflection</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">useDepthTexture</span> <span class="p">=</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">copyDepthReflection</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">useDepthTexture</span> <span class="p">=</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">copyDepth</span> <span class="p">&amp;&amp;</span> <span class="n">cameraSettings</span><span class="p">.</span><span class="n">copyDepth</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="缺失的纹理"><span class="me-2">缺失的纹理</span><a href="#缺失的纹理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>由于深度纹理是可选的，它可能不存在。当着色器无论如何采样它时，结果将是随机的。它可能是一个空纹理或一个旧副本，可能是另一个相机的。着色器也可能在不透明渲染阶段过早地采样深度纹理。我们至少可以做的是确保无效采样将产生一致的结果。我们通过在 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 的构造函数方法中创建一个默认的缺失纹理来做到这一点。没有用于纹理的 <code class="language-plaintext highlighter-rouge">CoreUtils</code> 方法，因此我们将自己将其隐藏标志设置为 <code class="language-plaintext highlighter-rouge">HideFlags.HideAndDontSave</code>。将其命名为 <code class="language-plaintext highlighter-rouge">Missing</code>，以便在通过帧调试器检查着色器属性时很明显使用了错误的纹理。使其成为一个简单的 1×1 纹理，所有通道都设置为 0.5。还在渲染器被释放时适当地销毁它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">Texture2D</span> <span class="n">missingTexture</span><span class="p">;</span>

<span class="k">public</span> <span class="nf">CameraRenderer</span> <span class="p">(</span><span class="n">Shader</span> <span class="n">shader</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">material</span> <span class="p">=</span> <span class="n">CoreUtils</span><span class="p">.</span><span class="nf">CreateEngineMaterial</span><span class="p">(</span><span class="n">shader</span><span class="p">);</span>
    <span class="n">missingTexture</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Texture2D</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hideFlags</span> <span class="p">=</span> <span class="n">HideFlags</span><span class="p">.</span><span class="n">HideAndDontSave</span><span class="p">,</span>
        <span class="n">name</span> <span class="p">=</span> <span class="s">"Missing"</span>
    <span class="p">};</span>
    <span class="n">missingTexture</span><span class="p">.</span><span class="nf">SetPixel</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">white</span> <span class="p">*</span> <span class="m">0.5f</span><span class="p">);</span>
    <span class="n">missingTexture</span><span class="p">.</span><span class="nf">Apply</span><span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">CoreUtils</span><span class="p">.</span><span class="nf">Destroy</span><span class="p">(</span><span class="n">material</span><span class="p">);</span>
    <span class="n">CoreUtils</span><span class="p">.</span><span class="nf">Destroy</span><span class="p">(</span><span class="n">missingTexture</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">Setup</code> 结束时使用缺失纹理作为深度纹理。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">Setup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">SampleName</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalTexture</span><span class="p">(</span><span class="n">depthTextureId</span><span class="p">,</span> <span class="n">missingTexture</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="淡化背景附近的粒子"><span class="me-2">淡化背景附近的粒子</span><a href="#淡化背景附近的粒子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>现在我们有了一个可用的深度纹理，我们可以继续最终支持软粒子。第一步是向 <code class="language-plaintext highlighter-rouge">UnlitParticles</code> 添加软粒子关键字切换、距离和范围的着色器属性，类似于近距离淡出属性。在这种情况下，距离是从粒子后面的任何物体开始测量的，因此我们默认将其设置为零。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">Toggle</span><span class="p">(</span><span class="n">_SOFT_PARTICLES</span><span class="p">)]</span> <span class="n">_SoftParticles</span> <span class="p">(</span><span class="s">"Soft Particles"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_SoftParticlesDistance</span> <span class="p">(</span><span class="s">"Soft Particles Distance"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_SoftParticlesRange</span> <span class="p">(</span><span class="s">"Soft Particles Range"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mo">01</span><span class="p">,</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
</pre></table></code></div></div><p>也为其添加着色器特性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _SOFT_PARTICLES
</span></pre></table></code></div></div><p>与近距离淡出类似，如果定义了关键字，则在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中将适当的配置字段设置为 <code class="language-plaintext highlighter-rouge">true</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_NEAR_FADE)
</span>    <span class="n">config</span><span class="p">.</span><span class="n">nearFade</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif
#if defined(_SOFT_PARTICLES)
</span>    <span class="n">config</span><span class="p">.</span><span class="n">softParticles</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">UnlitInput</code> 中，将新的着色器属性添加到 <code class="language-plaintext highlighter-rouge">UnityPerMaterial</code>，并将字段添加到 <code class="language-plaintext highlighter-rouge">InputConfig</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
    <span class="p">....</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_SoftParticlesDistance</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_SoftParticlesRange</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_ZWrite</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>

<span class="cp">#define INPUT_PROP(name) UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, name)
</span>
<span class="k">struct</span> <span class="n">InputConfig</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">bool</span> <span class="n">softParticles</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">InputConfig</span> <span class="nf">GetInputConfig</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">positionCC_SS</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">baseUV</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">c</span><span class="p">.</span><span class="n">softParticles</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在 <code class="language-plaintext highlighter-rouge">GetBase</code> 中应用另一个近距离衰减，这次基于片段的缓冲区深度减去其自身深度。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">nearFade</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">nearAttenuation</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">fragment</span><span class="p">.</span><span class="n">depth</span> <span class="o">-</span> <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_NearFadeDistance</span><span class="p">))</span> <span class="o">/</span>
        <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_NearFadeRange</span><span class="p">);</span>
    <span class="n">baseMap</span><span class="p">.</span><span class="n">a</span> <span class="o">*=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">nearAttenuation</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">softParticles</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">depthDelta</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">fragment</span><span class="p">.</span><span class="n">bufferDepth</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">fragment</span><span class="p">.</span><span class="n">depth</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">nearAttenuation</span> <span class="o">=</span> <span class="p">(</span><span class="n">depthDelta</span> <span class="o">-</span> <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_SoftParticlesDistance</span><span class="p">))</span> <span class="o">/</span>
        <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_SoftParticlesRange</span><span class="p">);</span>
    <span class="n">baseMap</span><span class="p">.</span><span class="n">a</span> <span class="o">*=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">nearAttenuation</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/gizmos-depth.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/gizmos-depth.png" alt="软粒子，调整淡出范围" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">软粒子，调整淡出范围</figcaption></figure><h3 id="不支持纹理复制"><span class="me-2">不支持纹理复制</span><a href="#不支持纹理复制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这一切都工作得很好，但仅在支持通过 <code class="language-plaintext highlighter-rouge">CopyTexture</code> 直接复制纹理的情况下，至少在基本级别上。这主要是这种情况，但对于 WebGL 2.0 则不是。因此，如果我们也想支持 WebGL 2.0，我们必须回退到通过着色器复制，这效率较低，但至少可以工作。</p><p>通过 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 中的静态布尔字段跟踪是否支持 <code class="language-plaintext highlighter-rouge">CopyTexture</code>。最初将其设置为 <code class="language-plaintext highlighter-rouge">false</code>，这样即使我们的开发机器都支持它，我们也可以测试回退方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">bool</span> <span class="n">copyTextureSupported</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">CopyAttachments</code> 中，如果支持，则通过 <code class="language-plaintext highlighter-rouge">CopyTexture</code> 复制深度，否则回退到使用我们的 <code class="language-plaintext highlighter-rouge">Draw</code> 方法。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">CopyAttachments</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">useDepthTexture</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
            <span class="n">depthTextureId</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelHeight</span><span class="p">,</span>
            <span class="m">32</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Point</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Depth</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copyTextureSupported</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">CopyTexture</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">depthTextureId</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Draw</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">depthTextureId</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">ExecuteBuffer</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这最初未能产生正确的结果，因为 <code class="language-plaintext highlighter-rouge">Draw</code> 更改了渲染目标，因此进一步的绘制出错了。我们必须在之后将渲染目标设置回相机缓冲区，再次加载我们的附件。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">copyTextureSupported</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">CopyTexture</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">depthTextureId</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="nf">Draw</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">depthTextureId</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetRenderTarget</span><span class="p">(</span>
        <span class="n">colorAttachmentId</span><span class="p">,</span>
        <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">Load</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span><span class="p">,</span>
        <span class="n">depthAttachmentId</span><span class="p">,</span>
        <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">Load</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>第二个出错的是深度根本没有被复制，因为我们的复制 pass 只写入默认着色器目标，这是针对颜色数据的，而不是深度。要复制深度，我们需要向 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 着色器添加第二个 copy-depth pass，该 pass 写入深度而不是颜色。我们通过将其 <code class="language-plaintext highlighter-rouge">ColorMask</code> 设置为零并打开 <code class="language-plaintext highlighter-rouge">ZWrite</code> 来做到这一点。它还需要一个特殊的片段函数，我们将其命名为 <code class="language-plaintext highlighter-rouge">CopyDepthPassFragment</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Name</span> <span class="s">"Copy Depth"</span>

    <span class="n">ColorMask</span> <span class="mi">0</span>
    <span class="n">ZWrite</span> <span class="n">On</span>

    <span class="n">HLSLPROGRAM</span>
        <span class="cp">#pragma target 3.5
</span>        <span class="cp">#pragma vertex DefaultPassVertex
</span>        <span class="cp">#pragma fragment CopyDepthPassFragment
</span>    <span class="n">ENDHLSL</span>
<span class="p">}</span>
</pre></table></code></div></div><p>新的片段函数必须采样深度并将其作为带有 <code class="language-plaintext highlighter-rouge">SV_DEPTH</code> 语义的单个 <code class="language-plaintext highlighter-rouge">float</code> 返回，而不是带有 <code class="language-plaintext highlighter-rouge">SV_TARGET</code> 语义的 <code class="language-plaintext highlighter-rouge">float4</code>。这样我们采样原始深度缓冲区值并直接将其用于片段的新深度。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">CopyPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">SAMPLE_TEXTURE2D_LOD</span><span class="p">(</span><span class="n">_SourceTexture</span><span class="p">,</span> <span class="n">sampler_linear_clamp</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">CopyDepthPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_DEPTH</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">SAMPLE_DEPTH_TEXTURE_LOD</span><span class="p">(</span><span class="n">_SourceTexture</span><span class="p">,</span> <span class="n">sampler_point_clamp</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">screenUV</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接下来，回到 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 并向 <code class="language-plaintext highlighter-rouge">Draw</code> 添加一个布尔参数，以指示我们是从深度绘制到深度，默认设置为 <code class="language-plaintext highlighter-rouge">false</code>。如果是，则使用第二个 pass 而不是第一个 pass。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Draw</span> <span class="p">(</span>
    <span class="n">RenderTargetIdentifier</span> <span class="k">from</span><span class="p">,</span> <span class="n">RenderTargetIdentifier</span> <span class="n">to</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isDepth</span> <span class="p">=</span> <span class="k">false</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">DrawProcedural</span><span class="p">(</span>
        <span class="n">Matrix4x4</span><span class="p">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">isDepth</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="m">0</span><span class="p">,</span> <span class="n">MeshTopology</span><span class="p">.</span><span class="n">Triangles</span><span class="p">,</span> <span class="m">3</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在复制深度缓冲区时指示我们正在使用深度。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">Draw</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">depthTextureId</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
</pre></table></code></div></div><p>在验证此方法也有效后，通过检查 <code class="language-plaintext highlighter-rouge">SystemInfo.copyTextureSupport</code> 来确定是否支持 <code class="language-plaintext highlighter-rouge">CopyTexture</code>。任何大于 <code class="language-plaintext highlighter-rouge">none</code> 的支持级别都足够了。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">bool</span> <span class="n">copyTextureSupported</span> <span class="p">=</span>
    <span class="n">SystemInfo</span><span class="p">.</span><span class="n">copyTextureSupport</span> <span class="p">&gt;</span> <span class="n">CopyTextureSupport</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="gizmos-和深度"><span class="me-2">Gizmos 和深度</span><a href="#gizmos-和深度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>现在我们有了绘制深度的方法，我们可以在结合后处理效果或使用深度纹理时再次使其 gizmos 具有深度感知能力。在 <code class="language-plaintext highlighter-rouge">DrawGizmosBeforeFX</code> 中，在绘制第一个 gizmos 之前，如果我们使用中间缓冲区，则将深度复制到相机目标。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">partial</span> <span class="k">void</span> <span class="nf">DrawGizmosBeforeFX</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Handles</span><span class="p">.</span><span class="nf">ShouldRenderGizmos</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">useIntermediateBuffer</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Draw</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">BuiltinRenderTextureType</span><span class="p">.</span><span class="n">CameraTarget</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
            <span class="nf">ExecuteBuffer</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">context</span><span class="p">.</span><span class="nf">DrawGizmos</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">GizmoSubset</span><span class="p">.</span><span class="n">PreImageEffects</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果使用后处理效果，我们也必须再次这样做。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">partial</span> <span class="k">void</span> <span class="nf">DrawGizmosAfterFX</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Handles</span><span class="p">.</span><span class="nf">ShouldRenderGizmos</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">postFXStack</span><span class="p">.</span><span class="n">IsActive</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">Draw</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">BuiltinRenderTextureType</span><span class="p">.</span><span class="n">CameraTarget</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
            <span class="nf">ExecuteBuffer</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">context</span><span class="p">.</span><span class="nf">DrawGizmos</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">GizmoSubset</span><span class="p">.</span><span class="n">PostImageEffects</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/gizmos-depth.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/gizmos-depth.png" alt="Gizmos 识别深度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Gizmos 识别深度</figcaption></figure><h2 id="扭曲效果"><span class="me-2">扭曲效果</span><a href="#扭曲效果" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们还将支持 Unity 粒子的另一个功能是扭曲，它可以用来创建像热量引起的大气折射这样的效果。这需要对颜色缓冲区进行采样，就像我们已经采样深度缓冲区一样，但需要添加 UV 偏移。</p><h3 id="颜色复制纹理"><span class="me-2">颜色复制纹理</span><a href="#颜色复制纹理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们首先向 <code class="language-plaintext highlighter-rouge">CameraBufferSettings</code> 添加复制颜色的切换，同样为常规相机和反射相机分别设置一个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="kt">bool</span> <span class="n">copyColor</span><span class="p">,</span> <span class="n">copyColorReflection</span><span class="p">,</span> <span class="n">copyDepth</span><span class="p">,</span> <span class="n">copyDepthReflection</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/camera-copy-color.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/camera-copy-color.png" alt="复制颜色和深度" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">复制颜色和深度</figcaption></figure><p>也使每个相机的复制颜色可配置。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="kt">bool</span> <span class="n">copyColor</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span> <span class="n">copyDepth</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/camera-buffer-settings-color.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/camera-buffer-settings-color.png" alt="也为相机启用" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">也为相机启用</figcaption></figure><p><code class="language-plaintext highlighter-rouge">CameraRenderer</code> 现在还必须跟踪颜色纹理的标识符以及是否使用颜色纹理。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">colorTextureId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraColorTexture"</span><span class="p">),</span>
<span class="n">depthTextureId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraDepthTexture"</span><span class="p">),</span>
<span class="n">sourceTextureId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_SourceTexture"</span><span class="p">);</span>
<span class="p">....</span>
<span class="kt">bool</span> <span class="n">useColorTexture</span><span class="p">,</span> <span class="n">useDepthTexture</span><span class="p">,</span> <span class="n">useIntermediateBuffer</span><span class="p">;</span>
<span class="p">....</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(....)</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">cameraType</span> <span class="p">==</span> <span class="n">CameraType</span><span class="p">.</span><span class="n">Reflection</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">useColorTexture</span> <span class="p">=</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">copyColorReflection</span><span class="p">;</span>
        <span class="n">useDepthTexture</span> <span class="p">=</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">copyDepthReflection</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">useColorTexture</span> <span class="p">=</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">copyColor</span> <span class="p">&amp;&amp;</span> <span class="n">cameraSettings</span><span class="p">.</span><span class="n">copyColor</span><span class="p">;</span>
        <span class="n">useDepthTexture</span> <span class="p">=</span> <span class="n">bufferSettings</span><span class="p">.</span><span class="n">copyDepth</span> <span class="p">&amp;&amp;</span> <span class="n">cameraSettings</span><span class="p">.</span><span class="n">copyDepth</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">....</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们是否使用中间缓冲区现在还取决于是否使用颜色纹理。我们还应该最初将颜色纹理设置为缺失纹理。在清理时也释放它。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">Setup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">....</span>
    <span class="n">useIntermediateBuffer</span> <span class="p">=</span>
        <span class="n">useColorTexture</span> <span class="p">||</span> <span class="n">useDepthTexture</span> <span class="p">||</span> <span class="n">postFXStack</span><span class="p">.</span><span class="n">IsActive</span><span class="p">;</span>
    <span class="p">....</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">SampleName</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalTexture</span><span class="p">(</span><span class="n">colorTextureId</span><span class="p">,</span> <span class="n">missingTexture</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalTexture</span><span class="p">(</span><span class="n">depthTextureId</span><span class="p">,</span> <span class="n">missingTexture</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Cleanup</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">lighting</span><span class="p">.</span><span class="nf">Cleanup</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">useIntermediateBuffer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">colorAttachmentId</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">useColorTexture</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">colorTextureId</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">useDepthTexture</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">ReleaseTemporaryRT</span><span class="p">(</span><span class="n">depthTextureId</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们现在需要在使用颜色或深度纹理或两者时复制相机附件。让我们使 <code class="language-plaintext highlighter-rouge">CopyAttachments</code> 的调用依赖于此。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">context</span><span class="p">.</span><span class="nf">DrawSkybox</span><span class="p">(</span><span class="n">camera</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">useColorTexture</span> <span class="p">||</span> <span class="n">useDepthTexture</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">CopyAttachments</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后我们可以让它分别复制两个纹理，之后重置渲染目标并执行一次缓冲区。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">CopyAttachments</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">useColorTexture</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
            <span class="n">colorTextureId</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelHeight</span><span class="p">,</span>
            <span class="m">0</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span> <span class="n">useHDR</span> <span class="p">?</span>
                <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">DefaultHDR</span> <span class="p">:</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copyTextureSupported</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">CopyTexture</span><span class="p">(</span><span class="n">colorAttachmentId</span><span class="p">,</span> <span class="n">colorTextureId</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Draw</span><span class="p">(</span><span class="n">colorAttachmentId</span><span class="p">,</span> <span class="n">colorTextureId</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">useDepthTexture</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">GetTemporaryRT</span><span class="p">(</span>
            <span class="n">depthTextureId</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">pixelHeight</span><span class="p">,</span>
            <span class="m">32</span><span class="p">,</span> <span class="n">FilterMode</span><span class="p">.</span><span class="n">Point</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Depth</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copyTextureSupported</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">.</span><span class="nf">CopyTexture</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">depthTextureId</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Draw</span><span class="p">(</span><span class="n">depthAttachmentId</span><span class="p">,</span> <span class="n">depthTextureId</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
            <span class="c1">//buffer.SetRenderTarget(....);</span>
        <span class="p">}</span>
        <span class="c1">//ExecuteBuffer();</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(!</span><span class="n">copyTextureSupported</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">SetRenderTarget</span><span class="p">(</span>
            <span class="n">colorAttachmentId</span><span class="p">,</span>
            <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">Load</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span><span class="p">,</span>
            <span class="n">depthAttachmentId</span><span class="p">,</span>
            <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">Load</span><span class="p">,</span> <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="采样缓冲区颜色"><span class="me-2">采样缓冲区颜色</span><a href="#采样缓冲区颜色" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要采样相机颜色纹理，请将其添加到 <code class="language-plaintext highlighter-rouge">Fragment</code>。我们不会向 <code class="language-plaintext highlighter-rouge">Fragment</code> 添加缓冲区颜色属性，因为我们对其精确位置的颜色不感兴趣。相反，我们引入一个 <code class="language-plaintext highlighter-rouge">GetBufferColor</code> 函数，它接受一个片段和 UV 偏移作为参数，返回采样的颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_CameraColorTexture</span><span class="p">);</span>
<span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">Fragment</span> <span class="p">{</span> <span class="p">....</span> <span class="p">};</span>

<span class="n">Fragment</span> <span class="nf">GetFragment</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">positionCS_SS</span><span class="p">)</span> <span class="p">{</span> <span class="p">....</span> <span class="p">}</span>

<span class="kt">float4</span> <span class="nf">GetBufferColor</span> <span class="p">(</span><span class="n">Fragment</span> <span class="n">fragment</span><span class="p">,</span> <span class="kt">float2</span> <span class="n">uvOffset</span> <span class="o">=</span> <span class="kt">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">fragment</span><span class="p">.</span><span class="n">screenUV</span> <span class="o">+</span> <span class="n">uvOffset</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">SAMPLE_TEXTURE2D_LOD</span><span class="p">(</span><span class="n">_CameraColorTexture</span><span class="p">,</span> <span class="n">sampler_linear_clamp</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>要测试这一点，在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中返回带有小偏移（如两个维度各 5%）的缓冲区颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">InputConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="n">GetInputConfig</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionCS_SS</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">GetBufferColor</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fragment</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/color-buffer-with-offset.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/color-buffer-with-offset.png" alt="带偏移的相机颜色缓冲区采样" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">带偏移的相机颜色缓冲区采样</figcaption></figure><p>请注意，由于颜色在不透明阶段之后被复制，因此透明对象从中丢失。因此，粒子会擦除在它们之前绘制的所有透明对象，包括彼此。同时，深度在这种情况下不起作用，因此比片段本身更靠近相机平面的片段的颜色也会被复制。</p><p>当确认它工作正常时，删除调试可视化。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="c1">//return GetBufferColor(config.fragment, 0.05);</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>可以避免对片段前方进行采样吗？</h3><div><p>是的，在一定程度上。例如，请参阅 Flow / Looking Through Water 教程。</p></div></aside><h3 id="扭曲向量"><span class="me-2">扭曲向量</span><a href="#扭曲向量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要创建有用的扭曲效果，我们需要一个平滑过渡的扭曲向量贴图。这是一个简单的单个圆形粒子的贴图。它是一个法线贴图，因此将其导入为法线贴图。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/particles-single-distortion.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/particles-single-distortion.png" alt="粒子扭曲贴图" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">粒子扭曲贴图</figcaption></figure><p>向 <code class="language-plaintext highlighter-rouge">UnlitParticles</code> 添加关键字切换着色器属性，以及扭曲贴图和强度属性。扭曲将作为屏幕空间 UV 偏移应用，因此需要小值。让我们使用 0-0.2 的强度范围，默认值为 0.1。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">Toggle</span><span class="p">(</span><span class="n">_DISTORTION</span><span class="p">)]</span> <span class="n">_Distortion</span> <span class="p">(</span><span class="s">"Distortion"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">[</span><span class="n">NoScaleOffset</span><span class="p">]</span> <span class="n">_DistortionMap</span><span class="p">(</span><span class="s">"Distortion Vectors"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"bumb"</span> <span class="p">{}</span>
<span class="n">_DistortionStrength</span><span class="p">(</span><span class="s">"Distortion Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/distortion-enabled.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/distortion-enabled.png" alt="启用扭曲" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">启用扭曲</figcaption></figure><p>添加所需的着色器特性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma shader_feature _DISTORTION
</span></pre></table></code></div></div><p>然后将扭曲贴图和强度属性添加到 <code class="language-plaintext highlighter-rouge">UnlitInput</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">);</span>
<span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_DistortionMap</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">sampler_BaseMap</span><span class="p">);</span>

<span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
    <span class="p">....</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_SoftParticlesRange</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_DistortionStrength</span><span class="p">)</span>
    <span class="p">....</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
</pre></table></code></div></div><p>引入一个新的 <code class="language-plaintext highlighter-rouge">GetDistortion</code> 函数，返回一个 <code class="language-plaintext highlighter-rouge">float2</code> 向量。让它采样扭曲贴图并像基础贴图一样应用翻书混合，然后解码按扭曲强度缩放的法线。我们只需要向量的 XY 分量，因此丢弃 Z。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">float2</span> <span class="nf">GetDistortion</span> <span class="p">(</span><span class="n">InputConfig</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">rawMap</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_DistortionMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">flipbookBlending</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rawMap</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span>
            <span class="n">rawMap</span><span class="p">,</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_DistortionMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">flipbookUVB</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span>
            <span class="n">c</span><span class="p">.</span><span class="n">flipbookUVB</span><span class="p">.</span><span class="n">z</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">DecodeNormal</span><span class="p">(</span><span class="n">rawMap</span><span class="p">,</span> <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_DistortionStrength</span><span class="p">)).</span><span class="n">xy</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中，如果启用了扭曲，则检索它并将其用作偏移来获取缓冲区颜色，覆盖基础颜色。在裁剪之后执行此操作。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="n">base</span> <span class="o">=</span> <span class="n">GetBase</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
<span class="cp">#if defined(_CLIPPING)
</span>    <span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">GetCutoff</span><span class="p">(</span><span class="n">config</span><span class="p">));</span>
<span class="cp">#endif
</span>
<span class="cp">#if defined(_DISTORTION)
</span>    <span class="kt">float2</span> <span class="n">distortion</span> <span class="o">=</span> <span class="n">GetDistortion</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">GetBufferColor</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fragment</span><span class="p">,</span> <span class="n">distortion</span><span class="p">);</span>
<span class="cp">#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/distorted-color-buffer.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/distorted-color-buffer.png" alt="扭曲的颜色缓冲区" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">扭曲的颜色缓冲区</figcaption></figure><p>结果是粒子径向扭曲颜色纹理，除了它们的角落，因为那里的扭曲向量为零。但扭曲效果应该取决于粒子的视觉强度，这由原始基础 alpha 控制。因此用基础 alpha 调制扭曲偏移向量。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float2</span> <span class="n">distortion</span> <span class="o">=</span> <span class="n">GetDistortion</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="o">*</span> <span class="n">base</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/modulated-distortion.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/modulated-distortion.png" alt="调制的扭曲" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">调制的扭曲</figcaption></figure><p>此时我们仍然得到硬边缘，暴露了粒子完全重叠并且是矩形的。我们通过保持粒子的原始 alpha 来隐藏这一点。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">base</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">GetBufferColor</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fragment</span><span class="p">,</span> <span class="n">distortion</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/faded-distortion.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/faded-distortion.png" alt="淡化的扭曲" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">淡化的扭曲</figcaption></figure><p>现在扭曲的颜色纹理样本也会淡出，这使得未扭曲的背景和其他粒子部分可见。结果是一个平滑的混乱，在物理上没有意义，但足以提供大气折射的错觉。这可以通过调整扭曲强度以及通过在粒子的生命周期内调整它们的颜色来平滑地淡入淡出粒子来进一步改进。此外，偏移向量与屏幕对齐，不受粒子方向的影响。因此，如果粒子设置为在其生命周期内旋转，它们的单个扭曲模式将看起来会扭曲。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/particles-flipbook-distortion.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/particles-flipbook-distortion.png" alt="扭曲效果" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">扭曲效果</figcaption></figure><h3 id="扭曲混合"><span class="me-2">扭曲混合</span><a href="#扭曲混合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>目前，当启用扭曲时，我们完全替换粒子的原始颜色，只保留它们的 alpha。粒子颜色可以以各种方式与扭曲的颜色缓冲区组合。我们将添加一个简单的扭曲混合着色器属性，以在粒子自己的颜色和它引起的扭曲之间进行插值，使用与 Unity 粒子着色器相同的方法。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">_DistortionStrength</span><span class="p">(</span><span class="s">"Distortion Strength"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span>
<span class="n">_DistortionBlend</span><span class="p">(</span><span class="s">"Distortion Blend"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/distortion-blend.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/distortion-blend.png" alt="扭曲混合滑块" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">扭曲混合滑块</figcaption></figure><p>将属性添加到 <code class="language-plaintext highlighter-rouge">UnlitInput</code> 以及一个函数来获取它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_DistortionStrength</span><span class="p">)</span>
<span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_DistortionBlend</span><span class="p">)</span>
<span class="p">....</span>
<span class="n">float</span> <span class="nf">GetDistortionBlend</span> <span class="p">(</span><span class="n">InputConfig</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">INPUT_PROP</span><span class="p">(</span><span class="n">_DistortionBlend</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>其思想是，当混合滑块为 1 时，我们只看到扭曲。降低它会使粒子颜色出现，但它不会完全隐藏扭曲。相反，我们根据其 alpha 减去混合滑块（饱和后）从扭曲插值到粒子颜色。因此，当启用扭曲时，粒子自己的颜色将始终更弱，并且与禁用扭曲时相比显得更小，除非它完全不透明的地方。在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中执行插值。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_DISTORTION)
</span>    <span class="kt">float2</span> <span class="n">distortion</span> <span class="o">=</span> <span class="n">GetDistortion</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="o">*</span> <span class="n">base</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
    <span class="n">base</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span>
        <span class="n">GetBufferColor</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fragment</span><span class="p">,</span> <span class="n">distortion</span><span class="p">).</span><span class="n">rgb</span><span class="p">,</span> <span class="n">base</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span>
        <span class="nb">saturate</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">GetDistortionBlend</span><span class="p">(</span><span class="n">config</span><span class="p">))</span>
    <span class="p">);</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>这对于更复杂的粒子（如我们的翻书示例）看起来更好。因此，这是翻书的扭曲纹理。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:2px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp15particles/particles-flipbook-distortion.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp15particles/particles-flipbook-distortion.png" alt="粒子翻书的扭曲贴图" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">粒子翻书的扭曲贴图</figcaption></figure><p>这可以用来创建有趣的扭曲效果。逼真的效果会很微妙，因为当系统处于运动状态时，一点扭曲就足够了。但出于演示目的，我将效果做得很强，以便它们在视觉上很明显，即使在截图中也是如此。</p><p> <video class="embed-video file" controls=""> <source src="https://catlikecoding.com/unity/tutorials/custom-srp/particles/distortion/distortion-with-flipbook-fx.mp4" type="video/mp4" /> Your browser does not support the video tag. Here is a <a href="https://catlikecoding.com/unity/tutorials/custom-srp/particles/distortion/distortion-with-flipbook-fx.mp4">link to the video file</a> instead. </video> <em>带有翻书和后处理效果的扭曲</em></p><h3 id="修复非标准相机"><span class="me-2">修复非标准相机</span><a href="#修复非标准相机" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们当前的方法在仅使用单个相机时有效，但在没有后处理效果的情况下渲染到中间纹理时会失败。这是因为我们正在执行到相机目标的常规复制，这会忽略视口和最终混合模式。因此，<code class="language-plaintext highlighter-rouge">CameraRenderer</code> 也需要一个 <code class="language-plaintext highlighter-rouge">FinalPass</code> 方法。它是 <code class="language-plaintext highlighter-rouge">PostFXStack.FinalPass</code> 的副本，只是我们将使用常规复制 pass，因此我们应该在之后将混合模式设置回 one-zero，以免影响其他复制操作。源纹理始终是颜色附件，最终混合模式成为参数。</p><p>同样，对于 Unity 2022，如果我们不渲染到完整视口，我们确实关心加载缓冲区。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">Rect</span> <span class="n">fullViewRect</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
<span class="p">....</span>
<span class="k">void</span> <span class="nf">DrawFinal</span> <span class="p">(</span><span class="n">CameraSettings</span><span class="p">.</span><span class="n">FinalBlendMode</span> <span class="n">finalBlendMode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">srcBlendId</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">finalBlendMode</span><span class="p">.</span><span class="n">source</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">dstBlendId</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">finalBlendMode</span><span class="p">.</span><span class="n">destination</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalTexture</span><span class="p">(</span><span class="n">sourceTextureId</span><span class="p">,</span> <span class="n">colorAttachmentId</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetRenderTarget</span><span class="p">(</span>
        <span class="n">BuiltinRenderTextureType</span><span class="p">.</span><span class="n">CameraTarget</span><span class="p">,</span>
        <span class="n">finalBlendMode</span><span class="p">.</span><span class="n">destination</span> <span class="p">==</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">Zero</span> <span class="p">&amp;&amp;</span> <span class="n">camera</span><span class="p">.</span><span class="n">rect</span> <span class="p">==</span> <span class="n">fullViewRect</span><span class="p">?</span>
            <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">DontCare</span> <span class="p">:</span> <span class="n">RenderBufferLoadAction</span><span class="p">.</span><span class="n">Load</span><span class="p">,</span>
        <span class="n">RenderBufferStoreAction</span><span class="p">.</span><span class="n">Store</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetViewport</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">pixelRect</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">DrawProcedural</span><span class="p">(</span>
        <span class="n">Matrix4x4</span><span class="p">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">MeshTopology</span><span class="p">.</span><span class="n">Triangles</span><span class="p">,</span> <span class="m">3</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">srcBlendId</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">SetGlobalFloat</span><span class="p">(</span><span class="n">dstBlendId</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在这种情况下，我们将混合模式着色器属性命名为 <code class="language-plaintext highlighter-rouge">_CameraSrcBlend</code> 和 <code class="language-plaintext highlighter-rouge">_CameraDstBlend</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">sourceTextureId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_SourceTexture"</span><span class="p">),</span>
<span class="n">srcBlendId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraSrcBlend"</span><span class="p">),</span>
<span class="n">dstBlendId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_CameraDstBlend"</span><span class="p">);</span>
</pre></table></code></div></div><p>调整 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 的复制 pass 以依赖这些属性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">Name</span> <span class="s">"Copy"</span>

    <span class="n">Blend</span> <span class="p">[</span><span class="n">_CameraSrcBlend</span><span class="p">]</span> <span class="p">[</span><span class="n">_CameraDstBlend</span><span class="p">]</span>

    <span class="n">HLSLPROGRAM</span>
        <span class="cp">#pragma target 3.5
</span>        <span class="cp">#pragma vertex DefaultPassVertex
</span>        <span class="cp">#pragma fragment CopyPassFragment
</span>    <span class="n">ENDHLSL</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，在 <code class="language-plaintext highlighter-rouge">Render</code> 中调用 <code class="language-plaintext highlighter-rouge">DrawFinal</code> 而不是 <code class="language-plaintext highlighter-rouge">Draw</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">postFXStack</span><span class="p">.</span><span class="n">IsActive</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">postFXStack</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="n">colorAttachmentId</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">useIntermediateBuffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">DrawFinal</span><span class="p">(</span><span class="n">cameraSettings</span><span class="p">.</span><span class="n">finalBlendMode</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>请注意，颜色和深度纹理仅包含当前相机渲染的内容。扭曲粒子和类似效果不会拾取其他相机的数据。</p><hr /><p>下一个文章<a href="../rendering-scale">Render Scale</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/scriptrenderpipeline/">ScriptRenderPipeline</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/srp/" class="post-tag no-text-decoration" >SRP</a> <a href="/tags/particles/" class="post-tag no-text-decoration" >Particles</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E9%A2%9C%E8%89%B2%E5%92%8C%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Fparticles%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E9%A2%9C%E8%89%B2%E5%92%8C%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Fparticles%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Fparticles%2F&text=%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E9%A2%9C%E8%89%B2%E5%92%8C%E6%B7%B1%E5%BA%A6%E7%BA%B9%E7%90%86%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/particles/">粒子系统：颜色和深度纹理</a><li class="text-truncate lh-lg"> <a href="/posts/color-grading/">Unity自定义渲染管线13：色彩分级</a><li class="text-truncate lh-lg"> <a href="/posts/post-processing/">自定义渲染管线:后处理 (翻译十一)</a><li class="text-truncate lh-lg"> <a href="/posts/hdr/">自定义渲染管线:HDR (翻译十二)</a><li class="text-truncate lh-lg"> <a href="/posts/point-spot-light-shadow/">自定义渲染管线:点光源与聚光灯阴影 (翻译十)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/multiple-camera/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1603641600" data-df="ll" > Oct 26, 2020 </time><h4 class="pt-0 my-2">自定义渲染管线:多摄像机渲染 (翻译十四)</h4><div class="text-muted"><p>深入探讨Unity自定义渲染管线中的多摄像机渲染技术，包括分屏渲染、摄像机混合以及渲染层遮罩的实现。</p></div></div></a></article><article class="col"> <a href="/posts/color-grading/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1601344800" data-df="ll" > Sep 29, 2020 </time><h4 class="pt-0 my-2">Unity自定义渲染管线13：色彩分级</h4><div class="text-muted"><p>通过色彩分级调整图像的颜色，复制 URP/HDRP 的多种色彩分级工具，并使用色彩查找表（LUT）来优化性能。</p></div></div></a></article><article class="col"> <a href="/posts/hdr/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1597593600" data-df="ll" > Aug 17, 2020 </time><h4 class="pt-0 my-2">自定义渲染管线:HDR (翻译十二)</h4><div class="text-muted"><p>实现高动态范围渲染、散射和高动态范围映射</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/multiple-camera/" class="btn btn-outline-primary" aria-label="Older" ><p>自定义渲染管线:多摄像机渲染 (翻译十四)</p></a> <a href="/posts/rendering-scale/" class="btn btn-outline-primary" aria-label="Newer" ><p>自定义管线:渲染缩放 (翻译十六)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/point-light/">Point Light</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/spot-light/">Spot Light</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
