<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="编写一个 HLSL shader 支持 SRP batcher、GPU instancing 以及 dynamic batching 为每个对象配置材质属性，并随机绘制多个对象 创建透明（transparent）和镂空（cutout）材质" /><meta property="og:description" content="编写一个 HLSL shader 支持 SRP batcher、GPU instancing 以及 dynamic batching 为每个对象配置材质属性，并随机绘制多个对象 创建透明（transparent）和镂空（cutout）材质" /><link rel="canonical" href="www.damonc.top/posts/drawcalls-shaders-batches/" /><meta property="og:url" content="www.damonc.top/posts/drawcalls-shaders-batches/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/SRP/srp1-2/tutorial-image2.jpg" /><meta property="og:image:alt" content="使用 custom render pipeline 进行渲染" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-10-31T00:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/SRP/srp1-2/tutorial-image2.jpg" /><meta name="twitter:image:alt" content="使用 custom render pipeline 进行渲染" /><meta property="twitter:title" content="自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2026-02-18T01:12:55+08:00","datePublished":"2019-10-31T00:00:00+08:00","description":"编写一个 HLSL shader 支持 SRP batcher、GPU instancing 以及 dynamic batching 为每个对象配置材质属性，并随机绘制多个对象 创建透明（transparent）和镂空（cutout）材质","headline":"自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)","image":{"lqip":"data:image/webp;base64,UklGRl4AAABXRUJQVlA4IFIAAABwAwCdASoUAAoAP3Ggxlk0q6ejsAgCkC4JQBdgAb3iol6uGYAA+KhprwKbhgE7b5bV5a9GuHUXDtkgBF8EsHNxRatrYbuVwf2khhH11BEoGAAA","alt":"使用 custom render pipeline 进行渲染","url":"https://img.damonc.top/posts/SRP/srp1-2/tutorial-image2.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/drawcalls-shaders-batches/"},"url":"www.damonc.top/posts/drawcalls-shaders-batches/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘摊手</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1572451200" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Oct 31, 2019 </time> </span> <span> Updated <time data-ts="1771348375" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 18, 2026 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/SRP/srp1-2/tutorial-image2.jpg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/SRP/srp1-2/tutorial-image2.jpg" alt="使用 custom render pipeline 进行渲染" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRl4AAABXRUJQVlA4IFIAAABwAwCdASoUAAoAP3Ggxlk0q6ejsAgCkC4JQBdgAb3iol6uGYAA+KhprwKbhgE7b5bV5a9GuHUXDtkgBF8EsHNxRatrYbuVwf2khhH11BEoGAAA"></a><figcaption class="text-center pt-2 pb-2">使用 custom render pipeline 进行渲染</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/drawcalls-shaders-batches/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="11954 words" > <em>66 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>编写一个 HLSL shader<li>支持 SRP batcher、GPU instancing 以及 dynamic batching<li>为每个对象配置材质属性，并随机绘制多个对象<li>创建透明（transparent）和镂空（cutout）材质</ul><hr /><h2 id="shaders"><span class="me-2">Shaders</span><a href="#shaders" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>为了绘制物体，CPU 必须告诉 GPU 绘制什么以及如何绘制。绘制的内容通常是一个 mesh。如何绘制则由 shader 定义，它是一组供 GPU 执行的指令。除了 mesh 之外，shader 还需要额外的信息来完成工作，包括物体的变换矩阵（transformation matrices）和材质属性。</p><p>Unity 的 <code class="language-plaintext highlighter-rouge">LW/Universal</code> 和 HD RP 允许你使用 Shader Graph package 来设计 shader，它会为你生成 shader 代码。但我们的自定义 RP 不支持该功能，因此我们必须亲手编写 shader 代码。这让我们能够完全控制并理解 shader 的工作原理。</p><h3 id="unlit-shader"><span class="me-2">Unlit Shader</span><a href="#unlit-shader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们的第一个 shader 将简单地以纯色绘制 mesh，不包含任何光照。可以通过 <em>Assets / Create / Shader</em> 菜单中的选项之一创建 shader asset。 Unlit Shader 是最合适的选择，但我们将从头开始，删除创建的 shader 文件中所有的默认代码。将该 asset 命名为 Unlit ，并将其存放在 Custom RP 下新建的 Shaders 文件夹中。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/shader-asset.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/shader-asset.png" alt="Unlit shader asset." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Unlit shader asset.</figcaption></figure><p>Shader 的定义类似于一个类，但只需使用 Shader 关键字，后跟一个字符串，该字符串用于在材质的 Shader 下拉菜单中为其创建一个条目。让我们使用 Custom RP/Unlit 。紧随其后的是一个代码块，其中包含更多带有关键字的前缀块。有一个 Properties 块用于定义材质属性，接着是一个 SubShader 块，其中必须包含一个 Pass 块，用于定义一种渲染方式。请创建该结构，内部块暂时保持为空。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Custom RP/Unlit"</span> <span class="p">{</span>

    <span class="n">Properties</span> <span class="p">{}</span>

    <span class="n">SubShader</span> 
    <span class="p">{</span>
        <span class="n">Pass</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这定义了一个最小化的 Shader，它可以编译并允许我们创建一个使用它的材质。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/unlit-material.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/unlit-material.png" alt="自定义 Unlit 材质" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">自定义 Unlit 材质</figcaption></figure><p>默认的 Shader 实现会将网格渲染为纯白色。材质显示了渲染队列（render queue）的默认属性，它是从 Shader 中自动获取的，并被设置为 2000，这是不透明几何体的默认值。它还有一个启用双面全局光照（double-sided global illumination）的开关，但这对我们来说并不重要。</p><h3 id="hlsl-programs"><span class="me-2">HLSL Programs</span><a href="#hlsl-programs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>用于编写 shader 代码的语言是高级着色语言（High-Level Shading Language），简称 HLSL。我们需要将其放置在 Pass 代码块中，位于 HLSLPROGRAM 和 ENDHLSL 关键字之间。这样做是因为在 Pass 代码块中也可以放置其他非 HLSL 代码。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">Pass</span> <span class="p">{</span>
    <span class="n">HLSLPROGRAM</span>
    <span class="n">ENDHLSL</span>
<span class="p">}</span>
</pre></table></code></div></div><p>为了绘制 mesh，GPU 必须对其所有三角形进行光栅化，将其转换为像素数据。它通过将顶点坐标从 3D 空间变换到 2D 可视化空间，然后填充被所得三角形覆盖的所有像素来实现这一点。这两个步骤由两个独立的 shader 程序控制，我们必须同时定义它们。第一个被称为顶点内核/程序/着色器（vertex kernel/program/shader），第二个被称为片元内核/程序/着色器（fragment kernel/program/shader）。一个片元（fragment）对应一个显示像素或纹理纹素（texel），尽管它可能不代表最终结果，因为稍后当有东西绘制在它上面时，它可能会被覆盖。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">HLSLPROGRAM</span>
<span class="cp">#pragma vertex UnlitPassVertex
#pragma fragment UnlitPassFragment
</span><span class="n">ENDHLSL</span>
</pre></table></code></div></div><p>shader 编译器现在会提示找不到声明的 shader kernels。我们需要编写同名的 HLSL 函数来定义它们的实现。我们可以直接在 pragma 指令下方编写，但我们将把所有 HLSL 代码放在一个单独的文件中。具体来说，我们将在同一个 asset 文件夹中使用一个 UnlitPass.hlsl 文件。我们可以通过添加一个带有文件相对路径的 <code class="language-plaintext highlighter-rouge">#include</code> 指令，来指示 shader 编译器插入该文件的内容。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">HLSLPROGRAM</span>
<span class="p">...</span>
<span class="cp">#include</span> <span class="cpf">"UnlitPass.hlsl"</span><span class="cp">
</span><span class="n">ENDHLSL</span>
</pre></table></code></div></div><p>Unity 没有创建 HLSL 文件的便捷菜单选项，因此你必须执行类似以下的操作：复制 shader 文件，将其重命名为 UnlitPass ，在外部将其文件扩展名更改为 hlsl 并清空其内容。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/unlit-pass-asset.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/unlit-pass-asset.png" alt="UnlitPass HLSL asset file." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">UnlitPass HLSL asset file.</figcaption></figure><h3 id="include-guard"><span class="me-2">Include Guard</span><a href="#include-guard" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>HLSL 文件用于对代码进行分组，就像 C# 类一样，尽管 HLSL 并没有类的概念。除了代码块的局部作用域外，只有一个全局作用域。因此，所有内容在任何地方都是可以访问的。包含（include）一个文件也不等同于使用命名空间。它会在 include 指令所在的位置插入文件的全部内容，所以如果你多次包含同一个文件，就会得到重复的代码，这极有可能导致编译错误。为了防止这种情况，我们将为 UnlitPass.hlsl 添加一个 <code class="language-plaintext highlighter-rouge">include guard</code>。</p><p>可以使用 #define 指令来定义任何标识符，通常使用大写字母。我们将使用它在文件顶部定义 <code class="language-plaintext highlighter-rouge">CUSTOM_UNLIT_PASS_INCLUDED</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_UNLIT_PASS_INCLUDED
#define CUSTOM_UNLIT_PASS_INCLUDED
#endif
</span></pre></table></code></div></div><p>如果宏已经被定义，那么 #ifndef 之后的所有代码都将被跳过，从而不会被编译。我们必须在文件末尾添加 #endif 指令来结束其作用域。</p><h3 id="shader-functions"><span class="me-2">Shader Functions</span><a href="#shader-functions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们在包含保护（include guard）的作用域内定义 shader 函数。它们的写法就像没有访问修饰符的 C# 方法。先从什么都不做的简单 void 函数开始。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_UNLIT_PASS_INCLUDED
#define CUSTOM_UNLIT_PASS_INCLUDED
</span>
<span class="kt">void</span> <span class="nf">UnlitPassVertex</span> <span class="p">()</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="nf">UnlitPassFragment</span> <span class="p">()</span> <span class="p">{}</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>为了生成有效的输出，我们必须让 fragment 函数返回一个颜色。该颜色由一个包含红、绿、蓝和 alpha 分量的四分量 $float4$ 向量定义。我们可以通过 $float4(0.0, 0.0, 0.0, 0.0)$ 来定义纯黑色，但也可以只写一个零，因为单个数值会自动扩展为完整的向量。由于我们正在创建一个不透明的 shader，因此 alpha 值并不重要，写零即可。</p><p>此时着色器编译器会报错，因为我们的函数缺少语义（semantics）。我们必须指明返回值的含义，因为我们可能会产生许多具有不同含义的数据。在这种情况下，我们提供渲染目标的默认系统值，方法是在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 的参数列表后写一个冒号，后跟 SV_TARGET。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnlitPassFragment</span> <span class="p">()</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">UnlitPassVertex</code> 负责变换顶点位置，因此应该返回一个位置。这同样是一个 $float4$ 向量，因为它必须被定义为齐次裁剪空间位置，我们稍后会详细介绍。我们再次从零向量开始，在这种情况下，我们必须指明其含义为 <code class="language-plaintext highlighter-rouge">SV_POSITION</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnlitPassVertex</span> <span class="p">()</span> <span class="o">:</span> <span class="nb">SV_POSITION</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="space-transformation"><span class="me-2">Space Transformation</span><a href="#space-transformation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当所有顶点都被设置为$0$时，mesh 会塌陷为一个点，并且不会渲染任何内容。vertex function 的主要任务是将原始顶点位置转换到正确的空间。调用该函数时，如果我们提出请求，它将获得可用的顶点数据。我们通过向 <code class="language-plaintext highlighter-rouge">UnlitPassVertex</code> 添加参数来实现这一点。我们需要在对象空间（object space）中定义的顶点位置，因此我们将其命名为 positionOS，采用与 Unity 新 RP 相同的命名约定。该位置的类型是 $float3$，因为它是一个 3D 点。让我们最初先返回它，并通过 $float4(positionOS, 1.0)$ 添加 1 作为所需的第四个分量。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionOS</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kt">float4</span><span class="p">(</span><span class="n">positionOS</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们还需要为输入添加语义，因为顶点数据可以包含的不仅仅是位置。在这种情况下，我们需要在参数名称后直接加上一个冒号来添加 <code class="language-plaintext highlighter-rouge">POSITION</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kt">float4</span><span class="p">(</span><span class="n">positionOS</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/object-space-position.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/object-space-position.png" alt="对象空间位置" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">对象空间位置</figcaption></figure><p>网格再次显示出来，但这是错误的，因为我们输出的位置是在错误的空间中。空间转换需要矩阵，这些矩阵在绘制时会被发送到 GPU。我们必须将这些矩阵添加到我们的着色器中，但由于它们总是相同的，我们将 Unity 提供的标准输入放在一个单独的 HLSL 文件中，既是为了保持代码结构化，也是为了能够将代码包含在其他着色器中。添加一个 <code class="language-plaintext highlighter-rouge">UnityInput.hlsl</code> 文件，并将其放在直接位于 Custom RP 下的 <strong>ShaderLibrary</strong> 文件夹中，以镜像 Unity 资源包的文件夹结构。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/shader-library.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/shader-library.png" alt="ShaderLibrary 文件夹与 UnityInput 文件" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">ShaderLibrary 文件夹与 UnityInput 文件</figcaption></figure><p>文件开头先编写一个 <code class="language-plaintext highlighter-rouge">include guard CUSTOM_UNITY_INPUT_INCLUDED</code> ，然后在全局作用域内定义一个名为 unity_ObjectToWorld 的 $float4x4$ 矩阵。在 C# 类中这相当于定义一个字段，但在着色器中它被称为 uniform 值。它由 GPU 在每次 draw 时设置一次，并在该次 draw 期间的所有 vertex 和 fragment 函数调用中保持不变（即 uniform，统一的）。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_UNITY_INPUT_INCLUDED
#define CUSTOM_UNITY_INPUT_INCLUDED
</span>
<span class="kt">float4x4</span> <span class="n">unity_ObjectToWorld</span><span class="p">;</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>我们可以使用矩阵将坐标从对象空间转换到世界空间。由于这是常见功能，让我们为此创建一个函数，并将其放在另一个文件中，这次是放在同一个 ShaderLibrary 文件夹的 Common.hlsl 文件里。我们在其中包含 UnityInput ，然后声明一个 <code class="language-plaintext highlighter-rouge">TransformObjectToWorld</code> 函数，将 <code class="language-plaintext highlighter-rouge">float3</code> 作为输入和输出。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cp">#ifndef CUSTOM_COMMON_INCLUDED
#define CUSTOM_COMMON_INCLUDED
</span>
<span class="cp">#include</span> <span class="cpf">"UnityInput.hlsl"</span><span class="cp">
</span>
<span class="kt">float3</span> <span class="nf">TransformObjectToWorld</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionOS</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
	
<span class="cp">#endif
</span></pre></table></code></div></div><p>空间转换是通过调用带有矩阵和向量的 mul 函数来完成的。在这种情况下，我们确实需要一个 4D 向量，但由于其第四个分量始终为 1，我们可以通过使用 $float4(positionOS, 1.0)$ 自行添加。结果同样是一个第四分量始终为 1 的 4D 向量。我们可以通过访问向量的 xyz 属性从中提取前三个分量，这被称为 swizzle 操作。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">TransformObjectToWorld</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionOS</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">positionOS</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们现在可以在 <code class="language-plaintext highlighter-rouge">UnlitPassVertex</code> 中转换到世界空间。首先在函数正上方包含 Common.hlsl 。由于它存在于不同的文件夹中，我们可以通过相对路径 ../ShaderLibrary/Common.hlsl 访问它。然后使用 <code class="language-plaintext highlighter-rouge">TransformObjectToWorld</code> 计算 positionWS 变量，并返回它以替代对象空间位置。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>#include "../ShaderLibrary/Common.hlsl"

float4 UnlitPassVertex (float3 positionOS : POSITION) : SV_POSITION {
	float3 positionWS = TransformObjectToWorld(positionOS.xyz);
	return float4(positionWS, 1.0);
}
</pre></table></code></div></div><p>结果仍然错误，因为我们需要一个在齐次裁剪空间中的位置。这个空间定义了一个立方体，其中包含相机视野内的一切，在透视相机的情况下，它会变形为梯形。从世界空间转换到这个空间可以通过乘以视图投影矩阵来完成，该矩阵考虑了相机的位置、方向、投影、视场和近远裁剪平面。unity_ObjectToWorld矩阵已经提供，所以将其添加到UnityInput.hlsl中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float4x4</span> <span class="n">unity_ObjectToWorld</span><span class="p">;</span>

<span class="kt">float4x4</span> <span class="n">unity_MatrixVP</span><span class="p">;</span>
</pre></table></code></div></div><p>向 Common.hlsl 添加一个 TransformWorldToHClip ，其工作原理与 <code class="language-plaintext highlighter-rouge">TransformObjectToWorld</code> 相同，不同之处在于其输入位于世界空间（world space），使用另一个矩阵，并生成一个 float4 。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">TransformObjectToWorld</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionOS</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">positionOS</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float4</span> <span class="nf">TransformWorldToHClip</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionWS</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_MatrixVP</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">positionWS</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让 UnlitPassVertex 使用该函数返回正确空间中的位置。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span> <span class="p">{</span>
	<span class="kt">float3</span> <span class="n">positionWS</span> <span class="o">=</span> <span class="n">TransformObjectToWorld</span><span class="p">(</span><span class="n">positionOS</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">positionWS</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/black-sphere.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/black-sphere.png" alt="修正黑色球体" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">修正黑色球体</figcaption></figure><p>我们刚刚定义的这两个函数非常常用，因此它们也被包含在 <code class="language-plaintext highlighter-rouge">Core RP Pipeline package</code> 中。核心库定义了更多有用且必不可少的内容，所以让我们安装该 package，删除我们自己的定义，并改为包含相关文件，在本例中是 <em>Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl</em>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">//float3 TransformObjectToWorld (float3 positionOS) {</span>
<span class="c1">//	return mul(unity_ObjectToWorld, float4(positionOS, 1.0)).xyz;</span>
<span class="c1">//}</span>

<span class="c1">//float4 TransformWorldToHClip (float3 positionWS) {</span>
<span class="c1">//	return mul(unity_MatrixVP, float4(positionWS, 1.0));</span>
<span class="c1">//}</span>

<span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><p>这会导致编译失败，因为 <code class="language-plaintext highlighter-rouge">SpaceTransforms.hlsl</code> 中的代码并不假定 unity_ObjectToWorld 存在。相反，它期望相关的矩阵通过宏定义为 UNITY_MATRIX_M，所以让我们在包含文件之前，在单独的一行编写 #define UNITY_MATRIX_M unity_ObjectToWorld 来实现这一点。之后，所有出现的 <code class="language-plaintext highlighter-rouge">UNITY_MATRIX_M</code> 都会被替换为 unity_ObjectToWorld。这样做是有原因的，我们稍后会发现。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#define UNITY_MATRIX_M unity_ObjectToWorld
</span>
<span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><p>对于逆矩阵 <code class="language-plaintext highlighter-rouge">unity_WorldToObject</code> 也是如此，它应该通过 <code class="language-plaintext highlighter-rouge">UNITY_MATRIX_I_M</code> 定义；<code class="language-plaintext highlighter-rouge">unity_MatrixV</code> 矩阵通过 <code class="language-plaintext highlighter-rouge">UNITY_MATRIX_V</code> 定义；而 <code class="language-plaintext highlighter-rouge">unity_MatrixVP</code> 通过 <code class="language-plaintext highlighter-rouge">UNITY_MATRIX_VP</code> 定义。最后，还有通过 <code class="language-plaintext highlighter-rouge">UNITY_MATRIX_P</code> 定义的投影矩阵，它以 <code class="language-plaintext highlighter-rouge">glstate_matrix_projection</code> 的形式提供。我们不需要这些额外的矩阵，但如果不包含它们，代码将无法编译。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#define UNITY_MATRIX_M unity_ObjectToWorld
#define UNITY_MATRIX_I_M unity_WorldToObject
#define UNITY_MATRIX_V unity_MatrixV
#define UNITY_MATRIX_VP unity_MatrixVP
#define UNITY_MATRIX_P glstate_matrix_projection
</span></pre></table></code></div></div><p>Unity 2022 需要额外的三个矩阵。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#define UNITY_MATRIX_M unity_ObjectToWorld
#define UNITY_MATRIX_I_M unity_WorldToObject
#define UNITY_MATRIX_V unity_MatrixV
#define UNITY_MATRIX_VP unity_MatrixVP
#define UNITY_MATRIX_P glstate_matrix_projection
#define UNITY_MATRIX_I_V unity_MatrixInvV
#define UNITY_PREV_MATRIX_M unity_prev_MatrixM
#define UNITY_PREV_MATRIX_I_M unity_prev_MatrixIM
</span></pre></table></code></div></div><p>也将额外的矩阵添加到 UnityInput 。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">float4x4</span> <span class="n">unity_ObjectToWorld</span><span class="p">;</span>
<span class="kt">float4x4</span> <span class="n">unity_WorldToObject</span><span class="p">;</span>

<span class="kt">float4x4</span> <span class="n">unity_MatrixVP</span><span class="p">;</span>
<span class="kt">float4x4</span> <span class="n">unity_MatrixV</span><span class="p">;</span>
<span class="kt">float4x4</span> <span class="n">unity_MatrixInvV</span><span class="p">;</span>
<span class="kt">float4x4</span> <span class="n">unity_prev_MatrixM</span><span class="p">;</span>
<span class="kt">float4x4</span> <span class="n">unity_prev_MatrixIM</span><span class="p">;</span>
<span class="kt">float4x4</span> <span class="n">glstate_matrix_projection</span><span class="p">;</span>
</pre></table></code></div></div><p>最后缺失的是一个非矩阵的项。它是 unity_WorldTransformParams，其中包含了一些我们在这里同样不需要的变换信息。它是一个定义为 real4 的向量，这本身不是一个有效的类型，而是根据目标平台指向 float4 或 half4 的别名。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float4x4</span> <span class="n">unity_ObjectToWorld</span><span class="p">;</span>
<span class="kt">float4x4</span> <span class="n">unity_WorldToObject</span><span class="p">;</span>
<span class="n">real4</span> <span class="n">unity_WorldTransformParams</span><span class="p">;</span>
</pre></table></code></div></div><p>该别名和许多其他基础宏是根据图形 API 定义的，我们可以通过包含 <em>Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl</em> 来获取所有这些内容。在包含 UnityInput.hlsl 之前，在我们的 Common.hlsl 文件中执行此操作。如果你对这些文件的内容感到好奇，可以在导入的 package 中检查它们。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"UnityInput.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><h3 id="颜色"><span class="me-2">颜色</span><a href="#颜色" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>可以通过调整 UnlitPassFragment 来更改渲染对象的颜色。例如，我们可以通过返回 $float4(1.0, 1.0, 0.0, 1.0)$ 而不是零来使其变为黄色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnlitPassFragment</span> <span class="p">()</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kt">float4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/yellow-sphere.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/yellow-sphere.png" alt="黄色球体" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">黄色球体</figcaption></figure><p>为了能够按材质配置颜色，我们必须将其定义为统一值。在 include 指令下方，<code class="language-plaintext highlighter-rouge">UnlitPassVertex</code> 函数之前执行此操作。我们需要一个 float4，并将其命名为 _BaseColor。前导下划线是表示材质属性的标准方式。在 UnlitPassFragment 中返回此值，而不是硬编码的颜色。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"../ShaderLibrary/Common.hlsl"</span><span class="cp">
</span>
<span class="kt">float4</span> <span class="n">_BaseColor</span><span class="p">;</span>

<span class="kt">float4</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span> <span class="p">{</span>
	<span class="kt">float3</span> <span class="n">positionWS</span> <span class="o">=</span> <span class="n">TransformObjectToWorld</span><span class="p">(</span><span class="n">positionOS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">positionWS</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float4</span> <span class="nf">UnlitPassFragment</span> <span class="p">()</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">_BaseColor</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们又回到了黑色，因为默认值为零。要将其链接到材质，我们必须将 _BaseColor 添加到 Unlit shader中的 Properties 块。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Properties {
    _BaseColor
}
</pre></table></code></div></div><p>属性名称后必须跟着一个用于检查器的字符串和一个 <code class="language-plaintext highlighter-rouge">Color</code> 类型标识符，就像为方法提供参数一样。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>_BaseColor("Color", Color)
</pre></table></code></div></div><p>最后，我们必须提供一个默认值，在本例中是为其分配一个包含四个数字的列表。我们使用白色。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>_BaseColor("Color", Color) = (1.0, 1.0, 1.0, 1.0)
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/unlit-material-color.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/unlit-material-color.png" alt="红色无光材质" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">红色无光材质</figcaption></figure><p>现在可以使用我们的着色器创建多个材质，每个材质都有不同的颜色。</p><h2 id="批处理"><span class="me-2">批处理</span><a href="#批处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>每次绘制调用都需要 CPU 和 GPU 之间的通信。如果大量数据必须发送到 GPU，那么它可能会因为等待而浪费时间。当 CPU 忙于发送数据时，它无法执行其他操作。这两个问题都可能降低帧率。目前我们的方法很简单：每个对象都有自己的绘制调用。这是最糟糕的做法，尽管我们最终发送的数据量很少，所以目前还可以。</p><p>举个例子，我创建了一个包含76个球体的场景，每个球体使用四种材质之一：红色、绿色、黄色和蓝色。它需要78次绘制调用来渲染，其中76次用于球体，一次用于天空盒，一次用于清除渲染目标。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/76-spheres.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/76-spheres.png" alt="76个球体，78次绘制调用" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">76个球体，78次绘制调用</figcaption></figure><p>如果你打开 Stats 窗口的 Game 面板，你就可以看到渲染帧所需的概览。这里有趣的事实是，它显示了 77 个批次——忽略清除——其中零个通过批处理节省。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/statistics.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/statistics.png" alt="游戏窗口统计。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">游戏窗口统计。</figcaption></figure><h3 id="srp-batcher"><span class="me-2">SRP Batcher</span><a href="#srp-batcher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>批处理是合并绘制调用的过程，减少 CPU 和 GPU 之间通信所花费的时间。最简单的方法是启用 <code class="language-plaintext highlighter-rouge">SRP batcher</code>。然而，这只适用于兼容的着色器，而我们的 <code class="language-plaintext highlighter-rouge">Unlit</code> 着色器不兼容。你可以在 Inspector 中选择它来验证。有一行 <code class="language-plaintext highlighter-rouge">SRP Batcher</code> 指示不兼容，下面给出了一个原因。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/not-compatible.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/not-compatible.png" alt="不兼容。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">不兼容。</figcaption></figure><p>SRP 批处理并没有减少绘制调用的数量，而是使其更精简。它在 GPU 上缓存材质属性，这样就不必在每次绘制调用时都发送它们。这减少了必须通信的数据量以及 CPU 在每次绘制调用中必须完成的工作。但这仅在着色器遵循严格的统一数据结构时才有效。</p><p>所有材质属性都必须在具体的内存缓冲区中定义，而不是在全局级别。这是通过将<code class="language-plaintext highlighter-rouge">_BaseColor</code>声明包装在名为<code class="language-plaintext highlighter-rouge">UnityPerMaterial</code>的<code class="language-plaintext highlighter-rouge">cbuffer</code>块中来完成的。这类似于结构体声明，但必须以分号结尾。它通过将<code class="language-plaintext highlighter-rouge">_BaseColor</code>放入特定的常量内存缓冲区来隔离它，尽管它仍然可以在全局级别访问。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">cbuffer</span> <span class="n">UnityPerMaterial</span> <span class="p">{</span>
	<span class="n">float</span> <span class="n">_BaseColor</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>常量缓冲区并非在所有平台（如 OpenGL ES 2.0）上都受支持，因此我们不直接使用<code class="language-plaintext highlighter-rouge">cbuffer</code>，而是可以使用我们从 <em>Core RP Library</em> 中包含的<code class="language-plaintext highlighter-rouge">CBUFFER_START</code>和<code class="language-plaintext highlighter-rouge">CBUFFER_END</code>宏。第一个宏将缓冲区名称作为参数，就像它是一个函数一样。在这种情况下，我们得到的结果与之前完全相同，只是<code class="language-plaintext highlighter-rouge">cbuffer</code>代码不会存在于不支持它的平台上。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
	<span class="kt">float4</span> <span class="n">_BaseColor</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>我们还必须对 <code class="language-plaintext highlighter-rouge">unity_ObjectToWorld、unity_WorldToObject 和 unity_WorldTransformParams</code> 执行此操作，只是它们必须分组到 UnityPerDraw 缓冲区中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityPerDraw</span><span class="p">)</span>
	<span class="kt">float4x4</span> <span class="n">unity_ObjectToWorld</span><span class="p">;</span>
	<span class="kt">float4x4</span> <span class="n">unity_WorldToObject</span><span class="p">;</span>
	<span class="n">real4</span> <span class="n">unity_WorldTransformParams</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><p>在这种情况下，如果使用其中一个值，则需要定义特定的值组。对于转换组，我们还需要包含 $float4 unity_LODFade$，即使我们不使用它。确切的顺序无关紧要，但 Unity 将其直接放在 unity_WorldToObject 之后，所以我们也这样做。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityPerDraw</span><span class="p">)</span>
	<span class="kt">float4x4</span> <span class="n">unity_ObjectToWorld</span><span class="p">;</span>
	<span class="kt">float4x4</span> <span class="n">unity_WorldToObject</span><span class="p">;</span>
	<span class="kt">float4</span> <span class="n">unity_LODFade</span><span class="p">;</span>
	<span class="n">real4</span> <span class="n">unity_WorldTransformParams</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/compatible.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/compatible.png" alt="与 SRP batcher 兼容。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">与 SRP batcher 兼容。</figcaption></figure><p>在我们的着色器兼容后，下一步是启用 SRP batcher，这通过将 <code class="language-plaintext highlighter-rouge">GraphicsSettings.useScriptableRenderPipelineBatching</code> 设置为 true 来完成。我们只需执行一次此操作，因此让我们在创建RP实例时执行此操作，方法是向 CustomRenderPipeline 添加一个构造函数。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="nf">CustomRenderPipeline</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">GraphicsSettings</span><span class="p">.</span><span class="n">useScriptableRenderPipelineBatching</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/statistics-srp-batching.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/statistics-srp-batching.png" alt="负批次已保存。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">负批次已保存。</figcaption></figure><p>Stats 面板显示保存了 76 个批次，尽管它显示的是负数。帧调试器现在在 <code class="language-plaintext highlighter-rouge">RenderLoopNewBatcher.Draw</code> 下显示一个 SRP Batch 条目，但请记住，它不是一个单独的绘制调用，而是一系列经过优化的绘制调用。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/srp-batch.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/srp-batch.png" alt="一个 SRP 批次。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">一个 SRP 批次。</figcaption></figure><h3 id="多种颜色"><span class="me-2">多种颜色</span><a href="#多种颜色" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>尽管我们使用了四种材质，但我们只获得了一个批次。这是因为所有数据都缓存在 GPU 上，每个绘制调用只需包含一个指向正确内存位置的偏移量。唯一的限制是每种材质的内存布局必须相同，这在本例中是成立的，因为我们对所有材质都使用了相同的着色器，每个着色器只包含一个颜色属性。Unity 不会比较材质的精确内存布局，它只会批处理使用完全相同着色器变体的绘制调用。</p><p>如果我们想要几种不同的颜色，这种方法很有效，但如果想让每个球体都有自己的颜色，我们就不得不创建更多的材质。如果能按对象设置颜色会更方便。这在默认情况下是不可能的，但我们可以通过创建自定义组件类型来支持它。将其命名为 <code class="language-plaintext highlighter-rouge">PerObjectMaterialProperties</code>。由于它是一个示例，我将其放在 Examples 文件夹下的 Custom RP 中。</p><p>其理念是，一个游戏对象可以附加一个 <code class="language-plaintext highlighter-rouge">PerObjectMaterialProperties</code> 组件，该组件有一个 <code class="language-plaintext highlighter-rouge">Base Color</code> 配置选项，用于设置其 <code class="language-plaintext highlighter-rouge">_BaseColor</code> 材质属性。它需要知道着色器属性的标识符，我们可以通过 <code class="language-plaintext highlighter-rouge">Shader.PropertyToID</code> 检索并存储在一个静态变量中，就像我们在 <code class="language-plaintext highlighter-rouge">CameraRenderer</code> 中为着色器通道标识符所做的那样，尽管在这种情况下它是一个整数。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="p">[</span><span class="n">DisallowMultipleComponent</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">PerObjectMaterialProperties</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
	
	<span class="k">static</span> <span class="kt">int</span> <span class="n">baseColorId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_BaseColor"</span><span class="p">);</span>
	
	<span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
	<span class="n">Color</span> <span class="n">baseColor</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">white</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/per-object-material-properties.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/per-object-material-properties.png" alt="PerObjectMaterialProperties 组件。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">PerObjectMaterialProperties 组件。</figcaption></figure><p>通过 <code class="language-plaintext highlighter-rouge">MaterialPropertyBlock</code> 对象设置每个对象的材质属性。我们只需要一个所有 <code class="language-plaintext highlighter-rouge">PerObjectMaterialProperties</code> 实例都可以重用的对象，因此为其声明一个静态字段。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">MaterialPropertyBlock</span> <span class="n">block</span><span class="p">;</span>
</pre></table></code></div></div><p>创建一个 MaterialPropertyBlock，然后使用属性标识符和颜色在其上调用 <code class="language-plaintext highlighter-rouge">SetColor</code>，然后通过 <code class="language-plaintext highlighter-rouge">SetPropertyBlock</code> 将该块应用于游戏对象的 <code class="language-plaintext highlighter-rouge">Renderer</code> 组件，该方法会复制其设置。在 OnValidate 中执行此操作，以便结果立即显示在编辑器中。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">OnValidate</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">block</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="n">baseColorId</span><span class="p">,</span> <span class="n">baseColor</span><span class="p">);</span>
    <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Renderer</span><span class="p">&gt;().</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我将该组件添加到了 24 个任意球体上，并给它们赋予了不同的颜色。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/many-colors.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/many-colors.png" alt="多种颜色。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">多种颜色。</figcaption></figure><p>不幸的是，SRP batcher 无法处理每个对象的材质属性。因此，这 24 个球体各自回退到一个常规的绘制调用，并且由于排序，可能会将其他球体也分成多个批次。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/24-non-batched.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/24-non-batched.png" alt="24个非批处理绘制调用。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">24个非批处理绘制调用。</figcaption></figure><p>此外，OnValidate 不会在构建中被调用。为了让单独的颜色出现在那里，我们还必须在 Awake 中应用它们，我们可以通过简单地在那里调用 OnValidate 来实现。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	<span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> <span class="p">{</span>
		<span class="nf">OnValidate</span><span class="p">();</span>
	<span class="p">}</span>
</pre></table></code></div></div><h3 id="gpu-instancing"><span class="me-2">GPU Instancing</span><a href="#gpu-instancing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>还有另一种合并绘制调用的方法，它适用于每个对象的材质属性。这被称为 GPU 实例化，其工作原理是为多个具有相同网格的对象一次性发出一个绘制调用。CPU 收集所有每个对象的变换和材质属性，并将它们放入数组中，然后发送到 GPU。GPU 随后遍历所有条目，并按照提供的顺序渲染它们。</p><p>由于 GPU 实例需要通过数组提供数据，我们当前的着色器尚不支持它。要实现此功能，第一步是在着色器的 Pass 块中，在vertex和fragment前添加 <code class="language-plaintext highlighter-rouge">#pragma multi_compile_instancing</code> 指令。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#pragma multi_compile_instancing
#pragma vertex UnlitPassVertex
#pragma fragment UnlitPassFragment
</span></pre></table></code></div></div><p>这将使 Unity 生成我们着色器的两个变体:支持 GPU instance和不支持GPU 实例。材质检查器中也出现了一个切换选项，允许我们为每个材质选择要使用的版本。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/gpu-instancing-material.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/gpu-instancing-material.png" alt="已启用 GPU 实例化的材质。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">已启用 GPU 实例化的材质。</figcaption></figure><p>支持 GPU 实例化需要改变方法，为此我们必须从核心着色器库中包含 UnityInstancing.hlsl 文件。这必须在定义 UNITY_MATRIX_M 和其他宏之后、包含 SpaceTransforms.hlsl 之前完成。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#define UNITY_MATRIX_P glstate_matrix_projection
</span>
<span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"</span><span class="cp">
#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><p>UnityInstancing.hlsl 所做的是重新定义这些宏，以访问实例化数据数组。但要使其工作，它需要知道当前正在渲染的对象的索引。该索引通过顶点数据提供，因此我们必须使其可用。 UnityInstancing.hlsl 定义了宏来简化此操作，但它们假设我们的顶点函数有一个结构体参数。</p><p>可以声明一个 struct（就像 cbuffer 一样），并将其用作函数的输入参数。我们还可以在结构体内部定义语义。这种方法的<strong>优点是比长参数列表更具可读性</strong>。因此，将 <code class="language-plaintext highlighter-rouge">UnlitPassVertex</code> 的 positionOS 参数封装在一个 Attributes 结构体中，表示顶点输入数据。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
	<span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">float4</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span> <span class="p">{</span>
	<span class="kt">float3</span> <span class="n">positionWS</span> <span class="o">=</span> <span class="n">TransformObjectToWorld</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">positionWS</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>当使用 GPU 实例化时，对象索引也可以作为顶点属性使用。我们只需在<code class="language-plaintext highlighter-rouge">Attributes</code>中放入<code class="language-plaintext highlighter-rouge"> UNITY_VERTEX_INPUT_INSTANCE_ID </code>即可在适当的时候添加它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
	<span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
	<span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</pre></table></code></div></div><p>接下来，在 <code class="language-plaintext highlighter-rouge">UnlitPassVertex</code> 的开头添加 ` UNITY_SETUP_INSTANCE_ID(input); `。这会从输入中提取索引并将其存储在一个全局静态变量中，其他实例化宏都依赖于此变量。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span> <span class="p">{</span>
	<span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
	<span class="kt">float3</span> <span class="n">positionWS</span> <span class="o">=</span> <span class="n">TransformObjectToWorld</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">positionWS</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这足以让 GPU 实例化工作，尽管 SRP batcher 优先，所以我们现在没有得到不同的结果。但是我们还不支持每个实例的材质数据。要添加这个，我们需要在需要时用数组引用替换 <code class="language-plaintext highlighter-rouge">_BaseColor</code>。这是通过将 <code class="language-plaintext highlighter-rouge">CBUFFER_START</code> 替换为 <code class="language-plaintext highlighter-rouge">UNITY_INSTANCING_BUFFER_START</code>，将 <code class="language-plaintext highlighter-rouge">CBUFFER_END</code> 替换为 <code class="language-plaintext highlighter-rouge">UNITY_INSTANCING_BUFFER_END</code> 来完成的，这现在也需要一个参数。这不必与开头相同，但没有令人信服的理由让它们不同。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">//CBUFFER_START(UnityPerMaterial)</span>
<span class="c1">//	float4 _BaseColor;</span>
<span class="c1">//CBUFFER_END</span>

<span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
	<span class="kt">float4</span> <span class="n">_BaseColor</span><span class="p">;</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
</pre></table></code></div></div><p>然后将 <code class="language-plaintext highlighter-rouge">_BaseColor</code> 的定义替换为 <code class="language-plaintext highlighter-rouge">UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)</code> 。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
	<span class="c1">//	float4 _BaseColor;</span>
	<span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
</pre></table></code></div></div><p>当使用实例化时，我们现在还必须在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中提供实例索引。为了简化此操作，我们将使用一个结构体让 <code class="language-plaintext highlighter-rouge">UnlitPassVertex</code> 同时输出位置和索引，并使用 <code class="language-plaintext highlighter-rouge">UNITY_TRANSFER_INSTANCE_ID(input, output)</code>; 在索引存在时复制它。我们将此结构体命名为 <code class="language-plaintext highlighter-rouge">Varyings</code>，就像 Unity 所做的那样，因为它包含的数据在同一三角形的不同片段之间可能会有所不同。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span>
	<span class="kt">float4</span> <span class="n">positionCS</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
	<span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="n">Varyings</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Varyings</span> <span class="n">output</span><span class="p">;</span>
	<span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
	<span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
	<span class="kt">float3</span> <span class="n">positionWS</span> <span class="o">=</span> <span class="n">TransformObjectToWorld</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">positionOS</span><span class="p">);</span>
	<span class="n">output</span><span class="p">.</span><span class="n">positionCS</span> <span class="o">=</span> <span class="n">TransformWorldToHClip</span><span class="p">(</span><span class="n">positionWS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>将此结构体作为参数添加到 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code>。然后像之前一样使用 <code class="language-plaintext highlighter-rouge">UNITY_SETUP_INSTANCE_ID</code> 来使索引可用。现在必须通过 UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor) 访问材质属性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnlitPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
	<span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/instanced-draw-calls.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/instanced-draw-calls.png" alt="实例化绘制调用" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">实例化绘制调用</figcaption></figure><p>Unity 现在能够将 24 个球体与每个对象的颜色结合起来，从而减少了绘制调用的数量。我最终得到了四个实例化绘制调用，因为这些球体之间仍然使用了四种材质。GPU 实例化仅适用于共享相同材质的对象。由于它们覆盖了材质颜色，因此它们都可以使用相同的材质，这使得它们可以在一个批次中绘制。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/one-instanced-material.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/one-instanced-material.png" alt="一个实例化材质" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">一个实例化材质</figcaption></figure><blockquote class="prompt-danger"><p>批处理大小存在限制</p><p>具体取决于目标平台以及每个实例需要提供的数据量。如果超出此限制，则会生成多个批处理。此外，如果使用了多种材质，排序仍然会拆分批处理。</p></blockquote><h3 id="绘制大量实例网格"><span class="me-2">绘制大量实例网格</span><a href="#绘制大量实例网格" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当数百个对象可以组合在一个绘制调用中时，GPU 实例化就成为一个显著的优势。但是手动编辑场景中的这么多对象是不切实际的。所以让我们随机生成一堆。创建一个 MeshBall 示例组件，它将在唤醒时生成大量对象。让它缓存 <code class="language-plaintext highlighter-rouge">_BaseColor</code> 着色器属性，并添加网格和材质的配置选项，这些材质必须支持实例化。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MeshBall</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>

	<span class="k">static</span> <span class="kt">int</span> <span class="n">baseColorId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_BaseColor"</span><span class="p">);</span>

	<span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
	<span class="n">Mesh</span> <span class="n">mesh</span> <span class="p">=</span> <span class="k">default</span><span class="p">;</span>

	<span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
	<span class="n">Material</span> <span class="n">material</span> <span class="p">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>创建一个带有此组件的游戏对象。我给它指定了默认的球体网格来绘制。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/mesh-ball-component.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/mesh-ball-component.png" alt="用于球体的网格球体组件。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">用于球体的网格球体组件。</figcaption></figure><p>我们可以生成许多新的游戏对象，但我们不必这样做。相反，我们将填充一个变换矩阵和颜色数组，并告诉 GPU 渲染一个带有这些数据的网格。这就是 GPU 实例化最有用之处。我们可以一次提供多达 1023 个实例，因此让我们添加长度为该值的数组字段，以及一个我们需要传递颜色数据的 <code class="language-plaintext highlighter-rouge">MaterialPropertyBlock</code>。在这种情况下，颜色数组的元素类型必须是 Vector4。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>	<span class="n">Matrix4x4</span><span class="p">[]</span> <span class="n">matrices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Matrix4x4</span><span class="p">[</span><span class="m">1023</span><span class="p">];</span>
	<span class="n">Vector4</span><span class="p">[]</span> <span class="n">baseColors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="m">1023</span><span class="p">];</span>

	<span class="n">MaterialPropertyBlock</span> <span class="n">block</span><span class="p">;</span>
</pre></table></code></div></div><p>创建一个 Awake 方法，用半径为 10 的球体内的随机位置和随机 RGB 颜色数据填充数组。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>	<span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">matrices</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
			<span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">TRS</span><span class="p">(</span>
				<span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="p">*</span> <span class="m">10f</span><span class="p">,</span> <span class="n">Quaternion</span><span class="p">.</span><span class="n">identity</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span>
			<span class="p">);</span>
			<span class="n">baseColors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span>
				<span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">Update</code> 中，如果块尚不存在，我们会创建一个新块，并对其调用 <code class="language-plaintext highlighter-rouge">SetVectorArray</code> 来配置颜色。之后，调用 <code class="language-plaintext highlighter-rouge">Graphics.DrawMeshInstanced</code>，并将网格、子网格索引零、材质、矩阵数组、元素数量和属性块作为参数。我们在此处设置块，以便网格球在热重载后仍然存在。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>	<span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">block</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
			<span class="n">block</span><span class="p">.</span><span class="nf">SetVectorArray</span><span class="p">(</span><span class="n">baseColorId</span><span class="p">,</span> <span class="n">baseColors</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">Graphics</span><span class="p">.</span><span class="nf">DrawMeshInstanced</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">matrices</span><span class="p">,</span> <span class="m">1023</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/mesh-ball.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/mesh-ball.png" alt="1023 个球体，3 次绘制调用。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">1023 个球体，3 次绘制调用。</figcaption></figure><p>Play Game，现在会生成一个密集的球体。渲染所需的绘制调用次数取决于平台，因为每个绘制调用的最大缓冲区大小不同。在我的情况下，渲染需要三次绘制调用。</p><blockquote class="prompt-warning"><p>单个网格的绘制顺序与我们提供数据的顺序相同。除此之外，没有任何排序或剔除，尽管整个批次一旦超出视锥体就会消失。</p></blockquote><h3 id="动态批处理"><span class="me-2">动态批处理</span><a href="#动态批处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>还有第三种减少绘制调用的方法，称为<strong>动态批处理</strong>。这是一种旧技术，它将共享相同材质的多个小网格组合成一个更大的网格进行绘制。但是当使用<code class="language-plaintext highlighter-rouge">MaterialPropertyBlock</code>时，此方法也无法有效和批。</p><p>较大的网格是按需生成的，因此只适用于小型网格。球体太大，但它适用于立方体。要查看其效果，请禁用 GPU 实例化，并在 <code class="language-plaintext highlighter-rouge">CameraRenderer.DrawVisibleGeometry</code> 中将 enableDynamicBatching 设置为 true。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">drawingSettings</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DrawingSettings</span><span class="p">(</span>
    <span class="n">unlitShaderTagId</span><span class="p">,</span> <span class="n">sortingSettings</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">enableDynamicBatching</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>
    <span class="n">enableInstancing</span> <span class="p">=</span> <span class="k">false</span>
<span class="p">};</span>
</pre></table></code></div></div><p>同时禁用 SRP 批处理器，因为它具有优先合批权。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">GraphicsSettings</span><span class="p">.</span><span class="n">useScriptableRenderPipelineBatching</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/cubes.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/cubes.png" alt="改为绘制立方体。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">改为绘制立方体。</figcaption></figure><p>通常情况下，GPU 实例化比动态批处理效果更好。这种方法也有一些注意事项，例如当涉及不同比例时，较大网格的法线向量不保证是normalize化单位长度。此外，由于现在是一个网格而不是多个网格，绘制顺序也会发生变化。</p><p>还有静态批处理，它的工作方式类似，但会提前对标记为批处理静态的对象进行处理。除了需要更多内存和存储空间外，它没有其他注意事项。RP 不用关注这一点，所以我们不必担心。</p><h3 id="配置批处理"><span class="me-2">配置批处理</span><a href="#配置批处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>哪种方法最好可能会有所不同，因此我们将其配置化。首先，添加布尔参数来控制是否使用动态批处理和 GUI 实例化来 DrawVisibleGeometry，而不是硬编码。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="k">void</span> <span class="nf">DrawVisibleGeometry</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">var</span> <span class="n">sortingSettings</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SortingSettings</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">criteria</span> <span class="p">=</span> <span class="n">SortingCriteria</span><span class="p">.</span><span class="n">CommonOpaque</span>
		<span class="p">};</span>
		<span class="kt">var</span> <span class="n">drawingSettings</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DrawingSettings</span><span class="p">(</span>
			<span class="n">unlitShaderTagId</span><span class="p">,</span> <span class="n">sortingSettings</span>
		<span class="p">)</span> <span class="p">{</span>
			<span class="n">enableDynamicBatching</span> <span class="p">=</span> <span class="n">useDynamicBatching</span><span class="p">,</span>
			<span class="n">enableInstancing</span> <span class="p">=</span> <span class="n">useGPUInstancing</span>
		<span class="p">};</span>
		<span class="err">…</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>Render 现在必须提供此配置，而此配置又依赖于 RP 提供。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>	<span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(</span>
		<span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">Camera</span> <span class="n">camera</span><span class="p">,</span>
		<span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span>
	<span class="p">)</span> <span class="p">{</span>
		<span class="err">…</span>
		<span class="nf">DrawVisibleGeometry</span><span class="p">(</span><span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">);</span>
		<span class="err">…</span>
	<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">CustomRenderPipeline</code> 将通过在其构造函数方法中设置的字段来跟踪选项，并在 Render 中传递它们。同时，为构造函数添加一个布尔参数用于 SRP batcher，而不是始终启用它。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>	<span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">;</span>

	<span class="k">public</span> <span class="nf">CustomRenderPipeline</span> <span class="p">(</span>
		<span class="kt">bool</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useSRPBatcher</span>
	<span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="p">.</span><span class="n">useDynamicBatching</span> <span class="p">=</span> <span class="n">useDynamicBatching</span><span class="p">;</span>
		<span class="k">this</span><span class="p">.</span><span class="n">useGPUInstancing</span> <span class="p">=</span> <span class="n">useGPUInstancing</span><span class="p">;</span>
		<span class="n">GraphicsSettings</span><span class="p">.</span><span class="n">useScriptableRenderPipelineBatching</span> <span class="p">=</span> <span class="n">useSRPBatcher</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="err">…</span>
	
	<span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">(</span>
		<span class="n">ScriptableRenderContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Camera</span><span class="p">&gt;</span> <span class="n">cameras</span>
	<span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&amp;;</span><span class="n">t</span> <span class="n">cameras</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
			<span class="n">renderer</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span>
				<span class="n">context</span><span class="p">,</span> <span class="n">cameras</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span>
			<span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>最后，将所有三个选项作为配置字段添加到 <code class="language-plaintext highlighter-rouge">CustomRenderPipelineAsset</code>，并在 CreatePipeline 中将它们传递给构造函数调用。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>	<span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
	<span class="kt">bool</span> <span class="n">useDynamicBatching</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span> <span class="n">useGPUInstancing</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span> <span class="n">useSRPBatcher</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

	<span class="k">protected</span> <span class="k">override</span> <span class="n">RenderPipeline</span> <span class="nf">CreatePipeline</span> <span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">CustomRenderPipeline</span><span class="p">(</span>
			<span class="n">useDynamicBatching</span><span class="p">,</span> <span class="n">useGPUInstancing</span><span class="p">,</span> <span class="n">useSRPBatcher</span>
		<span class="p">);</span>
	<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/rp-configuration.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/rp-configuration.png" alt="RP 配置。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">RP 配置。</figcaption></figure><p>现在可以更改我们的 RP 使用的方法。切换选项会立即生效，因为 Unity 编辑器在检测到资产更改时会创建一个新的 RP 实例。</p><h2 id="透明度"><span class="me-2">透明度</span><a href="#透明度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们的着色器可用于创建无光不透明材质。可以更改颜色的 alpha 分量，这通常表示透明度，但目前没有效果。我们还可以将渲染队列设置为 <code class="language-plaintext highlighter-rouge">Transparent</code> ，但这只改变对象何时以及以何种顺序绘制，而不是如何绘制。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/reduced-alpha.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/reduced-alpha.png" alt="降低了 alpha 并使用了透明渲染队列。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">降低了 alpha 并使用了透明渲染队列。</figcaption></figure><p>我们不需要编写单独的着色器来支持透明材质。稍作修改，我们的 Unlit 着色器就可以支持不透明和透明渲染。</p><h3 id="混合模式"><span class="me-2">混合模式</span><a href="#混合模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>不透明和透明渲染的主要区别在于我们是否替换之前绘制的内容，或者将之前的结果组合起来以产生透明效果。我们可以通过设置源和目标混合模式来控制这一点。在这里，源指的是现在绘制的内容，而目标指的是之前绘制的内容以及结果将最终出现在哪里。为此添加两个着色器属性：<code class="language-plaintext highlighter-rouge">_SrcBlend 和 _DstBlend</code>。它们是混合模式的枚举，但我们能使用的最佳类型是 <code class="language-plaintext highlighter-rouge">Float</code>，默认情况下，源设置为 1，目标设置为 0。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>	<span class="n">Properties</span> <span class="p">{</span>
		<span class="n">_BaseColor</span><span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">_SrcBlend</span> <span class="p">(</span><span class="s">"Src Blend"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="n">_DstBlend</span> <span class="p">(</span><span class="s">"Dst Blend"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>为了便于编辑，我们可以将 <code class="language-plaintext highlighter-rouge">Enum</code> 属性添加到属性中，并以完全限定的 UnityEngine.Rendering.BlendMode 枚举类型作为参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>		<span class="p">[</span><span class="n">Enum</span><span class="p">(</span><span class="n">UnityEngine</span><span class="p">.</span><span class="n">Rendering</span><span class="p">.</span><span class="n">BlendMode</span><span class="p">)]</span> <span class="n">_SrcBlend</span> <span class="p">(</span><span class="s">"Src Blend"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="p">[</span><span class="n">Enum</span><span class="p">(</span><span class="n">UnityEngine</span><span class="p">.</span><span class="n">Rendering</span><span class="p">.</span><span class="n">BlendMode</span><span class="p">)]</span> <span class="n">_DstBlend</span> <span class="p">(</span><span class="s">"Dst Blend"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/opaque-blend-modes.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/opaque-blend-modes.png" alt="不透明混合模式。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">不透明混合模式。</figcaption></figure><p>默认值代表我们已经使用的不透明混合配置。源设置为1，表示它被完全添加，而目标设置为零，表示它被忽略。</p><p>标准透明度的源混合模式是 <code class="language-plaintext highlighter-rouge">SrcAlpha</code>，这意味着渲染颜色的 RGB 分量会乘以其 alpha 分量。因此，alpha 越低，它就越弱。然后将目标混合模式设置为相反的模式：OneMinusSrcAlpha，以达到总权重为 1。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/transparent-blend-modes.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/transparent-blend-modes.png" alt="透明混合模式。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">透明混合模式。</figcaption></figure><p>混合模式可以在 <code class="language-plaintext highlighter-rouge">Pass</code> 块中使用 <code class="language-plaintext highlighter-rouge">Blend</code> 语句后跟两个模式来定义。我们想使用着色器属性，可以通过将它们放在方括号中来访问。这是可编程着色器时代之前的旧语法。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="n">Pass</span> <span class="p">{</span>
        <span class="n">Blend</span> <span class="p">[</span><span class="n">_SrcBlend</span><span class="p">]</span> <span class="p">[</span><span class="n">_DstBlend</span><span class="p">]</span>

        <span class="n">HLSLPROGRAM</span>
        <span class="err">…</span>
        <span class="n">ENDHLSL</span>
    <span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/semitransparent-spheres.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/semitransparent-spheres.png" alt="半透明黄色球体。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">半透明黄色球体。</figcaption></figure><h3 id="不写入深度"><span class="me-2">不写入深度</span><a href="#不写入深度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>透明渲染通常不写入深度缓冲区，因为它从中得不到好处，甚至可能产生不希望的结果。我们可以通过 ZWrite 语句控制是否写入深度。同样，我们可以使用着色器属性，这次使用 _ZWrite。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">Blend</span> <span class="p">[</span><span class="n">_SrcBlend</span><span class="p">]</span> <span class="p">[</span><span class="n">_DstBlend</span><span class="p">]</span>
    <span class="n">ZWrite</span> <span class="p">[</span><span class="n">_ZWrite</span><span class="p">]</span>
</pre></table></code></div></div><p>使用自定义的 Enum(Off, 0, On, 1) 属性定义着色器属性，以创建一个默认开启的、值为 0 和 1 的开关。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="p">[</span><span class="n">Enum</span><span class="p">(</span><span class="n">UnityEngine</span><span class="p">.</span><span class="n">Rendering</span><span class="p">.</span><span class="n">BlendMode</span><span class="p">)]</span> <span class="n">_SrcBlend</span> <span class="p">(</span><span class="s">"Src Blend"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">[</span><span class="n">Enum</span><span class="p">(</span><span class="n">UnityEngine</span><span class="p">.</span><span class="n">Rendering</span><span class="p">.</span><span class="n">BlendMode</span><span class="p">)]</span> <span class="n">_DstBlend</span> <span class="p">(</span><span class="s">"Dst Blend"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">[</span><span class="n">Enum</span><span class="p">(</span><span class="n">Off</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">On</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="n">_ZWrite</span> <span class="p">(</span><span class="s">"Z Write"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/z-write-off.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/z-write-off.png" alt="深度写入已关闭。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">深度写入已关闭。</figcaption></figure><h3 id="纹理"><span class="me-2">纹理</span><a href="#纹理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>之前我们使用 alpha 贴图创建了不均匀的半透明材质。我们通过向着色器添加 <code class="language-plaintext highlighter-rouge">_BaseMap</code> 纹理属性来支持这一点。在这种情况下，类型是 <code class="language-plaintext highlighter-rouge">2D</code>，我们将使用 Unity 的标准白色纹理作为默认值，用 ` white ` 字符串表示。此外，我们必须以一个空的 <code class="language-plaintext highlighter-rouge">code</code> 块结束纹理属性。它很久以前用于控制纹理设置，但今天仍应包含在内，以防止在某些情况下出现奇怪的错误。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">_BaseMap</span><span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
    <span class="n">_BaseColor</span><span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/material-with-texture.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/material-with-texture.png" alt="带纹理的材质。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">带纹理的材质。</figcaption></figure><p>纹理必须上传到 GPU 内存，Unity 会为我们完成此操作。着色器需要一个相关纹理的句柄，我们可以像定义 uniform 值一样定义它，只不过我们使用 TEXTURE2D 宏并将名称作为参数。我们还需要为纹理定义一个采样器状态，它控制纹理应如何采样，同时考虑其环绕和过滤模式。这是通过 SAMPLER 宏完成的，类似于 TEXTURE2D，但名称前缀为 sampler。这与 Unity 自动提供的采样器状态的名称匹配。</p><p>纹理和采样器状态是着色器资源。它们不能按实例提供，必须在全局范围声明。在 UnlitPass.hlsl 中的着色器属性之前完成此操作。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">sampler_BaseMap</span><span class="p">);</span>

<span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
	<span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
</pre></table></code></div></div><p>除此之外，Unity 还通过一个 float4 提供纹理的平铺和偏移，该 float4 的名称与纹理属性相同，但附加了 _ST，代表缩放和变换或类似含义。此属性应是 UnityPerMaterial 缓冲区的一部分，因此可以按实例设置。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
	<span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseMap_ST</span><span class="p">)</span>
	<span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">)</span>
</pre></table></code></div></div><p>为了能采样纹理，我们需要纹理坐标，它是顶点属性的一部分。具体来说，我们需要第一对坐标，因为可能有更多对。这通过向 <code class="language-plaintext highlighter-rouge">Attributes</code> 添加一个具有 <code class="language-plaintext highlighter-rouge">TEXCOORD0</code> 含义的 <code class="language-plaintext highlighter-rouge">float2</code> 字段来完成。由于它是用于我们的基础贴图，并且纹理空间维度普遍命名为 U 和 V，我们将其命名为 <code class="language-plaintext highlighter-rouge">baseUV</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Attributes</span> <span class="p">{</span>
	<span class="kt">float3</span> <span class="n">positionOS</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
	<span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
	<span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</pre></table></code></div></div><p>我们需要将坐标传递给片段函数，因为纹理是在那里采样的。因此，也要将 $float2 baseUV$ 添加到 <code class="language-plaintext highlighter-rouge">Varyings</code> 中。这次我们不需要添加特殊含义，它只是我们传递的数据，不需要 GPU 的特殊关注。但是，我们仍然必须赋予它一些含义。我们可以应用任何未使用的标识符，我们简单地使用 <code class="language-plaintext highlighter-rouge">VAR_BASE_UV</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Varyings</span> <span class="p">{</span>
	<span class="kt">float4</span> <span class="n">positionCS</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
	<span class="kt">float2</span> <span class="n">baseUV</span> <span class="o">:</span> <span class="n">VAR_BASE_UV</span><span class="p">;</span>
	<span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</pre></table></code></div></div><p>当我们在 <code class="language-plaintext highlighter-rouge">UnlitPassVertex</code> 中复制坐标时，我们也可以应用存储在 <code class="language-plaintext highlighter-rouge">_BaseMap_ST</code> 中的缩放和偏移。这样，我们就可以按顶点而不是按片段进行操作。缩放存储在 XY 中，偏移存储在 ZW 中，我们可以通过 swizzle 属性访问它们。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">Varyings</span> <span class="nf">UnlitPassVertex</span> <span class="p">(</span><span class="n">Attributes</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
	<span class="err">…</span>

	<span class="kt">float4</span> <span class="n">baseST</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_BaseMap_ST</span><span class="p">);</span>
	<span class="n">output</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span> <span class="o">*</span> <span class="n">baseST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">baseST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>UV 坐标现在可用于 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code>，并在三角形上进行插值。在这里通过使用 <code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D</code> 宏并以纹理、采样器状态和坐标作为参数来采样纹理。最终颜色是纹理和统一颜色通过乘法组合而成的。将两个相同大小的向量相乘会导致所有匹配分量相乘，因此在这种情况下是红色乘以红色，绿色乘以绿色，依此类推。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnlitPassFragment</span> <span class="p">(</span><span class="n">Varyings</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
	<span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
	<span class="kt">float4</span> <span class="n">baseMap</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
	<span class="kt">float4</span> <span class="n">baseColor</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">baseMap</span> <span class="o">*</span> <span class="n">baseColor</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/textured.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/textured.png" alt="带纹理的黄色球体。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">带纹理的黄色球体。</figcaption></figure><p>因为我们纹理的 RGB 数据是统一的白色，所以颜色不受影响。但 alpha 通道是变化的，因此透明度不再统一。</p><h3 id="alpha-裁剪"><span class="me-2">Alpha 裁剪</span><a href="#alpha-裁剪" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>另一种看穿表面的方法是在其中打孔。着色器也可以做到这一点，通过丢弃一些它们通常会渲染的片段。这会产生硬边，而不是我们目前看到的平滑过渡。这种技术被称为 alpha 裁剪。通常的做法是定义一个截止阈值。alpha 值低于此阈值的片段将被丢弃，而所有其他片段则被保留。</p><p>添加一个 <code class="language-plaintext highlighter-rouge">_Cutoff</code> 属性，默认设置为 0.5。由于 alpha 始终介于零和 1 之间，我们可以使用 <code class="language-plaintext highlighter-rouge">Range(0.0, 1.0)</code> 作为其类型。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">_BaseColor</span><span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">_Cutoff</span> <span class="p">(</span><span class="s">"Alpha Cutoff"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span>
</pre></table></code></div></div><p>也将其添加到 UnlitPass.hlsl 中的材质属性。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">)</span>
	<span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">)</span>
</pre></table></code></div></div><p>我们可以在 <code class="language-plaintext highlighter-rouge">UnlitPassFragment</code> 中调用 <code class="language-plaintext highlighter-rouge">clip</code> 函数来丢弃片段。如果传入的值为零或更小，它将中止并丢弃该片段。因此，将最终的 alpha 值（可通过 <code class="language-plaintext highlighter-rouge">a</code> 或 <code class="language-plaintext highlighter-rouge">w</code> 属性访问）减去截止阈值后传递给它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>	<span class="kt">float4</span> <span class="n">baseMap</span> <span class="o">=</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span><span class="n">_BaseMap</span><span class="p">,</span> <span class="n">sampler_BaseMap</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">baseUV</span><span class="p">);</span>
	<span class="kt">float4</span> <span class="n">baseColor</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_BaseColor</span><span class="p">);</span>
	<span class="kt">float4</span> <span class="n">base</span> <span class="o">=</span> <span class="n">baseMap</span> <span class="o">*</span> <span class="n">baseColor</span><span class="p">;</span>
	<span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">base</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/cutoff-inspector.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/cutoff-inspector.png" alt="Alpha 截止值设为 0.2。" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/cutoff-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/cutoff-scene.png" alt="Alpha 截止值设为 0.2。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Alpha 截止值设为 0.2。</figcaption></figure><p>一种材质通常使用透明度混合或 <code class="language-plaintext highlighter-rouge">Alpha</code> 裁剪，而不是同时使用两者。典型的裁剪材质除了被丢弃的片段外是完全不透明的，并且会写入深度缓冲区。它使用<code class="language-plaintext highlighter-rouge">AlphaTest</code>渲染队列，这意味着它会在所有完全不透明对象之后渲染。这样做是因为丢弃片段会使一些 GPU 优化变得不可能，因为三角形不能再被假定完全覆盖它们后面的内容。通过首先绘制完全不透明的对象，它们最终可能会覆盖 Alpha 裁剪对象的一部分，这样就不需要处理其隐藏的片段。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/clipped-inspector.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/clipped-inspector.png" alt="Alpha 裁剪材质。" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/clipped-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/clipped-scene.png" alt="Alpha 裁剪材质。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Alpha 裁剪材质。</figcaption></figure><p>但要使此优化生效，我们必须确保仅在需要时才使用 <code class="language-plaintext highlighter-rouge">clip</code>。我们将通过添加一个功能切换着色器属性来实现这一点。它是一个默认为零的 <code class="language-plaintext highlighter-rouge">Float</code> 属性，带有一个 <code class="language-plaintext highlighter-rouge">Toggle</code> 属性，用于控制着色器关键字，我们将使用 <code class="language-plaintext highlighter-rouge">_CLIPPING</code>。属性本身的名称无关紧要，因此只需使用 <code class="language-plaintext highlighter-rouge">_Clipping</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>		<span class="n">_Cutoff</span> <span class="p">(</span><span class="s">"Alpha Cutoff"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span>
		<span class="p">[</span><span class="n">Toggle</span><span class="p">(</span><span class="n">_CLIPPING</span><span class="p">)]</span> <span class="n">_Clipping</span> <span class="p">(</span><span class="s">"Alpha Clipping"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>  
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/alpha-clipping-off.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/alpha-clipping-off.png" alt="Alpha 裁剪已关闭，按理说。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Alpha 裁剪已关闭，按理说。</figcaption></figure><h3 id="着色器功能"><span class="me-2">着色器功能</span><a href="#着色器功能" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>启用此开关会将 <code class="language-plaintext highlighter-rouge">_CLIPPING</code> 关键字添加到材质的活动关键字列表中，禁用则会将其移除。但这本身并不会产生任何效果。我们必须告诉 Unity 根据关键字是否已定义来编译我们着色器的不同版本。我们通过在其 <code class="language-plaintext highlighter-rouge">Pass</code> 中的指令中添加 #pragma shader_feature _CLIPPING 来实现这一点。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="cp">#pragma shader_feature _CLIPPING
</span>    <span class="cp">#pragma multi_compile_instancing
</span></pre></table></code></div></div><p>现在，Unity 将会编译我们的着色器代码，无论是否定义了 <code class="language-plaintext highlighter-rouge">_CLIPPING</code>。它将生成一个或两个变体，具体取决于我们如何配置材质。因此，我们可以根据定义使代码具有条件性，就像包含守卫一样，但在这种情况下，我们只希望在定义了 <code class="language-plaintext highlighter-rouge">_CLIPPING</code> 时才包含裁剪行。我们可以使用 <code class="language-plaintext highlighter-rouge">#ifdef _CLIPPING</code> 来实现，但我更喜欢 <code class="language-plaintext highlighter-rouge">#if defined(_CLIPPING)</code>。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	<span class="cp">#if defined(_CLIPPING)
</span>		<span class="nb">clip</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">UnityPerMaterial</span><span class="p">,</span> <span class="n">_Cutoff</span><span class="p">));</span>
	<span class="cp">#endif
</span></pre></table></code></div></div><h3 id="cutoff-object1"><span class="me-2">Cutoff Object1</span><a href="#cutoff-object1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>由于Cutoff值是 <code class="language-plaintext highlighter-rouge">UnityPerMaterial</code> 缓冲区的一部分，因此可以按实例配置。所以让我们将该功能添加到 <code class="language-plaintext highlighter-rouge">PerObjectMaterialProperties</code> 中。它的工作方式与颜色相同，只是我们需要在属性块上调用 <code class="language-plaintext highlighter-rouge">SetFloat</code> 而不是 <code class="language-plaintext highlighter-rouge">SetColor</code>。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>	<span class="k">static</span> <span class="kt">int</span> <span class="n">baseColorId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_BaseColor"</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">cutoffId</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">PropertyToID</span><span class="p">(</span><span class="s">"_Cutoff"</span><span class="p">);</span>

	<span class="k">static</span> <span class="n">MaterialPropertyBlock</span> <span class="n">block</span><span class="p">;</span>

	<span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
	<span class="n">Color</span> <span class="n">baseColor</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">white</span><span class="p">;</span>

	<span class="p">[</span><span class="n">SerializeField</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">)]</span>
	<span class="kt">float</span> <span class="n">cutoff</span> <span class="p">=</span> <span class="m">0.5f</span><span class="p">;</span>

	<span class="err">…</span>

	<span class="k">void</span> <span class="nf">OnValidate</span> <span class="p">()</span> <span class="p">{</span>
		<span class="err">…</span>
		<span class="n">block</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="n">baseColorId</span><span class="p">,</span> <span class="n">baseColor</span><span class="p">);</span>
		<span class="n">block</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="n">cutoffId</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">);</span>
		<span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Renderer</span><span class="p">&gt;().</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
	<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/cutoff-per-object-inspector.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/cutoff-per-object-inspector.png" alt="每个实例化对象的 Alpha 截止值。" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/cutoff-per-object-scene.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/cutoff-per-object-scene.png" alt="每个实例化对象的 Alpha 截止值。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">每个实例化对象的 Alpha 截止值。</figcaption></figure><h3 id="alpha-裁剪球体球"><span class="me-2">Alpha 裁剪球体球</span><a href="#alpha-裁剪球体球" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>MeshBall 也是如此。现在我们可以使用剪裁材质，但所有实例最终都会有完全相同的孔洞。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/alpha-clipped-ball.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/alpha-clipped-ball.png" alt="近距离观察 Alpha 剪裁的网格球。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">近距离观察 Alpha 剪裁的网格球。</figcaption></figure><p>让我们通过给每个实例一个随机旋转，加上 0.5-1.5 范围内的随机统一缩放来增加一些多样性。但是，我们不会为每个实例设置截止值，而是将其颜色的 alpha 通道在 0.5-1 范围内变化。这给了我们不太精确的控制，但这只是一个随机示例。</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">TRS</span><span class="p">(</span>
    <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="p">*</span> <span class="m">10f</span><span class="p">,</span>
    <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span>
        <span class="n">Random</span><span class="p">.</span><span class="k">value</span> <span class="p">*</span> <span class="m">360f</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span> <span class="p">*</span> <span class="m">360f</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span> <span class="p">*</span> <span class="m">360f</span>
    <span class="p">),</span>
    <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span> <span class="p">*</span> <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">1.5f</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">baseColors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
        <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span>
        <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">1f</span><span class="p">)</span>
    <span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp1-2/more-varied-ball.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp1-2/more-varied-ball.png" alt="更多样化的网格球。" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">更多样化的网格球。</figcaption></figure><p>请注意，Unity 仍然会向 GPU 发送一个cutoff数组，每个实例一个，即使它们都相同。该值是材质的副本，因此通过改变它，可以一次性改变所有球体的孔洞，即使它们仍然不同。</p><p>下一个篇是<a href="../directional-lights">方向光</a>。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/scriptrenderpipeline/">ScriptRenderPipeline</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/srp/" class="post-tag no-text-decoration" >SRP</a> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF:Draw%20Calls%E3%80%81Shaders%E3%80%81%20Batches%20(%E7%BF%BB%E8%AF%91%E4%BA%8C)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Fdrawcalls-shaders-batches%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF:Draw%20Calls%E3%80%81Shaders%E3%80%81%20Batches%20(%E7%BF%BB%E8%AF%91%E4%BA%8C)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Fdrawcalls-shaders-batches%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Fdrawcalls-shaders-batches%2F&text=%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF:Draw%20Calls%E3%80%81Shaders%E3%80%81%20Batches%20(%E7%BF%BB%E8%AF%91%E4%BA%8C)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/rustom-render-pipeline/">自定义渲染管线:掌控渲染流程 (翻译一)</a><li class="text-truncate lh-lg"> <a href="/posts/drawcalls-shaders-batches/">自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</a><li class="text-truncate lh-lg"> <a href="/posts/flat-and-wireframe-shading/">平面着色与线框着色(翻译二十一)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-tessellation/">曲面细分(翻译二十二)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-surface-displacement/">曲面细分表面置换(翻译二十三)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/directional-lights/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1575043200" data-df="ll" > Nov 30, 2019 </time><h4 class="pt-0 my-2">自定义管线:方向光 (翻译三)</h4><div class="text-muted"><p>增加对多个方向光着色（shading）的支持。 已升级至 2022.3.62f2 1 光照 (Lighting) 如果我们想创建一个更真实的场景，那么我们就必须模拟光如何与表面相互作用。这需要一个比我们目前拥有的不发光（unlit）着色器更复杂的着色器。 1.1 受光着色器 (Lit Shader) 复制 UnlitPass.hlsl 文件并将其重命名为 LitPass.h...</p></div></div></a></article><article class="col"> <a href="/posts/rustom-render-pipeline/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1569427200" data-df="ll" > Sep 26, 2019 </time><h4 class="pt-0 my-2">自定义渲染管线:掌控渲染流程 (翻译一)</h4><div class="text-muted"><p>这是关于创建自定义脚本化渲染管线（Scriptable Render Pipeline, SRP）的系列教程的第一部分。它涵盖了我们将要在未来扩展的准系统渲染管线的初始创建。 创建渲染管线资源和实例 渲染摄像机视图 执行剔除、过滤和排序 分离不透明、透明和无效阶段 处理多个摄像机。 1 Render Pipeline 为了渲染任何内容，Unity 必须确定需...</p></div></div></a></article><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_2/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515333600" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展二(翻译十)</h4><div class="text-muted"><p>本篇摘要: 把自身阴影烘焙进材质 增加细节纹理部分 支持更丰富的shader变体 一次编辑多个材质球 遮挡区域的Self-Shading 美术能够创作非常复杂丰富的表面纹理，它只是一个视错觉。为了增强表面纹理视觉真实感，引入Self-Shading。 如何增强呢？通常我们使用了法线来增强模型表面的凹凸层次感，法线带来的视觉增强是第一步，但是法线只适用于采样直接光...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/rustom-render-pipeline/" class="btn btn-outline-primary" aria-label="Older" ><p>自定义渲染管线:掌控渲染流程 (翻译一)</p></a> <a href="/posts/directional-lights/" class="btn btn-outline-primary" aria-label="Newer" ><p>自定义管线:方向光 (翻译三)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
