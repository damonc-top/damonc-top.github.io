<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="景深光线的弯曲(翻译二十五)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="确定弥散圆（Circle of Confusion，CoC）。 创建 Bokeh（散景）。 对图像进行聚焦和去焦。 分离和合并前景与背景。" /><meta property="og:description" content="确定弥散圆（Circle of Confusion，CoC）。 创建 Bokeh（散景）。 对图像进行聚焦和去焦。 分离和合并前景与背景。" /><link rel="canonical" href="www.damonc.top/posts/unity-depth-of-field/" /><meta property="og:url" content="www.damonc.top/posts/unity-depth-of-field/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/2018/month1/catRender25/dof-01.jpeg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-01-30T10:12:34+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/2018/month1/catRender25/dof-01.jpeg" /><meta property="twitter:title" content="景深光线的弯曲(翻译二十五)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2018-01-30T10:12:34+08:00","datePublished":"2018-01-30T10:12:34+08:00","description":"确定弥散圆（Circle of Confusion，CoC）。 创建 Bokeh（散景）。 对图像进行聚焦和去焦。 分离和合并前景与背景。","headline":"景深光线的弯曲(翻译二十五)","image":{"lqip":"data:image/webp;base64,UklGRkIAAABXRUJQVlA4IDYAAAAwAwCdASoUAAoAP3Gixlk0rCejsAgCkC4JYwC7ABVAPF4AAOc0Mqa841ATwnaGkBonNUdwgAA=","url":"https://img.damonc.top/posts/2018/month1/catRender25/dof-01.jpeg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/unity-depth-of-field/"},"url":"www.damonc.top/posts/unity-depth-of-field/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>景深光线的弯曲(翻译二十五) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘摊手</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>景深光线的弯曲(翻译二十五)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>景深光线的弯曲(翻译二十五)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1517278354" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jan 30, 2018 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-01.jpeg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/2018/month1/catRender25/dof-01.jpeg" alt="Preview Image" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRkIAAABXRUJQVlA4IDYAAAAwAwCdASoUAAoAP3Gixlk0rCejsAgCkC4JYwC7ABVAPF4AAOc0Mqa841ATwnaGkBonNUdwgAA="></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/unity-depth-of-field/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="4163 words" > <em>23 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">景深光线的弯曲(翻译二十五)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">景深光线的弯曲(翻译二十五)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>确定弥散圆（Circle of Confusion，CoC）。<li>创建 Bokeh（散景）。<li>对图像进行聚焦和去焦。<li>分离和合并前景与背景。</ul><hr /><h2 id="1-搭建场景"><span class="me-2">1 搭建场景</span><a href="#1-搭建场景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们感知光线是因为我们感觉到光子撞击我们的视网膜。同样，摄像机可以记录光线，是因为光子撞击其胶片或图像传感器。在所有情况下，光线都被聚焦以产生清晰的图像，但并非所有东西都能同时处于焦点上。只有特定距离的东西才是清晰的，而所有更近或更远的东西看起来都是模糊的。这种视觉效果被称为<strong>景深（Depth-of-Field）</strong>。关于失焦投影如何表现的细节被称为 <strong>Bokeh（散景）</strong>，这是日语中模糊的意思。</p><p>通常，我们用自己的眼睛并不会注意到景深，因为我们关注的是焦点所在，而不是焦点之外的东西。它在照片和视频中可能更加明显，因为我们可以观察图像中不在摄像机焦点的部分。尽管这是一种物理限制，但 Bokeh 可以产生巨大的效果来引导观众的注意力。因此，它是一种艺术工具。</p><p>GPU 不需要聚焦光线，它们表现得像完美的摄像机，拥有无限的焦点。如果你想创建锐利的图像，这很棒，但如果你想将景深用于艺术目的，这就不太走运了。但是有很多方法可以伪造它。在本教程中，我们将创建一个类似于 Unity Post-processing Stack v2 中的景深效果，尽管会尽可能简化。</p><h3 id="11-搭建场景"><span class="me-2">1.1 搭建场景</span><a href="#11-搭建场景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了测试我们自己的景深效果，创建一个包含不同距离物体的小场景。我使用了一个 10×10 的平面，其电路材料平铺了五次作为地面。它为我们提供了一个具有大跨度、锐利、高频颜色变化的表面。这对于测试来说非常棒。我在上面放了一堆物体，还让四个物体漂浮在摄像机附近。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-02.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-02.png" alt="Test scene" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Test scene</figcaption></figure><p>我们将为新的 <code class="language-plaintext highlighter-rouge">DepthOfField</code> shader 使用与 Bloom shader 相同的设置。你可以复制它，并将其缩减为目前仅执行 blit 的单个 pass。不过，这一次我们将把 shader 放在 <code class="language-plaintext highlighter-rouge">Hidden</code> 菜单类别中，这会将其从 shader 下拉列表中排除。这是唯一值得注意的新东西。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Hidden/DepthOfField"</span> <span class="p">{</span>
    <span class="n">Properties</span> <span class="p">{</span>
        <span class="n">_MainTex</span> <span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">CGINCLUDE</span>
        <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>        <span class="kt">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
        <span class="n">float4</span> <span class="n">_MainTex_TexelSize</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
            <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
            <span class="n">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
            <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">Interpolators</span> <span class="n">VertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
            <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="n">ENDCG</span>

    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="n">Cull</span> <span class="n">Off</span>
        <span class="n">ZTest</span> <span class="n">Always</span>
        <span class="n">ZWrite</span> <span class="n">Off</span>
        <span class="n">Pass</span> <span class="p">{</span>
            <span class="n">CGPROGRAM</span>
                <span class="cp">#pragma vertex VertexProgram
</span>                <span class="cp">#pragma fragment FragmentProgram
</span>                <span class="n">half4</span> <span class="n">FragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>创建一个极简的 <code class="language-plaintext highlighter-rouge">DepthOfFieldEffect</code> 组件，再次使用与 bloom 效果相同的方法，但隐藏 shader 属性。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="p">[</span><span class="n">ExecuteInEditMode</span><span class="p">,</span> <span class="n">ImageEffectAllowedInSceneView</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">DepthOfFieldEffect</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">HideInInspector</span><span class="p">]</span>
    <span class="k">public</span> <span class="n">Shader</span> <span class="n">dofShader</span><span class="p">;</span>

    <span class="p">[</span><span class="n">NonSerialized</span><span class="p">]</span>
    <span class="n">Material</span> <span class="n">dofMaterial</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">OnRenderImage</span> <span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dofMaterial</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dofMaterial</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Material</span><span class="p">(</span><span class="n">dofShader</span><span class="p">);</span>
            <span class="n">dofMaterial</span><span class="p">.</span><span class="n">hideFlags</span> <span class="p">=</span> <span class="n">HideFlags</span><span class="p">.</span><span class="n">HideAndDontSave</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">dofMaterial</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>为了方便，我们不在 editor 中手动分配 shader，而是将其定义为组件的默认值。为此，在 editor 中选中脚本，并将 shader 字段挂在 inspector 顶部。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-03.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-03.png" alt="Default shader reference" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Default shader reference</figcaption></figure><p>将我们的新效果作为唯一的后期处理添加到摄像机。再次强调，我们假设在线性 HDR 空间中渲染，因此请相应配置项目和摄像机。此外，因为我们需要读取深度缓冲，此效果在开启 MSAA 时无法正确工作。因此请禁用摄像机的 MSAA。同时请注意，由于我们将依赖深度缓冲，该效果不会考虑透明几何体。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-04.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-04.png" alt="HDR camera without MSAA and with depth-of-ﬁeld" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">HDR camera without MSAA and with depth-of-ﬁeld</figcaption></figure><blockquote><p><strong>那我们就不能将它与透明物体一起使用了吗？</strong> 透明物体看起来也会受到影响，但使用的是它们背后任何东西的深度信息。这是所有使用深度缓冲技术的共同局限。你仍然可以使用透明，但只有当这些物体背后有足够近的固体表面时，看起来才勉强可以接受。</p></blockquote><h2 id="2-弥散圆-circle-of-confusion"><span class="me-2">2 弥散圆 (Circle of Confusion)</span><a href="#2-弥散圆-circle-of-confusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>最简单的摄像机形式是完美的针孔摄像机。像所有摄像机一样，它有一个记录光线的图像平面。在图像平面前面有一个极小的孔——被称为光圈（Aperture）——刚好大到允许单根光线通过。摄像机前面的物体会向多个方向发射或反射光线。对于每一个点，只有单根光线能够通过孔并被记录。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-08.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-08.png" alt="Recording three points" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Recording three points</figcaption></figure><blockquote><p><strong>投影图像是翻转的吗？</strong> 的确如此。所有用摄像机记录的图像，包括你的眼睛，都是翻转的。图像在进一步处理过程中会再次翻转，所以你不需要担心。</p></blockquote><p>因为每个点只捕获单根光线，所以图像总是清晰的。不幸的是，单根光线并不亮，所以产生的图像几乎看不见。你必须等待很长时间才能积累足够的光线以获得清晰的图像，这意味着这种摄像机需要很长的曝光时间。对于移动的物体会产生大量运动模糊。因此，它不是一个实用的摄像机。</p><p>为了能够缩短曝光时间，必须更快地积累光线。唯一的方法是同时记录多根光线。这可以通过增大光圈半径来实现。假设孔是圆形的，这意味着每个点都将以一锥光线而不是一根线投射到图像平面上。所以我们接收到了更多的光，但它不再落在一个点上，而是投射成一个圆盘（Disc）。覆盖多大面积取决于点、孔和图像平面之间的距离。结果是得到了一个更亮但模糊的图像。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-18.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-18.png" alt="Using a larger aperture" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Using a larger aperture</figcaption></figure><p>为了再次聚焦光线，我们必须以某种方式获取进入的光锥并将其带回一个点。这是通过在摄像机孔中放置一个透镜（Lens）来完成的。透镜以这样一种方式弯曲光线，使发散的光再次聚焦。这可以产生明亮且锐利的投影，但仅限于距离摄像机固定距离的点。距离更远的点发出的光线不会被足够聚焦，而距离太近的点发出的光线会被过度聚焦。在两种情况下，我们再次将点投射为圆盘，其大小取决于失焦程度。这种失焦投影被称为<strong>弥散圆（circle of confusion，简称 CoC）</strong>。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-19.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-19.png" alt="Only one point is in focus" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Only one point is in focus</figcaption></figure><h3 id="21-可视化-coc"><span class="me-2">2.1 可视化 CoC</span><a href="#21-可视化-coc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>弥散圆的半径是衡量点失焦程度的一个指标。让我们从可视化这个值开始。在 <code class="language-plaintext highlighter-rouge">DepthOfFieldEffect</code> 中添加一个常量来指示我们的第一个 pass，即 CoC pass。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">circleOfConfusionPass</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="err">…</span>
<span class="k">void</span> <span class="nf">OnRenderImage</span> <span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">dofMaterial</span><span class="p">,</span> <span class="n">circleOfConfusionPass</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>因为 CoC 取决于到摄像机的距离，我们需要读取深度缓冲。采样深度纹理，转换为线性深度并渲染。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="n">CGINCLUDE</span>
    <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>    <span class="kt">sampler2D</span> <span class="n">_MainTex</span><span class="p">,</span> <span class="n">_CameraDepthTexture</span><span class="p">;</span>
    <span class="err">…</span>
<span class="n">ENDCG</span>

<span class="n">SubShader</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="n">Pass</span> <span class="p">{</span> <span class="c1">// 0 circleOfConfusionPass</span>
        <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex VertexProgram
</span>            <span class="cp">#pragma fragment FragmentProgram
</span>            <span class="n">half4</span> <span class="n">FragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span>
                <span class="kr">half</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="n">LinearEyeDepth</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="22-选择简单的-coc"><span class="me-2">2.2 选择简单的 CoC</span><a href="#22-选择简单的-coc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们对原始深度值不感兴趣，而是对 CoC 值感兴趣。为此，我们需要确定一个<strong>焦距（focus distance）</strong>。这是摄像机与焦平面之间的距离，在这个平面上一切都是完美的。添加一个公共字段。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.1f</span><span class="p">,</span> <span class="m">100f</span><span class="p">)]</span>
<span class="k">public</span> <span class="kt">float</span> <span class="n">focusDistance</span> <span class="p">=</span> <span class="m">10f</span><span class="p">;</span>
</pre></table></code></div></div><p>CoC 的大小随着点到焦平面的距离而增大。确切的关系取决于摄像机及其配置，这可能变得相当复杂。模拟真实摄像机是可能的，但我们将使用一个简单的焦距范围（focus range），以便更容易理解和控制。我们的 CoC 将在这个范围内从零增加到最大值。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.1f</span><span class="p">,</span> <span class="m">10f</span><span class="p">)]</span>
<span class="k">public</span> <span class="kt">float</span> <span class="n">focusRange</span> <span class="p">=</span> <span class="m">3f</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-21.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-21.png" alt="Sliders for focus distance and range" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Sliders for focus distance and range</figcaption></figure><p>在 blit 之前设置这些配置。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">dofMaterial</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"_FocusDistance"</span><span class="p">,</span> <span class="n">focusDistance</span><span class="p">);</span>
<span class="n">dofMaterial</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"_FocusRange"</span><span class="p">,</span> <span class="n">focusRange</span><span class="p">);</span>
<span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">dofMaterial</span><span class="p">,</span> <span class="n">circleOfConfusionPass</span><span class="p">);</span>
</pre></table></code></div></div><p>添加变量到 shader。我们使用深度 $d$，焦距 $f$ 和焦距范围 $r$，可以通过 $CoC = \frac{d - f}{r}$ 找到 CoC。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">_FocusDistance</span><span class="p">,</span> <span class="n">_FocusRange</span><span class="p">;</span>

<span class="n">half4</span> <span class="nf">FragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">LinearEyeDepth</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">coc</span> <span class="o">=</span> <span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="n">_FocusDistance</span><span class="p">)</span> <span class="o">/</span> <span class="n">_FocusRange</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">coc</span><span class="p">;</span>
<span class="err">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-05.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-05.png" alt="Raw CoC" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Raw CoC</figcaption></figure><p>这会导致焦距之外的点出现正的 CoC 值，而焦距之前的点出现负的 CoC 值。值 -1 和 1 代表最大 CoC，因此我们应该通过 clamp 确保 CoC 值不超过这个范围。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="kt">float</span> <span class="n">coc</span> <span class="o">=</span> <span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="n">_FocusDistance</span><span class="p">)</span> <span class="o">/</span> <span class="n">_FocusRange</span><span class="p">;</span>
    <span class="n">coc</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">coc</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">coc</span><span class="p">;</span>
</pre></table></code></div></div><p>我们保留负的 CoC 值，以便区分前景和背景点。为了看到负的 CoC 值，你可以用红色着色。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-06.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-06.png" alt="Negative CoC is red" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Negative CoC is red</figcaption></figure><h3 id="23-缓冲-coc"><span class="me-2">2.3 缓冲 CoC</span><a href="#23-缓冲-coc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们需要 CoC 来缩放点的投影，但我们将在另一个 pass 中执行。所以我们将 CoC 值存储在一个临时缓冲中。因为我们只需要存储单个值，我们可以使用单通道纹理 <code class="language-plaintext highlighter-rouge">RenderTextureFormat.RHalf</code>。此外，此缓冲包含 CoC 数据而不是颜色值，因此它应该始终被视为线性数据。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">RenderTexture</span> <span class="n">coc</span> <span class="p">=</span> <span class="n">RenderTexture</span><span class="p">.</span><span class="nf">GetTemporary</span><span class="p">(</span>
    <span class="n">source</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">source</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
    <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">RHalf</span><span class="p">,</span> <span class="n">RenderTextureReadWrite</span><span class="p">.</span><span class="n">Linear</span>
<span class="p">);</span>
<span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">coc</span><span class="p">,</span> <span class="n">dofMaterial</span><span class="p">,</span> <span class="n">circleOfConfusionPass</span><span class="p">);</span>
<span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">coc</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
<span class="n">RenderTexture</span><span class="p">.</span><span class="nf">ReleaseTemporary</span><span class="p">(</span><span class="n">coc</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="3-bokeh-散景"><span class="me-2">3 Bokeh (散景)</span><a href="#3-bokeh-散景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>虽然 CoC 决定了每个点的散景效果强度，但光圈决定了它的外观。基本上，图像是由许多光圈形状在图像平面上的投影构成的。因此，创建散景的一种方法是根据其 CoC 的大小和不透明度，使用其颜色为每个纹素（texel）渲染一个 sprite。由于大量的过度绘制，这种方法成本非常高。</p><p>另一种方法是反向工作。与其将单个片元投射到许多片元上，不如让每个片元从所有可能影响它的纹素中累积颜色。这种技术不需要生成额外的几何体，但需要进行大量的纹理采样。我们将使用这种方法。</p><h3 id="31-累积散景"><span class="me-2">3.1 累积散景</span><a href="#31-累积散景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>创建一个用于生成散景效果的新 pass。假设整个图像完全失焦，我们需要平均当前片元周围 9×9 纹素块的颜色。这总共需要 81 次采样。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">Pass</span> <span class="p">{</span> <span class="c1">// 1 bokehPass</span>
    <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma vertex VertexProgram
</span>        <span class="cp">#pragma fragment FragmentProgram
</span>        <span class="n">half4</span> <span class="n">FragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span>
            <span class="n">half3</span> <span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">float2</span> <span class="n">o</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">_MainTex_TexelSize</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
                    <span class="n">color</span> <span class="o">+=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">+</span> <span class="n">o</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">color</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">81</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">half4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-07.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-07.png" alt="Square bokeh" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Square bokeh</figcaption></figure><p>结果是一个更块状的图像。实际上，我们使用的是方形光圈。</p><h3 id="32-圆形散景"><span class="me-2">3.2 圆形散景</span><a href="#32-圆形散景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>理想的光圈是圆形的，产生由许多重叠圆盘组成的散景。我们可以通过简单地丢弃那些偏移量太大的样本，将散景形状变成直径为 4 步的圆盘。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-09.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-09.png" alt="Round bokeh" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Round bokeh</figcaption></figure><p>为了不限于规则网格，我们使用旋转或同心圆模式。我们将使用 Unity Post-processing Stack v2 中的采样核（Kernel）。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#define BOKEH_KERNEL_MEDIUM
#if defined(BOKEH_KERNEL_SMALL)
</span>    <span class="kr">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kernelSampleCount</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="err">…</span>
<span class="cp">#elif defined (BOKEH_KERNEL_MEDIUM)
</span>    <span class="kr">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kernelSampleCount</span> <span class="o">=</span> <span class="mi">22</span><span class="p">;</span>
    <span class="kr">static</span> <span class="k">const</span> <span class="n">float2</span> <span class="n">kernel</span><span class="p">[</span><span class="n">kernelSampleCount</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">53333336</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="err">…</span>
    <span class="p">};</span>
<span class="cp">#endif
</span>
<span class="n">half4</span> <span class="n">FragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span>
    <span class="n">half3</span> <span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">kernelSampleCount</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float2</span> <span class="n">o</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="n">o</span> <span class="o">*=</span> <span class="n">_MainTex_TexelSize</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">color</span> <span class="o">+=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">+</span> <span class="n">o</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">color</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="n">kernelSampleCount</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">half4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-10.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-10.png" alt="Using the medium kernel" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Using the medium kernel</figcaption></figure><h3 id="33-模糊散景"><span class="me-2">3.3 模糊散景</span><a href="#33-模糊散景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了用相同数量的样本覆盖更多区域，我们可以像 bloom 效果一样，在半分辨率下创建该效果。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">width</span> <span class="p">=</span> <span class="n">source</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">height</span> <span class="p">=</span> <span class="n">source</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
<span class="n">RenderTextureFormat</span> <span class="n">format</span> <span class="p">=</span> <span class="n">source</span><span class="p">.</span><span class="n">format</span><span class="p">;</span>
<span class="n">RenderTexture</span> <span class="n">dof0</span> <span class="p">=</span> <span class="n">RenderTexture</span><span class="p">.</span><span class="nf">GetTemporary</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
<span class="n">RenderTexture</span> <span class="n">dof1</span> <span class="p">=</span> <span class="n">RenderTexture</span><span class="p">.</span><span class="nf">GetTemporary</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>

<span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">coc</span><span class="p">,</span> <span class="n">dofMaterial</span><span class="p">,</span> <span class="n">circleOfConfusionPass</span><span class="p">);</span>
<span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dof0</span><span class="p">);</span>
<span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">dof0</span><span class="p">,</span> <span class="n">dof1</span><span class="p">,</span> <span class="n">dofMaterial</span><span class="p">,</span> <span class="n">bokehPass</span><span class="p">);</span>
<span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">dof1</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
</pre></table></code></div></div><p>为了保持散景大小一致，我们必须将采样偏移减半：<code class="language-plaintext highlighter-rouge">o *= _MainTex_TexelSize.xy * 4;</code>。同时，我们会在生成散景后添加一个额外的模糊 pass（postfilter pass），使用 3×3 帐篷滤波器（tent filter）。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-11.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-11.png" alt="With a tent filter" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">With a tent filter</figcaption></figure><h3 id="34-散景大小"><span class="me-2">3.4 散景大小</span><a href="#34-散景大小" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>让散景半径通过一个字段可配置，范围为 1–10，默认值为 4（以半分辨率纹素表示）。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">1f</span><span class="p">,</span> <span class="m">10f</span><span class="p">)]</span>
<span class="k">public</span> <span class="kt">float</span> <span class="n">bokehRadius</span> <span class="p">=</span> <span class="m">4f</span><span class="p">;</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-12.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-12.png" alt="Conﬁgurable bokeh radius" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Conﬁgurable bokeh radius</figcaption></figure><h2 id="4-聚焦"><span class="me-2">4 聚焦</span><a href="#4-聚焦" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>现在我们可以确定 CoC 的大小并创建最大尺寸的散景。下一步是结合这些来渲染可变的散景，模拟摄像机聚焦。</p><h3 id="41-降采样-coc"><span class="me-2">4.1 降采样 CoC</span><a href="#41-降采样-coc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为我们在半分辨率下创建散景，所以我们也需要半分辨率的 CoC 数据。我们必须自己进行降采样，在一个自定义的 prefilter pass 中进行。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">coc</span><span class="p">,</span> <span class="n">dofMaterial</span><span class="p">,</span> <span class="n">circleOfConfusionPass</span><span class="p">);</span>
<span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dof0</span><span class="p">,</span> <span class="n">dofMaterial</span><span class="p">,</span> <span class="n">preFilterPass</span><span class="p">);</span>
</pre></table></code></div></div><p>在 prefilter pass 中，我们采用四个高分辨率纹素中极端的 CoC 值（绝对值最大）。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kr">half</span> <span class="n">coc0</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_CoCTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">+</span> <span class="n">o</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
<span class="err">…</span>
<span class="kr">half</span> <span class="n">cocMin</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">coc0</span><span class="p">,</span> <span class="n">coc1</span><span class="p">),</span> <span class="n">coc2</span><span class="p">),</span> <span class="n">coc3</span><span class="p">);</span>
<span class="kr">half</span> <span class="n">cocMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">coc0</span><span class="p">,</span> <span class="n">coc1</span><span class="p">),</span> <span class="n">coc2</span><span class="p">),</span> <span class="n">coc3</span><span class="p">);</span>
<span class="kr">half</span> <span class="n">coc</span> <span class="o">=</span> <span class="n">cocMax</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">cocMin</span> <span class="o">?</span> <span class="n">cocMax</span> <span class="o">:</span> <span class="n">cocMin</span><span class="p">;</span>
<span class="k">return</span> <span class="nf">half4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">coc</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="42-使用正确的-coc"><span class="me-2">4.2 使用正确的 CoC</span><a href="#42-使用正确的-coc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在第一个 pass 中计算 CoC 时，将其乘以散景半径：<code class="language-plaintext highlighter-rouge">coc = clamp(coc, -1, 1) * _BokehRadius;</code>。 在散景 pass 中，如果样本的 CoC 至少与用于其偏移的核半径（kernel radius）一样大，那么该点的投影就会重叠该片元。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">kernelSampleCount</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">o</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">_BokehRadius</span><span class="p">;</span>
    <span class="kr">half</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="err">…</span>
    <span class="n">half4</span> <span class="n">s</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">+</span> <span class="n">o</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">color</span> <span class="o">+=</span> <span class="n">s</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
        <span class="n">weight</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-13.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-13.png" alt="Bokeh based on CoC" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Bokeh based on CoC</figcaption></figure><h3 id="43-平滑采样"><span class="me-2">4.3 平滑采样</span><a href="#43-平滑采样" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>与其完全丢弃样本，我们根据 CoC 和偏移半径分配 0–1 范围内的权重。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kr">half</span> <span class="nf">Weigh</span> <span class="p">(</span><span class="kr">half</span> <span class="n">coc</span><span class="p">,</span> <span class="kr">half</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">saturate</span><span class="p">((</span><span class="n">coc</span> <span class="o">-</span> <span class="n">radius</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-14.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-14.png" alt="Smoothed sampling threshold" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Smoothed sampling threshold</figcaption></figure><h3 id="44-保持对焦"><span class="me-2">4.4 保持对焦</span><a href="#44-保持对焦" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>半分辨率渲染强制执行了最小程度的模糊。为了让焦点区域保持锐利，我们将半分辨率效果与全分辨率源图像混合。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kr">half</span> <span class="n">dofStrength</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">abs</span><span class="p">(</span><span class="n">coc</span><span class="p">));</span>
<span class="n">half3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">dof</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">dofStrength</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-15.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-15.png" alt="Sharp in-focus region" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Sharp in-focus region</figcaption></figure><h3 id="45-分离前景和背景"><span class="me-2">4.5 分离前景和背景</span><a href="#45-分离前景和背景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当失焦的前景位于对焦的背景前面时，简单的混合会产生错误。为了解决这个问题，我们需要分离前景和背景。背景样本的权重基于 <code class="language-plaintext highlighter-rouge">max(0, min(s.a, coc))</code>，而前景样本基于 <code class="language-plaintext highlighter-rouge">-s.a</code>。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-16.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-16.png" alt="Cutting out the foreground" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Cutting out the foreground</figcaption></figure><h3 id="46-重新合并前景和背景"><span class="me-2">4.6 重新合并前景和背景</span><a href="#46-重新合并前景和背景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们将前景和背景数据保存在单个缓冲中。在 combine pass 中，根据 CoC 和前景权重进行插值。</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kr">half</span> <span class="n">dofStrength</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">abs</span><span class="p">(</span><span class="n">coc</span><span class="p">));</span>
<span class="n">half3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span>
    <span class="n">source</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">dof</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span>
    <span class="n">dofStrength</span> <span class="o">+</span> <span class="n">dof</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">dofStrength</span> <span class="o">*</span> <span class="n">dof</span><span class="p">.</span><span class="n">a</span>
<span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-17.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-17.png" alt="Foreground edge without artifacts" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Foreground edge without artifacts</figcaption></figure><h3 id="47-降低散景强度"><span class="me-2">4.7 降低散景强度</span><a href="#47-降低散景强度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>最后，通过在 prefilter pass 中使用加权平均值来降低散景强度，以防止整体亮度发生太大变化。加权公式为 $w = \frac{1}{1 + \max(r, g, b)}$。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender25/dof-20.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender25/dof-20.png" alt="Weighed bokeh e!ect" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Weighed bokeh e!ect</figcaption></figure><p>你现在拥有了一个简单的景深效果，大致相当于 Unity Post-processing Stack v2 中的效果。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/shader/">Shader</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a> <a href="/tags/depth-of-field/" class="post-tag no-text-decoration" >Depth of Field</a> <a href="/tags/post-processing/" class="post-tag no-text-decoration" >Post Processing</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E6%99%AF%E6%B7%B1%E5%85%89%E7%BA%BF%E7%9A%84%E5%BC%AF%E6%9B%B2(%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%8D%81%E4%BA%94)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Funity-depth-of-field%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E6%99%AF%E6%B7%B1%E5%85%89%E7%BA%BF%E7%9A%84%E5%BC%AF%E6%9B%B2(%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%8D%81%E4%BA%94)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Funity-depth-of-field%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Funity-depth-of-field%2F&text=%E6%99%AF%E6%B7%B1%E5%85%89%E7%BA%BF%E7%9A%84%E5%BC%AF%E6%9B%B2(%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%8D%81%E4%BA%94)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/flat-and-wireframe-shading/">平面着色与线框着色(翻译二十一)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-tessellation/">曲面细分(翻译二十二)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-surface-displacement/">曲面细分表面置换(翻译二十三)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-bloom/">Bloom模糊光照(翻译二十四)</a><li class="text-truncate lh-lg"> <a href="/posts/claude-code-guide/">Claude Code学习总结：目录导航</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/unity-fxaa/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1517328000" data-df="ll" > Jan 31, 2018 </time><h4 class="pt-0 my-2">FXAA像素平滑(翻译二十六)</h4><div class="text-muted"><p>计算图像亮度（Luminance）。 寻找高对比度像素。 识别对比度边缘。 选择性混合。 搜索边缘端点。 1 搭建场景 显示器的分辨率是有限的。因此，未与像素网格对齐的图像特征会产生锯齿（Aliasing）。对角线和曲线看起来像阶梯，通常被称为“锯齿（jaggies）”。细线可能会断开。比像素还小的高对比度特征有时出现，有时不出现，导致物体移动时产生闪烁，通常被称为...</p></div></div></a></article><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_2/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515333600" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展二(翻译十)</h4><div class="text-muted"><p>本篇摘要: 把自身阴影烘焙进材质 增加细节纹理部分 支持更丰富的shader变体 一次编辑多个材质球 遮挡区域的Self-Shading 美术能够创作非常复杂丰富的表面纹理，它只是一个视错觉。为了增强表面纹理视觉真实感，引入Self-Shading。 如何增强呢？通常我们使用了法线来增强模型表面的凹凸层次感，法线带来的视觉增强是第一步，但是法线只适用于采样直接光...</p></div></div></a></article><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515326400" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展一(翻译九)</h4><div class="text-muted"><p>选中当前材质后，若材质使用的Shader调用了GUI拓展，则会自动读取该Shader的所有属性。通过重实现OnGUI函数后，获取其参数地址就能读取。</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/unity-bloom/" class="btn btn-outline-primary" aria-label="Older" ><p>Bloom模糊光照(翻译二十四)</p></a> <a href="/posts/unity-fxaa/" class="btn btn-outline-primary" aria-label="Newer" ><p>FXAA像素平滑(翻译二十六)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
