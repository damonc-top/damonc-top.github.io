<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="自定义管线:Shadow Masks (翻译六)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="烘焙静态阴影。 将实时光照与烘焙阴影结合。 混合实时阴影和烘焙阴影。 支持最多四个阴影掩码光源。" /><meta property="og:description" content="烘焙静态阴影。 将实时光照与烘焙阴影结合。 混合实时阴影和烘焙阴影。 支持最多四个阴影掩码光源。" /><link rel="canonical" href="www.damonc.top/posts/shadow-masks/" /><meta property="og:url" content="www.damonc.top/posts/shadow-masks/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/SRP/srp6/01-cover.jpg" /><meta property="og:image:alt" content="Realtime shadows nearby, baked shadows farther away." /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-02-27T00:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/SRP/srp6/01-cover.jpg" /><meta name="twitter:image:alt" content="Realtime shadows nearby, baked shadows farther away." /><meta property="twitter:title" content="自定义管线:Shadow Masks (翻译六)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2026-02-19T23:25:40+08:00","datePublished":"2020-02-27T00:00:00+08:00","description":"烘焙静态阴影。 将实时光照与烘焙阴影结合。 混合实时阴影和烘焙阴影。 支持最多四个阴影掩码光源。","headline":"自定义管线:Shadow Masks (翻译六)","image":{"lqip":"data:image/webp;base64,UklGRlIAAABXRUJQVlA4IEYAAACwAwCdASoUAAoAP3Ggxli0q6ejsAgCkC4JbACdMoACgk9g3FDGkAD5ydOWqBWJCpN+cLEpFZeyJgslScZvZGAAGgULyWAA","alt":"Realtime shadows nearby, baked shadows farther away.","url":"https://img.damonc.top/posts/SRP/srp6/01-cover.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/shadow-masks/"},"url":"www.damonc.top/posts/shadow-masks/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>自定义管线:Shadow Masks (翻译六) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js,npm/mermaid@11.12.0/dist/mermaid.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘摊手</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>自定义管线:Shadow Masks (翻译六)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>自定义管线:Shadow Masks (翻译六)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1582732800" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 27, 2020 </time> </span> <span> Updated <time data-ts="1771514740" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 19, 2026 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/SRP/srp6/01-cover.jpg" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/SRP/srp6/01-cover.jpg" alt="Realtime shadows nearby, baked shadows farther away." width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRlIAAABXRUJQVlA4IEYAAACwAwCdASoUAAoAP3Ggxli0q6ejsAgCkC4JbACdMoACgk9g3FDGkAD5ydOWqBWJCpN+cLEpFZeyJgslScZvZGAAGgULyWAA"></a><figcaption class="text-center pt-2 pb-2">Realtime shadows nearby, baked shadows farther away.</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/shadow-masks/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="6547 words" > <em>36 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">自定义管线:Shadow Masks (翻译六)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">自定义管线:Shadow Masks (翻译六)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><ul><li>烘焙静态阴影。<li>将实时光照与烘焙阴影结合。<li>混合实时阴影和烘焙阴影。<li>支持最多四个阴影掩码光源。</ul><hr /><h2 id="烘焙阴影"><span class="me-2">烘焙阴影</span><a href="#烘焙阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>使用光照贴图的一个优点是我们不受最大阴影距离的限制。烘焙阴影不会被剔除，但它们也无法改变。理想情况下，我们可以在最大阴影距离内使用实时阴影，而在那之后使用烘焙阴影。Unity 的阴影掩码（Shadowmask）混合光照模式使这成为可能。</p><h3 id="距离阴影掩码"><span class="me-2">距离阴影掩码</span><a href="#距离阴影掩码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>让我们考虑与前一个教程相同的场景，但减小最大阴影距离，使得结构内部的一部分没有阴影。这使得实时阴影结束的地方非常清晰。我们首先只有一个光源。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/02-baked-indirect.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/02-baked-indirect.png" alt="Baked indirect mixed lighting, max distance 11." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Baked indirect mixed lighting, max distance 11.</figcaption></figure><p>将混合光照模式切换为 <em>Shadowmask</em>。这将使光照数据失效，因此必须重新烘焙。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/02-shadowmask-mode.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/02-shadowmask-mode.png" alt="Shadowmask mixed lighting mode." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Shadowmask mixed lighting mode.</figcaption></figure><p>使用阴影掩码混合光照有两种方式，可以在 <em>Quality</em> 项目设置中进行配置。我们将使用 <em>Distance Shadowmask</em> 模式。另一种模式简称为 <em>Shadowmask</em>，我们稍后会介绍。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/03-distance-shadowmask-setting.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/03-distance-shadowmask-setting.png" alt="Shadow mask mode set to distance." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Shadow mask mode set to distance.</figcaption></figure><p>这两种阴影掩码模式使用相同的烘焙光照数据。在这两种情况下，光照贴图最终都包含间接光照，与 <em>Baked Indirect</em> 混合光照模式完全相同。不同之处在于现在还有一个烘焙的阴影掩码贴图，你可以通过烘焙光照贴图预览窗口查看。</p><p>在 Unity 2022 中，你可以通过禁用光照的 <em>Auto Generate</em>，手动生成它，然后检查生成的纹理资产来查看阴影掩码贴图。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/03-lightmap-and-shadowmask.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/03-lightmap-and-shadowmask.png" alt="Baked indirect light and shadow mask." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Baked indirect light and shadow mask.</figcaption></figure><p>阴影掩码贴图包含我们单个混合方向光的阴影衰减，代表由所有贡献全局光照的静态对象投射的阴影。数据存储在红色通道中，因此贴图是黑色和红色的。</p><p>就像烘焙间接光照一样，烘焙阴影在运行时无法改变。然而，无论光源的强度或颜色如何，阴影都将保持有效。但光源不应旋转，否则其阴影将没有意义。此外，如果光源的间接光照是烘焙的，你不应该过多地改变光源。例如，如果光源关闭后间接光照仍然存在，那显然是错误的。如果光源变化很大，那么你可以将其 <em>Indirect Multiplier</em> 设置为零，这样就不会为其烘焙间接光。</p><h3 id="检测阴影掩码"><span class="me-2">检测阴影掩码</span><a href="#检测阴影掩码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>要使用阴影掩码，我们的管线必须首先知道它的存在。由于这完全关乎阴影，这是我们的 <code class="language-plaintext highlighter-rouge">Shadows</code> 类的职责。我们将使用着色器关键字来控制是否使用阴影掩码。由于有两种模式，我们将引入另一个静态关键字数组，尽管目前它只包含一个关键字：<code class="language-plaintext highlighter-rouge">_SHADOW_MASK_DISTANCE</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">string</span><span class="p">[]</span> <span class="n">shadowMaskKeywords</span> <span class="p">=</span> <span class="p">{</span>
    <span class="s">"_SHADOW_MASK_DISTANCE"</span>
<span class="p">};</span>
</pre></table></code></div></div><p>添加一个布尔字段来跟踪我们是否正在使用阴影掩码。我们每帧都会重新评估，所以在 <code class="language-plaintext highlighter-rouge">Setup</code> 中将其初始化为 <code class="language-plaintext highlighter-rouge">false</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">useShadowMask</span><span class="p">;</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">useShadowMask</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">Render</code> 的末尾启用或禁用关键字。即使我们最终没有渲染任何实时阴影，我们也必须这样做，因为阴影掩码不是实时的。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">SetKeywords</span><span class="p">(</span><span class="n">shadowMaskKeywords</span><span class="p">,</span> <span class="n">useShadowMask</span> <span class="p">?</span> <span class="m">0</span> <span class="p">:</span> <span class="p">-</span><span class="m">1</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>为了知道是否需要阴影掩码，我们必须检查是否有光源使用了它。我们将在 <code class="language-plaintext highlighter-rouge">ReserveDirectionalShadows</code> 中执行此操作，当我们最终得到一个有效的投射阴影的光源时。</p><p>每个光源都包含有关其烘焙数据的信息。它存储在 <code class="language-plaintext highlighter-rouge">LightBakingOutput</code> 结构中，可以通过 <code class="language-plaintext highlighter-rouge">Light.bakingOutput</code> 属性检索。如果我们遇到一个光照贴图烘焙类型设置为混合（Mixed），且其混合光照模式设置为阴影掩码（Shadowmask）的光源，那么我们就在使用阴影掩码。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Vector3</span> <span class="nf">ReserveDirectionalShadows</span> <span class="p">(</span>
    <span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">LightBakingOutput</span> <span class="n">lightBaking</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">bakingOutput</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">lightBaking</span><span class="p">.</span><span class="n">lightmapBakeType</span> <span class="p">==</span> <span class="n">LightmapBakeType</span><span class="p">.</span><span class="n">Mixed</span> <span class="p">&amp;&amp;</span>
            <span class="n">lightBaking</span><span class="p">.</span><span class="n">mixedLightingMode</span> <span class="p">==</span> <span class="n">MixedLightingMode</span><span class="p">.</span><span class="n">Shadowmask</span>
        <span class="p">)</span> <span class="p">{</span>
            <span class="n">useShadowMask</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这会在需要时启用着色器关键字。在 <code class="language-plaintext highlighter-rouge">Lit</code> 着色器的 <code class="language-plaintext highlighter-rouge">CustomLit</code> 通道中为其添加相应的多重编译指令。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#pragma multi_compile _ _CASCADE_BLEND_SOFT _CASCADE_BLEND_DITHER
#pragma multi_compile _ _SHADOW_MASK_DISTANCE
#pragma multi_compile _ LIGHTMAP_ON
</span></pre></table></code></div></div><h3 id="阴影掩码数据"><span class="me-2">阴影掩码数据</span><a href="#阴影掩码数据" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在着色器端，我们必须知道阴影掩码是否正在使用，如果是，烘焙阴影是什么。让我们向 <code class="language-plaintext highlighter-rouge">Shadows</code> 添加一个 <code class="language-plaintext highlighter-rouge">ShadowMask</code> 结构来跟踪这两者，包含一个布尔值和一个浮点向量字段。将布尔值命名为 <code class="language-plaintext highlighter-rouge">distance</code>，以指示是否启用了距离阴影掩码模式。然后将此结构作为一个字段添加到全局 <code class="language-plaintext highlighter-rouge">ShadowData</code> 结构中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">ShadowMask</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="nb">distance</span><span class="p">;</span>
	<span class="kt">float4</span> <span class="n">shadows</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ShadowData</span> <span class="p">{</span>
	<span class="n">int</span> <span class="n">cascadeIndex</span><span class="p">;</span>
	<span class="n">float</span> <span class="n">cascadeBlend</span><span class="p">;</span>
	<span class="n">float</span> <span class="n">strength</span><span class="p">;</span>
	<span class="n">ShadowMask</span> <span class="n">shadowMask</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">GetShadowData</code> 中默认将阴影掩码初始化为未使用。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">ShadowData</span> <span class="nf">GetShadowData</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ShadowData</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="nb">distance</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">shadows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>虽然阴影掩码用于阴影处理，但它是场景烘焙光照数据的一部分。因此，检索它是 <code class="language-plaintext highlighter-rouge">GI</code> 的责任。所以也向 <code class="language-plaintext highlighter-rouge">GI</code> 结构添加一个阴影掩码字段，并在 <code class="language-plaintext highlighter-rouge">GetGI</code> 中将其初始化为未使用。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">GI</span> <span class="p">{</span>
	<span class="kt">float3</span> <span class="n">diffuse</span><span class="p">;</span>
	<span class="n">ShadowMask</span> <span class="n">shadowMask</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="n">GI</span> <span class="nf">GetGI</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">GI</span> <span class="n">gi</span><span class="p">;</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SampleLightMap</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">)</span> <span class="o">+</span> <span class="n">SampleLightProbe</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="nb">distance</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">shadows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gi</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Unity 通过 <code class="language-plaintext highlighter-rouge">unity_ShadowMask</code> 纹理及附带的采样器状态使阴影掩码贴图到着色器可见。在 <code class="language-plaintext highlighter-rouge">GI</code> 中定义这些，以及其他光照贴图纹理和采样器状态。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">samplerunity_Lightmap</span><span class="p">);</span>

<span class="n">TEXTURE2D</span><span class="p">(</span><span class="n">unity_ShadowMask</span><span class="p">);</span>
<span class="n">SAMPLER</span><span class="p">(</span><span class="n">samplerunity_ShadowMask</span><span class="p">);</span>
</pre></table></code></div></div><p>然后添加一个 <code class="language-plaintext highlighter-rouge">SampleBakedShadows</code> 函数来采样贴图，使用光照贴图 UV 坐标。就像常规光照贴图一样，这只对使用了光照贴图的几何体有意义，即定义了 <code class="language-plaintext highlighter-rouge">LIGHTMAP_ON</code> 时。否则没有烘焙阴影，衰减始终为 1。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">SampleBakedShadows</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">)</span> <span class="p">{</span>
	<span class="cp">#if defined(LIGHTMAP_ON)
</span>		<span class="k">return</span> <span class="n">SAMPLE_TEXTURE2D</span><span class="p">(</span>
			<span class="n">unity_ShadowMask</span><span class="p">,</span> <span class="n">samplerunity_ShadowMask</span><span class="p">,</span> <span class="n">lightMapUV</span>
		<span class="p">);</span>
	<span class="cp">#else
</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p>现在我们可以调整 <code class="language-plaintext highlighter-rouge">GetGI</code>，使其在定义了 <code class="language-plaintext highlighter-rouge">_SHADOW_MASK_DISTANCE</code> 时启用距离阴影掩码模式并采样烘焙阴影。请注意，这使得 <code class="language-plaintext highlighter-rouge">distance</code> 布尔值成为编译时常量，因此其使用不会导致动态分支。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">GI</span> <span class="nf">GetGI</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">GI</span> <span class="n">gi</span><span class="p">;</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SampleLightMap</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">)</span> <span class="o">+</span> <span class="n">SampleLightProbe</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="nb">distance</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">shadows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="cp">#if defined(_SHADOW_MASK_DISTANCE)
</span>		<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="nb">distance</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">shadows</span> <span class="o">=</span> <span class="n">SampleBakedShadows</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">);</span>
	<span class="cp">#endif
</span>	<span class="k">return</span> <span class="n">gi</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>由 <code class="language-plaintext highlighter-rouge">Lighting</code> 负责在 <code class="language-plaintext highlighter-rouge">GetLighting</code> 中循环光源之前将阴影掩码数据从 <code class="language-plaintext highlighter-rouge">GI</code> 复制到 <code class="language-plaintext highlighter-rouge">ShadowData</code>。此时，我们还可以通过直接返回阴影掩码数据作为最终光照颜色来调试它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">float3</span> <span class="nf">GetLighting</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">,</span> <span class="n">BRDF</span> <span class="n">brdf</span><span class="p">,</span> <span class="n">GI</span> <span class="n">gi</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ShadowData</span> <span class="n">shadowData</span> <span class="o">=</span> <span class="n">GetShadowData</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
	<span class="n">shadowData</span><span class="p">.</span><span class="n">shadowMask</span> <span class="o">=</span> <span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">shadows</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最初它似乎不起作用，因为所有内容最终都变成了白色。我们必须指示 Unity 将相关数据发送到 GPU，就像我们在上一个教程中为 <code class="language-plaintext highlighter-rouge">CameraRenderer.DrawVisibleGeometry</code> 中的光照贴图和探针所做的那样。在这种情况下，我们必须将 <code class="language-plaintext highlighter-rouge">PerObjectData.ShadowMask</code> 添加到每对象数据中。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">perObjectData</span> <span class="p">=</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">Lightmaps</span> <span class="p">|</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">ShadowMask</span> <span class="p">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbe</span> <span class="p">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbeProxyVolume</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/08-sampling-shadowmask.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/08-sampling-shadowmask.png" alt="Sampling shadow mask." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Sampling shadow mask.</figcaption></figure><aside class="collapsible-aside"><h3>为什么每次更改着色器代码时 Unity 都会烘焙光照？</h3><div><p>当更改包含在 meta pass 中的 HLSL 文件时，就会发生这种情况。你可以通过临时禁用 <em>Auto Generate</em> 来防止不必要的烘焙。</p></div></aside><h3 id="遮挡探针-occlusion-probes"><span class="me-2">遮挡探针 (Occlusion Probes)</span><a href="#遮挡探针-occlusion-probes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们可以看到阴影掩码正确地应用到了使用了光照贴图的对象。我们也看到动态对象没有阴影掩码数据，这是意料之中的。它们使用光照探针而不是光照贴图。然而，Unity 也会将阴影掩码数据烘焙到光照探针中，称之为遮挡探针。我们可以通过在 <code class="language-plaintext highlighter-rouge">UnityInput</code> 的 <code class="language-plaintext highlighter-rouge">UnityPerDraw</code> 缓冲区中添加 <code class="language-plaintext highlighter-rouge">unity_ProbesOcclusion</code> 向量来访问此数据。将其放在世界转换参数和光照贴图 UV 转换向量之间。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">real4</span> <span class="n">unity_WorldTransformParams</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">unity_ProbesOcclusion</span><span class="p">;</span>
<span class="kt">float4</span> <span class="n">unity_LightmapST</span><span class="p">;</span>
</pre></table></code></div></div><p>现在我们可以简单地在 <code class="language-plaintext highlighter-rouge">SampleBakedShadows</code> 中为动态对象返回该向量。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">SampleBakedShadows</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">)</span> <span class="p">{</span>
	<span class="cp">#if defined(LIGHTMAP_ON)
</span>		<span class="p">...</span>
	<span class="cp">#else
</span>		<span class="k">return</span> <span class="n">unity_ProbesOcclusion</span><span class="p">;</span>
	<span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p>同样，我们必须指示 Unity 将此数据发送到 GPU，这次是通过启用 <code class="language-plaintext highlighter-rouge">PerObjectData.OcclusionProbe</code> 标志。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">perObjectData</span> <span class="p">=</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">Lightmaps</span> <span class="p">|</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">ShadowMask</span> <span class="p">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbe</span> <span class="p">|</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">OcclusionProbe</span> <span class="p">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbeProxyVolume</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/09-sampling-occlusion-probes.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/09-sampling-occlusion-probes.png" alt="Sampling occlusion probes." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Sampling occlusion probes.</figcaption></figure><p>阴影掩码中未使用的通道对于探针被设置为白色，因此动态对象在完全照明时最终为白色，在完全阴影时最终为青色（cyan），而不是红色和黑色。</p><p>虽然这足以通过探针使阴影掩码工作，但它破坏了 GPU 实例化。遮挡数据可以自动实例化，但 <code class="language-plaintext highlighter-rouge">UnityInstancing</code> 仅在定义了 <code class="language-plaintext highlighter-rouge">SHADOWS_SHADOWMASK</code> 时才执行此操作。因此，在包含 <code class="language-plaintext highlighter-rouge">UnityInstancing</code> 之前，在 <code class="language-plaintext highlighter-rouge">Common</code> 中根据需要定义它。这是我们必须显式检查是否定义了 <code class="language-plaintext highlighter-rouge">_SHADOW_MASK_DISTANCE</code> 的唯一其他地方。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_SHADOW_MASK_DISTANCE)
</span>	<span class="cp">#define SHADOWS_SHADOWMASK
#endif
</span>
<span class="cp">#include</span> <span class="cpf">"Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"</span><span class="cp">
</span></pre></table></code></div></div><h3 id="lppvs"><span class="me-2">LPPVs</span><a href="#lppvs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>光照探针代理体（LPPV）也可以与阴影掩码配合使用。同样，我们必须通过设置标志来启用此功能，这次是 <code class="language-plaintext highlighter-rouge">PerObjectData.OcclusionProbeProxyVolume</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">perObjectData</span> <span class="p">=</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">Lightmaps</span> <span class="p">|</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">ShadowMask</span> <span class="p">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbe</span> <span class="p">|</span> <span class="n">PerObjectData</span><span class="p">.</span><span class="n">OcclusionProbe</span> <span class="p">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">LightProbeProxyVolume</span> <span class="p">|</span>
    <span class="n">PerObjectData</span><span class="p">.</span><span class="n">OcclusionProbeProxyVolume</span>
</pre></table></code></div></div><p>检索 LPPV 遮挡数据的工作方式与检索其光照数据相同，只是我们必须调用 <code class="language-plaintext highlighter-rouge">SampleProbeOcclusion</code> 而不是 <code class="language-plaintext highlighter-rouge">SampleProbeVolumeSH4</code>。它存储在相同的纹理中，需要相同的参数，唯一的例外是不需要法线向量。为此向 <code class="language-plaintext highlighter-rouge">SampleBakedShadows</code> 添加一个分支，以及目前所需世界位置的 <code class="language-plaintext highlighter-rouge">surface</code> 参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">SampleBakedShadows</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
	<span class="cp">#if defined(LIGHTMAP_ON)
</span>		<span class="p">...</span>
	<span class="cp">#else
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">SampleProbeOcclusion</span><span class="p">(</span>
				<span class="n">TEXTURE3D_ARGS</span><span class="p">(</span><span class="n">unity_ProbeVolumeSH</span><span class="p">,</span> <span class="n">samplerunity_ProbeVolumeSH</span><span class="p">),</span>
				<span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">unity_ProbeVolumeWorldToObject</span><span class="p">,</span>
				<span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">unity_ProbeVolumeParams</span><span class="p">.</span><span class="n">z</span><span class="p">,</span>
				<span class="n">unity_ProbeVolumeMin</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">unity_ProbeVolumeSizeInv</span><span class="p">.</span><span class="n">xyz</span>
			<span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">unity_ProbesOcclusion</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">GetGI</code> 中调用该函数时添加新的 <code class="language-plaintext highlighter-rouge">surface</code> 参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>	<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">shadows</span> <span class="o">=</span> <span class="n">SampleBakedShadows</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/10-sampling-lppv-occlusion.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/10-sampling-lppv-occlusion.png" alt="Sampling LPPV occlusion." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Sampling LPPV occlusion.</figcaption></figure><h3 id="mesh-ball"><span class="me-2">Mesh Ball</span><a href="#mesh-ball" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果我们的 mesh ball 使用了 LPPV，它就已经支持阴影掩码。但当它自己插值光照探针时，我们必须在 <code class="language-plaintext highlighter-rouge">MeshBall.Update</code> 中添加遮挡探针数据。这是通过为 <code class="language-plaintext highlighter-rouge">CalculateInterpolatedLightAndOcclusionProbes</code> 的最后一个参数使用一个临时 <code class="language-plaintext highlighter-rouge">Vector4</code> 数组，并通过 <code class="language-plaintext highlighter-rouge">CopyProbeOcclusionArrayFrom</code> 方法将其传递给属性块来完成的。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>		<span class="kt">var</span> <span class="n">lightProbes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SphericalHarmonicsL2</span><span class="p">[</span><span class="m">1023</span><span class="p">];</span>
		<span class="kt">var</span> <span class="n">occlusionProbes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="m">1023</span><span class="p">];</span>
		<span class="n">LightProbes</span><span class="p">.</span><span class="nf">CalculateInterpolatedLightAndOcclusionProbes</span><span class="p">(</span>
			<span class="n">positions</span><span class="p">,</span> <span class="n">lightProbes</span><span class="p">,</span> <span class="n">occlusionProbes</span>
		<span class="p">);</span>
		<span class="n">block</span><span class="p">.</span><span class="nf">CopySHCoefficientArraysFrom</span><span class="p">(</span><span class="n">lightProbes</span><span class="p">);</span>
		<span class="n">block</span><span class="p">.</span><span class="nf">CopyProbeOcclusionArrayFrom</span><span class="p">(</span><span class="n">occlusionProbes</span><span class="p">);</span>
</pre></table></code></div></div><p>在验证阴影掩码数据已正确发送到着色器后，我们可以从 <code class="language-plaintext highlighter-rouge">GetLighting</code> 中删除其调试可视化。</p><h2 id="混合阴影-mixing-shadows"><span class="me-2">混合阴影 (Mixing Shadows)</span><a href="#混合阴影-mixing-shadows" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>现在我们已经获得了阴影掩码，下一步是在实时阴影不存在时使用它，即当片元落在最大阴影距离之外时。</p><h3 id="在可用时使用烘焙阴影"><span class="me-2">在可用时使用烘焙阴影</span><a href="#在可用时使用烘焙阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>混合烘焙和实时阴影将使 <code class="language-plaintext highlighter-rouge">GetDirectionalShadowAttenuation</code> 的工作变得更加复杂。让我们首先隔离所有实时阴影采样代码，将其移动到 <code class="language-plaintext highlighter-rouge">Shadows</code> 中新的 <code class="language-plaintext highlighter-rouge">GetCascadedShadow</code> 函数中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="c1">//return gi.shadowMask.shadows.rgb;</span>

<span class="n">float</span> <span class="nf">GetCascadedShadow</span> <span class="p">(</span>
	<span class="n">DirectionalShadowData</span> <span class="n">directional</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="kt">float3</span> <span class="n">normalBias</span> <span class="o">=</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span>
		<span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">normalBias</span> <span class="o">*</span> <span class="n">_CascadeData</span><span class="p">[</span><span class="n">global</span><span class="p">.</span><span class="n">cascadeIndex</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
	<span class="kt">float3</span> <span class="n">positionSTS</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span>
		<span class="n">_DirectionalShadowMatrices</span><span class="p">[</span><span class="n">directional</span><span class="p">.</span><span class="n">tileIndex</span><span class="p">],</span>
		<span class="kt">float4</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">normalBias</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
	<span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">FilterDirectionalShadow</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">cascadeBlend</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">normalBias</span> <span class="o">=</span> <span class="n">surfaceWS</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span>
			<span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">normalBias</span> <span class="o">*</span> <span class="n">_CascadeData</span><span class="p">[</span><span class="n">global</span><span class="p">.</span><span class="n">cascadeIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
		<span class="n">positionSTS</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span>
			<span class="n">_DirectionalShadowMatrices</span><span class="p">[</span><span class="n">directional</span><span class="p">.</span><span class="n">tileIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
			<span class="kt">float4</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">normalBias</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
		<span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span>
			<span class="n">FilterDirectionalShadow</span><span class="p">(</span><span class="n">positionSTS</span><span class="p">),</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">global</span><span class="p">.</span><span class="n">cascadeBlend</span>
		<span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetDirectionalShadowAttenuation</span> <span class="p">(</span>
	<span class="n">DirectionalShadowData</span> <span class="n">directional</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="cp">#if !defined(_RECEIVE_SHADOWS)
</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="cp">#endif
</span>
	<span class="n">float</span> <span class="n">shadow</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">strength</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="n">GetCascadedShadow</span><span class="p">(</span><span class="n">directional</span><span class="p">,</span> <span class="n">global</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">directional</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后添加一个返回给定阴影掩码的烘焙阴影衰减的新函数 <code class="language-plaintext highlighter-rouge">GetBakedShadow</code>。如果掩码的距离模式已启用，则我们需要其 shadows 向量的第一个分量，否则没有可用的衰减，结果为 1。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetBakedShadow</span> <span class="p">(</span><span class="n">ShadowMask</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="nb">distance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="n">mask</span><span class="p">.</span><span class="n">shadows</span><span class="p">.</span><span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接下来，创建一个带有 <code class="language-plaintext highlighter-rouge">ShadowData</code>、实时阴影和阴影强度参数的 <code class="language-plaintext highlighter-rouge">MixBakedAndRealtimeShadows</code> 函数。它简单地将强度应用到阴影上，除非存在距离阴影掩码。如果是这样，用烘焙的阴影替换实时阴影。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">MixBakedAndRealtimeShadows</span> <span class="p">(</span>
	<span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">float</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">float</span> <span class="n">strength</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="n">float</span> <span class="n">baked</span> <span class="o">=</span> <span class="n">GetBakedShadow</span><span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="nb">distance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="n">baked</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">strength</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让 <code class="language-plaintext highlighter-rouge">GetDirectionalShadowAttenuation</code> 使用该函数而不是自己应用强度。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="n">shadow</span> <span class="o">=</span> <span class="n">GetCascadedShadow</span><span class="p">(</span><span class="n">directional</span><span class="p">,</span> <span class="n">global</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
	<span class="n">shadow</span> <span class="o">=</span> <span class="n">MixBakedAndRealtimeShadows</span><span class="p">(</span><span class="n">global</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">directional</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/13-faded-baked-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/13-faded-baked-shadows.png" alt="Faded baked shadows." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Faded baked shadows.</figcaption></figure><p>结果是我们现在总是使用阴影掩码，所以我们可以看到它在起作用。然而，烘焙阴影会像实时阴影一样随距离淡出。</p><h3 id="过渡到烘焙阴影"><span class="me-2">过渡到烘焙阴影</span><a href="#过渡到烘焙阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了基于深度从实时阴影过渡到烘焙阴影，我们必须根据全局阴影强度在它们之间进行插值。然而，我们还必须应用光源的阴影强度，这必须在插值之后完成。因此，我们不能再在 <code class="language-plaintext highlighter-rouge">GetDirectionalShadowData</code> 中立即合并两个强度。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>	<span class="n">data</span><span class="p">.</span><span class="n">strength</span> <span class="p">=</span>
		<span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">x</span><span class="p">;</span> <span class="c1">// * shadowData.strength;</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">MixBakedAndRealtimeShadows</code> 中根据全局强度执行烘焙阴影和实时阴影之间的插值，然后应用光源的阴影强度。但当没有阴影掩码时，仅将合并的强度应用到实时阴影，就像我们之前所做的那样。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">MixBakedAndRealtimeShadows</span> <span class="p">(</span>
	<span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">float</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">float</span> <span class="n">strength</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="n">float</span> <span class="n">baked</span> <span class="o">=</span> <span class="n">GetBakedShadow</span><span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="nb">distance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">baked</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">global</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">strength</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">strength</span> <span class="o">*</span> <span class="n">global</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/14-mixed-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/14-mixed-shadows.png" alt="Mixed shadows." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Mixed shadows.</figcaption></figure><p>结果是动态对象投射的阴影照常淡出，而静态对象投射的阴影则过渡到阴影掩码。</p><h3 id="仅烘焙阴影"><span class="me-2">仅烘焙阴影</span><a href="#仅烘焙阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>目前，我们的方法仅在有实时阴影要渲染时才有效。如果没有，那么阴影掩码也会消失。这可以通过缩小场景视图直到所有内容都位于最大阴影距离之外来验证。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/15-neither-realtime-nor-baked.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/15-neither-realtime-nor-baked.png" alt="Neither realtime nor baked shadows." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Neither realtime nor baked shadows.</figcaption></figure><p>我们必须支持存在阴影掩码但没有实时阴影的情况。让我们首先创建一个也有强度参数的 <code class="language-plaintext highlighter-rouge">GetBakedShadow</code> 函数变体，以便我们可以方便地获得受强度调制的烘焙阴影。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetBakedShadow</span> <span class="p">(</span><span class="n">ShadowMask</span> <span class="n">mask</span><span class="p">,</span> <span class="n">float</span> <span class="n">strength</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="nb">distance</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">GetBakedShadow</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">strength</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接下来，在 <code class="language-plaintext highlighter-rouge">GetDirectionalShadowAttenuation</code> 中检查合并的强度是否最终小于或等于零。如果是，与其总是返回 1，不如仅返回调制的烘焙阴影，仍然跳过实时阴影采样。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">strength</span> <span class="o">*</span> <span class="n">global</span><span class="p">.</span><span class="n">strength</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="n">GetBakedShadow</span><span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">,</span> <span class="n">directional</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
	<span class="p">}</span>
</pre></table></code></div></div><p>除此之外，我们还必须更改 <code class="language-plaintext highlighter-rouge">Shadows.ReserveDirectionalShadows</code>，使其不会立即跳过最终没有实时阴影投射器的光源。相反，首先确定光源是否使用阴影掩码。之后检查是否没有实时阴影投射器，在这种情况下，只有阴影强度是相关的。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span>
    <span class="n">shadowedDirLightCount</span> <span class="p">&lt;</span> <span class="n">maxShadowedDirLightCount</span> <span class="p">&amp;&amp;</span>
    <span class="n">light</span><span class="p">.</span><span class="n">shadows</span> <span class="p">!=</span> <span class="n">LightShadows</span><span class="p">.</span><span class="n">None</span> <span class="p">&amp;&amp;</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span> <span class="p">&gt;</span> <span class="m">0f</span> <span class="c1">//&amp;&amp;</span>
    <span class="c1">//cullingResults.GetShadowCasterBounds(visibleLightIndex, out Bounds b)</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">LightBakingOutput</span> <span class="n">lightBaking</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">bakingOutput</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">lightBaking</span><span class="p">.</span><span class="n">lightmapBakeType</span> <span class="p">==</span> <span class="n">LightmapBakeType</span><span class="p">.</span><span class="n">Mixed</span> <span class="p">&amp;&amp;</span>
        <span class="n">lightBaking</span><span class="p">.</span><span class="n">mixedLightingMode</span> <span class="p">==</span> <span class="n">MixedLightingMode</span><span class="p">.</span><span class="n">Shadowmask</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">useShadowMask</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(!</span><span class="n">cullingResults</span><span class="p">.</span><span class="nf">GetShadowCasterBounds</span><span class="p">(</span>
        <span class="n">visibleLightIndex</span><span class="p">,</span> <span class="k">out</span> <span class="n">Bounds</span> <span class="n">b</span>
    <span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但当阴影强度大于零时，着色器将采样阴影贴图，即使那是不正确的。我们可以通过在这种情况下否定阴影强度来使其工作。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(-</span><span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
</pre></table></code></div></div><p>然后在当我们跳过实时阴影时，将绝对强度传递给 <code class="language-plaintext highlighter-rouge">GetDirectionalShadowAttenuation</code> 中的 <code class="language-plaintext highlighter-rouge">GetBakedShadow</code>。这样，当没有实时阴影投射器时以及当我们超出最大阴影距离时，它都能工作。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">shadow</span> <span class="o">=</span> <span class="n">GetBakedShadow</span><span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">strength</span><span class="p">));</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/16-only-baked-shadows.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/16-only-baked-shadows.png" alt="Only baked shadows." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Only baked shadows.</figcaption></figure><h3 id="始终使用阴影掩码-always-use-the-shadow-mask"><span class="me-2">始终使用阴影掩码 (Always use the Shadow Mask)</span><a href="#始终使用阴影掩码-always-use-the-shadow-mask" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>还有另一种阴影掩码模式，简称为 <em>Shadowmask</em>。它的工作方式与距离模式完全相同，除了 Unity 会为使用阴影掩码的光源省略静态阴影投射器。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/17-always-shadowmask-mode.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/17-always-shadowmask-mode.png" alt="No realtime shadows cast by static geometry." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">No realtime shadows cast by static geometry.</figcaption></figure><p>这个想法是，因为阴影掩码随处可用，我们也可以随处将其用于静态阴影。这意味着实时阴影更少，这使得渲染更快，代价是近处静态阴影的质量较低。</p><p>要支持此模式，请将 <code class="language-plaintext highlighter-rouge">_SHADOW_MASK_ALWAYS</code> 关键字添加为 <code class="language-plaintext highlighter-rouge">Shadows</code> 中阴影掩码关键字数组的第一个元素。我们可以通过在 <code class="language-plaintext highlighter-rouge">Render</code> 中检查 <code class="language-plaintext highlighter-rouge">QualitySettings.shadowmaskMode</code> 属性来确定应该启用哪个。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">string</span><span class="p">[]</span> <span class="n">shadowMaskKeywords</span> <span class="p">=</span> <span class="p">{</span>
    <span class="s">"_SHADOW_MASK_ALWAYS"</span><span class="p">,</span>
    <span class="s">"_SHADOW_MASK_DISTANCE"</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Render</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">BeginSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">SetKeywords</span><span class="p">(</span><span class="n">shadowMaskKeywords</span><span class="p">,</span> <span class="n">useShadowMask</span> <span class="p">?</span>
        <span class="n">QualitySettings</span><span class="p">.</span><span class="n">shadowmaskMode</span> <span class="p">==</span> <span class="n">ShadowmaskMode</span><span class="p">.</span><span class="n">Shadowmask</span> <span class="p">?</span> <span class="m">0</span> <span class="p">:</span> <span class="m">1</span> <span class="p">:</span>
        <span class="p">-</span><span class="m">1</span>
    <span class="p">);</span>
    <span class="n">buffer</span><span class="p">.</span><span class="nf">EndSample</span><span class="p">(</span><span class="n">bufferName</span><span class="p">);</span>
    <span class="nf">ExecuteBuffer</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>对着色器中的多重编译指令也添加该关键字。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma multi_compile _ _SHADOW_MASK_ALWAYS _SHADOW_MASK_DISTANCE
</span></pre></table></code></div></div><p>并且在 <code class="language-plaintext highlighter-rouge">Common</code> 中决定是否定义 <code class="language-plaintext highlighter-rouge">SHADOWS_SHADOWMASK</code> 时也检查它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#if defined(_SHADOW_MASK_ALWAYS) || defined(_SHADOW_MASK_DISTANCE)
</span>	<span class="cp">#define SHADOWS_SHADOWMASK
#endif
</span></pre></table></code></div></div><p>给 <code class="language-plaintext highlighter-rouge">ShadowMask</code> 结构一个单独的布尔字段，以指示是否应始终使用阴影掩码。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">ShadowMask</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">always</span><span class="p">;</span>
	<span class="n">bool</span> <span class="nb">distance</span><span class="p">;</span>
	<span class="kt">float4</span> <span class="n">shadows</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="n">ShadowData</span> <span class="nf">GetShadowData</span> <span class="p">(</span><span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ShadowData</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">always</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在 <code class="language-plaintext highlighter-rouge">GetGI</code> 中连同其阴影数据一起适时地设置它。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">GI</span> <span class="nf">GetGI</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightMapUV</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">GI</span> <span class="n">gi</span><span class="p">;</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">SampleLightMap</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">)</span> <span class="o">+</span> <span class="n">SampleLightProbe</span><span class="p">(</span><span class="n">surfaceWS</span><span class="p">);</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">always</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="nb">distance</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">shadows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

	<span class="cp">#if defined(_SHADOW_MASK_ALWAYS)
</span>		<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">always</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">shadows</span> <span class="o">=</span> <span class="n">SampleBakedShadows</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
	<span class="cp">#elif defined(_SHADOW_MASK_DISTANCE)
</span>		<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="nb">distance</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">gi</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">shadows</span> <span class="o">=</span> <span class="n">SampleBakedShadows</span><span class="p">(</span><span class="n">lightMapUV</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
	<span class="cp">#endif
</span>	<span class="k">return</span> <span class="n">gi</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>两个版本的 <code class="language-plaintext highlighter-rouge">GetBakedShadow</code> 都应在任一模式处于使用状态时选择掩码。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetBakedShadow</span> <span class="p">(</span><span class="n">ShadowMask</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">always</span> <span class="o">||</span> <span class="n">mask</span><span class="p">.</span><span class="nb">distance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="n">mask</span><span class="p">.</span><span class="n">shadows</span><span class="p">.</span><span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetBakedShadow</span> <span class="p">(</span><span class="n">ShadowMask</span> <span class="n">mask</span><span class="p">,</span> <span class="n">float</span> <span class="n">strength</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">always</span> <span class="o">||</span> <span class="n">mask</span><span class="p">.</span><span class="nb">distance</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">GetBakedShadow</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">strength</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，当阴影掩码始终激活时，<code class="language-plaintext highlighter-rouge">MixBakedAndRealtimeShadows</code> 现在必须使用不同的方法。首先，实时阴影必须受全局强度调制，以便基于深度使其淡出。然后通过取它们的最小值来合并烘焙阴影和实时阴影。之后，将光源的阴影强度应用到合并后的阴影上。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">MixBakedAndRealtimeShadows</span> <span class="p">(</span>
	<span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">float</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">float</span> <span class="n">strength</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="n">float</span> <span class="n">baked</span> <span class="o">=</span> <span class="n">GetBakedShadow</span><span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="n">always</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">global</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">baked</span><span class="p">,</span> <span class="n">shadow</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">strength</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">.</span><span class="nb">distance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">baked</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">global</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">strength</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">strength</span> <span class="o">*</span> <span class="n">global</span><span class="p">.</span><span class="n">strength</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/19-always-shadowmask-mixed.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/19-always-shadowmask-mixed.png" alt="Baked static shadows mixed with realtime dynamic shadows." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Baked static shadows mixed with realtime dynamic shadows.</figcaption></figure><h2 id="多光源-multiple-lights"><span class="me-2">多光源 (Multiple Lights)</span><a href="#多光源-multiple-lights" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>因为阴影掩码贴图有四个通道，所以它最多可以支持四个混合光源。烘焙时最重要的光源获得红色通道，第二个光源获得绿色通道，依此类推。让我们通过复制我们的单个方向光、稍微旋转它并降低其强度来尝试一下，以便新光源最终使用绿色通道。</p><aside class="collapsible-aside"><h3>当有超过四个混合模式光源时会发生什么？</h3><div><p>Unity 将前四个之外的所有混合模式光源转换为完全烘焙光源。这是假设所有光源都是方向光，这是我们目前唯一支持的光源类型。其他光源类型的受影响区域有限，这可能使得多个光源使用相同的通道。</p></div></aside><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/20-two-lights-same-mask.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/20-two-lights-same-mask.png" alt="Two lights sharing the same baked shadows." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Two lights sharing the same baked shadows.</figcaption></figure><p>第二个光源的实时阴影按预期工作，但它最终将第一个光源的掩码用于烘焙阴影，这显然是错误的。当使用 <em>always-shadow-mask</em> 模式时，这最容易看到。</p><h3 id="阴影掩码通道"><span class="me-2">阴影掩码通道</span><a href="#阴影掩码通道" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>检查烘焙阴影掩码贴图可以发现阴影已正确烘焙。仅被第一个光源照射的区域是红色的，仅被第二个光源照射的区域是绿色的，被两者都照射的区域是黄色的。这适用于最多四个光源，尽管第四个在预览中不可见，因为不显示 Alpha 通道。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/21-baked-shadows-two-lights.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/21-baked-shadows-two-lights.png" alt="Baked shadows for two lights." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Baked shadows for two lights.</figcaption></figure><p>两个光源使用相同的烘焙阴影，因为我们总是使用红色通道。为了使其工作，我们必须将光源的通道索引发送到 GPU。我们不能依赖光源顺序，因为它在运行时可能会发生变化，因为光源可以被更改甚至禁用。</p><p>我们可以通过 <code class="language-plaintext highlighter-rouge">LightBakingOutput.occlusionMaskChannel</code> 字段在 <code class="language-plaintext highlighter-rouge">Shadows.ReserveDirectionalShadows</code> 中检索光源的掩码通道索引。由于我们将 4D 向量发送到 GPU，我们可以将其存储在返回向量的第四个通道中，将返回类型更改为 <code class="language-plaintext highlighter-rouge">Vector4</code>。当光源不使用阴影掩码时，我们通过将其索引设置为 -1 来指示。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Vector4</span> <span class="nf">ReserveDirectionalShadows</span> <span class="p">(</span>
    <span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visibleLightIndex</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">shadowedDirLightCount</span> <span class="p">&lt;</span> <span class="n">maxShadowedDirLightCount</span> <span class="p">&amp;&amp;</span>
        <span class="n">light</span><span class="p">.</span><span class="n">shadows</span> <span class="p">!=</span> <span class="n">LightShadows</span><span class="p">.</span><span class="n">None</span> <span class="p">&amp;&amp;</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span> <span class="p">&gt;</span> <span class="m">0f</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">maskChannel</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
        <span class="n">LightBakingOutput</span> <span class="n">lightBaking</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">bakingOutput</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">lightBaking</span><span class="p">.</span><span class="n">lightmapBakeType</span> <span class="p">==</span> <span class="n">LightmapBakeType</span><span class="p">.</span><span class="n">Mixed</span> <span class="p">&amp;&amp;</span>
            <span class="n">lightBaking</span><span class="p">.</span><span class="n">mixedLightingMode</span> <span class="p">==</span> <span class="n">MixedLightingMode</span><span class="p">.</span><span class="n">Shadowmask</span>
        <span class="p">)</span> <span class="p">{</span>
            <span class="n">useShadowMask</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">maskChannel</span> <span class="p">=</span> <span class="n">lightBaking</span><span class="p">.</span><span class="n">occlusionMaskChannel</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(!</span><span class="n">cullingResults</span><span class="p">.</span><span class="nf">GetShadowCasterBounds</span><span class="p">(</span>
            <span class="n">visibleLightIndex</span><span class="p">,</span> <span class="k">out</span> <span class="n">Bounds</span> <span class="n">b</span>
        <span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(-</span><span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="n">maskChannel</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">shadowedDirectionalLights</span><span class="p">[</span><span class="n">shadowedDirLightCount</span><span class="p">]</span> <span class="p">=</span>
            <span class="k">new</span> <span class="n">ShadowedDirectionalLight</span> <span class="p">{</span>
                <span class="n">visibleLightIndex</span> <span class="p">=</span> <span class="n">visibleLightIndex</span><span class="p">,</span>
                <span class="n">slopeScaleBias</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowBias</span><span class="p">,</span>
                <span class="n">nearPlaneOffset</span> <span class="p">=</span> <span class="n">light</span><span class="p">.</span><span class="n">shadowNearPlane</span>
            <span class="p">};</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span>
            <span class="n">light</span><span class="p">.</span><span class="n">shadowStrength</span><span class="p">,</span>
            <span class="n">settings</span><span class="p">.</span><span class="n">directional</span><span class="p">.</span><span class="n">cascadeCount</span> <span class="p">*</span> <span class="n">shadowedDirLightCount</span><span class="p">++,</span>
            <span class="n">light</span><span class="p">.</span><span class="n">shadowNormalBias</span><span class="p">,</span> <span class="n">maskChannel</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="p">-</span><span class="m">1f</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="选择合适的通道"><span class="me-2">选择合适的通道</span><a href="#选择合适的通道" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在着色器端，将阴影掩码通道作为额外的整数合并字段添加到 <code class="language-plaintext highlighter-rouge">Shadows</code> 中定义的 <code class="language-plaintext highlighter-rouge">DirectionalShadowData</code> 结构中。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">DirectionalShadowData</span> <span class="p">{</span>
	<span class="n">float</span> <span class="n">strength</span><span class="p">;</span>
	<span class="n">int</span> <span class="n">tileIndex</span><span class="p">;</span>
	<span class="n">float</span> <span class="n">normalBias</span><span class="p">;</span>
	<span class="n">int</span> <span class="n">shadowMaskChannel</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>然后 <code class="language-plaintext highlighter-rouge">GI</code> 必须在 <code class="language-plaintext highlighter-rouge">GetDirectionalShadowData</code> 中设置该通道。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">DirectionalShadowData</span> <span class="nf">GetDirectionalShadowData</span> <span class="p">(</span>
	<span class="n">int</span> <span class="n">lightIndex</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">shadowData</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="n">data</span><span class="p">.</span><span class="n">shadowMaskChannel</span> <span class="o">=</span> <span class="n">_DirectionalLightShadowData</span><span class="p">[</span><span class="n">lightIndex</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>向两个版本的 <code class="language-plaintext highlighter-rouge">GetBakedShadow</code> 添加一个通道参数，并使用它返回合适的阴影掩码数据。但仅在光源使用阴影掩码时执行此操作，即通道至少为零时。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetBakedShadow</span> <span class="p">(</span><span class="n">ShadowMask</span> <span class="n">mask</span><span class="p">,</span> <span class="n">int</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">always</span> <span class="o">||</span> <span class="n">mask</span><span class="p">.</span><span class="nb">distance</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shadow</span> <span class="o">=</span> <span class="n">mask</span><span class="p">.</span><span class="n">shadows</span><span class="p">[</span><span class="n">channel</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">GetBakedShadow</span> <span class="p">(</span><span class="n">ShadowMask</span> <span class="n">mask</span><span class="p">,</span> <span class="n">int</span> <span class="n">channel</span><span class="p">,</span> <span class="n">float</span> <span class="n">strength</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">always</span> <span class="o">||</span> <span class="n">mask</span><span class="p">.</span><span class="nb">distance</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">GetBakedShadow</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">channel</span><span class="p">),</span> <span class="n">strength</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><aside class="collapsible-aside"><h3>点积是不是比索引通道更好？</h3><div><p>是的，但着色器编译器会为我们处理这个问题。它将使用通道来索引一个静态向量缓冲区，其中合适的组件设置为 1，然后它将使用该缓冲区与掩码执行点积以过滤它。我们也可以将点积发送到 GPU 以跳过查找步骤，但这需要发送一个额外的向量数组，而该数组无论如何也需要被索引。</p></div></aside><p>调整 <code class="language-plaintext highlighter-rouge">MixBakedAndRealtimeShadows</code> 使其传递所需的阴影掩码通道。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">MixBakedAndRealtimeShadows</span> <span class="p">(</span>
	<span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">float</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">int</span> <span class="n">shadowMaskChannel</span><span class="p">,</span> <span class="n">float</span> <span class="n">strength</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="n">float</span> <span class="n">baked</span> <span class="o">=</span> <span class="n">GetBakedShadow</span><span class="p">(</span><span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">,</span> <span class="n">shadowMaskChannel</span><span class="p">);</span>
	<span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，在 <code class="language-plaintext highlighter-rouge">GetDirectionalShadowAttenuation</code> 中添加所需的通道参数。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">float</span> <span class="nf">GetDirectionalShadowAttenuation</span> <span class="p">(</span>
	<span class="n">DirectionalShadowData</span> <span class="n">directional</span><span class="p">,</span> <span class="n">ShadowData</span> <span class="n">global</span><span class="p">,</span> <span class="n">Surface</span> <span class="n">surfaceWS</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="cp">#if !defined(_RECEIVE_SHADOWS)
</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
	<span class="cp">#endif
</span>
	<span class="n">float</span> <span class="n">shadow</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">strength</span> <span class="o">*</span> <span class="n">global</span><span class="p">.</span><span class="n">strength</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="n">GetBakedShadow</span><span class="p">(</span>
			<span class="n">global</span><span class="p">.</span><span class="n">shadowMask</span><span class="p">,</span> <span class="n">directional</span><span class="p">.</span><span class="n">shadowMaskChannel</span><span class="p">,</span>
			<span class="nb">abs</span><span class="p">(</span><span class="n">directional</span><span class="p">.</span><span class="n">strength</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="n">GetCascadedShadow</span><span class="p">(</span><span class="n">directional</span><span class="p">,</span> <span class="n">global</span><span class="p">,</span> <span class="n">surfaceWS</span><span class="p">);</span>
		<span class="n">shadow</span> <span class="o">=</span> <span class="n">MixBakedAndRealtimeShadows</span><span class="p">(</span>
			<span class="n">global</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">directional</span><span class="p">.</span><span class="n">shadowMaskChannel</span><span class="p">,</span> <span class="n">directional</span><span class="p">.</span><span class="n">strength</span>
		<span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/SRP/srp6/24-both-lights-own-channel.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/SRP/srp6/24-both-lights-own-channel.png" alt="Both lights using their own channel." width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2" style="font-size:0.8em;color:var(--text-color-secondary);">Both lights using their own channel.</figcaption></figure><aside class="collapsible-aside"><h3>Subtractive 混合光照模式呢？</h3><div><p>Subtractive 光照是另一种合并烘焙光照和阴影的方式，仅使用单个光照贴图。其想法是你完全烘焙一个光源，但也将其用于实时光照。然后你计算该光源的实时漫反射光照，采样实时阴影，并使用它来确定有多少漫反射光被遮挡，你将其从漫反射 GI 中减去。</p><p>因此，你最终得到了使用烘焙光照的静态对象——即使为它们计算了漫反射实时光照——它们可以接收实时阴影。动态对象必须依赖遮挡探针来接收静态阴影。</p><p>这是一种预算方案（budget approach），受到严格限制。它仅适用于无法更改的单个方向光。所有间接光照或任何其他烘焙光源都会产生不正确的结果，通过可配置的阴影颜色限制变暗可以缓解这种情况，该颜色应与场景的平均间接 GI 颜色匹配。</p><p>在本系列中我不会包含对 Subtractive 模式的支持。如果你有空间放置阴影掩码贴图，那么 <em>always-shadow-mask</em> 模式优于 Subtractive。如果没有，请考虑采用完全烘焙，这允许更复杂的光照设置。</p></div></aside><hr /><p>下一个教程是<a href="../lod-reflections">LOD和反射</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/scriptrenderpipeline/">ScriptRenderPipeline</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/srp/" class="post-tag no-text-decoration" >SRP</a> <a href="/tags/shadows/" class="post-tag no-text-decoration" >Shadows</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:Shadow%20Masks%20(%E7%BF%BB%E8%AF%91%E5%85%AD)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2Fshadow-masks%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:Shadow%20Masks%20(%E7%BF%BB%E8%AF%91%E5%85%AD)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2Fshadow-masks%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2Fshadow-masks%2F&text=%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF:Shadow%20Masks%20(%E7%BF%BB%E8%AF%91%E5%85%AD)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/complex-maps/">自定义管线:遮罩、细节与法线贴图 (翻译八)</a><li class="text-truncate lh-lg"> <a href="/posts/custom-render-pipeline/">自定义渲染管线:初识渲染流程 (翻译一)</a><li class="text-truncate lh-lg"> <a href="/posts/drawcalls-shaders-batches/">自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</a><li class="text-truncate lh-lg"> <a href="/posts/directional-lights/">自定义管线:方向光 (翻译三)</a><li class="text-truncate lh-lg"> <a href="/posts/directional-shadows/">自定义管线:方向阴影 (翻译四)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/directional-shadows/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1576598400" data-df="ll" > Dec 18, 2019 </time><h4 class="pt-0 my-2">自定义管线:方向阴影 (翻译四)</h4><div class="text-muted"><p>渲染阴影 当绘制物体时，表面和光照信息就足以计算光照了。但是两者之间可能有东西阻挡光线，在我们正在绘制的表面上投下阴影。为了使阴影成为可能，我们必须以某种方式让着色器知道阴影投射物体。有多种技术可以做到这一点。最常见的方法是生成一个阴影贴图，存储光线从光源出发在击中表面之前可以传播多远。同一方向上更远的任何东西都不能被同一个光源照亮。Unity 的渲染管线使用这种方法，我们也一样。 ...</p></div></div></a></article><article class="col"> <a href="/posts/point-spot-lights/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1590919200" data-df="ll" > May 31, 2020 </time><h4 class="pt-0 my-2">Unity自定义渲染管线系列（九）点光源与聚光灯</h4><div class="text-muted"><p>扩展渲染管线以支持点光源和聚光灯，包含实时渲染和烘焙光照，同时实现每物体最多8个光源的限制。</p></div></div></a></article><article class="col"> <a href="/posts/complex-maps/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1588240800" data-df="ll" > Apr 30, 2020 </time><h4 class="pt-0 my-2">自定义管线:遮罩、细节与法线贴图 (翻译八)</h4><div class="text-muted"><p>创建一个电路板般的材质。 添加对 MODS 蒙版贴图的支持。 引入一个辅助细节贴图。 执行切线空间法线贴图。 背景 到目前为止，我们一直使用非常简单的材质来测试渲染管线。但它也应该支持复杂的材质，这样我们可以表现更有趣的表面。在本教程中，我们将借助几张纹理创建一个艺术风格的电路材质。 漫反射贴图 我们材质的核心是漫反射贴图（Albedo Map）。它由几层不同深浅的...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/baked-light/" class="btn btn-outline-primary" aria-label="Older" ><p>自定义管线:烘焙光照 (翻译五)</p></a> <a href="/posts/lod-reflections/" class="btn btn-outline-primary" aria-label="Newer" ><p>自定义管线:LOD和反射细节 (翻译七)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/shadows/">Shadows</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
