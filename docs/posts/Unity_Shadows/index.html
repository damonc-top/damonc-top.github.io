<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Unity Shadow 阴影(翻译七)" /><meta name="author" content="catlikecoding" /><meta property="og:locale" content="en" /><meta name="description" content="当一个物体位于光源和另一个物体之间时，它可能会阻止部分或全部光线到达另一个物体。这些光线照亮了第一个物体就不再可能照亮第二个物体。因此，第二个物体有一部不发光，而不发光的区域位于第一个物体的阴影下。我们通常是这样描述：第一个物体投射了一个阴影到第二个物体。" /><meta property="og:description" content="当一个物体位于光源和另一个物体之间时，它可能会阻止部分或全部光线到达另一个物体。这些光线照亮了第一个物体就不再可能照亮第二个物体。因此，第二个物体有一部不发光，而不发光的区域位于第一个物体的阴影下。我们通常是这样描述：第一个物体投射了一个阴影到第二个物体。" /><link rel="canonical" href="www.damonc.top/posts/Unity_Shadows/" /><meta property="og:url" content="www.damonc.top/posts/Unity_Shadows/" /><meta property="og:site_name" content="仗剑天涯" /><meta property="og:image" content="https://img.damonc.top/posts/2018/month1/catRender7/tutorial-image.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-01-05T20:00:00+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://img.damonc.top/posts/2018/month1/catRender7/tutorial-image.png" /><meta property="twitter:title" content="Unity Shadow 阴影(翻译七)" /><meta name="twitter:site" content="@elonmusk" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"catlikecoding","url":"https://catlikecoding.com/unity/tutorials"},"dateModified":"2026-02-15T22:53:15+08:00","datePublished":"2018-01-05T20:00:00+08:00","description":"当一个物体位于光源和另一个物体之间时，它可能会阻止部分或全部光线到达另一个物体。这些光线照亮了第一个物体就不再可能照亮第二个物体。因此，第二个物体有一部不发光，而不发光的区域位于第一个物体的阴影下。我们通常是这样描述：第一个物体投射了一个阴影到第二个物体。","headline":"Unity Shadow 阴影(翻译七)","image":{"lqip":"data:image/webp;base64,UklGRkYAAABXRUJQVlA4IDoAAADQAgCdASoUAAoAP3Ggxlk0q6ejsAgCkC4JZgAADgoAAO0KEwrsQY9aH6L/ujoHyEOWtVPWijLHCoAA","url":"https://img.damonc.top/posts/2018/month1/catRender7/tutorial-image.png","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.damonc.top/posts/Unity_Shadows/"},"url":"www.damonc.top/posts/Unity_Shadows/"}</script><meta name="fediverse:creator" content="@damonc@mastodon.social"><title>Unity Shadow 阴影(翻译七) | 仗剑天涯</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.loli.net" ><link rel="dns-prefetch" href="https://fonts.loli.net" ><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="dns-prefetch" href="https://gstatic.loli.net" ><link rel="preconnect" href="https://fastly.jsdelivr.net" ><link rel="dns-prefetch" href="https://fastly.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="module" src="/assets/js/dist/theme.min.js"></script> <script> /* Apply sidebar collapsed state as early as possible to prevent flickering */ if (localStorage.getItem('sidebar-collapsed') === 'true') { document.documentElement.setAttribute('data-sidebar-collapsed', 'true'); } </script> <script defer src="https://fastly.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js,npm/mermaid@11.12.0/dist/mermaid.min.js"></script> <script type="module" defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script async src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script type="module"> window.WalinePrefix = "/pro"; import { pageviewCount } from '/assets/js/dist/waline.min.js'; pageviewCount({ serverURL: 'https://comments.damonc.top', update: true }); </script> <script type="module" defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"> <button type="button" id="sidebar-collapse-btn" class="btn" aria-label="Toggle Sidebar"> <i class="fas fa-bars-staggered"></i> </button><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://img.damonc.top/commons/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">仗剑天涯</a><p class="site-subtitle fst-italic mb-0">听说读写看做忘摊手</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/damonc-top" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elonmusk" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['damoncbl','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Unity Shadow 阴影(翻译七)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>Unity Shadow 阴影(翻译七)</h1><p class="post-desc fw-light mb-4">当一个物体位于光源和另一个物体之间时，它可能会阻止部分或全部光线到达另一个物体。这些光线照亮了第一个物体就不再可能照亮第二个物体。因此，第二个物体有一部不发光，而不发光的区域位于第一个物体的阴影下。我们通常是这样描述：第一个物体投射了一个阴影到第二个物体。</p><div class="post-meta text-muted"> <span> Posted <time data-ts="1515153600" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jan 5, 2018 </time> </span> <span> Updated <time data-ts="1771167195" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Feb 15, 2026 </time> </span><div class="mt-3 mb-3"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/tutorial-image.png" class="popup img-link preview-img blur"><img data-src="https://img.damonc.top/posts/2018/month1/catRender7/tutorial-image.png" alt="Preview Image" width="1200" height="630" data-lqip="true" src="data:image/webp;base64,UklGRkYAAABXRUJQVlA4IDoAAADQAgCdASoUAAoAP3Ggxlk0q6ejsAgCkC4JZgAADgoAAO0KEwrsQY9aH6L/ujoHyEOWtVPWijLHCoAA"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://catlikecoding.com/unity/tutorials">catlikecoding</a> </em> </span><div> <span> <em class="waline-pageview-count" data-path="/posts/Unity_Shadows/"> <i class="fas fa-spinner fa-spin small"></i> </em> views </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="7529 words" > <em>41 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">Unity Shadow 阴影(翻译七)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">Unity Shadow 阴影(翻译七)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><p>本篇摘要:</p><ul><li>探索Unity中的阴影渲染<li>投射一个方向光阴影<li>接收一个方向光阴影<li>支持对聚光源和点光源阴影</ul><hr /><h2 id="方向光阴影-direction"><span class="me-2">方向光阴影-Direction</span><a href="#方向光阴影-direction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>前面写的光照shader产生了相当真实的效果，可它假设着来自每个光源的光线最终都会击中它的片元，但是这只有在那些光线没有被遮挡才成立。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20191218085818298-1814779079.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20191218085818298-1814779079.png" alt="方向光投射阴影的草图" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">方向光投射阴影的草图</figcaption></figure><p>当一个物体位于光源和另一个物体之间时，它可能会阻止部分或全部光线到达另一个物体。这些光线照亮了第一个物体就不再可能照亮第二个物体。因此，第二个物体有一部不发光，而不发光的区域位于第一个物体的阴影下。我们通常是这样描述：第一个物体投射了一个阴影到第二个物体。</p><p>实际上，在全光照和全阴影的存在过渡区，被称为半阴影。这是因为所有光源都有一个体积，因此，这些区域只有部分光源是可见的，意味着它是部分阴影。光源远大，表面距离阴影投射器越远，半影区域也就越大。</p><p>但是Unity不支持半影，只支持软阴影soft shadow，但它是阴影过滤算法。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004113666-17566508.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004113666-17566508.png" alt="半阴影或是soft shadow" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">半阴影或是soft shadow</figcaption></figure><h3 id="启用阴影-enable-shadow"><span class="me-2">启用阴影-Enable Shadow</span><a href="#启用阴影-enable-shadow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>先关闭环境光，这样会更容易看见阴影。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004114401-1156490901.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004114401-1156490901.png" alt="没有投射阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">没有投射阴影</figcaption></figure><p>没有阴影，物体间的空间视觉感不太强。在QualitySetting可以打开或关闭阴影。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004114977-1581119995.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004114977-1581119995.png" alt="阴影参数" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">阴影参数</figcaption></figure><p>同时确保光源开启投射阴影，分辨率依赖于上面的quality设置</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004115441-758263297.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004115441-758263297.png" alt="阴影类型" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">阴影类型</figcaption></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004116185-479542116.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004116185-479542116.png" alt="阴影投射" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">阴影投射</figcaption></figure><h3 id="阴影贴图-shadow-map"><span class="me-2">阴影贴图-Shadow map</span><a href="#阴影贴图-shadow-map" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Unity是如何把阴影添加到屏幕？上面所有物体使用的standard着色器，有一些方法确定光线是否被阻挡。</p><p>要搞清楚一个点是否在阴影中，可以通过在场景中从光线到表面片元投射光线，如果光线在到达表面之前击中某些东西，说明它就被阻挡了。这些事是物理引擎做的，但是要计算每个片元与每个光是不实际的，而且还要把结果传递给GPU。</p><p>现在有许多支持实时阴影的技术，它们各有优劣。而<strong>Unity采用了最常用的技术：Shadow Mapping</strong>。这意味着unity把阴影数据存储至纹理中。现在来看看它是如何工作的。</p><p>打开frame Debugger，Window/Frame Debugger。点击Enable，按顺序查看面板信息。注意看看每帧在gameScene视图中的不同，以及阴影的开启。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004116813-251352475.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004116813-251352475.png" alt="frame debugger调试" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">frame debugger调试</figcaption></figure><p>当启用阴影绘制时，这个绘制过程变得非常复杂：有更多的渲染阶段，和更多的draw call。阴影绘制非常昂贵！</p><h3 id="渲染深度纹理-rendering-to-the-depth-texture"><span class="me-2">渲染深度纹理-Rendering to the Depth Texture</span><a href="#渲染深度纹理-rendering-to-the-depth-texture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当方向阴影激活后，Unity在渲染过程开启一个<strong>depth pass</strong>通道计算。结果存储在与屏幕分辨率相匹配的纹理，这个pass通道会渲染整个屏幕，但是<strong>只收集每个片元的深度信息</strong>。这些信息与GPU用于确定一个片段渲染结束时在先前渲染的片段之上(前)还是之下(后)的信息<strong>相同</strong>。</p><p>这个数据对应在裁剪空间(clip space)坐标的z分量值。而裁剪空间是定义摄像机能看见的区域，<strong>深度信息最终存储为0-1范围内的值</strong>。在debugger查看该纹理时，近裁切面附近的纹理显示趋近为(白)浅色，远裁切面附近的纹素texel，颜色趋近黑(暗)色。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004117380-1866548771.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004117380-1866548771.png" alt="depth texture, 摄像机近裁切面为5" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">depth texture, 摄像机近裁切面为5</figcaption></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004117917-92987945.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004117917-92987945.png" alt="与屏幕分辨率一致" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">与屏幕分辨率一致</figcaption></figure><p>这些信息实际上与阴影没有太多直接关系，但Unity在后面的pass通道使用了它。</p><h3 id="渲染阴影贴图-rendering-to-shadow-maps"><span class="me-2">渲染阴影贴图-Rendering to Shadow Maps</span><a href="#渲染阴影贴图-rendering-to-shadow-maps" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这步主要工作：先渲染第一个光源的阴影贴图，然后就会渲染第二个光源的阴影贴图。</p><p>再一次渲染整个屏幕，并再次把深度信息存储在纹理中。但是，这此的屏幕渲染是从光源位置角度进行的，<strong>实际上是把光源作为摄像机</strong>。这意味着用深度值告诉了我们<strong>光线击中物体之前走了多远距离</strong>，<strong>这可以用来确定什么东西被遮蔽了!</strong></p><blockquote class="prompt-tip"><p>阴影贴图记录了实际的几何图形的深度信息。而法线贴图是为了添加粗糙表面的一种错觉， 阴影贴图会忽略它们。因此，阴影不受法线贴图的影响。</p></blockquote><p>由于我们使用方向光，这些光模拟的摄像机是正交投影，没有透视投影。因此它们模拟的相机的位置精确性就不那么重要。Unity将定位常规相机使其能够看见视野内所有物体。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004118495-150954892.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004118495-150954892.png" alt="左第一个光源，右第二个光源" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004119056-187327811.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004119056-187327811.png" alt="左第一个光源，右第二个光源" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">左第一个光源，右第二个光源</figcaption></figure><blockquote class="prompt-tip"><p>事实上，原来Unity渲染整个场景不是每个光只渲染一次，而是每个光要渲染四次！</p><p>这个阴影纹理被分成四个象限，每个象限从不同的角度呈现。这是因为我们选择使用 <em>Four Cascades</em>(QualitySetting)。如果我们设置为Two Cascades，就是每个光渲染两次； 如果设置没有，只会渲染一次。我们接下来要探查阴影质量与该项设置的关系。Unity为什么渲染这么 多次。</p></blockquote><h3 id="收集阴影-collecting-shadows"><span class="me-2">收集阴影-Collecting Shadows</span><a href="#收集阴影-collecting-shadows" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们已经从摄像机的角度得到场景的深度信息，也有了从每个光模拟的相机视角得到的深度信息，这些数据存在不同的裁剪空间。但是我们知道这些空间的相对位置和方向，因此能从一个空间转换到另一个空间。这允许我们从两个视角比较深度测量。理论上讲，我们有两个向量应该在同一点交会结束，这样相机和光源都能看见该点，说明它被点亮了。如果光的向量在到达该点之前结束，则光被挡住，这意味着该点被阴影化。</p><blockquote class="prompt-tip"><p>当摄像机看不到一个点时？ 看不到的这些点被隐藏在距离相机更近的其他点后面。 场景深度纹理仅包含最接近的点。 因此没有时间浪费在评估隐藏点。</p></blockquote><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004119634-36088154.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004119634-36088154.png" alt="每个光的屏幕空间阴影" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004120273-1411206867.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004120273-1411206867.png" alt="每个光的屏幕空间阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">每个光的屏幕空间阴影</figcaption></figure><p>Unity通过渲染一个单独的覆盖整个视野的面片来创建这些纹理，它使用了Hidden/Internal-ScreenSpaceShadows shader的通道，每个片元从场景和光源的深度纹理采样，进行比较，渲染最终阴影值到屏幕空间的阴影纹理。亮的纹素值设为1，阴影纹素值设为0。此时Unity能执行过滤，创建柔和的阴影。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004120767-1471511920.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004120767-1471511920.png" alt="shader 通道0" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">shader 通道0</figcaption></figure><blockquote class="prompt-tip"><p>为什么Unity在渲染和收集间交替？</p><p>每个光需要它自己的屏幕空间阴影贴图，然而从光源位置视野渲染的阴影贴图能被重复使用。</p></blockquote><h3 id="采样阴影贴图-sampling-the-shadow-maps"><span class="me-2">采样阴影贴图-Sampling the Shadow Maps</span><a href="#采样阴影贴图-sampling-the-shadow-maps" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>最后，Unity完成了阴影渲染。现在屏幕是常规渲染，只有一个更改：光照颜色与它的阴影贴图的值相乘。这就消除了被遮挡的光线。渲染的每个片元都要采样阴影贴图，每个最终隐藏在其他对象之后的片元会最后绘制。因此这些片元最后能接收到最终能遮挡它们的对象的阴影。当在frame debugger步进调试观察时，您还可以看到阴影在实际投射它的对象之前出现。当然这些错误只在渲染帧时很明显，一旦完成渲染就是正确的了</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004121539-766772112.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219004121539-766772112.png" alt="部分渲染帧" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">部分渲染帧</figcaption></figure><h3 id="阴影质量-shadow-quality"><span class="me-2">阴影质量-Shadow Quality</span><a href="#阴影质量-shadow-quality" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然场景是从光源的方向进行渲染，但是该方向与场景内摄像机视野方向不匹配。因此阴影贴图的纹素与最终呈现图像的纹素是没有对齐的，会出现锯齿。阴影贴图的分辨率也会不同，最终图像的分辨率是由显示设置决定的，而阴影贴图的分辨率由阴影质量设置决定。</p><p>当阴影贴图的纹素最后渲染的比最终图像大时，将很明显：阴影的边缘出现叠加，在使用硬阴影时非常明显。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104536520-1647041130.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104536520-1647041130.png" alt="硬阴影 vs 软阴影" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104537010-710024064.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104537010-710024064.png" alt="硬阴影 vs 软阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">硬阴影 vs 软阴影</figcaption></figure><p>在质量设置面板修改使用hard shadow、lowest resolution、no cascades。就会看见满屏的锯齿。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104537807-1725277269.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104537807-1725277269.png" alt="低质量阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">低质量阴影</figcaption></figure><blockquote class="prompt-danger"><p>“阴影是一张纹理”</p><p>现在就非常明显了。但是上图有些阴影出现在了不该出现的地方。</p></blockquote><p>距离摄像机越近的阴影，它们的纹素变得越大。这是由于阴影贴图当前覆盖了场景相机的整个可视区域。在QualitySetting面板通过降低阴影覆盖的区域，来提升靠近相机区域的阴影质量。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104538524-1008907954.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104538524-1008907954.png" alt="Shadow Distance降至25，其他参数一致" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Shadow Distance降至25，其他参数一致</figcaption></figure><p>通过限制靠近屏幕相机的阴影区域，我们能使用相同的阴影纹理去覆盖更多小区域。结果是能得到更好的阴影。但是会丢失更远区域的阴影细节，因为当阴影接近最大距离时会逐渐消失。</p><p>理想情况是，既要获得近距离高质量阴影，同时也要保留远处的阴影。因为远处的阴影最后渲染在较小的屏幕区域，就可以用作低分辨率阴影纹理。这就是<strong>Shadow Cascades的工作</strong>。当启用该选项，多个阴影贴图渲染进同一张纹理，每张贴图对应某些距离来使用。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104539269-790456352.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104539269-790456352.png" alt="fourCascades,100Distance,hardShodw,LowResolution" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">fourCascades,100Distance,hardShodw,LowResolution</figcaption></figure><p>当使用FourCascades，上图结果看起来比之前的要好，尽管我们使用了同一张纹理分辨率，我们更有效的使用了纹理。不过缺点就是我们现在至少要渲染场景3次以上。当渲染屏幕空间阴影纹理时，Unity关注从正确Cascade采样，如下图CascadeSplits：一个cascade结束是下一个的开始。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104539767-1296197985.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104539767-1296197985.png" alt="Cascade Splits" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Cascade Splits</figcaption></figure><p>可以控制cascade的范围，作为阴影距离的一部分。也能通过改变_Shading Mode/Miscellaneous/Shadow Cascades_观察scene视图的变化。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104540599-1094570005.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104540599-1094570005.png" alt="Cascade范围：StableFit" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Cascade范围：StableFit</figcaption></figure><p>上图显示的cascade形状(覆盖区域)是可以通过_Shadow Projection_调整，默认是_Stable Fit_：这个模式cascade条带选择的区域基于距离摄像机位置的远近。其他模式是_Close Fit_：使用相机的深度信息替代，在相机可视方向产生一条规则的条带。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104541528-964824910.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200219104541528-964824910.png" alt="Close Fit" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Close Fit</figcaption></figure><p>Close Fit模式可以更高效的利用阴影纹理，绘制更高质量的阴影。然而，该阴影投射模式(ShadowProjection)取决于阴影产生后位置和方向以及相机参数。结果是，当移动或旋转相机，阴影贴图也会跟着移动。这就是著名的<strong>阴影抖动</strong>。所以Stale Fit是引擎默认的选项。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011549767-631714908.gif" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011549767-631714908.gif" alt="Close Fit: swimming" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Close Fit: swimming</figcaption></figure><p>Stable Fit模式下，在相机位置改变时Unity能够对齐纹理，纹素看起来好像没动。实际上cascade移动了，只是在cascade相互过渡时阴影会发生改变。如果没有注意到cascade改变，就不容易察觉到。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011551635-334469142.gif" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011551635-334469142.gif" alt="Stable Fit: edge transition" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Stable Fit: edge transition</figcaption></figure><h3 id="阴影痤疮0什么鬼"><span class="me-2">阴影“痤疮”(0!什么鬼)</span><a href="#阴影痤疮0什么鬼" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当我们使用低质量的硬阴影时，我们看见一些阴影出现在不正确的地方。不幸的是，不管如何设置_Quality Setting_都会发生。</p><blockquote class="prompt-warning"><p>Shadow Acne</p><p>阴影贴图中每个纹素表示光线击中表面的点。然而，这些纹素不是单独点。它们最后要覆盖很大的区域并且与光的方向对 齐，而不是与表面一致。结果时，它们会像黑色瓦片最终黏在、穿过、伸出表面；当阴影纹理的一部分从投射出阴影的表面 伸出时，表面看起来也会产生阴影。</p></blockquote><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011552772-162435124.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011552772-162435124.png" alt="凸起" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">凸起</figcaption></figure><p>阴影凸起的另一个来源是数字精度的限制，当使用非常小的距离时这些限制会导致不正确的结果。默认是0.05.</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011553241-1223925943.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011553241-1223925943.png" alt="Image" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2"></figcaption></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011554194-2082319886.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011554194-2082319886.png" alt="light组件中设置没有biases" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">light组件中设置没有biases</figcaption></figure><p>避免该问题的一个方法是：当渲染阴影纹理时增加深度偏移。这个_偏差系数_目的是增加‘光投射到表面距离’，把阴影‘推进’表面内。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011554763-238944472.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011554763-238944472.png" alt="Biases系数控制粉刺" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">Biases系数控制粉刺</figcaption></figure><p>较低的Bias系数会产生粉刺，而较高的偏差系数就会有另一个问题：当投射阴影的对象逐渐远离光源时，阴影也会逐渐飘离原对象。使用较小的值问题还可接受，但太大的值会导致物体与该物体的阴影不再相连接了，好像飞起来了。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011555603-1490654705.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011555603-1490654705.png" alt="太大的Bias导致阴影飘移" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">太大的Bias导致阴影飘移</figcaption></figure><p>除了距离bias偏差，还有法线偏差。该系数辅助调整阴影投射：沿着法线，将投射的阴影顶点向内‘推’。该值也会改善“阴影粉刺”，但是越大的值越会使阴影变得更小并且有可能使阴影中间出现洞。</p><p><strong>best bias settings</strong>？没有最优的默认值，必须不停的实验调整 。</p><h3 id="抗锯齿"><span class="me-2">抗锯齿</span><a href="#抗锯齿" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Anti-Aliasing:图形边缘锯齿缓和。在Unity开启了4倍抗锯齿，感觉并没有达到想要的抗锯齿效果。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011555867-728275342.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011555867-728275342.png" alt="Image" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2"></figcaption></figure><p><strong>Unity采用的多重采样抗锯齿方案：MSAA，通过沿三角形边缘执行超级采样以消除边缘锯齿，更重要的是Unity渲染屏幕空间阴影时，它使用了一个单独四方面片覆盖整个可视区域。结果是，这就没有了三角形边缘，因此MSAA对屏幕空间阴影纹理采样就没有效果了。MSAA对最终图像有效，但阴影值是取之屏幕空间阴影纹理，当亮表面紧挨着暗表面被阴影覆盖时就非常明显。明暗之间的边缘是反锯齿的，而阴影边缘则不是</strong>。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011556603-1672887107.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011556603-1672887107.png" alt="no AA" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">no AA</figcaption></figure><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011557407-1382894965.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200220011557407-1382894965.png" alt="4倍MSAA" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">4倍MSAA</figcaption></figure><p>当然也有FXAA，是<strong>屏幕后处理抗锯齿</strong>，效果挺好！</p><h2 id="投射阴影"><span class="me-2">投射阴影</span><a href="#投射阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>通过上面我们知道了Unity如何创建方向光阴影，是时候写自己的Shader来支持阴影了。当前光照shader既不支持投射阴影也不支持接收阴影。</p><p>首先来处理投射阴影：我们知道对于方向光阴影Unity会渲染多次屏幕。对每个阴影纹理一次是深度pass渲染，一次是每个光源渲染。而屏幕空间阴影纹理是屏幕效果暂时与我们无关。阴影渲染Pass标签是_ShadowCaster。_因为我们只对深度值感兴趣，它与别的Pass相比应该会简单。增加一个pass</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">Pass</span><span class="p">{</span>
    <span class="n">Tags</span><span class="p">{</span><span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ShadowCaster"</span><span class="p">}</span>
    <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma target 3.0
</span>        <span class="cp">#pragma vertex MyVertexProgram
</span>        <span class="cp">#pragma fragment MyFragmentProgram
</span>        <span class="cp">#include</span> <span class="cpf">"MyShadow.cginc"</span><span class="cp">
</span>    <span class="n">ENDCG</span>
<span class="p">}</span>
</pre></table></code></div></div><p>创建一个_MyShadow.cginc_文件</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#if !defined(MY_SHADOW_INCLUDE)
#define MY_SHADOW_INCLUDE
#include “UnityCG.cginc”
</span><span class="k">struct</span> <span class="n">InputData</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">float4</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">half4</span> <span class="nf">MyFragmentProgram</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>上面写完就嫩产生方向光阴影了。下面开始用代码调优阴影质量。</p><h3 id="偏差-bias"><span class="me-2">偏差-Bias</span><a href="#偏差-bias" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们要支持阴影的偏移。在渲染深度Pass时该值是0，但当渲染阴影纹理时，偏差值取光照组件设置。我们要做的就是：<strong>在顶点函数中在裁切空间下，对顶点坐标应用深度偏差</strong>。UnityCG函数_UnityApplyLinerShadowBias：_</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">{</span>
    <span class="kt">float4</span> <span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
    <span class="k">return</span>	<span class="n">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><em>在裁剪空间增加Z分量，复杂的是在其次坐标空间下，必须补偿透视投影，这样偏移不会随着与相机距离改变而改变，也必须确保结果不会越界。</em></p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="kt">float4</span> <span class="n">clipPos</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(UNITY_REVERSED_Z)
</span>    <span class="c1">// We use max/min instead of clamp to ensure proper handling of the rare case</span>
    <span class="c1">// where both numerator and denominator are zero and the fraction becomes NaN.</span>
    <span class="n">clipPos</span><span class="p">.</span><span class="n">z</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">clipPos</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">float</span> <span class="n">clamped</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">clipPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">clipPos</span><span class="p">.</span><span class="n">w</span><span class="o">*</span><span class="n">UNITY_NEAR_CLIP_VALUE</span><span class="p">);</span>
<span class="cp">#else
</span>    <span class="n">clipPos</span><span class="p">.</span><span class="n">z</span> <span class="o">+=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">clipPos</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">clamped</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">clipPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">clipPos</span><span class="p">.</span><span class="n">w</span><span class="o">*</span><span class="n">UNITY_NEAR_CLIP_VALUE</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="n">clipPos</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">clipPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">clamped</span><span class="p">,</span> <span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">clipPos</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>同时支持Normal Bias，必须根据法向量移动顶点坐标。因此，添加一个normal变量。然后可以使用UnityCG定义的UnityClipSpaceShadowCasterPos函数</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">{</span>
    <span class="c1">//float4 position = UnityObjectToClipPos(i.position);</span>
    <span class="kt">float4</span> <span class="n">position</span> <span class="o">=</span> <span class="n">UnityClipSpaceShadowCasterPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="k">return</span>    <span class="n">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><em>先将顶点坐标转换到世界空间，然后转换到裁剪空间。计算光的方向，计算法线和光的角度，取正弦值，最后转与观察投影矩阵相乘转到裁剪空间。</em></p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kt">float4</span> <span class="nf">UnityClipSpaceShadowCasterPos</span><span class="p">(</span><span class="kt">float4</span> <span class="n">vertex</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">normal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float4</span> <span class="n">wPos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">vertex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float3</span> <span class="n">wNormal</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">normal</span><span class="p">);</span>
        <span class="kt">float3</span> <span class="n">wLight</span> <span class="o">=</span> <span class="nb">normalize</span><span class="p">(</span><span class="n">UnityWorldSpaceLightDir</span><span class="p">(</span><span class="n">wPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>

        <span class="c1">// apply normal offset bias (inset position along the normal)</span>
        <span class="c1">// bias needs to be scaled by sine between normal and light direction</span>
        <span class="c1">// (http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/)</span>
        <span class="c1">//</span>
        <span class="c1">// unity_LightShadowBias.z contains user-specified normal offset amount</span>
        <span class="c1">// scaled by world space texel size.</span>

        <span class="n">float</span> <span class="n">shadowCos</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">wNormal</span><span class="p">,</span> <span class="n">wLight</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowSine</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">shadowCos</span><span class="o">*</span><span class="n">shadowCos</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">normalBias</span> <span class="o">=</span> <span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">shadowSine</span><span class="p">;</span>

        <span class="n">wPos</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-=</span> <span class="n">wNormal</span> <span class="o">*</span> <span class="n">normalBias</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_VP</span><span class="p">,</span> <span class="n">wPos</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>写完就具备了完全的阴影投射</p><h2 id="接收阴影"><span class="me-2">接收阴影</span><a href="#接收阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>First,我们先关注主方向光的阴影，因为该光源属于BasePass，必须要先适配。<strong>当主方向光投射阴影，Unity会找一个启用了SHADOWS_SCREEN关键字的shader变体</strong>。所以我们要在Base Pass创建两个变体，同之前使用顶点光关键字类似：一个无，一个是该关键字。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#pragma multi_compile _ VERTEXLIGHT_ON
#pragma multi_compile _ SHADOWS_SCREEN
</span></pre></table></code></div></div><p>该basePass有两个multi_compile指令，每个都是单关键字。因此编译后这里会有4个变体：</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// Total snippets: 3</span>
<span class="c1">// --</span>
<span class="c1">// Snippet #0 platforms ffffffff:</span>
<span class="n">SHADOWS_SCREEN</span> <span class="n">VERTEXLIGHT_ON</span>

<span class="mi">4</span> <span class="n">keyword</span> <span class="n">variants</span> <span class="n">used</span> <span class="k">in</span> <span class="n">scene</span><span class="o">:</span>

<span class="o">&lt;</span><span class="n">no</span> <span class="n">keywords</span> <span class="n">defined</span><span class="o">&gt;</span>
<span class="n">SHADOWS_SCREEN</span>
<span class="n">VERTEXLIGHT_ON</span>
<span class="n">SHADOWS_SCREEN</span> <span class="n">VERTEXLIGHT_ON</span>
</pre></table></code></div></div><p>(老版本Unity有可能出现)当增加了multi_compile指令后，shader编译器会提示关于__ShadowCoord_不存在。这是因为_UNITY_LIGHT_ATTENUATION_宏在使用阴影时的行为不同导致。在MyLighting_shadow.cginc顶点函数快速修复</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#if defined(UNITY_SCREEN) float attenuation = 1;
#else
</span>    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
<span class="cp">#endif
</span></pre></table></code></div></div><h3 id="采样阴影"><span class="me-2">采样阴影</span><a href="#采样阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Secend,采样屏幕空间阴影纹理。<br /> Third,需要获取屏幕空间纹理坐标，从顶点函数传递给片元函数。在插值器Interpolator添加一个float4 变量以支持传递阴影纹理坐标。从裁剪空间开始(裁剪空间顶点坐标)。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Interpolator</span><span class="p">{</span>
    <span class="cp">#if defined(SHADOWS_SCREEN)
</span>        <span class="kt">float4</span> <span class="n">shadowCoordinate</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
<span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//。。。</span>
    <span class="cp">#if defined(SHADOWS_SCREE)
</span>        <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="c1">//。。。</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015552159-153113228.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015552159-153113228.png" alt="错误的纹理坐标映射" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">错误的纹理坐标映射</figcaption></figure><p>AutoLignt.cginc定义了Sampler2D _ShadowMapTexture，可以通过它访问屏幕阴影纹理。但是要覆盖整个屏幕，就需要屏幕空间坐标。在裁剪空间，XY坐标范围是[-1, 1]，而屏幕空间下是[0,1]；然后偏移坐标与屏幕左小脚等于0对齐。因为我们处理的使透视变换，偏移坐标值取决于距离，这里的偏移值等于加上齐次坐标的w分量之后的一半。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#if defined(SHADOWS_SCREEN)
</span>    <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="cp">#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015552728-1203950638.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015552728-1203950638.png" alt="错误的左下角映射" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">错误的左下角映射</figcaption></figure><p>上图的投影错误，还需要通过x和y除以齐次坐标进一步转换</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015553704-577419973.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015553704-577419973.png" alt="错误投影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">错误投影</figcaption></figure><p>上图结果仍然是错误的，影子被拉伸了。这是由于在顶点函数计算导致，不应该在传递给片元函数时提前修改原始数据，需要保持它们的独立性。在片元函数再次除以w.</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015555540-1368845680.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015555540-1368845680.png" alt="颠倒的投影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">颠倒的投影</figcaption></figure><p>此时，影子是上下颠倒的。如果它们被翻转，这意味着你的图形Direct3D屏幕空间Y坐标从0向下到1，而不是向上。要与此同步，翻转顶点的Y坐标。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#if defined(SHADOWS_SCREEN)
</span>    <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float2</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">w</span><span class="p">);</span><span class="c1">// (i.pos.xy + i.pos.w) * 0.5;</span>
    <span class="n">i</span><span class="p">.</span><span class="n">shadowCoordinate</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
<span class="cp">#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015556220-1277984238.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015556220-1277984238.png" alt="继续错误" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">继续错误</figcaption></figure><h3 id="内置函数使用"><span class="me-2">内置函数使用</span><a href="#内置函数使用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>SHADOW_COORDS宏定义纹理坐标</p><p>TRANSFRE_SHADOW宏获取阴影纹理坐标(转换)</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#define TRANSFER_SHADOW(a) a._ShadowCoord = ComputeScreenPos(a.pos);
</span></pre></table></code></div></div><p>SHADOW_ATTENUATION宏阴影纹理明暗衰减</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#define SHADOW_COORDS
</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span> <span class="n">unityShadowCoord4</span> <span class="n">_ShadowCoord</span> <span class="o">:</span> <span class="n">TEXCOORD</span><span class="err">##</span><span class="n">idx1</span><span class="p">;</span>
    <span class="cp">#define SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)
</span></pre></table></code></div></div><p>UNITY_LIGHT_ATTENUATION宏包含了SHADOW_ATTENUATION宏使用，可替换之</p><p>当启用SHADOWS_SCREEN指令时，会自动计算，不启用不计算，没有任何损失。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="c1">// #if defined(SHADOWS_SCREEN)</span>
    <span class="c1">//    float4 shadowCoordinates : TEXCOORD5;</span>
    <span class="c1">// #endif</span>
    <span class="n">SHADOW_COORDS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="c1">//...</span>
<span class="p">};</span>

<span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="c1">// #if defined(SHADOWS_SCREEN)</span>
    <span class="c1">//   i.shadowCoordinates = i.position;</span>
    <span class="c1">// #endif</span>
    <span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
<span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="cp">#if defined(SHADOWS_SCREEN)
</span>        <span class="n">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="cp">#else
</span>        <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015557055-486911408.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222015557055-486911408.png" alt="正确了" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">正确了</figcaption></figure><p>ComputeScreenPos函数</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">inline</span> <span class="kt">float4</span> <span class="nf">ComputeNonStereoScreenPos</span><span class="p">(</span><span class="kt">float4</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">o</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="kt">float2</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">_ProjectionParams</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">zw</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">inline</span> <span class="kt">float4</span> <span class="nf">ComputeScreenPos</span><span class="p">(</span><span class="kt">float4</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">o</span> <span class="o">=</span> <span class="n">ComputeNonStereoScreenPos</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="cp">#if defined(UNITY_SINGLE_PASS_STEREO)
</span>    <span class="n">o</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">TransformStereoScreenSpaceTex</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">pos</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="聚光灯阴影"><span class="me-2">聚光灯阴影</span><a href="#聚光灯阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>关闭方向光，增加聚光灯后，竟然直接有阴影了。这是Unity宏带来的便利。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151429610-436331942.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151429610-436331942.png" alt="点光源阴影" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">点光源阴影</figcaption></figure><p>再看帧调试器</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151430321-98573745.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151430321-98573745.png" alt="SpotLight Debugger" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">SpotLight Debugger</figcaption></figure><p>上图对于聚光灯源阴影的渲染工作量很少</p><p><strong>不同之处</strong>：</p><ol><li>没有方向光独立的深度pass和屏幕空间阴影pass，而是直接渲染阴影纹理；<li>与方向光渲染阴影还有很大的差别之处：聚光灯光线不是平行的，因此用光的位置模拟相机视角会得到一个透视视角，结果就是不支持阴影分段渲染(cascades)；<li>normal bias(法线偏差)<strong>只</strong>支持方向光阴影，对于<strong>其他</strong>光源类型简单的置为0；<li>采样代码不同。</ol><p><strong>相同之处</strong>：</p><ol><li>投射阴影的这段代码通用。</ol><h3 id="采样阴影纹理"><span class="me-2">采样阴影纹理</span><a href="#采样阴影纹理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>由于聚光灯不使用屏幕空间的阴影，这段采样纹理代码就有点不一样。因此，如果我们想要使用软阴影，我们必须在fragment程序中进行<strong>过滤</strong>。而Unity宏已经做了过滤计算UnitySampleShadowmap。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">//阴影坐标把顶点坐标从模型空间转到世界空间再转到光的阴影空间得到。</span>

<span class="c1">// - Spot light shadows</span>
<span class="cp">#if defined (SHADOWS_DEPTH) &amp;&amp; defined (SPOT)
</span>
<span class="cp">#define SHADOW_COORDS(idx1) unityShadowCoord4 _ShadowCoord : TEXCOORD##idx1;
#define TRANSFER_SHADOW(a) a._ShadowCoord = mul(unity_WorldToShadow[0], mul(unity_ObjectToWorld,v.vertex));
#define SHADOW_ATTENUATION(a) UnitySampleShadowmap(a._ShadowCoord)
#endif
</span></pre></table></code></div></div><p>然后<code class="language-plaintext highlighter-rouge">SHADOW_ATTENUATION</code>宏使用<code class="language-plaintext highlighter-rouge">UnitySampleShadowmap</code>函数采样阴影映射。这个函数定义在_UnityShadowLibrary_，_AutoLight_文件引用了它。当使用硬阴影时，该函数对阴影纹理采样一次。当使用软阴影时，它对纹理采样四次并对结果取平均值。这个结果没有用于屏幕空间阴影的过滤效果好，但是速度快得多。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151431024-1101864231.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151431024-1101864231.png" alt="hard vs. soft SpotLight Shadow" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151431654-1775286822.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151431654-1775286822.png" alt="hard vs. soft SpotLight Shadow" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">hard vs. soft SpotLight Shadow</figcaption></figure><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="c1">// Spot light shadows</span>
<span class="k">inline</span> <span class="n">fixed</span> 

<span class="nf">UnitySampleShadowmap</span> <span class="p">(</span><span class="kt">float4</span> <span class="n">shadowCoord</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// DX11 feature level 9.x shader compiler (d3dcompiler_47 at least)</span>
    <span class="c1">// has a bug where trying to do more than one shadowmap sample fails compilation</span>
    <span class="c1">// with "inconsistent sampler usage". Until that is fixed, just never compile</span>
    <span class="c1">// multi-tap shadow variant on d3d11_9x.</span>
    <span class="cp">#if defined (SHADOWS_SOFT) &amp;&amp; !defined (SHADER_API_D3D11_9X)
</span>        <span class="c1">// 4-tap shadows</span>
        <span class="cp">#if defined (SHADOWS_NATIVE)
</span>            <span class="cp">#if defined (SHADER_API_D3D9)
</span>                <span class="c1">// HLSL for D3D9, when modifying the shadow UV coordinate, really wants to do</span>
                <span class="c1">// some funky swizzles, assuming that Z coordinate is unused in texture sampling.</span>
                <span class="c1">// So force it to do projective texture reads here, with .w being one.</span>
                <span class="kt">float4</span> <span class="n">coord</span> <span class="o">=</span> <span class="n">shadowCoord</span> <span class="o">/</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
                <span class="kt">half4</span> <span class="n">shadows</span><span class="p">;</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
                <span class="n">shadows</span> <span class="o">=</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span> <span class="o">+</span> <span class="n">shadows</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span><span class="p">);</span>
            <span class="cp">#else
</span>                <span class="c1">// On other platforms, no need to do projective texture reads.</span>
                <span class="kt">float3</span> <span class="n">coord</span> <span class="o">=</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
                <span class="kt">half4</span> <span class="n">shadows</span><span class="p">;</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                <span class="n">shadows</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
                <span class="n">shadows</span> <span class="o">=</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span> <span class="o">+</span> <span class="n">shadows</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span><span class="p">);</span>
            <span class="cp">#endif
</span>        <span class="cp">#else
</span>            <span class="kt">float3</span> <span class="n">coord</span> <span class="o">=</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
            <span class="kt">float4</span> <span class="n">shadowVals</span><span class="p">;</span>
            <span class="n">shadowVals</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span> <span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xy</span><span class="p">);</span>
            <span class="n">shadowVals</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span> <span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">xy</span><span class="p">);</span>
            <span class="n">shadowVals</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span> <span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xy</span><span class="p">);</span>
            <span class="n">shadowVals</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE</span> <span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">coord</span> <span class="o">+</span> <span class="n">_ShadowOffsets</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">xy</span><span class="p">);</span>
            <span class="kt">half4</span> <span class="n">shadows</span> <span class="o">=</span> <span class="p">(</span><span class="n">shadowVals</span> <span class="o">&lt;</span> <span class="n">coord</span><span class="p">.</span><span class="n">zzzz</span><span class="p">)</span> <span class="o">?</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
        <span class="cp">#endif
</span>        <span class="c1">// average-4 PCF</span>
        <span class="n">half</span> <span class="n">shadow</span> <span class="o">=</span> <span class="nb">dot</span> <span class="p">(</span><span class="n">shadows</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="n">f</span><span class="p">);</span>
    <span class="cp">#else
</span>        <span class="c1">// 1-tap shadows</span>
        <span class="cp">#if defined (SHADOWS_NATIVE)
</span>        <span class="n">half</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_SHADOW_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">shadowCoord</span><span class="p">);</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">r</span> <span class="o">+</span> <span class="n">shadow</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">_LightShadowData</span><span class="p">.</span><span class="n">r</span><span class="p">);</span>
        <span class="cp">#else
</span>        <span class="n">half</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SAMPLE_DEPTH_TEXTURE_PROJ</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">UNITY_PROJ_COORD</span><span class="p">(</span><span class="n">shadowCoord</span><span class="p">))</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">shadowCoord</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">shadowCoord</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">?</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">r</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h2 id="点光源阴影"><span class="me-2">点光源阴影</span><a href="#点光源阴影" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>如果直接使用点光源，会有编译报错：undeclared identifier ‘UnityDecodeCubeShadowDepth’。该函数在_UnityCG.cginc_文件。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151432459-1922680396.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151432459-1922680396.png" alt="UnityPBSLighting文件引用；AutoLight文件引用" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">UnityPBSLighting文件引用；AutoLight文件引用</figcaption></figure><p>所以根据引用结构，需要把UnityPBSLighing文件放在第一位引用。就不会报错了。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151433321-1428961084.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151433321-1428961084.png" alt="左：render six times per light" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151434107-2064323872.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151434107-2064323872.png" alt="左：render six times per light" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">左：render six times per light</figcaption></figure><h3 id="投射阴影-1"><span class="me-2">投射阴影</span><a href="#投射阴影-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>从帧调试器查看，左边一个光要渲染6次，两盏光就是12次了。有很多个RenderJobPoint渲染了。结果是，点光源的阴影纹理是一个立方体贴图，而立方体贴图是通过相机在6个不同方向观察场景，每个方向渲染一面组成六面体，前面1.4讲过把光源模拟相机对屏幕渲染。所以点光源阴影计算很费，尤其是实时点光源阴影。</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151434750-920356967.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151434750-920356967.png" alt="错误的阴影纹理" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">错误的阴影纹理</figcaption></figure><p>当渲染点光源阴影纹理时，Unity引擎会找shader变体关键字<code class="language-plaintext highlighter-rouge">SHADOWS_CUBE，而SHADOWS_DEPTH关键字只适用于方向光和聚光灯。为了支持点光源阴影，Unity提供了一个特殊编译指令</code></p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#pragma multi_compile_shadowcaster
</span>
<span class="c1">// --</span>
<span class="c1">// Snippet #2 platforms ffffffff:</span>
<span class="n">SHADOWS_CUBE</span> <span class="n">SHADOWS_DEPTH</span>

<span class="mi">2</span> <span class="n">keyword</span> <span class="n">variants</span> <span class="n">used</span> <span class="k">in</span> <span class="n">scene</span><span class="o">:</span>
<span class="n">SHADOWS_DEPTH</span>
<span class="n">SHADOWS_CUBE</span>
</pre></table></code></div></div><p>所以，需要创建一个独立的处理程序。这里首先要计算光到表面的距离，但得知道光到表面的方向。在顶点函数先转换顶点坐标所在世界空间，再计算光的方向。然后在片元函数计算该方向向量长度再与bias偏差相加。然后再除以点光源的范围映射到[0.1]再与长度相乘，最后解码。而_LightPositionRange.w = 1/range已经计算好了隐射范围，直接用。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cp">#if defined(SHADOWS_CUBE)
</span>    <span class="k">struct</span> <span class="n">Interplotars</span> <span class="p">{</span>
    <span class="kt">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">;</span>
        <span class="kt">float3</span> <span class="n">lightVec</span> <span class="o">:</span> <span class="nb">TEXCOORD0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">Interplotars</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">v</span><span class="p">){</span>
        <span class="n">Interplotars</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
        <span class="n">i</span><span class="p">.</span><span class="n">lightVec</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">position</span><span class="p">).</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">_LightPositionRange</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
        <span class="c1">//float4 position = UnityClipSpaceShadowCasterPos(i.position, i.normal);//方向光源：简单的裁剪空间顶点坐标</span>
        <span class="k">return</span>	<span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">half4</span> <span class="nf">MyFragmentProgram</span><span class="p">(</span><span class="n">Interplotars</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
        <span class="n">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightVec</span><span class="p">)</span> <span class="o">+</span> <span class="n">unity_LightShadowBias</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
        <span class="n">depth</span> <span class="o">*=</span> <span class="n">_LightPositionRange</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">UnityEncodeCubeShadowDepth</span><span class="p">(</span><span class="n">depth</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#else
</span>    <span class="kt">float4</span> <span class="nf">MyVertexProgram</span><span class="p">(</span><span class="n">InputData</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="nb">SV_POSITION</span><span class="p">{</span>
        <span class="c1">//float4 position = UnityObjectToClipPos(i.position);</span>
        <span class="kt">float4</span> <span class="n">position</span> <span class="o">=</span> <span class="n">UnityClipSpaceShadowCasterPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="k">return</span>	<span class="n">UnityApplyLinearShadowBias</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">half4</span> <span class="nf">MyFragmentProgram</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif
</span></pre></table></code></div></div><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151435367-1088891603.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151435367-1088891603.png" alt="正确的阴影纹理" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">正确的阴影纹理</figcaption></figure><p>UnityEncodeCubeShadowDepth函数：</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// Shadow caster pass helpers</span>
<span class="kt">float4</span> <span class="nf">UnityEncodeCubeShadowDepth</span> <span class="p">(</span><span class="n">float</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp">#ifdef UNITY_USE_RGBA_FOR_POINT_SHADOWS
</span>    <span class="k">return</span> <span class="n">EncodeFloatRGBA</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">999</span><span class="p">));</span>
    <span class="cp">#else
</span>    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 使用浮点类型cube——map,存储再8位RGBA纹理</span>
<span class="k">inline</span> <span class="kt">float4</span> <span class="nf">EncodeFloatRGBA</span><span class="p">(</span> <span class="n">float</span> <span class="n">v</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float4</span> <span class="n">kEncodeMul</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">65025</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16581375</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">kEncodeBit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">255</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">float4</span> <span class="n">enc</span> <span class="o">=</span> <span class="n">kEncodeMul</span> <span class="o">*</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">enc</span> <span class="o">=</span> <span class="nb">frac</span> <span class="p">(</span><span class="n">enc</span><span class="p">);</span><span class="c1">//返回小数部分</span>
    <span class="n">enc</span> <span class="o">-=</span> <span class="n">enc</span><span class="p">.</span><span class="n">yzww</span> <span class="o">*</span> <span class="n">kEncodeBit</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">enc</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="采样阴影纹理-1"><span class="me-2">采样阴影纹理</span><a href="#采样阴影纹理-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在additional pass的编译指令，Unity宏已经做了。</p><div class="language-hlsl highlighter-rouge"><div class="code-header"> <span data-label-text="Hlsl"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="c1">//同样计算光的方向，然后采样cubeMap。区别是float3类型而不是float4，不需要齐次坐标。</span>
<span class="c1">// - Point light shadows</span>
<span class="cp">#if defined (SHADOWS_CUBE)
#define SHADOW_COORDS(idx1) unityShadowCoord3 _ShadowCoord : TEXCOORD##idx1;
#define TRANSFER_SHADOW(a) a._ShadowCoord = mul(unity_ObjectToWorld, v.vertex).xyz - _LightPositionRange.xyz;
#define SHADOW_ATTENUATION(a) UnitySampleShadowmap(a._ShadowCoord)
#endif
</span>
<span class="c1">// </span>
<span class="c1">// Point light shadows</span>
<span class="c1">//在这种情况下，UnitySampleShadowmap采样一个立方体地图，而不是2D纹理。</span>
<span class="cp">#if defined (SHADOWS_CUBE)
</span>
<span class="n">samplerCUBE_float</span> <span class="n">_ShadowMapTexture</span><span class="p">;</span>
<span class="k">inline</span> <span class="n">float</span> <span class="nf">SampleCubeDistance</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp">#ifdef UNITY_FAST_COHERENT_DYNAMIC_BRANCHING
</span>        <span class="k">return</span> <span class="n">UnityDecodeCubeShadowDepth</span><span class="p">(</span><span class="nb">texCUBElod</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="n">UnityDecodeCubeShadowDepth</span><span class="p">(</span><span class="nb">texCUBE</span><span class="p">(</span><span class="n">_ShadowMapTexture</span><span class="p">,</span> <span class="n">vec</span><span class="p">));</span>
    <span class="cp">#endif
</span><span class="p">}</span>
<span class="k">inline</span> <span class="n">half</span> <span class="nf">UnitySampleShadowmap</span> <span class="p">(</span><span class="kt">float3</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float</span> <span class="n">mydist</span> <span class="o">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightPositionRange</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">mydist</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">97</span><span class="p">;</span> <span class="c1">// bias</span>

    <span class="cp">#if defined (SHADOWS_SOFT)
</span>        <span class="n">float</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">128</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">shadowVals</span><span class="p">;</span>
        <span class="n">shadowVals</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="o">+</span><span class="kt">float3</span><span class="p">(</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">));</span>
        <span class="n">shadowVals</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="o">+</span><span class="kt">float3</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">));</span>
        <span class="n">shadowVals</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="o">+</span><span class="kt">float3</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">));</span>
        <span class="n">shadowVals</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="o">+</span><span class="kt">float3</span><span class="p">(</span> <span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">));</span>
        <span class="kt">half4</span> <span class="n">shadows</span> <span class="o">=</span> <span class="p">(</span><span class="n">shadowVals</span> <span class="o">&lt;</span> <span class="n">mydist</span><span class="p">.</span><span class="n">xxxx</span><span class="p">)</span> <span class="o">?</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">rrrr</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">dot</span><span class="p">(</span><span class="n">shadows</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="p">);</span>
    <span class="cp">#else
</span>        <span class="n">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">SampleCubeDistance</span> <span class="p">(</span><span class="n">vec</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">mydist</span> <span class="o">?</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">r</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>

<span class="cp">#endif // #if defined (SHADOWS_CUBE)
</span></pre></table></code></div></div><p>同样，如果使用软阴影会采样四次并取平均值，硬阴影采样一次。同时没有进行过滤计算，计算昂贵且效果很粗糙！</p><figure style="margin:1rem 0;"><div style="display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap;"><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151435824-1969485390.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151435824-1969485390.png" alt="hard vs soft pointLight Shadows" width="100%" height="auto" loading="lazy"></a></div><div style="flex:0 1 auto;min-width:150px;max-width:300px;"> <a href="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151436465-1258622662.png" class="popup img-link shimmer" class="img-link shimmer" ><img src="https://img.damonc.top/posts/2018/month1/catRender7/1692664-20200222151436465-1258622662.png" alt="hard vs soft pointLight Shadows" width="100%" height="auto" loading="lazy"></a></div></div><figcaption class="text-center pt-2 pb-2">hard vs soft pointLight Shadows</figcaption></figure><p>对于点光源阴影实在不能用于手机平台，替代方式就是用无阴影点光+cookie投射，模拟阴影。或者用较少的聚光灯阴影代替。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/unity3d/">Unity3D</a>, <a href="/categories/shader/">Shader</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Unity%20Shadow%20%E9%98%B4%E5%BD%B1(%E7%BF%BB%E8%AF%91%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&url=www.damonc.top%2Fposts%2FUnity_Shadows%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Unity%20Shadow%20%E9%98%B4%E5%BD%B1(%E7%BF%BB%E8%AF%91%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF&u=www.damonc.top%2Fposts%2FUnity_Shadows%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=www.damonc.top%2Fposts%2FUnity_Shadows%2F&text=Unity%20Shadow%20%E9%98%B4%E5%BD%B1(%E7%BF%BB%E8%AF%91%E4%B8%83)%20-%20%E4%BB%97%E5%89%91%E5%A4%A9%E6%B6%AF" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/rustom-render-pipeline/">自定义渲染管线:掌控渲染流程 (翻译一)</a><li class="text-truncate lh-lg"> <a href="/posts/drawcalls-shaders-batches/">自定义渲染管线:Draw Calls、Shaders、 Batches (翻译二)</a><li class="text-truncate lh-lg"> <a href="/posts/flat-and-wireframe-shading/">平面着色与线框着色(翻译二十一)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-tessellation/">曲面细分(翻译二十二)</a><li class="text-truncate lh-lg"> <a href="/posts/unity-surface-displacement/">曲面细分表面置换(翻译二十三)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_2/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515333600" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展二(翻译十)</h4><div class="text-muted"><p>本篇摘要: 把自身阴影烘焙进材质 增加细节纹理部分 支持更丰富的shader变体 一次编辑多个材质球 遮挡区域的Self-Shading 美术能够创作非常复杂丰富的表面纹理，它只是一个视错觉。为了增强表面纹理视觉真实感，引入Self-Shading。 如何增强呢？通常我们使用了法线来增强模型表面的凹凸层次感，法线带来的视觉增强是第一步，但是法线只适用于采样直接光...</p></div></div></a></article><article class="col"> <a href="/posts/Unity_ShaderGUI_Extension_1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515326400" data-df="ll" > Jan 7, 2018 </time><h4 class="pt-0 my-2">Unity Shader GUI 扩展一(翻译九)</h4><div class="text-muted"><p>选中当前材质后，若材质使用的Shader调用了GUI拓展，则会自动读取该Shader的所有属性。通过重实现OnGUI函数后，获取其参数地址就能读取。</p></div></div></a></article><article class="col"> <a href="/posts/Unity_Reflection/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1515240000" data-df="ll" > Jan 6, 2018 </time><h4 class="pt-0 my-2">Unity Reflection 反射(翻译八)</h4><div class="text-muted"><p>一块完美的镜子是不会发生漫反射，但现在我们自己的Shader包含的光照：环境光、漫反射、高光反射、纹理、阴影，结果看起来蛮好。但是当把Metallic设为1，Smoothness设位0.95，看起来很亮就很不自然了。从下图看尽管颜色是白色但整个表面都是黑色，只有一个很小的高亮点。这个亮点形成1是光源的入射，2朝向观察者的反射。</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/Unity_Advance_Texture/" class="btn btn-outline-primary" aria-label="Older" ><p>Unity 纹理高级用法(翻译六)</p></a> <a href="/posts/Unity_Reflection/" class="btn btn-outline-primary" aria-label="Newer" ><p>Unity Reflection 反射(翻译八)</p></a></nav><div id="waline-container" class="mt-5 pt-4" style="border-top: 1px dashed #ccc; padding-top: 20px;"><div id="waline"></div></div><link rel="stylesheet" href="/assets/css/waline.css"> <script type="module"> window.WalinePrefix = "/pro"; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { observer.disconnect(); import('/assets/js/dist/waline.min.js').then(({ init }) => { init({ el: '#waline', serverURL: 'https://comments.damonc.top', dark: 'html[data-mode="dark"]', emoji: [ 'https://fastly.jsdelivr.net/npm/@waline/emojis@1.4.0/qq' ], reaction: true, pageview: false }); }); } }); observer.observe(document.getElementById('waline-container')); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/damonc-top">仗剑天涯</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>The blog is powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">Shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">AI</a> <a class="post-tag btn btn-outline-primary" href="/tags/cli-agent/">CLI Agent</a> <a class="post-tag btn btn-outline-primary" href="/tags/srp/">SRP</a> <a class="post-tag btn btn-outline-primary" href="/tags/best-practices/">Best Practices</a> <a class="post-tag btn btn-outline-primary" href="/tags/post-processing/">Post Processing</a> <a class="post-tag btn btn-outline-primary" href="/tags/anti-aliasing/">Anti-aliasing</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/bloom/">Bloom</a> <a class="post-tag btn btn-outline-primary" href="/tags/configuration/">Configuration</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
